[{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/__mocks__/@react-native-async-storage/async-storage.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":2,"column":14,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":2,"endColumn":90}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"console.log('Loading manual mock for AsyncStorage');\nconst mock = require('@react-native-async-storage/async-storage/jest/async-storage-mock');\nmodule.exports = mock;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/__mocks__/async-storage-mock.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/_friends.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isFocused' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":121,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":121,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useEffect, useMemo } from 'react';\nimport { View, Text, ScrollView, Dimensions, StyleSheet } from 'react-native';\nimport Animated, { FadeIn, FadeOut } from 'react-native-reanimated';\nimport { useRouter, useFocusEffect } from 'expo-router';\nimport { GestureDetector } from 'react-native-gesture-handler';\nimport * as Haptics from 'expo-haptics';\nimport { Q } from '@nozbe/watermelondb';\n\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { checkAndApplyDormancy, FriendSearchBar, FriendSearchResults, SearchFilters, SortOption } from '@/modules/relationships';\nimport { FriendTierList } from '@/modules/relationships';\nimport { TierSegmentedControl } from '@/components/TierSegmentedControl';\nimport { TierInfo } from '@/components/TierInfo';\nimport { FAB } from '@/components/fab';\nimport { InsightsFAB } from '@/components/InsightsFAB';\nimport { InsightsSheet } from '@/components/InsightsSheet';\nimport { AddFriendMenu } from '@/components/AddFriendMenu';\nimport { useUIStore } from '@/stores/uiStore';\nimport { usePlans, PlanService, getSuggestionCooldownDays } from '@/modules/interactions';\nimport { useSuggestions } from '@/modules/interactions';\nimport { Suggestion } from '@/shared/types/common';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { useCardGesture } from '@/context/CardGestureContext';\nimport { SuggestionTrackerService } from '@/modules/interactions';\nimport { IntentionActionSheet } from '@/components/IntentionActionSheet';\nimport Intention from '@/db/models/Intention';\nimport { SimpleTutorialTooltip } from '@/components/SimpleTutorialTooltip';\nimport { useTutorialStore } from '@/stores/tutorialStore';\nimport { Tier } from '@/modules/relationships';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\n\nconst { width: screenWidth } = Dimensions.get('window');\n\nfunction DashboardContent() {\n  const router = useRouter();\n  const { colors } = useTheme();\n  const { isQuickWeaveOpen, showMicroReflectionSheet } = useUIStore();\n  const { gesture, animatedScrollHandler, activeCardId } = useCardGesture();\n  const { suggestions, dismissSuggestion } = useSuggestions();\n\n  const suggestionCount = suggestions.length;\n  const hasCritical = suggestions.some(s => s.priority === 'high');\n  const { dismissIntention, intentions } = usePlans();\n  const [insightsSheetVisible, setInsightsSheetVisible] = useState(false);\n  const [selectedIntention, setSelectedIntention] = useState<Intention | null>(null);\n  const [addFriendMenuVisible, setAddFriendMenuVisible] = useState(false);\n\n  // Search state\n  const [searchQuery, setSearchQuery] = useState('');\n  const [searchFilters, setSearchFilters] = useState<SearchFilters>({\n    healthStatus: [],\n    archetypes: [],\n  });\n  const [sortOption, setSortOption] = useState<SortOption>('default');\n\n  // Load persisted sort preference\n  useEffect(() => {\n    AsyncStorage.getItem('friendSortPreference').then(stored => {\n      if (stored && ['default', 'needs-attention', 'thriving-first', 'recently-connected', 'longest-since', 'alphabetical'].includes(stored)) {\n        setSortOption(stored as SortOption);\n      }\n    });\n  }, []);\n\n  // Persist sort preference when it changes\n  const handleSortChange = useCallback((newSort: SortOption) => {\n    setSortOption(newSort);\n    AsyncStorage.setItem('friendSortPreference', newSort);\n  }, []);\n\n  // Determine if search/sort view is active (any non-default state)\n  const isSearchActive = useMemo(() => {\n    return searchQuery.trim().length > 0 ||\n      searchFilters.healthStatus.length > 0 ||\n      searchFilters.archetypes.length > 0 ||\n      sortOption !== 'default';\n  }, [searchQuery, searchFilters, sortOption]);\n\n  // Manual friend count for segmented control (simplified fetch)\n  const [friendCounts, setFriendCounts] = useState({ inner: 0, close: 0, community: 0 });\n\n  // Circle dashboard tutorial state\n  const hasAddedFirstFriend = useTutorialStore((state) => state.hasAddedFirstFriend);\n  const hasSeenQuickWeaveIntro = useTutorialStore((state) => state.hasSeenQuickWeaveIntro);\n  const hasPerformedQuickWeave = useTutorialStore((state) => state.hasPerformedQuickWeave);\n  const markQuickWeaveIntroSeen = useTutorialStore((state) => state.markQuickWeaveIntroSeen);\n  const markQuickWeavePerformed = useTutorialStore((state) => state.markQuickWeavePerformed);\n\n  const [showCircleTutorial, setShowCircleTutorial] = useState(false);\n  const [circleTutorialStep, setCircleTutorialStep] = useState(0);\n\n  // Use a simple observable for total friend count to trigger tutorials\n  const [totalFriendsCount, setTotalFriendsCount] = useState(0);\n\n  useEffect(() => {\n    // Quick and dirty way to get counts for the segment control and tutorial check\n    // In a future refactor, TierSegmentedControl should observe these counts itself\n    const subscription = database.get<FriendModel>('friends').query().observe().subscribe(friends => {\n      const counts = { inner: 0, close: 0, community: 0 };\n      friends.forEach(f => {\n        if (f.dunbarTier === 'InnerCircle') counts.inner++;\n        else if (f.dunbarTier === 'CloseFriends') counts.close++;\n        else counts.community++;\n      });\n      setFriendCounts(counts);\n      setTotalFriendsCount(friends.length);\n\n      // Check for dormancy whenever friend list updates\n      if (friends.length > 0) {\n        checkAndApplyDormancy();\n      }\n    });\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  useFocusEffect(\n    React.useCallback(() => {\n      activeCardId.value = null;\n      let isFocused = true;\n      return () => {\n        isFocused = false;\n        if (activeCardId.value !== null) {\n          activeCardId.value = null;\n        }\n      };\n    }, [activeCardId])\n  );\n\n  // Show Circle dashboard tutorial when user has added first friend but hasn't seen intro\n  useEffect(() => {\n    if (hasAddedFirstFriend && !hasSeenQuickWeaveIntro && !hasPerformedQuickWeave && totalFriendsCount > 0) {\n      const timer = setTimeout(() => {\n        setShowCircleTutorial(true);\n        setCircleTutorialStep(0);\n      }, 500);\n      return () => clearTimeout(timer);\n    }\n  }, [hasAddedFirstFriend, hasSeenQuickWeaveIntro, hasPerformedQuickWeave, totalFriendsCount]);\n\n  // Watch for QuickWeave being opened\n  useEffect(() => {\n    if (showCircleTutorial && circleTutorialStep === 1 && isQuickWeaveOpen) {\n      handleCircleTutorialComplete();\n    }\n  }, [isQuickWeaveOpen, showCircleTutorial, circleTutorialStep]);\n\n  const [activeTier, setActiveTier] = React.useState<'inner' | 'close' | 'community'>('inner');\n  const scrollViewRef = React.useRef<ScrollView>(null);\n  const tiers = ['inner', 'close', 'community'] as const;\n\n  const handleTierChange = (tier: 'inner' | 'close' | 'community') => {\n    setActiveTier(tier);\n    scrollViewRef.current?.scrollTo({ x: tiers.indexOf(tier) * screenWidth, animated: true });\n  };\n\n  const handleCircleTutorialNext = useCallback(() => {\n    if (circleTutorialStep === 0) setCircleTutorialStep(1);\n    else setShowCircleTutorial(false);\n  }, [circleTutorialStep]);\n\n  const handleCircleTutorialComplete = useCallback(async () => {\n    await markQuickWeaveIntroSeen();\n    await markQuickWeavePerformed();\n    setShowCircleTutorial(false);\n    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  }, [markQuickWeaveIntroSeen, markQuickWeavePerformed]);\n\n  const handleCircleTutorialSkip = useCallback(async () => {\n    await markQuickWeaveIntroSeen();\n    setShowCircleTutorial(false);\n  }, [markQuickWeaveIntroSeen]);\n\n  const onAddFriend = () => setAddFriendMenuVisible(true);\n\n  const handleAddSingle = () => {\n    router.push(`/add-friend?tier=${activeTier}`);\n  };\n\n  const handleAddBatch = () => {\n    router.push(`/batch-add-friends?tier=${activeTier}`);\n  };\n\n  const onScroll = (event: any) => {\n    const slide = Math.round(event.nativeEvent.contentOffset.x / screenWidth);\n    if (slide !== tiers.indexOf(activeTier)) {\n      setActiveTier(tiers[slide]);\n    }\n  };\n\n  const handleActOnSuggestion = async (suggestion: Suggestion) => {\n    setInsightsSheetVisible(false);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    await SuggestionTrackerService.trackSuggestionActed(suggestion.id);\n\n    if (suggestion.category === 'portfolio') return;\n\n    if (suggestion.action.type === 'reflect') {\n      const friend = await database.get<FriendModel>('friends').find(suggestion.friendId);\n      if (friend && suggestion.action.interactionId) {\n        const activityLabel = suggestion.subtitle.match(/your (.*?) with/)?.[1] || 'time together';\n        showMicroReflectionSheet({\n          friendId: suggestion.friendId,\n          friendName: suggestion.friendName || '',\n          activityId: '',\n          activityLabel,\n          interactionId: suggestion.action.interactionId,\n          friendArchetype: friend.archetype,\n        });\n      }\n    } else if (suggestion.action.type === 'log') {\n      router.push(`/weave-logger?friendId=${suggestion.friendId}`);\n    } else if (suggestion.action.type === 'plan') {\n      router.push(`/friend-profile?friendId=${suggestion.friendId}`);\n    }\n  };\n\n  const handleDismissSuggestion = async (suggestionId: string) => {\n    const cooldownDays = getSuggestionCooldownDays(suggestionId);\n    await dismissSuggestion(suggestionId, cooldownDays);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  // Safe mapping from internal view state to database enum\n  const getDbTier = (viewTier: 'inner' | 'close' | 'community'): Tier => {\n    switch (viewTier) {\n      case 'inner': return 'InnerCircle';\n      case 'close': return 'CloseFriends';\n      default: return 'Community';\n    }\n  };\n\n  const renderTier = (viewTier: 'inner' | 'close' | 'community') => {\n    return (\n      <FriendTierList\n        tier={getDbTier(viewTier)}\n        scrollHandler={animatedScrollHandler}\n        isQuickWeaveOpen={isQuickWeaveOpen}\n      />\n    );\n  };\n\n  const handleClearSearch = useCallback(() => {\n    setSearchQuery('');\n    setSearchFilters({ healthStatus: [], archetypes: [] });\n    handleSortChange('default');\n  }, [handleSortChange]);\n\n  return (\n    <View style={[styles.safeArea, { backgroundColor: colors.background }]}>\n      {/* Search Bar - Always visible */}\n      <FriendSearchBar\n        searchQuery={searchQuery}\n        onSearchChange={setSearchQuery}\n        filters={searchFilters}\n        onFiltersChange={setSearchFilters}\n        sortOption={sortOption}\n        onSortChange={handleSortChange}\n        isActive={isSearchActive}\n        onClear={handleClearSearch}\n      />\n\n      {/* Conditional Rendering: Search Results or Tier View */}\n      {isSearchActive ? (\n        /* Search Results View */\n        <Animated.View\n          key=\"search-results\"\n          entering={FadeIn.duration(200)}\n          exiting={FadeOut.duration(150)}\n          style={{ flex: 1 }}\n        >\n          <GestureDetector gesture={gesture}>\n            <FriendSearchResults\n              searchQuery={searchQuery}\n              filters={searchFilters}\n              sortOption={sortOption}\n              scrollHandler={animatedScrollHandler}\n              isQuickWeaveOpen={isQuickWeaveOpen}\n            />\n          </GestureDetector>\n        </Animated.View>\n      ) : (\n        /* Normal Tier View */\n        <Animated.View\n          key=\"tier-view\"\n          entering={FadeIn.duration(200)}\n          exiting={FadeOut.duration(150)}\n          style={{ flex: 1 }}\n        >\n          <TierSegmentedControl\n            activeTier={activeTier}\n            onTierChange={handleTierChange}\n            counts={friendCounts}\n          />\n          <TierInfo activeTier={activeTier} />\n\n          <GestureDetector gesture={gesture}>\n            <Animated.ScrollView\n              ref={scrollViewRef as any}\n              horizontal\n              pagingEnabled\n              showsHorizontalScrollIndicator={false}\n              onMomentumScrollEnd={onScroll}\n              scrollEventThrottle={16}\n              scrollEnabled={!isQuickWeaveOpen}\n              directionalLockEnabled={true}\n            >\n              {renderTier('inner')}\n              {renderTier('close')}\n              {renderTier('community')}\n            </Animated.ScrollView>\n          </GestureDetector>\n        </Animated.View>\n      )}\n\n      <FAB onClick={onAddFriend} />\n\n      <InsightsFAB\n        isVisible={suggestionCount > 0 || intentions.length > 0}\n        hasSuggestions={suggestionCount > 0}\n        hasCritical={hasCritical}\n        onClick={() => setInsightsSheetVisible(true)}\n      />\n\n      {/* MicroReflectionSheet is handled globally by QuickWeaveProvider in _layout.tsx */}\n\n      <InsightsSheet\n        isVisible={insightsSheetVisible}\n        suggestions={suggestions}\n        intentions={intentions}\n        onClose={() => setInsightsSheetVisible(false)}\n        onAct={handleActOnSuggestion}\n        onLater={handleDismissSuggestion}\n        onIntentionPress={(intention) => {\n          setSelectedIntention(intention);\n          setInsightsSheetVisible(false);\n        }}\n      />\n\n      <IntentionActionSheet\n        intention={selectedIntention}\n        isOpen={selectedIntention !== null}\n        onClose={() => setSelectedIntention(null)}\n        onSchedule={async (intention, intentionFriend) => {\n          await PlanService.convertIntentionToPlan(intention.id);\n          setSelectedIntention(null);\n          router.push({ pathname: '/friend-profile', params: { friendId: intentionFriend.id } });\n        }}\n        onDismiss={async (intention) => {\n          await dismissIntention(intention.id);\n          setSelectedIntention(null);\n        }}\n      />\n\n      <AddFriendMenu\n        isOpen={addFriendMenuVisible}\n        onClose={() => setAddFriendMenuVisible(false)}\n        onAddSingle={handleAddSingle}\n        onAddBatch={handleAddBatch}\n      />\n\n      {showCircleTutorial && circleTutorialStep === 0 && (\n        <SimpleTutorialTooltip\n          visible={true}\n          title=\"Your Circle dashboard\"\n          description=\"Tap any friend card to open their profile, where you can set intentions, plan future weaves, or log past moments in detail.\"\n          onNext={handleCircleTutorialNext}\n          onSkip={handleCircleTutorialSkip}\n          currentStep={0}\n          totalSteps={2}\n        />\n      )}\n\n      {showCircleTutorial && circleTutorialStep === 1 && (\n        <SimpleTutorialTooltip\n          visible={true}\n          title=\"QuickWeave: The fast way\"\n          description=\"For quick logging, press and hold any friend card. A radial menu will appear with interaction options.\"\n          onSkip={handleCircleTutorialSkip}\n          currentStep={1}\n          totalSteps={2}\n        />\n      )}\n    </View>\n  );\n}\n\nexport default function RootLayout() {\n  return (<DashboardContent />);\n}\n\nconst styles = StyleSheet.create({\n  safeArea: { flex: 1 },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/_home.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":33,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useRef } from 'react';\n\nimport { HomeWidgetGrid, WidgetGridItem } from '@/components/home/HomeWidgetGrid';\nimport { SocialSeasonWidgetV2 } from '@/components/home/widgets/SocialSeasonWidgetV2';\nimport { YourEnergyWidget } from '@/components/home/widgets/YourEnergyWidget';\nimport { TodaysFocusWidgetV2 } from '@/components/home/widgets/TodaysFocusWidgetV2';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { ReflectionReadyWidget } from '@/components/home/widgets/ReflectionReadyWidget';\nimport { SocialBatterySheet } from '@/components/home/SocialBatterySheet';\nimport { ReflectionReadyPrompt } from '@/components/WeeklyReflection/ReflectionReadyPrompt';\nimport { YearInMoonsModal } from '@/components/YearInMoons/YearInMoonsModal';\nimport { useUserProfileStore } from '@/modules/auth';\nimport { notificationStore } from '@/modules/notifications';\nimport { getUserAccountAge } from '@/modules/notifications';\nimport { useTutorialStore } from '@/stores/tutorialStore';\nimport { useUIStore } from '@/stores/uiStore';\nimport { isSameWeek } from 'date-fns';\n\n/**\n * The home screen of the application.\n * Displays a grid of widgets and handles modals for social battery check-ins and weekly reflections.\n * @returns {React.ReactElement} The rendered home screen.\n */\nexport default function Home() {\n  const { observeProfile, profile, submitBatteryCheckin, updateProfile } = useUserProfileStore();\n  const {\n    openWeeklyReflection,\n    isReflectionPromptOpen,\n    openReflectionPrompt,\n    closeReflectionPrompt\n  } = useUIStore();\n  const theme = useTheme();\n  const colors = theme?.colors || {};\n  const [showBatterySheet, setShowBatterySheet] = useState(false);\n  const [showYearInMoons, setShowYearInMoons] = useState(false);\n  const [isWidgetVisible, setIsWidgetVisible] = useState(false);\n\n  // Mounted state and timeout refs to prevent race conditions\n  const isMountedRef = useRef(true);\n  const batteryTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const reflectionPromptTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const moonsTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Tutorial state - check if QuickWeave tutorial is done\n  const hasPerformedQuickWeave = useTutorialStore((state) => state.hasPerformedQuickWeave);\n\n  // Cleanup timeouts on unmount to prevent setState on unmounted component\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n      if (batteryTimerRef.current) clearTimeout(batteryTimerRef.current);\n      if (reflectionPromptTimerRef.current) clearTimeout(reflectionPromptTimerRef.current);\n      if (moonsTimerRef.current) clearTimeout(moonsTimerRef.current);\n    };\n  }, []);\n\n  // Initialize user profile observable on mount\n  useEffect(() => {\n    try {\n      const cleanup = observeProfile();\n      return cleanup;\n    } catch (error) {\n      console.error('[Home] Failed to observe profile:', error);\n      // Optionally show error toast to user\n    }\n  }, []);\n\n  // Check if user should be prompted for battery check-in\n  // Wait until QuickWeave tutorial is complete before showing (avoid conflicts)\n  useEffect(() => {\n    // Default to enabled if not explicitly set\n    if (!profile) return;\n    const isEnabled = profile.batteryCheckinEnabled ?? true;\n    if (!isEnabled) return;\n\n    // Don't show battery sheet during onboarding flow\n    // Wait until user has completed their first QuickWeave OR has been using the app for a while\n    const checkEligibility = async () => {\n      if (hasPerformedQuickWeave) return true;\n\n      // Fallback for existing users: check account age\n      const age = await getUserAccountAge();\n      return age !== null && age >= 3;\n    };\n\n    checkEligibility().then(isEligible => {\n      if (!isEligible) return;\n\n      const lastCheckin = profile.socialBatteryLastCheckin;\n      if (!lastCheckin) {\n        console.log('[Home] No last check-in found, showing battery sheet');\n        // Never checked in - show after brief delay\n        batteryTimerRef.current = setTimeout(() => {\n          if (isMountedRef.current) {\n            setShowBatterySheet(true);\n          }\n        }, 600);\n        return () => {\n          if (batteryTimerRef.current) {\n            clearTimeout(batteryTimerRef.current);\n          }\n        };\n      }\n\n      // Check if last check-in was today\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      const lastCheckinDate = new Date(lastCheckin);\n      lastCheckinDate.setHours(0, 0, 0, 0);\n\n      const needsCheckin = lastCheckinDate < today;\n      console.log(`[Home] Battery Check-in Status: Last=${lastCheckinDate.toDateString()}, Today=${today.toDateString()}, Needs=${needsCheckin}`);\n\n      if (needsCheckin) {\n        // Last check-in was before today - show after brief delay\n        batteryTimerRef.current = setTimeout(() => {\n          if (isMountedRef.current) {\n            setShowBatterySheet(true);\n          }\n        }, 600);\n        return () => {\n          if (batteryTimerRef.current) {\n            clearTimeout(batteryTimerRef.current);\n          }\n        };\n      }\n    });\n  }, [profile, hasPerformedQuickWeave]);\n\n  // Check if weekly reflection should be shown\n  useEffect(() => {\n    const checkWeeklyReflection = async () => {\n      if (!profile) return;\n\n      const lastDate = await notificationStore.getLastReflectionDate();\n      // Due if no last date, or if last date is NOT in the same week (Sunday start)\n      const isDue = !lastDate || !isSameWeek(lastDate, new Date(), { weekStartsOn: 0 });\n\n      // Check grace period: only show widget after 3+ days of app usage\n      const accountAge = await getUserAccountAge();\n      const meetsGracePeriod = accountAge !== null && accountAge >= 3;\n\n      // Check days\n      const today = new Date();\n      const currentDay = today.getDay();\n      const isSunday = currentDay === 0;\n      const isMonday = currentDay === 1;\n\n      // Widget Visibility: Sunday OR Monday, if due and meets grace period\n      const widgetVisible = isDue && meetsGracePeriod && (isSunday || isMonday);\n      setIsWidgetVisible(widgetVisible);\n\n      // Prompt Logic: Sunday ONLY, if due and meets grace period\n      if (!isDue || !meetsGracePeriod || !isSunday) return;\n\n      // Get user preferences (defaults: Sunday, auto-show enabled)\n      const reflectionDay = profile.reflectionDay ?? 0; // 0 = Sunday\n      const autoShow = profile.reflectionAutoShow ?? true;\n      const lastSnoozed = profile.reflectionLastSnoozed;\n\n      // Check if snoozed (snooze lasts until next day at 9 AM)\n      let isSnoozed = false;\n      if (lastSnoozed) {\n        const snoozeUntil = new Date(lastSnoozed);\n        snoozeUntil.setDate(snoozeUntil.getDate() + 1);\n        snoozeUntil.setHours(9, 0, 0, 0);\n        isSnoozed = today < snoozeUntil;\n      }\n\n      // Only auto-show if it's the reflection day (Sunday), auto-show is enabled, and not snoozed\n      if (currentDay === reflectionDay && autoShow && !isSnoozed) {\n        // Wait longer than battery check-in so it doesn't conflict\n        // Show after 2 seconds if battery sheet is dismissed or not shown\n        reflectionPromptTimerRef.current = setTimeout(() => {\n          // Use global open action\n          if (isMountedRef.current && !showBatterySheet && !isReflectionPromptOpen) {\n            openReflectionPrompt();\n          }\n        }, 2000);\n        return () => {\n          if (reflectionPromptTimerRef.current) {\n            clearTimeout(reflectionPromptTimerRef.current);\n          }\n        };\n      }\n    };\n\n    checkWeeklyReflection();\n  }, [profile, showBatterySheet]);\n\n  const handleBatterySubmit = async (value: number, note?: string) => {\n    await submitBatteryCheckin(value, note);\n    setShowBatterySheet(false);\n  };\n\n  const handleReflectionStart = () => {\n    closeReflectionPrompt();\n    // Add small delay to ensure prompt closes before reflection opens (prevents iOS modal conflict)\n    setTimeout(() => {\n      openWeeklyReflection();\n    }, 500);\n  };\n\n  const handleReflectionRemindLater = async () => {\n    closeReflectionPrompt();\n    // Save snooze timestamp to profile\n    if (profile) {\n      await updateProfile({\n        reflectionLastSnoozed: Date.now(),\n      });\n    }\n  };\n\n  // Define widget grid - Compass Hub design\n  // Order: Action (Focus) → Context (Season) → Reflection (Moons) → Reflection Ready (if due)\n  const widgets: WidgetGridItem[] = [\n    {\n      id: 'todays-focus',\n      component: TodaysFocusWidgetV2,\n      config: {\n        id: 'todays-focus',\n        type: 'todays-focus',\n        fullWidth: true,\n      },\n      position: 0,\n      visible: true,\n    },\n    {\n      id: 'social-season',\n      component: SocialSeasonWidgetV2,\n      config: {\n        id: 'social-season',\n        type: 'social-season',\n        fullWidth: true,\n      },\n      position: 1,\n      visible: true,\n    },\n    {\n      id: 'your-energy',\n      component: YourEnergyWidget,\n      config: {\n        id: 'your-energy',\n        type: 'your-energy',\n        fullWidth: true,\n      },\n      position: 2,\n      visible: true,\n    },\n    {\n      id: 'reflection-ready',\n      component: ReflectionReadyWidget,\n      config: {\n        id: 'reflection-ready',\n        type: 'reflection-ready',\n        fullWidth: true,\n      },\n      props: {\n        onPress: openReflectionPrompt, // Use global action\n      },\n      position: 3,\n      visible: isWidgetVisible,\n    },\n  ];\n\n  return (\n    <>\n      <HomeWidgetGrid widgets={widgets} />\n\n      <SocialBatterySheet\n        isVisible={showBatterySheet}\n        onSubmit={handleBatterySubmit}\n        onDismiss={() => setShowBatterySheet(false)}\n        onViewYearInMoons={() => {\n          setShowBatterySheet(false);\n          // Add delay to allow sheet to close before opening modal\n          moonsTimerRef.current = setTimeout(() => {\n            if (isMountedRef.current) {\n              setShowYearInMoons(true);\n            }\n          }, 500);\n        }}\n      />\n\n      <ReflectionReadyPrompt\n        isVisible={isReflectionPromptOpen}\n        onStart={handleReflectionStart}\n        onRemindLater={handleReflectionRemindLater}\n        onDismiss={closeReflectionPrompt}\n      />\n\n      <YearInMoonsModal\n        isOpen={showYearInMoons}\n        onClose={() => setShowYearInMoons(false)}\n      />\n    </>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/_layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/add-friend.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/batch-add-friends.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/dashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":50,"column":34,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":50,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FriendModel' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":51,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":30},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":51,"column":33,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":51,"endColumn":62}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef } from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet, Dimensions, ScrollView, NativeSyntheticEvent, NativeScrollEvent } from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { Sparkles, Users, Settings } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { SettingsModal } from '@/components/settings-modal';\nimport { SocialBatterySheet } from '@/components/home/SocialBatterySheet';\nimport BadgeUnlockModal from '@/components/BadgeUnlockModal';\nimport { useUserProfileStore } from '@/modules/auth';\nimport { useUIStore } from '@/stores/uiStore';\nimport { useSuggestions } from '@/modules/interactions';\nimport HomeScreen from './_home';\nimport FriendsScreen from './_friends';\n\nconst { width: screenWidth } = Dimensions.get('window');\n\nexport default function Dashboard() {\n    const theme = useTheme();\n    const colors = theme?.colors || {};\n    const [activeTab, setActiveTab] = useState<'insights' | 'circle'>('circle');\n    const [showSettings, setShowSettings] = useState(false);\n    const {\n        isSocialBatterySheetOpen,\n        openSocialBatterySheet,\n        closeSocialBatterySheet\n    } = useUIStore();\n    const { submitBatteryCheckin } = useUserProfileStore();\n    const { suggestions } = useSuggestions();\n    const suggestionCount = suggestions.length;\n    const scrollViewRef = useRef<ScrollView>(null);\n\n    const handleTabPress = (tab: 'insights' | 'circle') => {\n        setActiveTab(tab);\n        const index = tab === 'insights' ? 0 : 1;\n        scrollViewRef.current?.scrollTo({ x: index * screenWidth, animated: true });\n    };\n\n    const onScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n        const slide = Math.round(event.nativeEvent.contentOffset.x / screenWidth);\n        const newTab = slide === 0 ? 'insights' : 'circle';\n        if (newTab !== activeTab) {\n            setActiveTab(newTab);\n        }\n    };\n\n    // Auto-repair specific logic for broken tiers (one-time check on mount)\n    // This fixes friends that were saved with \"inner\"/\"close\" instead of \"InnerCircle\"/\"CloseFriends\"\n    React.useEffect(() => {\n        const repairTiers = async () => {\n            const { database } = require('@/db');\n            const FriendModel = require('@/db/models/Friend').default;\n\n            const friendsToFix = await database.get('friends').query().fetch();\n            const updates: any[] = [];\n\n            for (const friend of friendsToFix) {\n                let needsFix = false;\n                let newTier = '';\n\n                if (friend.dunbarTier === 'inner') {\n                    needsFix = true;\n                    newTier = 'InnerCircle';\n                } else if (friend.dunbarTier === 'close') {\n                    needsFix = true;\n                    newTier = 'CloseFriends';\n                } else if (friend.dunbarTier === 'community') {\n                    needsFix = true;\n                    newTier = 'Community'; // Ensure capitalization if needed, though Community is usually correct\n                }\n\n                if (needsFix) {\n                    updates.push(friend.prepareUpdate((f: any) => {\n                        f.dunbarTier = newTier;\n                    }));\n                }\n            }\n\n            if (updates.length > 0) {\n                console.log(`Repaired ${updates.length} friends with incorrect tier values.`);\n                await database.write(async () => {\n                    await database.batch(...updates);\n                });\n            }\n        };\n\n        repairTiers();\n    }, []);\n\n    return (\n        <View style={{ flex: 1, backgroundColor: colors.background }}>\n            <SafeAreaView style={styles.container} edges={['top']}>\n                <View style={[styles.tabBar, { backgroundColor: 'transparent', borderBottomColor: colors.border }]}>\n                    <View style={styles.tabsContainer}>\n                        <TouchableOpacity\n                            style={[styles.tab, activeTab === 'insights' && styles.activeTab]}\n                            onPress={() => handleTabPress('insights')}\n                        >\n                            <View style={styles.tabIconContainer}>\n                                <Sparkles\n                                    size={24}\n                                    color={activeTab === 'insights' ? colors.primary : colors['muted-foreground']}\n                                />\n                                {suggestionCount > 0 && (\n                                    <View style={[styles.notificationBadge, { backgroundColor: colors.primary }]}>\n                                        <Text style={styles.notificationText}>{suggestionCount}</Text>\n                                    </View>\n                                )}\n                            </View>\n                            <Text style={[styles.tabLabel, { color: activeTab === 'insights' ? colors.primary : colors['muted-foreground'] }]}>\n                                Insights\n                            </Text>\n                        </TouchableOpacity>\n\n                        <TouchableOpacity\n                            style={[styles.tab, activeTab === 'circle' && styles.activeTab]}\n                            onPress={() => handleTabPress('circle')}\n                        >\n                            <Users size={24} color={activeTab === 'circle' ? colors.primary : colors['muted-foreground']} />\n                            <Text style={[styles.tabLabel, { color: activeTab === 'circle' ? colors.primary : colors['muted-foreground'] }]}>\n                                Circle\n                            </Text>\n                        </TouchableOpacity>\n                    </View>\n\n                    <TouchableOpacity onPress={() => setShowSettings(true)} style={styles.settingsButton}>\n                        <Settings size={24} color={colors['muted-foreground']} />\n                    </TouchableOpacity>\n                </View>\n\n                <ScrollView\n                    ref={scrollViewRef}\n                    horizontal\n                    pagingEnabled\n                    showsHorizontalScrollIndicator={false}\n                    onMomentumScrollEnd={onScroll}\n                    scrollEventThrottle={16}\n                    style={styles.scrollView}\n                    contentOffset={{ x: screenWidth, y: 0 }}\n                >\n                    <View style={{ width: screenWidth, flex: 1 }}>\n                        <HomeScreen />\n                    </View>\n                    <View style={{ width: screenWidth, flex: 1 }}>\n                        <FriendsScreen />\n                    </View>\n                </ScrollView>\n\n                <SettingsModal\n                    isOpen={showSettings}\n                    onClose={() => setShowSettings(false)}\n                    onOpenBatteryCheckIn={() => {\n                        setShowSettings(false);\n                        openSocialBatterySheet();\n                    }}\n                />\n\n                <SocialBatterySheet\n                    isVisible={isSocialBatterySheetOpen}\n                    onSubmit={async (value, note) => {\n                        await submitBatteryCheckin(value, note);\n                        closeSocialBatterySheet();\n                    }}\n                    onDismiss={() => closeSocialBatterySheet()}\n                />\n            </SafeAreaView>\n            <BadgeUnlockModal />\n        </View>\n    );\n}\n\nconst styles = StyleSheet.create({\n    container: { flex: 1 },\n    tabBar: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        borderBottomWidth: 1,\n        paddingHorizontal: 20,\n        justifyContent: 'space-between',\n    },\n    tabsContainer: { flexDirection: 'row', flex: 1 },\n    tab: {\n        flex: 1,\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingVertical: 16,\n        gap: 8,\n    },\n    activeTab: { borderBottomWidth: 2, borderBottomColor: 'transparent' },\n    tabLabel: { fontFamily: 'Inter_600SemiBold', fontSize: 16 },\n    settingsButton: { padding: 12 },\n    scrollView: { flex: 1 },\n    tabIconContainer: { position: 'relative' },\n    notificationBadge: {\n        position: 'absolute',\n        top: -4,\n        right: -8,\n        minWidth: 18,\n        height: 18,\n        borderRadius: 9,\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingHorizontal: 4,\n    },\n    notificationText: {\n        color: '#FFFFFF',\n        fontSize: 11,\n        fontWeight: '600',\n        fontFamily: 'Inter_600SemiBold',\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/edit-friend.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/friend-profile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/global-calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/journal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friendName' is defined but never used. Allowed unused args must match /^_/u.","line":104,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":56},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":135,"column":62,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":135,"endColumn":122},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":136,"column":48,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":136,"endColumn":75}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View } from 'react-native';\nimport { useLocalSearchParams, useRouter } from 'expo-router';\nimport {\n    JournalHome,\n    QuickCaptureSheet,\n    GuidedReflectionModal,\n    FriendshipArcView,\n    JournalEntryModal,\n} from '@/components/Journal';\nimport { WeeklyReflectionDetailModal } from '@/components/WeeklyReflection/WeeklyReflectionDetailModal';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\n\nexport default function JournalScreen() {\n    const router = useRouter();\n    const params = useLocalSearchParams<{\n        mode?: string;\n        friendId?: string;\n        weaveId?: string;\n        openEntryId?: string;\n        openEntryType?: string;\n        prefilledText?: string;\n        prefilledFriendIds?: string;\n    }>();\n\n    const [showQuickCapture, setShowQuickCapture] = useState(false);\n    const [showGuided, setShowGuided] = useState(params.mode === 'guided');\n    const [selectedFriendId, setSelectedFriendId] = useState<string | null>(params.friendId || null);\n    const [prefilledText, setPrefilledText] = useState<string>('');\n    const [prefilledFriendIds, setPrefilledFriendIds] = useState<string[]>([]);\n\n    // Selection state\n    const [selectedEntry, setSelectedEntry] = useState<JournalEntry | null>(null);\n    const [selectedReflection, setSelectedReflection] = useState<WeeklyReflection | null>(null);\n\n    // Deep link handling\n    React.useEffect(() => {\n        const handleDeepLink = async () => {\n            // Handle opening specific entry\n            if (params.openEntryId) {\n                try {\n                    if (params.openEntryType === 'reflection') {\n                        const reflection = await database.get<WeeklyReflection>('weekly_reflections').find(params.openEntryId);\n                        setSelectedReflection(reflection);\n                    } else {\n                        // Default to journal\n                        const entry = await database.get<JournalEntry>('journal_entries').find(params.openEntryId);\n                        setSelectedEntry(entry);\n                    }\n                } catch (error) {\n                    console.error('Error opening linked entry:', error);\n                }\n            }\n\n            // Handle prefilled guided reflection\n            if (params.mode === 'guided') {\n                if (params.prefilledText) {\n                    setPrefilledText(params.prefilledText);\n                }\n                if (params.prefilledFriendIds) {\n                    setPrefilledFriendIds(params.prefilledFriendIds.split(',').filter(Boolean));\n                }\n                setShowGuided(true);\n            }\n        };\n\n        handleDeepLink();\n    }, [params.openEntryId, params.mode]); // Don't depend on params object directly to avoid loops\n\n    const handleArcEntryPress = async (id: string, type: 'journal' | 'reflection') => {\n        try {\n            if (type === 'journal') {\n                const entry = await database.get<JournalEntry>('journal_entries').find(id);\n                setSelectedEntry(entry);\n            } else if (type === 'reflection') {\n                const reflection = await database.get<WeeklyReflection>('weekly_reflections').find(id);\n                setSelectedReflection(reflection);\n            }\n        } catch (error) {\n            console.error('Error fetching entry:', error);\n        }\n    };\n\n    return (\n        <>\n            {selectedFriendId ? (\n                <FriendshipArcView\n                    friendId={selectedFriendId}\n                    onBack={() => {\n                        if (params.friendId) {\n                            if (router.canGoBack()) {\n                                router.back();\n                            } else {\n                                router.replace('/');\n                            }\n                        } else {\n                            setSelectedFriendId(null);\n                        }\n                    }}\n                    onEntryPress={handleArcEntryPress}\n                    onWriteAbout={(friendId, friendName) => {\n                        setPrefilledFriendIds([friendId]);\n                        setSelectedFriendId(null);\n                        setShowGuided(true);\n                    }}\n                />\n            ) : (\n                <JournalHome\n                    onClose={() => {\n                        if (router.canGoBack()) {\n                            router.back();\n                        } else {\n                            router.replace('/');\n                        }\n                    }}\n                    onNewEntry={(mode) => {\n                        if (mode === 'quick') setShowQuickCapture(true);\n                        else setShowGuided(true);\n                    }}\n                    onEntryPress={(entry) => {\n                        if ('weekStartDate' in entry) {\n                            setSelectedReflection(entry as WeeklyReflection);\n                        } else {\n                            setSelectedEntry(entry as JournalEntry);\n                        }\n                    }}\n                    onFriendArcPress={(friendId) => {\n                        setSelectedFriendId(friendId);\n                    }}\n                    onMemoryAction={async (memory) => {\n                        // Fetch full data needed for the modal\n                        const { getMemoryForNotification } = require('@/modules/journal/services/journal-context-engine');\n                        const { useUIStore } = require('@/stores/uiStore');\n\n                        const type = memory.id.includes('reflection') ? 'reflection' : 'journal';\n                        const data = await getMemoryForNotification(memory.relatedEntryId!, type);\n\n                        if (data) {\n                            useUIStore.getState().openMemoryMoment(data);\n                        }\n                    }}\n                />\n            )}\n\n            <QuickCaptureSheet\n                visible={showQuickCapture}\n                onClose={() => setShowQuickCapture(false)}\n                onExpandToFull={(text, friendIds) => {\n                    setPrefilledText(text);\n                    setPrefilledFriendIds(friendIds);\n                    setShowQuickCapture(false);\n                    setShowGuided(true);\n                }}\n            />\n\n            <GuidedReflectionModal\n                visible={showGuided}\n                onClose={() => {\n                    setShowGuided(false);\n                    setPrefilledText('');\n                    setPrefilledFriendIds([]);\n                }}\n                onSave={(entry) => {\n                    console.log('Saved:', entry);\n                }}\n                prefilledWeaveId={params.weaveId}\n                prefilledText={prefilledText}\n                prefilledFriendIds={prefilledFriendIds}\n            />\n\n            {/* Entry Viewers */}\n            <JournalEntryModal\n                isOpen={!!selectedEntry}\n                onClose={() => setSelectedEntry(null)}\n                entry={selectedEntry}\n                onSave={() => {\n                    // Refresh data if needed, or just close\n                    setSelectedEntry(null);\n                }}\n            />\n\n            <WeeklyReflectionDetailModal\n                isOpen={!!selectedReflection}\n                onClose={() => setSelectedReflection(null)}\n                reflection={selectedReflection}\n            />\n        </>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/onboarding.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/permissions.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Notifications' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet, Alert } from 'react-native';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useRouter } from 'expo-router';\nimport Animated, { FadeInDown } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\nimport * as Contacts from 'expo-contacts';\nimport * as Calendar from 'expo-calendar';\nimport * as Notifications from 'expo-notifications';\nimport { Bell, Users, CalendarDays, CheckCircle2, XCircle } from 'lucide-react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { useNotificationPermissions } from '@/modules/notifications';\n\nconst PERMISSIONS_COMPLETED_KEY = '@weave:permissions_completed';\nconst NOTIFICATION_PERMISSION_ASKED_KEY = '@weave:notification_permission_asked';\n\ntype PermissionStatus = 'pending' | 'granted' | 'denied';\n\ninterface Permission {\n  id: string;\n  title: string;\n  description: string;\n  icon: React.ReactNode;\n  required: boolean;\n  status: PermissionStatus;\n}\n\nexport default function PermissionsScreen() {\n  const router = useRouter();\n  const { colors } = useTheme();\n  const { requestPermission: requestNotificationPermission } = useNotificationPermissions();\n  const [isRequesting, setIsRequesting] = useState(false);\n  const navigationTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const hasNavigatedRef = useRef(false);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (navigationTimeoutRef.current) {\n        clearTimeout(navigationTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  const [permissions, setPermissions] = useState<Permission[]>([\n    {\n      id: 'contacts',\n      title: 'Contacts',\n      description: 'Helps you quickly find and add friends from your address book',\n      icon: <Users size={28} color={colors.primary} />,\n      required: true,\n      status: 'pending',\n    },\n    {\n      id: 'notifications',\n      title: 'Notifications',\n      description: 'Gentle reminders to nurture your relationships',\n      icon: <Bell size={28} color={colors.primary} />,\n      required: false,\n      status: 'pending',\n    },\n    {\n      id: 'calendar',\n      title: 'Calendar',\n      description: 'Sync planned interactions and detect past events to log',\n      icon: <CalendarDays size={28} color={colors.primary} />,\n      required: false,\n      status: 'pending',\n    },\n  ]);\n\n  const updatePermissionStatus = (id: string, status: PermissionStatus) => {\n    setPermissions((prev) =>\n      prev.map((p) => (p.id === id ? { ...p, status } : p))\n    );\n  };\n\n  const requestPermissions = async () => {\n    setIsRequesting(true);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n\n    try {\n      // Request Contacts\n      const contactsResult = await Contacts.requestPermissionsAsync();\n      updatePermissionStatus(\n        'contacts',\n        contactsResult.status === 'granted' ? 'granted' : 'denied'\n      );\n\n      // Request Notifications\n      const notificationGranted = await requestNotificationPermission();\n      updatePermissionStatus(\n        'notifications',\n        notificationGranted ? 'granted' : 'denied'\n      );\n\n      // Request Calendar\n      const calendarResult = await Calendar.requestCalendarPermissionsAsync();\n      updatePermissionStatus(\n        'calendar',\n        calendarResult.status === 'granted' ? 'granted' : 'denied'\n      );\n\n      // Mark permissions flow as completed\n      await AsyncStorage.setItem(PERMISSIONS_COMPLETED_KEY, 'true');\n      await AsyncStorage.setItem(NOTIFICATION_PERMISSION_ASKED_KEY, 'true');\n\n      // Short delay to show status updates\n      navigationTimeoutRef.current = setTimeout(() => {\n        if (!hasNavigatedRef.current) {\n          handleContinue();\n        }\n      }, 800);\n    } catch (error) {\n      console.error('[Permissions] Error requesting permissions:', error);\n      Alert.alert(\n        'Permission Error',\n        'There was an issue requesting permissions. You can grant them later in Settings.',\n        [{ text: 'Continue', onPress: handleContinue }]\n      );\n    } finally {\n      setIsRequesting(false);\n    }\n  };\n\n  const handleContinue = () => {\n    if (hasNavigatedRef.current) return; // Prevent double navigation\n    hasNavigatedRef.current = true;\n\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    router.replace('/add-friend?fromOnboarding=true');\n  };\n\n  const handleSkip = async () => {\n    // Cancel any pending navigation\n    if (navigationTimeoutRef.current) {\n      clearTimeout(navigationTimeoutRef.current);\n      navigationTimeoutRef.current = null;\n    }\n\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n    // Mark as completed so we don't show this screen again\n    await AsyncStorage.setItem(PERMISSIONS_COMPLETED_KEY, 'true');\n    handleContinue();\n  };\n\n  const allGranted = permissions.every((p) => p.status === 'granted');\n  const someGranted = permissions.some((p) => p.status === 'granted');\n\n  return (\n    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={['top', 'bottom']}>\n      <View style={styles.content}>\n        <Animated.View entering={FadeInDown.duration(600).delay(100)}>\n          <Text style={[styles.title, { color: colors.foreground }]}>\n            Let's Set Up Weave\n          </Text>\n          <Text style={[styles.subtitle, { color: colors['muted-foreground'] }]}>\n            To help you nurture your relationships, Weave needs a few permissions.\n          </Text>\n        </Animated.View>\n\n        <View style={styles.permissionsContainer}>\n          {permissions.map((permission, index) => (\n            <Animated.View\n              key={permission.id}\n              entering={FadeInDown.duration(600).delay(300 + index * 100)}\n              style={[\n                styles.permissionCard,\n                {\n                  backgroundColor: colors.card,\n                  borderColor: colors.border,\n                },\n              ]}\n            >\n              <View style={styles.permissionHeader}>\n                <View\n                  style={[\n                    styles.iconContainer,\n                    { backgroundColor: colors.muted },\n                  ]}\n                >\n                  {permission.icon}\n                </View>\n                <View style={styles.permissionInfo}>\n                  <View style={styles.titleRow}>\n                    <Text style={[styles.permissionTitle, { color: colors.foreground }]}>\n                      {permission.title}\n                    </Text>\n                    {permission.required && (\n                      <View style={[styles.requiredBadge, { backgroundColor: colors.primary }]}>\n                        <Text style={styles.requiredText}>Required</Text>\n                      </View>\n                    )}\n                  </View>\n                  <Text style={[styles.permissionDescription, { color: colors['muted-foreground'] }]}>\n                    {permission.description}\n                  </Text>\n                </View>\n                {permission.status !== 'pending' && (\n                  <View style={styles.statusIcon}>\n                    {permission.status === 'granted' ? (\n                      <CheckCircle2 size={24} color=\"#10b981\" />\n                    ) : (\n                      <XCircle size={24} color={colors['muted-foreground']} />\n                    )}\n                  </View>\n                )}\n              </View>\n            </Animated.View>\n          ))}\n        </View>\n\n        <Animated.View\n          entering={FadeInDown.duration(600).delay(800)}\n          style={styles.actionsContainer}\n        >\n          {!someGranted ? (\n            <>\n              <TouchableOpacity\n                style={[styles.primaryButton, { backgroundColor: colors.primary }]}\n                onPress={requestPermissions}\n                disabled={isRequesting}\n              >\n                <Text style={styles.primaryButtonText}>\n                  {isRequesting ? 'Requesting...' : 'Allow Permissions'}\n                </Text>\n              </TouchableOpacity>\n\n              <TouchableOpacity\n                style={styles.secondaryButton}\n                onPress={handleSkip}\n                disabled={isRequesting}\n              >\n                <Text style={[styles.secondaryButtonText, { color: colors['muted-foreground'] }]}>\n                  Skip for now\n                </Text>\n              </TouchableOpacity>\n            </>\n          ) : (\n            <TouchableOpacity\n              style={[styles.primaryButton, { backgroundColor: colors.primary }]}\n              onPress={handleContinue}\n            >\n              <Text style={styles.primaryButtonText}>\n                {allGranted ? 'All set! Continue' : 'Continue'}\n              </Text>\n            </TouchableOpacity>\n          )}\n        </Animated.View>\n\n        <Animated.View entering={FadeInDown.duration(600).delay(1000)}>\n          <Text style={[styles.footnote, { color: colors['muted-foreground'] }]}>\n            You can change these permissions anytime in Settings\n          </Text>\n        </Animated.View>\n      </View>\n    </SafeAreaView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: 24,\n    paddingTop: 40,\n    paddingBottom: 20,\n  },\n  title: {\n    fontFamily: 'Lora_700Bold',\n    fontSize: 32,\n    fontWeight: '700',\n    marginBottom: 12,\n    textAlign: 'center',\n  },\n  subtitle: {\n    fontFamily: 'Inter_400Regular',\n    fontSize: 16,\n    lineHeight: 24,\n    textAlign: 'center',\n    marginBottom: 40,\n  },\n  permissionsContainer: {\n    flex: 1,\n    gap: 16,\n  },\n  permissionCard: {\n    borderRadius: 16,\n    borderWidth: 1,\n    padding: 16,\n  },\n  permissionHeader: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    gap: 12,\n  },\n  iconContainer: {\n    width: 56,\n    height: 56,\n    borderRadius: 12,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  permissionInfo: {\n    flex: 1,\n  },\n  titleRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n    marginBottom: 4,\n  },\n  permissionTitle: {\n    fontFamily: 'Inter_600SemiBold',\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  requiredBadge: {\n    paddingHorizontal: 8,\n    paddingVertical: 2,\n    borderRadius: 6,\n  },\n  requiredText: {\n    fontFamily: 'Inter_600SemiBold',\n    fontSize: 10,\n    fontWeight: '600',\n    color: 'white',\n    textTransform: 'uppercase',\n  },\n  permissionDescription: {\n    fontFamily: 'Inter_400Regular',\n    fontSize: 13,\n    lineHeight: 18,\n  },\n  statusIcon: {\n    marginLeft: 8,\n  },\n  actionsContainer: {\n    gap: 12,\n    marginTop: 24,\n  },\n  primaryButton: {\n    paddingVertical: 16,\n    borderRadius: 12,\n    alignItems: 'center',\n  },\n  primaryButtonText: {\n    fontFamily: 'Inter_600SemiBold',\n    fontSize: 16,\n    fontWeight: '600',\n    color: 'white',\n  },\n  secondaryButton: {\n    paddingVertical: 12,\n    alignItems: 'center',\n  },\n  secondaryButtonText: {\n    fontFamily: 'Inter_600SemiBold',\n    fontSize: 14,\n    fontWeight: '500',\n  },\n  footnote: {\n    fontFamily: 'Inter_400Regular',\n    fontSize: 12,\n    textAlign: 'center',\n    marginTop: 16,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/privacy-policy.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/terms-of-service.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/tier-balance.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/app/weave-logger.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Modal' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":110,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":115},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BlurView' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":40,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'savedInteraction' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":180,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":180,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport { View, Text, TouchableOpacity, TextInput, ScrollView, Keyboard, TouchableWithoutFeedback, Vibration, Modal, Alert } from 'react-native';\nimport { Stack, useRouter, useLocalSearchParams } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport Animated, { FadeInUp, useSharedValue, withSpring } from 'react-native-reanimated';\nimport { CelebrationAnimation } from '@/components/CelebrationAnimation';\nimport { calculateDeepeningLevel } from '@/modules/intelligence';\nimport { BlurView } from 'expo-blur';\n\nimport { useInteractions, type StructuredReflection } from '@/modules/interactions';\nimport { WeaveReflectPrompt, useWeaveReflectPrompt } from '@/components/Journal';\nimport { useDebounceCallback } from '@/shared/hooks/useDebounceCallback';\nimport { Calendar as CalendarIcon, X, Sparkles, Users } from 'lucide-react-native';\nimport { CustomCalendar } from '@/components/CustomCalendar';\nimport { MoonPhaseSelector } from '@/components/MoonPhaseSelector';\nimport { ContextualReflectionInput } from '@/components/ContextualReflectionInput';\nimport { format, subDays, isSameDay, startOfDay } from 'date-fns';\nimport { type Vibe, type InteractionCategory, type Archetype } from '@/components/types';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { getAllCategories, getCategoryMetadata, type CategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport { FriendSelector } from '@/components/FriendSelector';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { ReciprocitySelector, InitiatorType } from '@/components/ReciprocitySelector';\nimport { STORY_CHIPS } from '@/modules/reflection';\nimport { ErrorBoundary } from '@/shared/components/ErrorBoundary';\n\nconst categories: CategoryMetadata[] = getAllCategories().map(getCategoryMetadata);\n\nconst dateOptions = [\n  { id: 'today', icon: '☀️', label: 'Today', getDate: () => startOfDay(new Date()) },\n  { id: 'yesterday', icon: '🌙', label: 'Yesterday', getDate: () => startOfDay(subDays(new Date(), 1)) },\n];\n\nexport default function WeaveLoggerScreen() {\n  const router = useRouter();\n  const { friendId } = useLocalSearchParams<{ friendId: string }>();\n  const { logWeave } = useInteractions();\n  const { colors, isDarkMode } = useTheme();\n\n  const [selectedFriends, setSelectedFriends] = useState<FriendModel[]>([]);\n  const [showCalendar, setShowCalendar] = useState(false);\n  const [showFriendSelector, setShowFriendSelector] = useState(false);\n  const [selectedCategory, setSelectedCategory] = useState<InteractionCategory | null>(null);\n  const [selectedDate, setSelectedDate] = useState<Date>(startOfDay(new Date()));\n  const [selectedVibe, setSelectedVibe] = useState<Vibe | null>(null);\n  const [reflection, setReflection] = useState<StructuredReflection>({});\n  const [friendArchetype, setFriendArchetype] = useState<Archetype | undefined>(undefined);\n  const [showCelebration, setShowCelebration] = useState(false);\n  const [title, setTitle] = useState<string>('');\n  const [initiator, setInitiator] = useState<InitiatorType | undefined>(undefined);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const {\n    showPrompt,\n    checkAndShowPrompt,\n    hidePrompt,\n    promptInteraction,\n    promptFriends\n  } = useWeaveReflectPrompt();\n\n  const scrollViewRef = useRef<ScrollView>(null);\n  const scale = useSharedValue(1);\n  const [detailsSectionY, setDetailsSectionY] = useState(0);\n  const isMountedRef = useRef(true);\n  const navigationTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n      if (navigationTimeoutRef.current) {\n        clearTimeout(navigationTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Fetch friend's data and set as initial selected friend\n  useEffect(() => {\n    if (friendId) {\n      database.get<FriendModel>(FriendModel.table)\n        .find(friendId)\n        .then(friend => {\n          setSelectedFriends([friend]);\n          setFriendArchetype(friend.archetype as Archetype);\n        })\n        .catch(err => {\n          console.error('Error fetching friend:', err);\n          Alert.alert(\n            'Error',\n            'Could not load friend details. Please try again.',\n            [\n              {\n                text: 'OK',\n                onPress: () => {\n                  if (router.canGoBack()) {\n                    router.back();\n                  } else {\n                    router.replace('/');\n                  }\n                }\n              }\n            ]\n          );\n        });\n    }\n  }, [friendId]);\n\n  // Auto-scroll to details section when category is selected\n  useEffect(() => {\n    if (selectedCategory && detailsSectionY > 0) {\n      setTimeout(() => {\n        scrollViewRef.current?.scrollTo({ y: detailsSectionY - 50, animated: true });\n      }, 300);\n    }\n  }, [selectedCategory, detailsSectionY]);\n\n  const handleCategorySelect = (category: InteractionCategory) => {\n    setSelectedCategory(category);\n    Vibration.vibrate(50);\n    scale.value = withSpring(0.95, { damping: 15 });\n    setTimeout(() => {\n      scale.value = withSpring(1, { damping: 15 });\n    }, 100);\n  };\n\n  const handleDateSelect = (date: Date) => {\n    setSelectedDate(startOfDay(date));\n    setShowCalendar(false);\n  };\n\n  const handleQuickDateSelect = (date: Date) => {\n    setSelectedDate(startOfDay(date));\n    Vibration.vibrate(50);\n  };\n\n  const handleSave = useDebounceCallback(async () => {\n    if (!selectedCategory || selectedFriends.length === 0 || !selectedDate || isSubmitting) return;\n\n    setIsSubmitting(true);\n    try {\n      // Build legacy notes field from chips + custom notes for backward compatibility\n      const legacyNotes = [\n        ...(reflection.chips || []).map(chip => {\n          const storyChip = STORY_CHIPS.find((s: any) => s.id === chip.chipId);\n          if (!storyChip) return '';\n\n          let text = storyChip.template;\n\n          if (storyChip.components) {\n            Object.entries(storyChip.components).forEach(([componentId, component]: [string, any]) => {\n              const value = chip.componentOverrides[componentId] || component.original;\n              text = text.replace(`{${componentId}}`, value);\n            });\n          }\n\n          return text;\n        }),\n        reflection.customNotes || '',\n      ]\n        .filter(Boolean)\n        .join(' ');\n\n      await logWeave({\n        friendIds: selectedFriends.map(f => f.id),\n        category: selectedCategory,\n        activity: selectedCategory,\n        notes: legacyNotes,\n        date: selectedDate,\n        type: 'log',\n        status: 'completed',\n        mode: 'one-on-one',\n        vibe: selectedVibe,\n        reflection,\n        title: title.trim() || undefined,\n        initiator,\n      });\n\n      const savedInteraction = { id: 'temp-id', ...reflection }; // This is a mock, ideally logWeave returns the interaction\n      // But logWeave in useInteractions seems to return void or promise void.\n      // We might need to fetch the interaction or just pass the data we have.\n      // For now, let's assume we can proceed without the exact ID for the prompt check,\n      // or we need to update logWeave to return it.\n      // Actually, checkAndShowPrompt takes interaction and friends.\n\n      // Let's modify the flow to check prompt BEFORE navigating back.\n\n      // Show celebration animation\n      setShowCelebration(true);\n      Vibration.vibrate();\n\n      // Check if we should prompt for reflection\n      // We need the interaction object. Since logWeave doesn't return it (presumably),\n      // we might construct a partial one or fetch it.\n      // For now, let's pass the data we have.\n      const interactionData = {\n        id: 'new-weave', // Placeholder\n        interactionDate: selectedDate.getTime(),\n        interactionType: 'log',\n        interactionCategory: selectedCategory,\n        vibe: selectedVibe,\n        duration: 'Medium', // Default or derived\n        notes: legacyNotes,\n      };\n\n      const shouldShow = await checkAndShowPrompt(interactionData as any, selectedFriends);\n\n      if (!shouldShow) {\n        // Navigate back after animation\n        navigationTimeoutRef.current = setTimeout(() => {\n          if (!isMountedRef.current) return;\n\n          try {\n            if (router.canGoBack()) {\n              if (router.canGoBack()) {\n                router.back();\n              } else {\n                router.replace('/');\n              }\n            } else {\n              // Fallback: navigate to home/dashboard\n              router.replace('/');\n            }\n          } catch (navError) {\n            console.error('[WeaveLogger] Navigation error:', navError);\n            // Force navigate to home as last resort\n            if (isMountedRef.current) {\n              router.replace('/');\n            }\n          }\n        }, 900);\n      }\n      // If shouldShow, the prompt will appear and handle navigation on dismiss/reflect\n\n    } catch (error) {\n      console.error('[WeaveLogger] Error saving weave:', error);\n      // Show error to user but still try to navigate back\n      navigationTimeoutRef.current = setTimeout(() => {\n        if (!isMountedRef.current) return;\n\n        if (router.canGoBack()) {\n          if (router.canGoBack()) {\n            router.back();\n          } else {\n            router.replace('/');\n          }\n        } else {\n          router.replace('/');\n        }\n      }, 100);\n    } finally {\n      // Only unlock submission if something went wrong quickly or if prompt is shown?\n      // Actually, if prompt is shown, we want to keep it locked maybe?\n      // But if user cancels alert or something, we might want to unlock.\n      // Given the navigation, locking it until unmount/nav is fine.\n      // But if there's an error, we should unlock?\n      // The error block navigates away too. So essentially this is a one-way trip.\n      // We can leave isSubmitting true to prevent any further taps during transition.\n    }\n  });\n\n  const deepeningMetrics = calculateDeepeningLevel(reflection);\n\n  const screenTitle = selectedFriends.length === 0\n    ? 'Log a Weave'\n    : selectedFriends.length === 1\n      ? `Weave with ${selectedFriends[0].name}`\n      : selectedFriends.length === 2\n        ? `Weave with ${selectedFriends[0].name} & ${selectedFriends[1].name}`\n        : `Weave with ${selectedFriends.length} friends`;\n\n  return (\n    <ErrorBoundary>\n      <SafeAreaView className=\"flex-1\" style={{ backgroundColor: colors.background }}>\n        <Stack.Screen options={{ title: screenTitle }} />\n\n        {/* Celebration animation */}\n        <CelebrationAnimation\n          visible={showCelebration}\n          intensity={deepeningMetrics.level === 'none' ? 'light' : deepeningMetrics.level}\n          onComplete={() => setShowCelebration(false)}\n        />\n\n        {/* Calendar Sheet */}\n        <StandardBottomSheet\n          visible={showCalendar}\n          onClose={() => setShowCalendar(false)}\n          snapPoints={['50%']}\n        >\n          <View className=\"flex-1 p-6\">\n            <View className=\"flex-row justify-between items-center mb-4\">\n              <Text className=\"font-lora-bold text-xl\" style={{ color: colors.foreground }}>\n                Pick a Date\n              </Text>\n              <TouchableOpacity onPress={() => setShowCalendar(false)} className=\"p-2 -mr-2\">\n                <X color={colors['muted-foreground']} size={22} />\n              </TouchableOpacity>\n            </View>\n\n            <CustomCalendar\n              selectedDate={selectedDate}\n              onDateSelect={handleDateSelect}\n              minDate={undefined}\n            />\n          </View>\n        </StandardBottomSheet>\n\n        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>\n          <ScrollView\n            ref={scrollViewRef}\n            className=\"flex-1\"\n            contentContainerStyle={{ paddingBottom: 120, paddingHorizontal: 20 }}\n          >\n            {/* Date Selection */}\n            <View className=\"mb-8\">\n              <Text className=\"font-lora-bold text-xl mb-4\" style={{ color: colors.foreground }}>\n                When did this happen?\n              </Text>\n              <View className=\"flex-row gap-3 mb-3\">\n                {dateOptions.map((opt, index) => {\n                  const date = opt.getDate();\n                  const isSelected = isSameDay(selectedDate, date);\n                  return (\n                    <Animated.View\n                      key={opt.id}\n                      className=\"flex-1\"\n                      entering={FadeInUp.duration(500).delay(index * 50)}\n                    >\n                      <TouchableOpacity\n                        className=\"p-4 rounded-2xl items-center justify-center\"\n                        style={{\n                          backgroundColor: colors.card,\n                          borderWidth: isSelected ? 2 : 1,\n                          borderColor: isSelected ? colors.primary : colors.border,\n                          shadowColor: '#000',\n                          shadowOffset: { width: 0, height: 2 },\n                          shadowOpacity: 0.05,\n                          shadowRadius: 8,\n                          elevation: 2,\n                          minHeight: 90,\n                        }}\n                        onPress={() => handleQuickDateSelect(date)}\n                      >\n                        <Text className=\"text-3xl mb-2\">{opt.icon}</Text>\n                        <Text className=\"font-inter-semibold text-sm\" style={{ color: colors.foreground }}>\n                          {opt.label}\n                        </Text>\n                      </TouchableOpacity>\n                    </Animated.View>\n                  );\n                })}\n                <Animated.View className=\"flex-1\" entering={FadeInUp.duration(500).delay(100)}>\n                  <TouchableOpacity\n                    className=\"p-4 rounded-2xl items-center justify-center\"\n                    style={{\n                      backgroundColor: colors.card,\n                      borderWidth: 1,\n                      borderColor: colors.border,\n                      shadowColor: '#000',\n                      shadowOffset: { width: 0, height: 2 },\n                      shadowOpacity: 0.05,\n                      shadowRadius: 8,\n                      elevation: 2,\n                      minHeight: 90,\n                    }}\n                    onPress={() => setShowCalendar(true)}\n                  >\n                    <CalendarIcon size={28} color={colors.primary} style={{ marginBottom: 8 }} />\n                    <Text className=\"font-inter-semibold text-sm\" style={{ color: colors.foreground }}>\n                      Pick Date\n                    </Text>\n                  </TouchableOpacity>\n                </Animated.View>\n              </View>\n              <Text className=\"font-inter-regular text-sm text-center\" style={{ color: colors['muted-foreground'] }}>\n                {format(selectedDate, 'EEEE, MMMM d, yyyy')}\n              </Text>\n            </View>\n\n            {/* Friend Selection */}\n            <View className=\"mb-8\">\n              <Text className=\"font-lora-bold text-xl mb-4\" style={{ color: colors.foreground }}>\n                Who was there?\n              </Text>\n\n              {/* Selected friends display */}\n              <View className=\"flex-row flex-wrap gap-2 mb-3\">\n                {selectedFriends.map((friend, index) => (\n                  <View\n                    key={friend.id}\n                    className=\"flex-row items-center px-3 py-2 rounded-full\"\n                    style={{\n                      backgroundColor: colors.primary + '20',\n                      borderWidth: 1,\n                      borderColor: colors.primary + '40',\n                    }}\n                  >\n                    <Text className=\"font-inter-medium text-sm\" style={{ color: colors.foreground }}>\n                      {friend.name}\n                    </Text>\n                    {index !== 0 && selectedFriends.length > 1 && (\n                      <TouchableOpacity\n                        className=\"ml-2\"\n                        onPress={() => setSelectedFriends(selectedFriends.filter(f => f.id !== friend.id))}\n                      >\n                        <X size={14} color={colors.foreground} />\n                      </TouchableOpacity>\n                    )}\n                  </View>\n                ))}\n\n                {/* Add Friend Button */}\n                <TouchableOpacity\n                  className=\"flex-row items-center px-3 py-2 rounded-full\"\n                  style={{\n                    backgroundColor: colors.card,\n                    borderWidth: 1,\n                    borderColor: colors.border,\n                  }}\n                  onPress={() => setShowFriendSelector(true)}\n                >\n                  <Users size={16} color={colors.primary} />\n                  <Text className=\"font-inter-medium text-sm ml-2\" style={{ color: colors.primary }}>\n                    Add Friend\n                  </Text>\n                </TouchableOpacity>\n              </View>\n            </View>\n\n            {/* Category Selection */}\n            <View className=\"mb-8\">\n              <Text className=\"font-lora-bold text-xl mb-4\" style={{ color: colors.foreground }}>\n                How did you connect?\n              </Text>\n              <View className=\"flex-row flex-wrap gap-3\">\n                {categories.map((cat, index) => (\n                  <Animated.View\n                    key={cat.id}\n                    style={{ width: '48%' }}\n                    entering={FadeInUp.duration(500).delay(index * 50)}\n                  >\n                    <TouchableOpacity\n                      className=\"p-3 rounded-2xl items-center justify-center\"\n                      style={{\n                        backgroundColor: colors.card,\n                        borderWidth: selectedCategory === cat.id ? 2 : 1,\n                        borderColor: selectedCategory === cat.id ? colors.primary : colors.border,\n                        shadowColor: '#000',\n                        shadowOffset: { width: 0, height: 2 },\n                        shadowOpacity: 0.05,\n                        shadowRadius: 8,\n                        elevation: 2,\n                        minHeight: 120,\n                      }}\n                      onPress={() => handleCategorySelect(cat.id)}\n                    >\n                      <Text className=\"text-2xl mb-1\">{cat.icon}</Text>\n                      <Text className=\"font-inter-semibold text-sm text-center mb-1\" style={{ color: colors.foreground }}>\n                        {cat.label}\n                      </Text>\n                      <Text className=\"font-inter-regular text-xs text-center\" style={{ color: colors['muted-foreground'] }}>\n                        {cat.description}\n                      </Text>\n                    </TouchableOpacity>\n                  </Animated.View>\n                ))}\n              </View>\n            </View>\n\n            {/* Details Section - Only shows after category selected */}\n            {selectedCategory && (\n              <Animated.View\n                entering={FadeInUp.duration(500)}\n                onLayout={(event) => {\n                  const { y } = event.nativeEvent.layout;\n                  setDetailsSectionY(y);\n                }}\n              >\n                {/* Title Field */}\n                <View className=\"mb-8\">\n                  <Text className=\"font-lora-bold text-xl mb-2\" style={{ color: colors.foreground }}>\n                    Name this moment\n                  </Text>\n                  <Text className=\"font-inter-regular text-sm mb-3\" style={{ color: colors['muted-foreground'] }}>\n                    Optional - give it a memorable name\n                  </Text>\n                  <TextInput\n                    className=\"p-4 rounded-xl font-inter-regular text-base\"\n                    style={{\n                      backgroundColor: colors.card,\n                      borderWidth: 1,\n                      borderColor: colors.border,\n                      color: colors.foreground,\n                    }}\n                    placeholder='e.g., \"Coffee at Blue Bottle\"'\n                    placeholderTextColor={colors['muted-foreground']}\n                    value={title}\n                    onChangeText={setTitle}\n                  />\n                </View>\n\n\n\n                {/* Reciprocity Section */}\n                <View className=\"mb-8\">\n                  <Text className=\"font-lora-bold text-xl mb-4\" style={{ color: colors.foreground }}>\n                    Who initiated?\n                  </Text>\n                  <ReciprocitySelector\n                    value={initiator}\n                    onChange={setInitiator}\n                    friendName={selectedFriends.length === 1 ? selectedFriends[0].name : 'Them'}\n                    hideLabel\n                  />\n                </View>\n\n                {/* Reflection Section */}\n                <View className=\"mb-8\">\n                  <View className=\"flex-row items-center gap-2 mb-2\">\n                    <Sparkles size={20} color={colors.primary} />\n                    <Text className=\"font-lora-bold text-xl\" style={{ color: colors.foreground }}>\n                      Tell the story\n                    </Text>\n                  </View>\n                  <Text className=\"font-inter-regular text-sm mb-4\" style={{ color: colors['muted-foreground'] }}>\n                    Capture what made this weave meaningful\n                  </Text>\n                  <ContextualReflectionInput\n                    category={selectedCategory}\n                    archetype={friendArchetype}\n                    vibe={selectedVibe}\n                    value={reflection}\n                    onChange={setReflection}\n                  />\n                </View>\n\n                {/* Vibe Section */}\n                <View className=\"mb-8\">\n                  <Text className=\"font-lora-bold text-xl mb-4\" style={{ color: colors.foreground }}>\n                    How did it feel? 🌙\n                  </Text>\n                  <MoonPhaseSelector onSelect={setSelectedVibe} selectedVibe={selectedVibe} />\n                </View>\n\n\n              </Animated.View>\n            )}\n          </ScrollView>\n        </TouchableWithoutFeedback>\n\n        {/* Save Button */}\n        {selectedCategory && (\n          <View\n            className=\"absolute bottom-0 left-0 right-0 p-5\"\n            style={{ backgroundColor: colors.background, borderTopWidth: 1, borderColor: colors.border }}\n          >\n            <TouchableOpacity\n              className=\"p-4 rounded-xl items-center\"\n              style={{\n                backgroundColor: isSubmitting ? colors.muted : colors.primary,\n                shadowColor: '#000',\n                shadowOffset: { width: 0, height: 4 },\n                shadowOpacity: 0.1,\n                shadowRadius: 12,\n                elevation: 8,\n              }}\n              onPress={handleSave}\n              disabled={isSubmitting}\n            >\n              <Text className=\"font-inter-semibold text-base\" style={{ color: isSubmitting ? colors['muted-foreground'] : colors['primary-foreground'] }}>\n                {isSubmitting ? 'Saving...' : 'Save Weave'}\n              </Text>\n            </TouchableOpacity>\n          </View>\n        )}\n\n        {/* Friend Selector Modal */}\n        <FriendSelector\n          visible={showFriendSelector}\n          onClose={() => setShowFriendSelector(false)}\n          initialFriendId={friendId}\n          selectedFriends={selectedFriends}\n          onSelectionChange={setSelectedFriends}\n        />\n\n        <WeaveReflectPrompt\n          visible={showPrompt}\n          interaction={promptInteraction}\n          friends={promptFriends}\n          onReflect={() => {\n            hidePrompt();\n            router.replace({\n              pathname: '/journal',\n              params: {\n                mode: 'guided',\n                weaveId: promptInteraction?.id\n              }\n            });\n          }}\n          onDismiss={() => {\n            hidePrompt();\n            if (router.canGoBack()) {\n              if (router.canGoBack()) {\n                router.back();\n              } else {\n                router.replace('/');\n              }\n            } else {\n              router.replace('/');\n            }\n          }}\n        />\n      </SafeAreaView>\n    </ErrorBoundary>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/babel.config.js","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":8,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":8,"endColumn":60}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\n      ['babel-preset-expo', { jsxImportSource: 'nativewind' }],\n    ],\n    plugins: [\n      require('react-native-css-interop/dist/babel-plugin'),\n      'react-native-reanimated/plugin',\n    ],\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/declarations.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/eslint.config.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":2,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":2,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/jest.setup.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":60,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":60,"endColumn":80,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/metro.config.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":2,"column":28,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":2,"endColumn":55,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":5,"column":5,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":5,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/nativewind-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/react-native.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/AchievementCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/AchievementsModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/AddFriendMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/AppProviders.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ArchetypeCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ArchetypeCarouselPicker.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":127,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ArchetypeCarouselPicker Component\n *\n * Beautiful native carousel-style archetype picker\n * Swipe through archetypes with smooth animations\n * Premium iOS-feeling design\n */\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  FlatList,\n  TouchableOpacity,\n  Dimensions,\n  StyleSheet,\n  Platform,\n  Image,\n} from 'react-native';\nimport * as Haptics from 'expo-haptics';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { type Archetype } from './types';\nimport { archetypeData } from '@/shared/constants/constants';\nimport { ChevronLeft, ChevronRight, Info } from 'lucide-react-native';\nimport { useUIStore } from '../stores/uiStore';\n\n// Import assets\nimport EmperorIcon from '@/assets/TarotIcons/TheEmperor.svg';\nimport EmpressIcon from '@/assets/TarotIcons/TheEmpress.svg';\nimport HighPriestessIcon from '@/assets/TarotIcons/HighPriestess.svg';\nimport FoolIcon from '@/assets/TarotIcons/TheFool.svg';\nimport SunIcon from '@/assets/TarotIcons/TheSun.svg';\nimport HermitIcon from '@/assets/TarotIcons/TheHermit.svg';\nimport MagicianIcon from '@/assets/TarotIcons/TheMagician.svg';\nimport LoversIcon from '@/assets/TarotIcons/TheLovers.svg';\n\nconst { width: SCREEN_WIDTH } = Dimensions.get('window');\nconst CARD_WIDTH = SCREEN_WIDTH - 80;\nconst CARD_HEIGHT = 360;\n\ninterface ArchetypeCarouselPickerProps {\n  selectedArchetype: Archetype;\n  onSelect: (archetype: Archetype) => void;\n}\n\nconst ARCHETYPES: Archetype[] = [\n  'Emperor',\n  'Empress',\n  'HighPriestess',\n  'Fool',\n  'Sun',\n  'Hermit',\n  'Magician',\n];\n\n// Map archetypes to their tarot card SVG file paths\nconst TAROT_CARD_SOURCES: Record<Archetype, any> = {\n  Emperor: EmperorIcon,\n  Empress: EmpressIcon,\n  HighPriestess: HighPriestessIcon,\n  Fool: FoolIcon,\n  Sun: SunIcon,\n  Hermit: HermitIcon,\n  Magician: MagicianIcon,\n  Lovers: LoversIcon,\n  Unknown: null,\n};\n\nexport function ArchetypeCarouselPicker({\n  selectedArchetype,\n  onSelect,\n}: ArchetypeCarouselPickerProps) {\n  const { colors } = useTheme();\n  const flatListRef = useRef<FlatList>(null);\n  const [currentIndex, setCurrentIndex] = useState(\n    ARCHETYPES.indexOf(selectedArchetype)\n  );\n  const { setArchetypeModal } = useUIStore();\n\n  useEffect(() => {\n    const newIndex = ARCHETYPES.indexOf(selectedArchetype);\n    if (newIndex !== -1 && newIndex !== currentIndex) {\n      setCurrentIndex(newIndex);\n      flatListRef.current?.scrollToIndex({ index: newIndex, animated: true });\n    }\n  }, [selectedArchetype]);\n\n  const handleScroll = (event: any) => {\n    const offsetX = event.nativeEvent.contentOffset.x;\n    const index = Math.round(offsetX / SCREEN_WIDTH);\n    if (index !== currentIndex && index >= 0 && index < ARCHETYPES.length) {\n      setCurrentIndex(index);\n      onSelect(ARCHETYPES[index]);\n      if (Platform.OS === 'ios') {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n      }\n    }\n  };\n\n  const scrollToIndex = (index: number) => {\n    if (index >= 0 && index < ARCHETYPES.length) {\n      flatListRef.current?.scrollToIndex({ index, animated: true });\n      setCurrentIndex(index);\n      onSelect(ARCHETYPES[index]);\n      if (Platform.OS === 'ios') {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n      }\n    }\n  };\n\n  const getArchetypeGradient = (archetype: Archetype): string[] => {\n    const gradients: Record<Archetype, string[]> = {\n      Emperor: ['#ef4444', '#dc2626'],\n      Empress: ['#10b981', '#059669'],\n      HighPriestess: ['#8b5cf6', '#7c3aed'],\n      Fool: ['#f59e0b', '#d97706'],\n      Sun: ['#eab308', '#ca8a04'],\n      Hermit: ['#6366f1', '#4f46e5'],\n      Magician: ['#ec4899', '#db2777'],\n      Lovers: ['#fb7185', '#f43f5e'],\n      Unknown: ['#9ca3af', '#6b7280'],\n    };\n    return gradients[archetype] || ['#6b7280', '#4b5563'];\n  };\n\n  const renderArchetype = ({ item, index }: { item: Archetype; index: number }) => {\n    const data = archetypeData[item];\n    if (!data) return null;\n\n    const isSelected = item === selectedArchetype;\n    const gradient = getArchetypeGradient(item);\n\n    return (\n      <View style={styles.cardContainer}>\n        <View\n          style={[\n            styles.card,\n            {\n              backgroundColor: colors.card,\n              borderColor: isSelected ? colors.primary : colors.border,\n              shadowColor: isSelected ? colors.primary : '#000',\n            },\n          ]}\n        >\n          {/* Gradient Background */}\n          <LinearGradient\n            colors={[...gradient.map(c => c + (isSelected ? 'E6' : '10')), 'transparent'] as any}\n            style={styles.gradientBackground}\n            start={{ x: 0, y: 0 }}\n            end={{ x: 1, y: 1 }}\n          />\n\n          {/* Tarot Card Section */}\n          <View style={styles.iconSection}>\n            <View\n              style={[\n                styles.tarotCardContainer,\n                {\n                  shadowColor: gradient[0],\n                  backgroundColor: colors.card,\n                  borderRadius: 12,\n                },\n              ]}\n            >\n              <Image\n                source={TAROT_CARD_SOURCES[item]}\n                style={styles.tarotCardImage}\n                resizeMode=\"contain\"\n              />\n            </View>\n          </View>\n\n          {/* Info Section */}\n          <View style={styles.infoSection}>\n            <Text style={[styles.archetypeName, { color: colors.foreground }]}>\n              {data.name}\n            </Text>\n            <Text style={[styles.archetypeEssence, { color: gradient[0] }]}>\n              {data.essence}\n            </Text>\n            <Text\n              style={[styles.archetypeDescription, { color: colors['muted-foreground'] }]}\n              numberOfLines={3}\n            >\n              {data.description}\n            </Text>\n          </View>\n\n          {/* Learn More Button */}\n          <TouchableOpacity\n            onPress={() => {\n              setArchetypeModal(item);\n              if (Platform.OS === 'ios') {\n                Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n              }\n            }}\n            style={[\n              styles.learnMoreButton,\n              { backgroundColor: gradient[0] + '15', borderColor: gradient[0] + '30' },\n            ]}\n            activeOpacity={0.7}\n          >\n            <Info size={16} color={gradient[0]} />\n            <Text style={[styles.learnMoreText, { color: gradient[0] }]}>\n              Learn More\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </View>\n    );\n  };\n\n  return (\n    <View style={styles.container}>\n      {/* Carousel */}\n      <FlatList\n        ref={flatListRef}\n        data={ARCHETYPES}\n        renderItem={renderArchetype}\n        keyExtractor={(item) => item}\n        horizontal\n        pagingEnabled\n        showsHorizontalScrollIndicator={false}\n        onMomentumScrollEnd={handleScroll}\n        snapToInterval={SCREEN_WIDTH}\n        decelerationRate=\"fast\"\n        contentContainerStyle={styles.flatListContent}\n        getItemLayout={(data, index) => ({\n          length: SCREEN_WIDTH,\n          offset: SCREEN_WIDTH * index,\n          index,\n        })}\n      />\n\n      {/* Navigation Controls */}\n      <View style={styles.controls}>\n        <TouchableOpacity\n          onPress={() => scrollToIndex(currentIndex - 1)}\n          disabled={currentIndex === 0}\n          style={[\n            styles.navButton,\n            {\n              backgroundColor: colors.card,\n              borderColor: colors.border,\n              opacity: currentIndex === 0 ? 0.3 : 1,\n            },\n          ]}\n          activeOpacity={0.7}\n        >\n          <ChevronLeft size={24} color={colors.foreground} />\n        </TouchableOpacity>\n\n        {/* Pagination Dots */}\n        <View style={styles.pagination}>\n          {ARCHETYPES.map((archetype, index) => {\n            const isActive = index === currentIndex;\n            return (\n              <TouchableOpacity\n                key={archetype}\n                onPress={() => scrollToIndex(index)}\n                style={[\n                  styles.dot,\n                  {\n                    backgroundColor: isActive ? colors.primary : colors.border,\n                    width: isActive ? 24 : 8,\n                  },\n                ]}\n                activeOpacity={0.7}\n              />\n            );\n          })}\n        </View>\n\n        <TouchableOpacity\n          onPress={() => scrollToIndex(currentIndex + 1)}\n          disabled={currentIndex === ARCHETYPES.length - 1}\n          style={[\n            styles.navButton,\n            {\n              backgroundColor: colors.card,\n              borderColor: colors.border,\n              opacity: currentIndex === ARCHETYPES.length - 1 ? 0.3 : 1,\n            },\n          ]}\n          activeOpacity={0.7}\n        >\n          <ChevronRight size={24} color={colors.foreground} />\n        </TouchableOpacity>\n      </View>\n\n      {/* Helper Text */}\n      <Text style={[styles.helperText, { color: colors['muted-foreground'] }]}>\n        Swipe or tap arrows to browse • Tap \"Learn More\" for details\n      </Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    marginVertical: 16,\n  },\n  flatListContent: {\n    paddingHorizontal: 40,\n  },\n  cardContainer: {\n    width: SCREEN_WIDTH,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  card: {\n    width: CARD_WIDTH,\n    height: CARD_HEIGHT,\n    borderRadius: 24,\n    borderWidth: 3,\n    padding: 24,\n    shadowOffset: { width: 0, height: 8 },\n    shadowOpacity: 0.15,\n    shadowRadius: 16,\n    elevation: 8,\n    overflow: 'hidden',\n  },\n  gradientBackground: {\n    ...StyleSheet.absoluteFillObject,\n    opacity: 0.5,\n  },\n  iconSection: {\n    alignItems: 'center',\n    marginBottom: 20,\n  },\n  tarotCardContainer: {\n    width: 120,\n    height: 180,\n    alignItems: 'center',\n    justifyContent: 'center',\n    shadowOffset: { width: 0, height: 6 },\n    shadowOpacity: 0.25,\n    shadowRadius: 16,\n    elevation: 6,\n  },\n  tarotCardImage: {\n    width: '100%',\n    height: '100%',\n  },\n  infoSection: {\n    flex: 1,\n    alignItems: 'center',\n  },\n  archetypeName: {\n    fontSize: 28,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n    marginBottom: 8,\n    textAlign: 'center',\n  },\n  archetypeEssence: {\n    fontSize: 16,\n    fontWeight: '600',\n    fontFamily: 'Inter_600SemiBold',\n    marginBottom: 16,\n    textAlign: 'center',\n    textTransform: 'uppercase',\n    letterSpacing: 1,\n  },\n  archetypeDescription: {\n    fontSize: 15,\n    lineHeight: 22,\n    fontFamily: 'Inter_400Regular',\n    textAlign: 'center',\n    paddingHorizontal: 8,\n  },\n  learnMoreButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: 12,\n    paddingHorizontal: 20,\n    borderRadius: 16,\n    borderWidth: 1,\n    gap: 8,\n  },\n  learnMoreText: {\n    fontSize: 14,\n    fontWeight: '600',\n    fontFamily: 'Inter_600SemiBold',\n  },\n  controls: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginTop: 24,\n    paddingHorizontal: 40,\n  },\n  navButton: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    borderWidth: 2,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  pagination: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n  },\n  dot: {\n    height: 8,\n    borderRadius: 4,\n  },\n  helperText: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n    textAlign: 'center',\n    marginTop: 16,\n    paddingHorizontal: 40,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ArchetypeDetailModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'multiplier' is defined but never used. Allowed unused args must match /^_/u.","line":185,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":74}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, Modal, TouchableOpacity, ScrollView } from 'react-native';\nimport { useUIStore } from '../stores/uiStore';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { X, Sparkles } from 'lucide-react-native';\nimport { type Archetype, type InteractionCategory } from './types';\nimport { archetypeData, CategoryArchetypeMatrix } from '@/shared/constants/constants';\nimport { CATEGORY_METADATA } from '@/shared/constants/interaction-categories';\nimport { BlurView } from 'expo-blur';\n\n// Import SVG files as components\nimport EmperorSvg from '@/assets/TarotIcons/TheEmperor.svg';\nimport EmpressSvg from '@/assets/TarotIcons/TheEmpress.svg';\nimport HighPriestessSvg from '@/assets/TarotIcons/HighPriestess.svg';\nimport FoolSvg from '@/assets/TarotIcons/TheFool.svg';\nimport SunSvg from '@/assets/TarotIcons/TheSun.svg';\nimport HermitSvg from '@/assets/TarotIcons/TheHermit.svg';\nimport MagicianSvg from '@/assets/TarotIcons/TheMagician.svg';\nimport LoversSvg from '@/assets/TarotIcons/TheLovers.svg';\n\n// Map archetypes to their tarot card SVG components\nconst TAROT_CARD_COMPONENTS: Record<Archetype, React.FC<any>> = {\n  Emperor: EmperorSvg,\n  Empress: EmpressSvg,\n  HighPriestess: HighPriestessSvg,\n  Fool: FoolSvg,\n  Sun: SunSvg,\n  Hermit: HermitSvg,\n  Magician: MagicianSvg,\n  Lovers: LoversSvg,\n  Unknown: React.Fragment,\n};\n\n// Helper: Get top interaction suggestions for an archetype\nfunction getTopInteractions(archetype: Archetype): Array<{ category: InteractionCategory; multiplier: number; level: 'peak' | 'high' | 'good' }> {\n  if (archetype === 'Unknown') return [];\n\n  const affinities = CategoryArchetypeMatrix[archetype];\n  const suggestions = Object.entries(affinities)\n    .map(([category, multiplier]) => ({\n      category: category as InteractionCategory,\n      multiplier,\n      level: multiplier >= 1.8 ? 'peak' : multiplier >= 1.5 ? 'high' : 'good' as 'peak' | 'high' | 'good'\n    }))\n    .filter(item => item.multiplier >= 1.4) // Only show good+ affinities\n    .sort((a, b) => b.multiplier - a.multiplier)\n    .slice(0, 5); // Top 5\n\n  return suggestions;\n}\n\nexport function ArchetypeDetailModal() {\n  const { archetypeModal, setArchetypeModal } = useUIStore();\n  const { colors, isDarkMode } = useTheme();\n\n  if (!archetypeModal) {\n    return null;\n  }\n\n  const data = archetypeData[archetypeModal];\n  const topInteractions = getTopInteractions(archetypeModal);\n\n  // Color scheme for affinity levels\n  const getAffinityColor = (level: 'peak' | 'high' | 'good') => {\n    if (level === 'peak') return '#10b981'; // Green\n    if (level === 'high') return '#3b82f6'; // Blue\n    return '#8b5cf6'; // Purple\n  };\n\n  return (\n    <Modal\n      animationType=\"fade\"\n      transparent={true}\n      visible={!!archetypeModal}\n      onRequestClose={() => setArchetypeModal(null)}\n    >\n      <BlurView intensity={90} className=\"flex-1 justify-center items-center\" tint={isDarkMode ? 'dark' : 'light'}>\n        <TouchableOpacity\n          className=\"flex-1 justify-center items-center w-full\"\n          activeOpacity={1}\n          onPress={() => setArchetypeModal(null)}\n        >\n          <TouchableOpacity activeOpacity={1} className=\"w-[85%] max-w-[400px] max-h-[80%]\">\n            <View\n              className=\"w-full rounded-3xl p-6\"\n              style={{\n                backgroundColor: colors.card,\n                shadowColor: '#000',\n                shadowOffset: { width: 0, height: 8 },\n                shadowOpacity: 0.3,\n                shadowRadius: 16,\n                elevation: 8,\n              }}\n            >\n              <TouchableOpacity\n                className=\"absolute top-4 right-4 z-10 p-1\"\n                onPress={() => setArchetypeModal(null)}\n              >\n                <X color={colors['muted-foreground']} size={24} />\n              </TouchableOpacity>\n\n              <ScrollView\n                showsVerticalScrollIndicator={false}\n                contentContainerStyle={{ alignItems: 'center', paddingHorizontal: 16, paddingBottom: 20 }}\n              >\n                <View\n                  className=\"mb-4 mt-2\"\n                  style={{\n                    width: 120,\n                    height: 180,\n                  }}\n                >\n                  {React.createElement(TAROT_CARD_COMPONENTS[archetypeModal], {\n                    width: 120,\n                    height: 180,\n                  })}\n                </View>\n\n                <Text\n                  className=\"font-lora-bold text-2xl mb-2 text-center\"\n                  style={{ color: colors.foreground }}\n                >\n                  {data.name}\n                </Text>\n\n                <Text\n                  className=\"font-inter-medium text-[15px] mb-4 text-center italic\"\n                  style={{ color: colors['muted-foreground'] }}\n                >\n                  {data.essence}\n                </Text>\n\n                <Text\n                  className=\"font-inter-regular text-[15px] text-center leading-[22px] mb-5\"\n                  style={{ color: colors.foreground }}\n                >\n                  {data.description}\n                </Text>\n\n                <View\n                  className=\"h-[1px] w-full my-4\"\n                  style={{ backgroundColor: colors.border }}\n                />\n\n                <Text\n                  className=\"font-inter-semibold text-[16px] mb-3 self-start\"\n                  style={{ color: colors.foreground }}\n                >\n                  How to Connect\n                </Text>\n\n                <Text\n                  className=\"font-inter-regular text-[14px] leading-[20px] mb-4\"\n                  style={{ color: colors['muted-foreground'] }}\n                >\n                  {data.careStyle}\n                </Text>\n\n                {/* Top Interaction Suggestions */}\n                {topInteractions.length > 0 && (\n                  <>\n                    <View\n                      className=\"h-[1px] w-full my-4\"\n                      style={{ backgroundColor: colors.border }}\n                    />\n\n                    <View className=\"flex-row items-center gap-2 mb-3 self-start\">\n                      <Sparkles size={16} color={colors.primary} />\n                      <Text\n                        className=\"font-inter-semibold text-[16px]\"\n                        style={{ color: colors.foreground }}\n                      >\n                        Perfect Connections\n                      </Text>\n                    </View>\n\n                    <Text\n                      className=\"font-inter-regular text-[13px] leading-[18px] mb-3\"\n                      style={{ color: colors['muted-foreground'] }}\n                    >\n                      These interactions resonate most with this archetype\n                    </Text>\n\n                    <View className=\"flex-row flex-wrap gap-2\">\n                      {topInteractions.map(({ category, level, multiplier }) => {\n                        const metadata = CATEGORY_METADATA[category];\n                        const affinityColor = getAffinityColor(level);\n\n                        return (\n                          <View\n                            key={category}\n                            className=\"flex-row items-center gap-1.5 rounded-full px-3 py-2\"\n                            style={{\n                              backgroundColor: `${affinityColor}15`,\n                              borderWidth: 1,\n                              borderColor: `${affinityColor}40`,\n                            }}\n                          >\n                            <Text className=\"text-base\">{metadata.icon}</Text>\n                            <Text\n                              className=\"font-inter text-[13px] font-semibold\"\n                              style={{ color: affinityColor }}\n                            >\n                              {metadata.label}\n                            </Text>\n                            <Text\n                              className=\"font-inter text-[11px] font-medium\"\n                              style={{ color: `${affinityColor}CC` }}\n                            >\n                              {level === 'peak' ? '★' : level === 'high' ? '✦' : '◆'}\n                            </Text>\n                          </View>\n                        );\n                      })}\n                    </View>\n\n                    <View className=\"mt-3 flex-row items-start gap-1.5 px-1\">\n                      <Text className=\"font-inter text-[11px]\" style={{ color: colors['muted-foreground'] }}>\n                        ★ Peak\n                      </Text>\n                      <Text className=\"font-inter text-[11px]\" style={{ color: colors['muted-foreground'] }}>\n                        •\n                      </Text>\n                      <Text className=\"font-inter text-[11px]\" style={{ color: colors['muted-foreground'] }}>\n                        ✦ High\n                      </Text>\n                      <Text className=\"font-inter text-[11px]\" style={{ color: colors['muted-foreground'] }}>\n                        •\n                      </Text>\n                      <Text className=\"font-inter text-[11px]\" style={{ color: colors['muted-foreground'] }}>\n                        ◆ Good\n                      </Text>\n                    </View>\n                  </>\n                )}\n              </ScrollView>\n            </View>\n          </TouchableOpacity>\n        </TouchableOpacity>\n      </BlurView>\n    </Modal>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ArchetypeIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ArchetypeLibrary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/BadgeUnlockModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'width' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":37,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BadgeUnlockModal Component\n *\n * Non-intrusive top-drawer notification for new badge/achievement unlocks.\n * Shows a small banner at the top of the screen.\n */\n\nimport React, { useEffect } from 'react';\nimport {\n  View,\n  Dimensions,\n} from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withTiming,\n  runOnJS,\n} from 'react-native-reanimated';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { Gesture, GestureDetector } from 'react-native-gesture-handler';\nimport { useUIStore } from '../stores/uiStore';\nimport { markBadgeAsCelebrated } from '@/modules/gamification';\nimport { markAchievementAsCelebrated } from '@/modules/gamification';\nimport { BlurView } from 'expo-blur';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Text } from '@/shared/ui/Text';\n\nconst { width } = Dimensions.get('window');\n\nexport default function BadgeUnlockModal() {\n  const badgeQueue = useUIStore((state) => state.badgeUnlockQueue);\n  const achievementQueue = useUIStore((state) => state.achievementUnlockQueue);\n  const dismissBadge = useUIStore((state) => state.dismissBadgeUnlock);\n  const dismissAchievement = useUIStore((state) => state.dismissAchievementUnlock);\n  const insets = useSafeAreaInsets();\n  const { isDarkMode, colors } = useTheme();\n\n  // Badge takes priority over achievements\n  const currentBadge = badgeQueue[0];\n  const currentAchievement = !currentBadge ? achievementQueue[0] : null;\n\n  const visible = !!(currentBadge || currentAchievement);\n  const translateY = useSharedValue(-200);\n\n  useEffect(() => {\n    if (visible) {\n      // Slide in\n      translateY.value = withSpring(0, { damping: 15 });\n\n      // Auto dismiss after 4 seconds\n      const timer = setTimeout(() => {\n        handleDismiss();\n      }, 4000);\n\n      return () => clearTimeout(timer);\n    } else {\n      translateY.value = -200;\n    }\n  }, [visible]);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  async function handleDismiss() {\n    // Slide out first\n    translateY.value = withTiming(-200, { duration: 300 }, (finished) => {\n      if (finished) {\n        runOnJS(cleanup)();\n      }\n    });\n  }\n\n  async function cleanup() {\n    try {\n      if (currentBadge) {\n        await markBadgeAsCelebrated(currentBadge.badge.id, currentBadge.friendId);\n        dismissBadge();\n      } else if (currentAchievement) {\n        await markAchievementAsCelebrated(currentAchievement.achievement.id);\n        dismissAchievement();\n      }\n    } catch (error) {\n      console.error('Error dismissing badge/achievement:', error);\n    }\n  }\n\n  // Swipe up gesture\n  const pan = Gesture.Pan()\n    .onUpdate((event) => {\n      if (event.translationY < 0) {\n        translateY.value = event.translationY;\n      }\n    })\n    .onEnd((event) => {\n      if (event.translationY < -20 || event.velocityY < -500) {\n        runOnJS(handleDismiss)();\n      } else {\n        translateY.value = withSpring(0);\n      }\n    });\n\n  if (!visible) return null;\n\n  const item = currentBadge?.badge || currentAchievement?.achievement;\n  const friendName = currentBadge?.friendName;\n  const isHidden = currentAchievement?.isHidden;\n\n  if (!item) return null;\n\n  // Get rarity color\n  const rarityColors = {\n    common: { bg: '#10b981', border: '#059669' }, // emerald-500\n    rare: { bg: '#3b82f6', border: '#2563eb' }, // blue-500\n    epic: { bg: '#a855f7', border: '#7c3aed' }, // purple-500\n    legendary: { bg: '#f59e0b', border: '#d97706' }, // amber-500\n  };\n\n  const rarity = item.rarity as keyof typeof rarityColors || 'common';\n  const rarityColor = rarityColors[rarity] || rarityColors.common;\n\n  return (\n    <GestureDetector gesture={pan}>\n      <Animated.View\n        className=\"absolute top-0 left-0 right-0 items-center z-50 px-4\"\n        style={[\n          animatedStyle,\n          { paddingTop: insets.top + 10 },\n        ]}\n      >\n        <View\n          className=\"w-full max-w-[400px] shadow-lg\"\n          style={{\n            shadowColor: '#000',\n            shadowOffset: { width: 0, height: 4 },\n            shadowOpacity: 0.15,\n            shadowRadius: 12,\n            elevation: 5,\n          }}\n        >\n          <BlurView\n            intensity={90}\n            tint={isDarkMode ? 'dark' : 'light'}\n            className=\"rounded-2xl overflow-hidden border\"\n            style={{ borderColor: rarityColor.border }}\n          >\n            <View className=\"flex-row items-center p-3 gap-3\">\n              <View\n                className=\"w-12 h-12 rounded-full items-center justify-center\"\n                style={{ backgroundColor: rarityColor.bg }}\n              >\n                <Text className=\"text-2xl\">{item.icon}</Text>\n              </View>\n\n              <View className=\"flex-1 justify-center\">\n                <Text\n                  className=\"text-xs uppercase tracking-wider mb-0.5 font-sans-semibold\"\n                  style={{ color: isDarkMode ? '#fff' : '#000' }}\n                >\n                  {isHidden ? 'Hidden Discovery!' : currentBadge ? 'Badge Earned!' : 'Achievement Unlocked!'}\n                </Text>\n                <Text\n                  variant=\"h3\"\n                  className=\"text-base mb-0.5\"\n                  style={{ color: rarityColor.bg, fontFamily: 'Lora_700Bold' }}\n                >\n                  {item.name}\n                </Text>\n                {friendName && (\n                  <Text variant=\"caption\" style={{ color: isDarkMode ? '#ccc' : '#666' }}>\n                    with {friendName}\n                  </Text>\n                )}\n              </View>\n            </View>\n          </BlurView>\n        </View>\n      </Animated.View>\n    </GestureDetector>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/CalendarView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/CelebrationAnimation.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Sparkles' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { View, StyleSheet, Text } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withSequence,\n  withTiming,\n  withDelay,\n  Easing,\n  runOnJS,\n} from 'react-native-reanimated';\nimport { Sparkles } from 'lucide-react-native';\n\ninterface CelebrationAnimationProps {\n  visible: boolean;\n  onComplete?: () => void;\n  intensity?: 'light' | 'moderate' | 'deep' | 'profound';\n}\n\n/**\n * Celebration animation that appears when:\n * 1. User logs a weave (light celebration)\n * 2. User deepens a weave (intensity based on deepening level)\n */\nexport function CelebrationAnimation({\n  visible,\n  onComplete,\n  intensity = 'moderate',\n}: CelebrationAnimationProps) {\n  const scale = useSharedValue(0);\n  const opacity = useSharedValue(0);\n  const rotation = useSharedValue(0);\n\n  // Particle animations\n  const particles = Array.from({ length: intensity === 'profound' ? 12 : intensity === 'deep' ? 8 : intensity === 'moderate' ? 5 : 3 });\n\n  useEffect(() => {\n    if (visible) {\n      // Main animation sequence\n      scale.value = withSequence(\n        withSpring(1.2, { damping: 8, stiffness: 200 }),\n        withSpring(1, { damping: 12, stiffness: 150 })\n      );\n\n      opacity.value = withSequence(\n        withTiming(1, { duration: 200, easing: Easing.out(Easing.quad) }),\n        withDelay(\n          600, // Shortened to 600ms for all intensities\n          withTiming(0, { duration: 200 }, (finished) => {\n            if (finished && onComplete) {\n              runOnJS(onComplete)();\n            }\n          })\n        )\n      );\n\n      rotation.value = withSequence(\n        withTiming(360, { duration: intensity === 'profound' ? 800 : 600, easing: Easing.out(Easing.cubic) }),\n        withTiming(0, { duration: 0 })\n      );\n    } else {\n      scale.value = 0;\n      opacity.value = 0;\n      rotation.value = 0;\n    }\n  }, [visible, intensity]);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { scale: scale.value },\n      { rotate: `${rotation.value}deg` },\n    ],\n    opacity: opacity.value,\n  }));\n\n  if (!visible) return null;\n\n  return (\n    <View style={styles.container} pointerEvents=\"none\">\n      {/* Center burst */}\n      <Animated.View style={[styles.centerBurst, animatedStyle]}>\n        <View style={styles.sparkleContainer}>\n          <Text style={styles.sparkleText}>✨</Text>\n        </View>\n      </Animated.View>\n\n      {/* Particle burst */}\n      {particles.map((_, i) => (\n        <Particle key={i} index={i} total={particles.length} intensity={intensity} />\n      ))}\n    </View>\n  );\n}\n\nfunction Particle({ index, total, intensity }: { index: number; total: number; intensity: string }) {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n  const opacity = useSharedValue(0);\n  const scale = useSharedValue(0);\n\n  useEffect(() => {\n    const angle = (index / total) * Math.PI * 2;\n    const distance = intensity === 'profound' ? 120 : intensity === 'deep' ? 100 : 80;\n\n    translateX.value = withSequence(\n      withTiming(Math.cos(angle) * distance, { duration: 500, easing: Easing.out(Easing.quad) }),\n      withTiming(Math.cos(angle) * distance * 1.2, { duration: 300 })\n    );\n\n    translateY.value = withSequence(\n      withTiming(Math.sin(angle) * distance, { duration: 500, easing: Easing.out(Easing.quad) }),\n      withTiming(Math.sin(angle) * distance * 1.2, { duration: 300 })\n    );\n\n    opacity.value = withSequence(\n      withTiming(1, { duration: 200 }),\n      withDelay(300, withTiming(0, { duration: 400 }))\n    );\n\n    scale.value = withSequence(\n      withSpring(1, { damping: 10 }),\n      withDelay(300, withTiming(0, { duration: 400 }))\n    );\n  }, []);\n\n  const particleStyle = useAnimatedStyle(() => ({\n    transform: [\n      { translateX: translateX.value },\n      { translateY: translateY.value },\n      { scale: scale.value },\n    ],\n    opacity: opacity.value,\n  }));\n\n  return (\n    <Animated.View style={[styles.particle, particleStyle]}>\n      <Text style={styles.particleText}>✨</Text>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    ...StyleSheet.absoluteFillObject,\n    alignItems: 'center',\n    justifyContent: 'center',\n    zIndex: 1000,\n  },\n  centerBurst: {\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  sparkleContainer: {\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  sparkleText: {\n    fontSize: 50,\n    textAlign: 'center',\n  },\n  particle: {\n    position: 'absolute',\n  },\n  particleText: {\n    fontSize: 20,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ContextualReflectionInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/CustomCalendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/CustomChipModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/DataInitializer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AsyncStorage' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, ReactNode } from 'react';\nimport { AppState } from 'react-native';\nimport { SplashScreen, usePathname } from 'expo-router';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming, Easing } from 'react-native-reanimated';\nimport * as Sentry from '@sentry/react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n\nimport {\n    useFonts,\n    Lora_400Regular,\n    Lora_700Bold,\n} from '@expo-google-fonts/lora';\nimport {\n    Inter_400Regular,\n    Inter_500Medium,\n    Inter_600SemiBold,\n} from '@expo-google-fonts/inter';\n\nimport { initializeDataMigrations, initializeUserProfile, initializeUserProgress } from '@/db';\nimport { LoadingScreen } from '@/shared/components/LoadingScreen';\nimport { useDatabaseReady } from '@/shared/hooks/useDatabaseReady';\nimport { useAppStateChange } from '@/shared/hooks/useAppState';\nimport { useTutorialStore } from '@/stores/tutorialStore';\nimport { AutoBackupService } from '@/modules/backup';\nimport { useBackgroundSyncStore } from '@/modules/auth';\nimport { PlanService } from '@/modules/interactions';\nimport { NotificationOrchestrator } from '@/modules/notifications';\n\nimport {\n    initializeAnalytics,\n    trackEvent,\n    trackRetentionMetrics,\n    AnalyticsEvents,\n    setPostHogInstance,\n    setUserProperties\n} from '@/shared/services/analytics.service';\nimport { usePostHog } from '@/shared/services/posthog.service';\n\n// Prevent the splash screen from auto-hiding before asset loading is complete.\nSplashScreen.preventAutoHideAsync();\n\ninterface DataInitializerProps {\n    children: ReactNode;\n}\n\nexport function DataInitializer({ children }: DataInitializerProps) {\n    const posthog = usePostHog();\n    const [analyticsInitialized, setAnalyticsInitialized] = useState(false);\n    const hasCompletedOnboarding = useTutorialStore((state) => state.hasCompletedOnboarding);\n    const pathname = usePathname();\n\n    const [fontsLoaded, fontError] = useFonts({\n        Lora_400Regular,\n        Lora_700Bold,\n        Inter_400Regular,\n        Inter_500Medium,\n        Inter_600SemiBold,\n    });\n\n    const [dataLoaded, setDataLoaded] = useState(false);\n    const [isSplashAnimationComplete, setIsSplashAnimationComplete] = useState(false);\n\n    // Animated opacity for smooth fade-in of content\n    const contentOpacity = useSharedValue(0);\n\n    // Custom hook to handle safe database initialization check\n    const isDatabaseReady = useDatabaseReady(dataLoaded);\n\n    // Analytics Initialization\n    useEffect(() => {\n        if (posthog) {\n            setPostHogInstance(posthog);\n\n            if (!analyticsInitialized) {\n                trackEvent(AnalyticsEvents.APP_OPENED);\n                trackRetentionMetrics();\n                setAnalyticsInitialized(true);\n            }\n\n            // Sync onboarding status for existing users who might have missed the event\n            if (hasCompletedOnboarding) {\n                setUserProperties({ onboarding_completed: true });\n            }\n        }\n    }, [posthog, analyticsInitialized, hasCompletedOnboarding]);\n\n    // Manually track screen views\n    useEffect(() => {\n        if (posthog && pathname) {\n            posthog.screen(pathname);\n        }\n    }, [posthog, pathname]);\n\n    // App State & Backup Logic\n    useEffect(() => {\n        const subscription = AppState.addEventListener('change', (nextAppState) => {\n            if (nextAppState === 'background' || nextAppState === 'inactive') {\n                AutoBackupService.checkAndBackup();\n            }\n        });\n\n        return () => {\n            subscription.remove();\n        };\n    }, []);\n\n    // Splash Screen Logic\n    useEffect(() => {\n        SplashScreen.hideAsync().catch(() => {\n            // Ignore errors if splash screen is already hidden\n        });\n\n        // Enforce minimum display time for the splash animation\n        const timer = setTimeout(() => {\n            setIsSplashAnimationComplete(true);\n        }, 1500);\n\n        return () => clearTimeout(timer);\n    }, []);\n\n    // Initialize Data\n    useEffect(() => {\n        const initializeData = async () => {\n            try {\n                await initializeDataMigrations();\n                await initializeUserProfile();\n                await initializeUserProgress();\n                await initializeAnalytics();\n\n                // Sync calendar changes on app launch (non-blocking)\n                import('@/modules/interactions').then(({ useInteractionsStore }) => {\n                    useInteractionsStore.getState().syncCalendar().catch((error) => {\n                        console.error('[App] Error syncing calendar on launch:', error);\n                    });\n                });\n\n                // Scan for event suggestions on app launch (non-blocking)\n                import('@/modules/interactions').then(({ useEventSuggestionStore }) => {\n                    useEventSuggestionStore.getState().scanForSuggestions().catch((error) => {\n                        console.error('[App] Error scanning for event suggestions on launch:', error);\n                    });\n                });\n\n                // Check for pending plans\n                PlanService.checkPendingPlans().catch(err => {\n                    console.error('[App] Error checking pending plans on launch:', err);\n                });\n\n                setDataLoaded(true);\n            } catch (error) {\n                console.error('Failed to initialize app data:', error);\n                Sentry.captureException(error);\n                setDataLoaded(true);\n            }\n        };\n\n        initializeData();\n    }, []);\n\n    // Initialize background sync\n    useEffect(() => {\n        const initBackgroundSync = async () => {\n            try {\n                await useBackgroundSyncStore.getState().loadSettings();\n            } catch (error) {\n                console.error('[App] Failed to initialize background sync:', error);\n            }\n        };\n        initBackgroundSync();\n    }, []);\n\n    // Fade in content when UI is mounted\n    useEffect(() => {\n        if (isDatabaseReady) {\n            contentOpacity.value = withTiming(1, {\n                duration: 800,\n                easing: Easing.out(Easing.ease),\n            });\n        }\n    }, [isDatabaseReady]);\n\n    const contentStyle = useAnimatedStyle(() => ({\n        opacity: contentOpacity.value,\n    }));\n\n    // Monitor app state changes for logging and maintenance\n    useAppStateChange((state) => {\n        if (state === 'active') {\n            trackEvent(AnalyticsEvents.APP_OPENED);\n            trackRetentionMetrics();\n\n            NotificationOrchestrator.onAppForeground().catch((error) => {\n                console.error('[App] Error during foreground notification checks:', error);\n            });\n\n            // Sync calendar changes when app becomes active\n            import('@/modules/interactions').then(({ useInteractionsStore }) => {\n                useInteractionsStore.getState().syncCalendar().catch((error) => {\n                    console.error('[App] Error syncing calendar on foreground:', error);\n                });\n            });\n\n            import('@/modules/interactions').then(({ useEventSuggestionStore }) => {\n                useEventSuggestionStore.getState().scanForSuggestions().catch((error) => {\n                    console.error('[App] Error scanning for event suggestions:', error);\n                });\n            });\n\n            PlanService.checkPendingPlans().catch(err => {\n                console.error('[App] Error checking pending plans on active:', err);\n            });\n        } else if (state === 'background') {\n            trackEvent(AnalyticsEvents.APP_BACKGROUNDED);\n        }\n    });\n\n    if (!fontsLoaded && !fontError) {\n        return null;\n    }\n\n    return (\n        <>\n            <Animated.View style={[{ flex: 1 }, contentStyle]}>\n                {children}\n            </Animated.View>\n\n            <LoadingScreen visible={!fontsLoaded || !dataLoaded || !isDatabaseReady || !isSplashAnimationComplete} />\n        </>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/DigestSheet.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EveningDigestChannel' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":26,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'openMemoryMoment' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":28,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'memories' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { StyleSheet, View, Text, ScrollView } from 'react-native';\nimport { Calendar, Sparkles, Clock, Moon } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { AnimatedBottomSheet } from '@/shared/ui/Sheet';\nimport { ListItem } from '@/components/ui/ListItem';\nimport { Button } from '@/components/ui/Button';\nimport { Card } from '@/components/ui/Card';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport { DigestItem, EveningDigestChannel } from '@/modules/notifications';\nimport { useRouter } from 'expo-router';\nimport { useUIStore } from '@/stores/uiStore';\nimport { format } from 'date-fns';\n\ninterface DigestSheetProps {\n    isVisible: boolean;\n    onClose: () => void;\n    items: DigestItem[];\n}\n\nexport const DigestSheet: React.FC<DigestSheetProps> = ({\n    isVisible,\n    onClose,\n    items,\n}) => {\n    const { tokens, typography, isDarkMode } = useTheme();\n    const router = useRouter();\n    const { openMemoryMoment } = useUIStore();\n\n    const plans = items.filter(i => i.type === 'plan' || i.type === 'confirmation');\n    const upcoming = items.filter(i => i.type === 'birthday' || i.type === 'life_event');\n    const suggestions = items.filter(i => i.type === 'suggestion');\n    // Memories (if ever added to digest)\n    const memories = items.filter(i => i.type === 'memory');\n\n    const handleAction = async (item: DigestItem) => {\n        onClose();\n        if (item.type === 'plan' || item.type === 'confirmation') {\n            // Navigate to where? Maybe just open focus detail sheet for confirmation?\n            // Or navigate to a specific interaction if possible.\n            // For now, let's open FocusDetailSheet by triggering Today's Focus Widget opening logic?\n            // Actually, `TodaysFocusWidgetV2` logic handles confirmation inside `FocusDetailSheet`.\n            // Ideally we confirm directly or open a dedicated view.\n            // Requirement says \"navigate to plan detail or confirm flow\".\n            // Since we don't have a standalone plan detail screen easily accessible,\n            // we will navigate to dashboard where Focus widget is.\n            router.push('/dashboard');\n        } else if (item.friendId) {\n            router.push(`/friend-profile?friendId=${item.friendId}`);\n        } else if (item.type === 'memory') {\n            // Provide memory moment data if available?\n            // item.data should contain memory details if we implemented memory in digest fully.\n            // For now, assume it links to profile or journal\n        }\n    };\n\n    const renderItem = (item: DigestItem, index: number, total: number) => (\n        <View key={`${item.type}-${item.title}-${index}`} style={{ paddingHorizontal: 16 }}>\n            <ListItem\n                title={item.title}\n                subtitle={item.subtitle}\n                showDivider={index < total - 1}\n                compact\n                trailing={\n                    <Button\n                        label=\"View\"\n                        variant=\"secondary\"\n                        size=\"small\"\n                        style={{ height: 32, paddingVertical: 4, paddingHorizontal: 12 }}\n                        onPress={() => handleAction(item)}\n                    />\n                }\n            />\n        </View>\n    );\n\n    return (\n        <AnimatedBottomSheet\n            visible={isVisible}\n            onClose={onClose}\n            height=\"form\"\n            scrollable\n        >\n            <View style={styles.header}>\n                <View>\n                    <Text style={[styles.title, { color: tokens.foreground, fontFamily: typography.fonts.serifBold }]}>\n                        Evening Check-in\n                    </Text>\n                    <Text style={[styles.subtitle, { color: tokens.foregroundMuted, fontFamily: typography.fonts.sans }]}>\n                        {format(new Date(), 'EEEE, MMMM d')}\n                    </Text>\n                </View>\n            </View>\n\n            <View style={{ paddingHorizontal: 20 }}>\n                {plans.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Plans\" icon={<Clock size={20} color={tokens.primaryMuted} />} />\n                        <Card padding=\"none\">\n                            {plans.map((item, i) => renderItem(item, i, plans.length))}\n                        </Card>\n                    </View>\n                )}\n\n                {upcoming.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Coming Up\" icon={<Calendar size={20} color={tokens.primaryMuted} />} />\n                        <Card padding=\"none\">\n                            {upcoming.map((item, i) => renderItem(item, i, upcoming.length))}\n                        </Card>\n                    </View>\n                )}\n\n                {suggestions.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Suggestions\" icon={<Sparkles size={20} color={tokens.primaryMuted} />} />\n                        <Card padding=\"none\">\n                            {suggestions.map((item, i) => renderItem(item, i, suggestions.length))}\n                        </Card>\n                    </View>\n                )}\n\n                {items.length === 0 && (\n                    <View style={styles.emptyState}>\n                        <Moon size={48} color={tokens.primaryMuted} />\n                        <Text style={[styles.emptyTitle, { color: tokens.foreground, fontFamily: typography.fonts.serifBold }]}>\n                            All Quiet Tonight\n                        </Text>\n                        <Text style={[styles.emptyText, { color: tokens.foregroundMuted, fontFamily: typography.fonts.sans }]}>\n                            No pending plans or urgent suggestions. Rest easy!\n                        </Text>\n                    </View>\n                )}\n            </View>\n        </AnimatedBottomSheet>\n    );\n};\n\nconst styles = StyleSheet.create({\n    overlay: {\n        flex: 1,\n        justifyContent: 'flex-end',\n    },\n    sheet: {\n        borderTopLeftRadius: 24,\n        borderTopRightRadius: 24,\n        height: '80%',\n        paddingTop: 24,\n    },\n    header: {\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n        alignItems: 'flex-start',\n        paddingHorizontal: 24,\n        marginBottom: 24,\n    },\n    title: {\n        fontSize: 28,\n        marginBottom: 4,\n    },\n    subtitle: {\n        fontSize: 16,\n    },\n    closeButton: {\n        padding: 4,\n        marginTop: 4,\n    },\n    content: {\n        paddingHorizontal: 20,\n        paddingBottom: 40,\n    },\n    section: {\n        marginBottom: 24,\n    },\n    emptyState: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingVertical: 60,\n        gap: 16,\n    },\n    emptyTitle: {\n        fontSize: 20,\n    },\n    emptyText: {\n        fontSize: 16,\n        textAlign: 'center',\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/DuplicateResolverModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":23,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, Modal, TouchableOpacity, Image, KeyboardAvoidingView, Platform } from 'react-native';\nimport { BlurView } from 'expo-blur';\nimport { Check, X, AlertCircle } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport * as Contacts from 'expo-contacts';\nimport { Text } from '@/shared/ui/Text';\nimport { Input } from '@/shared/ui/Input';\n\ninterface DuplicateResolverModalProps {\n    isVisible: boolean;\n    conflicts: Array<{\n        contact: Contacts.Contact;\n        type: 'existing_friend' | 'batch_duplicate';\n        originalName: string;\n        suggestedName?: string;\n    }>;\n    onResolve: (resolutions: Array<{ contactId: string; newName: string; skipped: boolean }>) => void;\n    onCancel: () => void;\n}\n\nexport function DuplicateResolverModal({ isVisible, conflicts, onResolve, onCancel }: DuplicateResolverModalProps) {\n    const { colors, isDarkMode } = useTheme();\n    const [currentIndex, setCurrentIndex] = useState(0);\n    const [currentName, setCurrentName] = useState('');\n    const [resolutions, setResolutions] = useState<Array<{ contactId: string; newName: string; skipped: boolean }>>([]);\n\n    // Initialize current name when index changes\n    React.useEffect(() => {\n        if (conflicts[currentIndex]) {\n            setCurrentName(conflicts[currentIndex].suggestedName || conflicts[currentIndex].originalName);\n        }\n    }, [currentIndex, conflicts]);\n\n    const currentConflict = conflicts[currentIndex];\n\n    const handleNext = (skipped: boolean) => {\n        const newResolution = {\n            contactId: currentConflict.contact.id || '',\n            newName: currentName.trim(),\n            skipped,\n        };\n\n        const newResolutions = [...resolutions, newResolution];\n        setResolutions(newResolutions);\n\n        if (currentIndex < conflicts.length - 1) {\n            setCurrentIndex(currentIndex + 1);\n        } else {\n            // All done\n            onResolve(newResolutions);\n            // Reset for next time (though component usually unmounts/hides)\n            setCurrentIndex(0);\n            setResolutions([]);\n        }\n    };\n\n    if (!currentConflict) return null;\n\n    return (\n        <Modal\n            visible={isVisible}\n            transparent\n            animationType=\"fade\"\n            statusBarTranslucent\n        >\n            <BlurView intensity={20} className=\"flex-1 justify-center items-center p-5 bg-black/40\">\n                <KeyboardAvoidingView\n                    behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n                    className=\"flex-1 justify-center items-center w-full\"\n                >\n                    <View\n                        className=\"w-full max-w-sm rounded-3xl p-6 border shadow-xl\"\n                        style={{\n                            backgroundColor: colors.card,\n                            borderColor: colors.border,\n                            elevation: 8\n                        }}\n                    >\n\n                        <View className=\"items-center mb-6\">\n                            <View className=\"w-16 h-16 rounded-full justify-center items-center mb-4 bg-amber-100\">\n                                <AlertCircle size={32} color=\"#d97706\" />\n                            </View>\n                            <Text variant=\"h3\" weight=\"bold\" className=\"mb-2 text-center\">\n                                Duplicate Found ({currentIndex + 1}/{conflicts.length})\n                            </Text>\n                            <Text align=\"center\" color=\"muted\" className=\"leading-6\">\n                                {currentConflict.type === 'existing_friend'\n                                    ? `You already have a friend named \"${currentConflict.originalName}\".`\n                                    : `You selected multiple contacts named \"${currentConflict.originalName}\".`\n                                }\n                            </Text>\n                        </View>\n\n                        <View\n                            className=\"flex-row items-center p-4 rounded-2xl mb-6 gap-4\"\n                            style={{ backgroundColor: colors.background }}\n                        >\n                            <View className=\"w-14 h-14\">\n                                {currentConflict.contact.imageAvailable && currentConflict.contact.image ? (\n                                    <Image\n                                        source={{ uri: currentConflict.contact.image.uri }}\n                                        className=\"w-full h-full rounded-full\"\n                                    />\n                                ) : (\n                                    <View\n                                        className=\"w-full h-full rounded-full justify-center items-center\"\n                                        style={{ backgroundColor: colors.primary }}\n                                    >\n                                        <Text weight=\"bold\" className=\"text-xl text-white\">\n                                            {currentConflict.originalName.charAt(0)}\n                                        </Text>\n                                    </View>\n                                )}\n                            </View>\n                            <View className=\"flex-1\">\n                                <Input\n                                    label=\"Save as:\"\n                                    value={currentName}\n                                    onChangeText={setCurrentName}\n                                    autoFocus\n                                    selectTextOnFocus\n                                    containerClassName=\"mb-0\"\n                                />\n                            </View>\n                        </View>\n\n                        <View className=\"flex-row gap-3 mb-4\">\n                            <TouchableOpacity\n                                className=\"flex-1 h-12 rounded-xl flex-row justify-center items-center gap-2 border\"\n                                style={{ borderColor: colors.border }}\n                                onPress={() => handleNext(true)}\n                            >\n                                <X size={20} color={colors['muted-foreground']} />\n                                <Text color=\"muted\" weight=\"semibold\">Don't Add</Text>\n                            </TouchableOpacity>\n\n                            <TouchableOpacity\n                                className=\"flex-1 h-12 rounded-xl flex-row justify-center items-center gap-2\"\n                                style={{ backgroundColor: colors.primary, opacity: !currentName.trim() ? 0.5 : 1 }}\n                                onPress={() => handleNext(false)}\n                                disabled={!currentName.trim()}\n                            >\n                                <Check size={20} color={colors['primary-foreground']} />\n                                <Text style={{ color: colors['primary-foreground'] }} weight=\"semibold\">Save</Text>\n                            </TouchableOpacity>\n                        </View>\n\n                        <TouchableOpacity\n                            className=\"items-center\"\n                            onPress={onCancel}\n                        >\n                            <Text color=\"muted\" weight=\"medium\" className=\"underline\">Cancel Import</Text>\n                        </TouchableOpacity>\n\n                    </View>\n                </KeyboardAvoidingView>\n            </BlurView>\n        </Modal>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/EditInteractionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Check' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Icon' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo } from 'react';\nimport { View, TouchableOpacity, ScrollView, Modal, StyleSheet } from 'react-native';\nimport { X, CalendarDays, Check } from 'lucide-react-native';\nimport Animated, { FadeInUp } from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { Text } from '@/shared/ui/Text';\nimport { Input } from '@/shared/ui/Input';\nimport { Button } from '@/shared/ui/Button';\nimport { Card } from '@/shared/ui/Card';\nimport { Icon } from '@/shared/ui/Icon';\nimport { type Interaction, type InteractionCategory, type Vibe, type StructuredReflection } from './types';\nimport { getAllCategories, getCategoryMetadata, type CategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { MoonPhaseSelector } from './MoonPhaseSelector';\nimport { CustomCalendar } from '@/components/CustomCalendar';\nimport { format } from 'date-fns';\nimport { BlurView } from 'expo-blur';\nimport { ReciprocitySelector, InitiatorType } from '@/components/ReciprocitySelector';\n\ninterface EditInteractionModalProps {\n  interaction: Interaction | null;\n  isOpen: boolean;\n  onClose: () => void;\n  onSave: (interactionId: string, updates: {\n    title?: string;\n    category?: InteractionCategory;\n    interactionCategory?: InteractionCategory;\n    activity?: string;\n    interactionType?: string;\n    vibe?: Vibe | null;\n    reflection?: StructuredReflection;\n    reflectionJSON?: string;\n    interactionDate?: Date;\n    initiator?: InitiatorType;\n    note?: string;\n  }) => Promise<void>;\n}\n\nconst categories: CategoryMetadata[] = getAllCategories().map(cat => getCategoryMetadata(cat));\n\nexport function EditInteractionModal({\n  interaction,\n  isOpen,\n  onClose,\n  onSave,\n}: EditInteractionModalProps) {\n  const { colors, isDarkMode } = useTheme();\n  const [title, setTitle] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState<InteractionCategory | null>(null);\n  const [selectedVibe, setSelectedVibe] = useState<Vibe | null>(null);\n  const [customNotes, setCustomNotes] = useState('');\n  const [isSaving, setIsSaving] = useState(false);\n  const [selectedDate, setSelectedDate] = useState<Date | null>(null);\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [initiator, setInitiator] = useState<InitiatorType | undefined>(undefined);\n\n  // Update state when interaction changes\n  React.useEffect(() => {\n    if (interaction) {\n      setTitle(interaction.title || '');\n      setSelectedCategory((interaction.interactionCategory || interaction.activity) as InteractionCategory);\n      setSelectedVibe(interaction.vibe || null);\n      setCustomNotes(interaction.reflection?.customNotes || interaction.note || '');\n      setSelectedDate(interaction.interactionDate);\n      setInitiator(interaction.initiator as InitiatorType | undefined);\n    }\n  }, [interaction]);\n\n  const handleSave = async () => {\n    if (!interaction) return;\n\n    setIsSaving(true);\n    try {\n      const updates: any = {};\n\n      if (title !== interaction.title) {\n        updates.title = title;\n      }\n\n      if (selectedCategory && selectedCategory !== (interaction.interactionCategory || interaction.activity)) {\n        updates.interactionCategory = selectedCategory;\n        updates.activity = selectedCategory;\n        const metadata = getCategoryMetadata(selectedCategory);\n        updates.interactionType = metadata.label;\n      }\n\n      if (selectedVibe !== interaction.vibe) {\n        updates.vibe = selectedVibe;\n      }\n\n      // Update reflection if custom notes changed\n      if (customNotes !== (interaction.reflection?.customNotes || interaction.note || '')) {\n        const newReflection = {\n          ...interaction.reflection,\n          customNotes,\n        };\n        updates.reflectionJSON = JSON.stringify(newReflection);\n        updates.note = customNotes;\n      }\n\n      if (selectedDate && selectedDate.getTime() !== interaction.interactionDate.getTime()) {\n        updates.interactionDate = selectedDate;\n      }\n\n      if (initiator !== interaction.initiator) {\n        updates.initiator = initiator;\n      }\n\n      await onSave(interaction.id, updates);\n      onClose();\n    } catch (error) {\n      console.error('Error updating interaction:', error);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  // Calculate dirty state\n  const isDirty = React.useMemo(() => {\n    if (!interaction) return false;\n\n    const initialTitle = interaction.title || '';\n    const initialCategory = (interaction.interactionCategory || interaction.activity) as InteractionCategory;\n    const initialVibe = interaction.vibe || null;\n    const initialNotes = interaction.reflection?.customNotes || interaction.note || '';\n    // Handle potential string dates if data isn't perfectly typed at runtime, though types say Date.\n    const initialDate = interaction.interactionDate instanceof Date ? interaction.interactionDate.getTime() : new Date(interaction.interactionDate).getTime();\n    const initialInitiator = interaction.initiator as InitiatorType | undefined;\n\n    // Current date comparison\n    const currentDate = selectedDate ? selectedDate.getTime() : 0;\n\n    return (\n      title !== initialTitle ||\n      selectedCategory !== initialCategory ||\n      selectedVibe !== initialVibe ||\n      customNotes !== initialNotes ||\n      currentDate !== initialDate ||\n      initiator !== initialInitiator\n    );\n  }, [interaction, title, selectedCategory, selectedVibe, customNotes, selectedDate, initiator]);\n\n  if (!interaction) return null;\n\n  const footerComponent = React.useMemo(() => (\n    <Button\n      label=\"Save Changes\"\n      onPress={handleSave}\n      loading={isSaving}\n      disabled={isSaving || !selectedCategory}\n      fullWidth\n      variant=\"primary\"\n    />\n  ), [isSaving, selectedCategory, handleSave]);\n\n  return (\n    <StandardBottomSheet\n      visible={isOpen}\n      onClose={onClose}\n      hasUnsavedChanges={isDirty}\n      height=\"full\"\n      title=\"Edit Weave\"\n      scrollable\n      footerComponent={footerComponent}\n    >\n      <View className=\"px-5 pb-10 gap-8\">\n        {/* Title Input */}\n        <View>\n          <Input\n            label=\"Title\"\n            placeholder='e.g., \"Coffee at Blue Bottle\"'\n            value={title}\n            onChangeText={setTitle}\n          />\n        </View>\n\n        {/* Date Selection */}\n        <View>\n          <Text variant=\"label\" className=\"mb-2\" style={{ color: colors.foreground }}>\n            Date\n          </Text>\n          <TouchableOpacity\n            onPress={() => setShowDatePicker(true)}\n            activeOpacity={0.7}\n          >\n            <View className=\"flex-row items-center gap-3 p-4 border rounded-xl\" style={{ backgroundColor: colors.card, borderColor: colors.border }}>\n              <CalendarDays size={20} color={colors.primary} />\n              <Text variant=\"body\">\n                {selectedDate ? format(selectedDate, 'EEEE, MMMM d, yyyy') : 'Select date'}\n              </Text>\n            </View>\n          </TouchableOpacity>\n        </View>\n\n        {/* Category Selection */}\n        <View>\n          <Text variant=\"label\" className=\"mb-3\" style={{ color: colors.foreground }}>\n            Category\n          </Text>\n          <View className=\"flex-row flex-wrap justify-between gap-y-3\">\n            {categories.map((cat) => {\n              const isSelected = selectedCategory === cat.id;\n              return (\n                <Animated.View\n                  key={cat.id}\n                  className=\"w-[48%]\"\n                >\n                  <TouchableOpacity\n                    onPress={() => setSelectedCategory(cat.id)}\n                    activeOpacity={0.7}\n                    className={`p-3 rounded-2xl border items-center justify-center min-h-[120px] ${isSelected ? 'border-2' : 'border'}`}\n                    style={{\n                      backgroundColor: colors.card,\n                      borderColor: isSelected ? colors.primary : colors.border,\n                      shadowColor: '#000',\n                      shadowOffset: { width: 0, height: 2 },\n                      shadowOpacity: 0.05,\n                      shadowRadius: 8,\n                      elevation: 2,\n                    }}\n                  >\n                    <Text className=\"text-3xl mb-2\">{cat.icon}</Text>\n                    <Text variant=\"body\" weight=\"semibold\" className=\"text-center mb-1\">\n                      {cat.label}\n                    </Text>\n                    <Text variant=\"caption\" color=\"muted\" className=\"text-center text-xs\">\n                      {cat.description}\n                    </Text>\n                  </TouchableOpacity>\n                </Animated.View>\n              );\n            })}\n          </View>\n        </View>\n\n        {/* Vibe Selection */}\n        <View>\n          <Text variant=\"label\" className=\"mb-3\" style={{ color: colors.foreground }}>\n            Vibe\n          </Text>\n          <MoonPhaseSelector onSelect={setSelectedVibe} selectedVibe={selectedVibe} />\n        </View>\n\n        {/* Reciprocity Section */}\n        <View>\n          <Text variant=\"label\" className=\"mb-3\" style={{ color: colors.foreground }}>\n            Who initiated?\n          </Text>\n          <ReciprocitySelector\n            value={initiator}\n            onChange={setInitiator}\n            hideLabel\n          />\n        </View>\n\n        {/* Notes */}\n        <View>\n          <Input\n            label=\"Notes\"\n            placeholder=\"Add notes about this moment...\"\n            value={customNotes}\n            onChangeText={setCustomNotes}\n            multiline\n            numberOfLines={4}\n            style={{ minHeight: 120, textAlignVertical: 'top', paddingTop: 12 }}\n          />\n        </View>\n      </View>\n\n      {/* Calendar Modal - Keeping legacy simple modal for date picker to avoid nesting sheets complexities, but styled with NativeWind */}\n      {showDatePicker && (\n        <Modal\n          visible={true}\n          transparent\n          animationType=\"fade\"\n          onRequestClose={() => setShowDatePicker(false)}\n        >\n          <BlurView intensity={isDarkMode ? 20 : 40} tint={isDarkMode ? 'dark' : 'light'} style={StyleSheet.absoluteFill}>\n            <TouchableOpacity\n              className=\"flex-1 justify-center items-center p-5\"\n              activeOpacity={1}\n              onPress={() => setShowDatePicker(false)}\n            >\n              <Animated.View\n                entering={FadeInUp.duration(200).springify()}\n                className=\"w-full max-w-md rounded-3xl p-6 shadow-2xl\"\n                style={{\n                  backgroundColor: isDarkMode ? colors.background + 'F5' : colors.background + 'F8',\n                }}\n                onStartShouldSetResponder={() => true}\n              >\n                <View className=\"flex-row justify-between items-center mb-4\">\n                  <Text variant=\"h3\" weight=\"bold\">\n                    Pick a Date\n                  </Text>\n                  <TouchableOpacity onPress={() => setShowDatePicker(false)} className=\"p-2 -mr-2\">\n                    <X color={colors['muted-foreground']} size={22} />\n                  </TouchableOpacity>\n                </View>\n\n                <CustomCalendar\n                  selectedDate={selectedDate || new Date()}\n                  onDateSelect={(date) => {\n                    setSelectedDate(date);\n                    setShowDatePicker(false);\n                  }}\n                />\n              </Animated.View>\n            </TouchableOpacity>\n          </BlurView>\n        </Modal>\n      )}\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/EditReflectionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TouchableOpacity' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, TouchableOpacity } from 'react-native';\nimport Animated, { FadeIn } from 'react-native-reanimated';\nimport { ContextualReflectionInput } from './ContextualReflectionInput';\nimport { CelebrationAnimation } from './CelebrationAnimation';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { type Interaction, type StructuredReflection, type InteractionCategory, type Archetype, type Vibe } from './types';\nimport { calculateDeepeningLevel } from '@/modules/intelligence';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\n\nimport { MoonPhaseSelector } from './MoonPhaseSelector';\n\ninterface EditReflectionModalProps {\n  interaction: Interaction | null;\n  isOpen: boolean;\n  onClose: () => void;\n  onSave: (interactionId: string, reflection: StructuredReflection, vibe?: Vibe | null) => Promise<void>;\n  friendArchetype?: Archetype;\n}\n\nexport function EditReflectionModal({\n  interaction,\n  isOpen,\n  onClose,\n  onSave,\n  friendArchetype,\n}: EditReflectionModalProps) {\n  const { colors } = useTheme();\n  const [reflection, setReflection] = useState<StructuredReflection>(interaction?.reflection || {});\n  const [selectedVibe, setSelectedVibe] = useState<Vibe | null>(interaction?.vibe as Vibe | null);\n  const [isSaving, setIsSaving] = useState(false);\n  const [showCelebration, setShowCelebration] = useState(false);\n\n  // Update reflection when interaction changes\n  React.useEffect(() => {\n    if (interaction) {\n      setReflection(interaction.reflection || {});\n      setSelectedVibe(interaction.vibe as Vibe | null);\n    }\n  }, [interaction]);\n\n  const handleSave = async () => {\n    if (!interaction) return;\n\n    setIsSaving(true);\n    try {\n      await onSave(interaction.id, reflection, selectedVibe);\n\n      // Show celebration animation\n      setShowCelebration(true);\n\n      // Close modal after animation\n      setTimeout(() => {\n        onClose();\n        setShowCelebration(false);\n      }, 900);\n    } catch (error) {\n      console.error('Error saving reflection:', error);\n      setIsSaving(false);\n    }\n  };\n\n  if (!interaction) return null;\n\n  const category = (interaction.interactionCategory || interaction.activity) as InteractionCategory;\n  const deepeningMetrics = calculateDeepeningLevel(reflection);\n\n  return (\n    <StandardBottomSheet\n      visible={isOpen}\n      onClose={onClose}\n      height=\"full\"\n      title=\"Tell me more\"\n      scrollable\n      footerComponent={\n        <Button\n          label={isSaving ? 'Saving...' : 'Save Reflection'}\n          onPress={handleSave}\n          loading={isSaving}\n          disabled={isSaving}\n          fullWidth\n          variant=\"primary\"\n        />\n      }\n    >\n      {/* Celebration animation */}\n      <CelebrationAnimation\n        visible={showCelebration}\n        intensity={deepeningMetrics.level === 'none' ? 'light' : deepeningMetrics.level}\n        onComplete={() => setShowCelebration(false)}\n      />\n\n      <Animated.View entering={FadeIn.duration(300)} className=\"px-5 pb-5\">\n        <View className=\"mb-6\">\n          <Text variant=\"h3\" className=\"mb-4\">\n            How did it feel?\n          </Text>\n          <MoonPhaseSelector\n            selectedVibe={selectedVibe}\n            onSelect={setSelectedVibe}\n          />\n        </View>\n\n        <ContextualReflectionInput\n          category={category}\n          archetype={friendArchetype}\n          vibe={selectedVibe}\n          value={reflection}\n          onChange={setReflection}\n        />\n      </Animated.View>\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/EventSuggestionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Modal, View, Text, TouchableOpacity, ScrollView } from 'react-native';\nimport { X, Calendar, MapPin, Users } from 'lucide-react-native';\nimport { BlurView } from 'expo-blur';\nimport { router } from 'expo-router';\nimport { useEventSuggestionStore } from '@/modules/interactions';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { format } from 'date-fns';\nimport Animated, { FadeIn, FadeOut, SlideInDown, SlideOutDown } from 'react-native-reanimated';\n\n/**\n * Modal to suggest logging a past calendar event as a weave\n * Shows up when the app detects a recent event with friend matches\n */\nexport function EventSuggestionModal() {\n  const { showingPastEvent, dismissPastEvent, hidePastEventModal } = useEventSuggestionStore();\n  const { colors } = useTheme();\n\n  if (!showingPastEvent) {\n    return null;\n  }\n\n  const { event } = showingPastEvent;\n  const friendNames = event.matchedFriends.map((m) => m.friend.name).join(', ');\n  const dateStr = format(event.startDate, 'EEEE, MMM d');\n\n  const handleLogWeave = () => {\n    // Navigate to interaction form with pre-filled data\n    const friendIds = event.matchedFriends.map((m) => m.friend.id);\n\n    const params = new URLSearchParams({\n      type: 'log',\n      friendIds: friendIds.join(','),\n      date: event.startDate.toISOString(),\n      title: event.title,\n      category: event.suggestedCategory || 'event',\n    });\n\n    if (event.location) {\n      params.append('location', event.location);\n    }\n\n    if (event.notes) {\n      params.append('notes', event.notes);\n    }\n\n    hidePastEventModal();\n    router.push(`/interaction-form?${params.toString()}`);\n  };\n\n  const handleDismiss = () => {\n    dismissPastEvent(event.id);\n    hidePastEventModal();\n  };\n\n  const handleNotNow = () => {\n    hidePastEventModal();\n  };\n\n  // Get event type emoji\n  const getEventEmoji = () => {\n    switch (event.eventType) {\n      case 'birthday':\n        return '🎂';\n      case 'anniversary':\n        return '💝';\n      case 'holiday':\n        return '🎉';\n      case 'meal':\n        return '🍽️';\n      case 'social':\n        return '🎊';\n      case 'activity':\n        return '🎯';\n      default:\n        return '📅';\n    }\n  };\n\n  return (\n    <Modal transparent visible animationType=\"none\">\n      <Animated.View\n        entering={FadeIn.duration(200)}\n        exiting={FadeOut.duration(150)}\n        className=\"flex-1\"\n      >\n        <BlurView\n          intensity={20}\n          tint=\"dark\"\n          className=\"flex-1 justify-center items-center px-6\"\n        >\n          <TouchableOpacity\n            className=\"absolute inset-0\"\n            onPress={handleNotNow}\n            activeOpacity={1}\n          />\n\n          <Animated.View\n            entering={SlideInDown.duration(300).springify()}\n            exiting={SlideOutDown.duration(200)}\n            className=\"w-full max-w-md rounded-3xl p-6\"\n            style={{\n              backgroundColor: colors.card,\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: 8 },\n              shadowOpacity: 0.3,\n              shadowRadius: 16,\n              elevation: 10,\n            }}\n          >\n            {/* Close button */}\n            <TouchableOpacity\n              onPress={handleNotNow}\n              className=\"absolute top-4 right-4 w-8 h-8 rounded-full items-center justify-center z-10\"\n              style={{ backgroundColor: colors.muted }}\n            >\n              <X color={colors['muted-foreground']} size={18} />\n            </TouchableOpacity>\n\n            {/* Header */}\n            <View className=\"items-center mb-4\">\n              <View\n                className=\"w-16 h-16 rounded-full items-center justify-center mb-3\"\n                style={{ backgroundColor: `${colors.primary}20` }}\n              >\n                <Text className=\"text-4xl\">{getEventEmoji()}</Text>\n              </View>\n              <Text\n                className=\"text-xl font-lora-bold text-center mb-1\"\n                style={{ color: colors.foreground }}\n              >\n                Did you weave?\n              </Text>\n              <Text\n                className=\"text-sm font-inter-regular text-center\"\n                style={{ color: colors['muted-foreground'] }}\n              >\n                We noticed you had a calendar event\n              </Text>\n            </View>\n\n            {/* Event details */}\n            <View\n              className=\"rounded-xl p-4 mb-4\"\n              style={{ backgroundColor: colors.muted }}\n            >\n              <Text\n                className=\"text-base font-inter-semibold mb-3\"\n                style={{ color: colors.foreground }}\n              >\n                {event.title}\n              </Text>\n\n              {/* Friends */}\n              <View className=\"flex-row items-center gap-2 mb-2\">\n                <Users color={colors['muted-foreground']} size={16} />\n                <Text\n                  className=\"text-sm font-inter-regular flex-1\"\n                  style={{ color: colors['muted-foreground'] }}\n                >\n                  {friendNames}\n                </Text>\n              </View>\n\n              {/* Date */}\n              <View className=\"flex-row items-center gap-2 mb-2\">\n                <Calendar color={colors['muted-foreground']} size={16} />\n                <Text\n                  className=\"text-sm font-inter-regular\"\n                  style={{ color: colors['muted-foreground'] }}\n                >\n                  {dateStr}\n                </Text>\n              </View>\n\n              {/* Location */}\n              {event.location && (\n                <View className=\"flex-row items-center gap-2\">\n                  <MapPin color={colors['muted-foreground']} size={16} />\n                  <Text\n                    className=\"text-sm font-inter-regular flex-1\"\n                    style={{ color: colors['muted-foreground'] }}\n                    numberOfLines={1}\n                  >\n                    {event.location}\n                  </Text>\n                </View>\n              )}\n            </View>\n\n            {/* Action buttons */}\n            <View className=\"gap-3\">\n              {/* Log weave button */}\n              <TouchableOpacity\n                onPress={handleLogWeave}\n                className=\"rounded-xl py-3.5\"\n                style={{ backgroundColor: colors.primary }}\n              >\n                <Text className=\"text-base font-inter-semibold text-center text-white\">\n                  Log This Weave\n                </Text>\n              </TouchableOpacity>\n\n              {/* Not now button */}\n              <TouchableOpacity\n                onPress={handleNotNow}\n                className=\"rounded-xl py-3.5\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <Text\n                  className=\"text-base font-inter-medium text-center\"\n                  style={{ color: colors.foreground }}\n                >\n                  Not Now\n                </Text>\n              </TouchableOpacity>\n\n              {/* Dismiss button */}\n              <TouchableOpacity onPress={handleDismiss}>\n                <Text\n                  className=\"text-sm font-inter-regular text-center\"\n                  style={{ color: colors['muted-foreground'] }}\n                >\n                  Don't suggest this again\n                </Text>\n              </TouchableOpacity>\n            </View>\n          </Animated.View>\n        </BlurView>\n      </Animated.View>\n    </Modal>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/FeedbackModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, Platform, Alert, ScrollView } from 'react-native';\nimport { Send } from 'lucide-react-native';\nimport * as Sentry from '@sentry/react-native';\nimport Constants from 'expo-constants';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { trackEvent, AnalyticsEvents } from '@/shared/services/analytics.service';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { Text } from '@/shared/ui/Text';\nimport { Input } from '@/shared/ui/Input';\nimport { Button } from '@/shared/ui/Button';\n\ninterface FeedbackModalProps {\n  visible: boolean;\n  onClose: () => void;\n}\n\nexport function FeedbackModal({ visible, onClose }: FeedbackModalProps) {\n  const { colors } = useTheme();\n  const [feedback, setFeedback] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const handleSubmit = async () => {\n    if (!feedback.trim()) {\n      Alert.alert('Feedback Required', 'Please enter your feedback before submitting.');\n      return;\n    }\n\n    setIsSubmitting(true);\n\n    try {\n      // Collect device info\n      const deviceInfo = {\n        platform: Platform.OS,\n        platformVersion: Platform.Version,\n        appVersion: Constants.expoConfig?.version || 'unknown',\n        deviceModel: Constants.deviceName,\n        timestamp: new Date().toISOString(),\n      };\n\n      // Send to Sentry User Feedback\n      const eventId = Sentry.captureMessage('User Feedback Submitted', {\n        level: 'info',\n        tags: {\n          type: 'user_feedback',\n          platform: Platform.OS,\n        },\n        contexts: {\n          device: deviceInfo,\n        },\n        extra: {\n          feedback: feedback.trim(),\n        },\n      });\n\n      // Also submit via Sentry's feedback integration\n      Sentry.captureUserFeedback({\n        event_id: eventId,\n        name: 'Beta Tester',\n        email: 'beta@weave.app', // Placeholder\n        comments: feedback.trim(),\n      });\n\n      // Track analytics\n      trackEvent(AnalyticsEvents.FEEDBACK_SUBMITTED, {\n        feedback_length: feedback.length,\n        platform: Platform.OS,\n      });\n\n      Alert.alert(\n        'Thank You!',\n        'Your feedback has been submitted successfully. We appreciate your help in making Weave better!',\n        [{ text: 'OK', onPress: () => onClose() }]\n      );\n\n      setFeedback('');\n    } catch (error) {\n      console.error('Failed to submit feedback:', error);\n      Sentry.captureException(error);\n      Alert.alert('Error', 'Failed to submit feedback. Please try again.');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <StandardBottomSheet\n      visible={visible}\n      onClose={onClose}\n      height=\"form\"\n      title=\"Send Feedback\"\n      scrollable\n      footerComponent={\n        <Button\n          label={isSubmitting ? \"Submitting...\" : \"Submit Feedback\"}\n          onPress={handleSubmit}\n          loading={isSubmitting}\n          fullWidth\n          variant=\"primary\"\n          icon={<Send size={20} color={colors['primary-foreground']} />}\n        />\n      }\n    >\n      <View className=\"px-5 pb-5\">\n        {/* Instructions */}\n        <Text\n          color=\"muted\"\n          className=\"mb-4\"\n        >\n          Help us improve Weave! Share any bugs, suggestions, or thoughts you have.\n          Your feedback is invaluable.\n        </Text>\n\n        {/* Feedback Input */}\n        <Input\n          value={feedback}\n          onChangeText={setFeedback}\n          placeholder=\"What happened? Any suggestions?\"\n          multiline\n          numberOfLines={6}\n          style={{\n            minHeight: 120,\n            textAlignVertical: 'top',\n            paddingTop: 12,\n          }}\n          containerClassName=\"mb-4\"\n        />\n\n        {/* Device Info Notice */}\n        <Text\n          variant=\"caption\"\n          color=\"muted\"\n          className=\"mb-6\"\n        >\n          Device info (OS, version, model) will be included automatically to help us debug.\n        </Text>\n      </View>\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/FocusDetailSheet.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":55,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":55,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'category' is defined but never used. Allowed unused args must match /^_/u.","line":96,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'color' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":98,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friend' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":238,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":238,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { StyleSheet, View, Text, ScrollView } from 'react-native';\nimport {\n    Calendar, Sparkles, CheckCircle2, Lightbulb,\n    AlertTriangle, RefreshCw, Zap, Heart, Clock, Star,\n    Gift, Briefcase, Home, GraduationCap, PartyPopper,\n    HeartCrack, Activity, Target, History, Egg\n} from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { AnimatedBottomSheet } from '@/shared/ui/Sheet';\nimport { ListItem } from '@/components/ui/ListItem';\nimport { Button } from '@/components/ui/Button';\nimport { Card } from '@/components/ui/Card';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport Interaction from '@/db/models/Interaction';\nimport { Suggestion } from '@/shared/types/common';\nimport FriendModel from '@/db/models/Friend';\nimport { format } from 'date-fns';\nimport { calculateWeeklySummary, generateContextualPrompts, selectBestPrompt, ContextualPrompt } from '@/modules/reflection';\nimport { getCategoryLabel } from '@/modules/interactions';\n\ninterface UpcomingDate {\n    friend: FriendModel;\n    type: 'birthday' | 'anniversary' | 'life_event';\n    daysUntil: number;\n    title?: string;\n    importance?: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface FocusDetailSheetProps {\n    isVisible: boolean;\n    onClose: () => void;\n    upcomingPlans: Interaction[];\n    completedPlans: Interaction[];\n    suggestions: Suggestion[];\n    upcomingDates: UpcomingDate[];\n    friends: FriendModel[];\n    onConfirmPlan: (id: string) => void;\n    onReschedulePlan: (plan: Interaction) => void;\n    onSuggestionAction: (suggestion: Suggestion) => void;\n}\n\nexport const FocusDetailSheet: React.FC<FocusDetailSheetProps> = ({\n    isVisible,\n    onClose,\n    upcomingPlans,\n    completedPlans,\n    suggestions,\n    upcomingDates,\n    friends,\n    onConfirmPlan,\n    onReschedulePlan,\n    onSuggestionAction,\n}) => {\n    const { tokens, typography, spacing, isDarkMode } = useTheme();\n    const [planFriendIds, setPlanFriendIds] = React.useState<Record<string, string[]>>({});\n    const [prompt, setPrompt] = React.useState<ContextualPrompt | null>(null);\n\n    React.useEffect(() => {\n        let isMounted = true;\n        const loadFriends = async () => {\n            const newMap: Record<string, string[]> = {};\n            const allPlans = [...upcomingPlans, ...completedPlans];\n            for (const plan of allPlans) {\n                try {\n                    const iFriends = await plan.interactionFriends.fetch();\n                    newMap[plan.id] = iFriends.map((f: any) => f.friendId);\n                } catch (e) {\n                    console.error('Error loading plan friends:', e);\n                }\n            }\n            if (isMounted) setPlanFriendIds(newMap);\n        };\n        loadFriends();\n        return () => { isMounted = false; };\n    }, [upcomingPlans, completedPlans]);\n\n    React.useEffect(() => {\n        let isMounted = true;\n        const loadPrompt = async () => {\n            try {\n                const summary = await calculateWeeklySummary();\n                const prompts = generateContextualPrompts(summary);\n                const bestPrompt = selectBestPrompt(prompts);\n                if (isMounted) setPrompt(bestPrompt);\n            } catch (error) {\n                console.error('Error loading reflection prompt:', error);\n            }\n        };\n        if (isVisible) {\n            loadPrompt();\n        }\n        return () => { isMounted = false; };\n    }, [isVisible]);\n\n    const renderSuggestionIcon = (iconName: string, category?: string) => {\n        const size = 20;\n        const color = tokens.primary;\n\n        switch (iconName) {\n            case 'AlertTriangle': return <AlertTriangle size={size} color={tokens.destructive} />;\n            case 'RefreshCw': return <RefreshCw size={size} color={tokens.primary} />;\n            case 'History': return <History size={size} color={tokens.warning} />; // High drift\n            case 'Zap': return <Zap size={size} color=\"#F59E0B\" />; // Amber for momentum\n            case 'Sparkles': return <Sparkles size={size} color=\"#8B5CF6\" />; // Purple for deepen\n            case 'Clock': return <Clock size={size} color={tokens.foregroundMuted} />;\n            case 'Heart': return <Heart size={size} color=\"#EC4899\" />; // Pink/Red\n            case 'Gift': return <Gift size={size} color=\"#EC4899\" />;\n            case 'Briefcase': return <Briefcase size={size} color={tokens.primary} />;\n            case 'Home': return <Home size={size} color={tokens.primary} />;\n            case 'GraduationCap': return <GraduationCap size={size} color={tokens.primary} />;\n            case 'PartyPopper': return <PartyPopper size={size} color=\"#F59E0B\" />;\n            case 'HeartCrack': return <HeartCrack size={size} color={tokens.foregroundMuted} />;\n            case 'Activity': return <Activity size={size} color={tokens.destructive} />;\n            case 'Target': return <Target size={size} color={tokens.primary} />;\n            case 'Egg': return <Egg size={size} color={tokens.primary} />;\n            case 'Star': return <Star size={size} color=\"#F59E0B\" />;\n            default: return <Sparkles size={size} color={tokens.primary} />;\n        }\n    };\n\n    return (\n        <AnimatedBottomSheet\n            visible={isVisible}\n            onClose={onClose}\n            height=\"full\"\n            scrollable\n            title=\"Today's Focus\"\n        >\n            <View>\n                {/* Reflection Prompt */}\n                {prompt && (\n                    <View style={[styles.promptContainer, { backgroundColor: tokens.primary + '10', borderColor: tokens.primary + '20' }]}>\n                        <View style={styles.promptHeader}>\n                            <Lightbulb size={16} color={tokens.primary} />\n                            <Text style={[styles.promptLabel, { color: tokens.primary, fontFamily: typography.fonts.sansSemiBold }]}>\n                                REFLECTION\n                            </Text>\n                        </View>\n                        <Text style={[styles.promptText, { color: tokens.foreground, fontFamily: typography.fonts.serif }]}>\n                            {prompt.prompt}\n                        </Text>\n                    </View>\n                )}\n\n                {/* Upcoming Plans Section */}\n                {upcomingPlans.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Upcoming\" icon={<Calendar size={20} color={tokens.primaryMuted} />} />\n                        <Card padding=\"none\">\n                            {upcomingPlans.map((plan, index) => {\n                                const friendIds = planFriendIds[plan.id] || [];\n                                const planFriends = friends.filter(f => friendIds.includes(f.id));\n                                const friendName = planFriends.length > 0 ? planFriends[0].name : '';\n                                const subtitle = `${friendName ? `with ${friendName} • ` : ''}${format(new Date(plan.interactionDate), 'h:mm a')}`;\n\n                                return (\n                                    <View key={plan.id} style={{ paddingHorizontal: 16 }}>\n                                        <ListItem\n                                            title={plan.title || `${getCategoryLabel(plan.interactionCategory ?? undefined)}${friendName ? ` with ${friendName}` : ''}`}\n                                            subtitle={subtitle}\n                                            showDivider={index < upcomingPlans.length - 1}\n                                            compact\n                                            trailing={\n                                                <View style={styles.actions}>\n                                                    <Button\n                                                        label=\"Reschedule\"\n                                                        size=\"small\"\n                                                        variant=\"secondary\"\n                                                        onPress={() => onReschedulePlan(plan)}\n                                                        style={compactButtonStyle}\n                                                    />\n                                                </View>\n                                            }\n                                        />\n                                    </View>\n                                );\n                            })}\n                        </Card>\n                    </View>\n                )}\n\n                {/* Completed Plans Section */}\n                {completedPlans.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Completed Today\" icon={<CheckCircle2 size={20} color={tokens.success} />} />\n                        <Card padding=\"none\">\n                            {completedPlans.map((plan, index) => {\n                                const friendIds = planFriendIds[plan.id] || [];\n                                const planFriends = friends.filter(f => friendIds.includes(f.id));\n                                const friendName = planFriends.length > 0 ? planFriends[0].name : '';\n                                const subtitle = `${friendName ? `with ${friendName} • ` : ''}${format(new Date(plan.interactionDate), 'h:mm a')}`;\n\n                                return (\n                                    <View key={plan.id} style={{ paddingHorizontal: 16 }}>\n                                        <ListItem\n                                            title={plan.title || `${getCategoryLabel(plan.interactionCategory ?? undefined)}${friendName ? ` with ${friendName}` : ''}`}\n                                            subtitle={subtitle}\n                                            showDivider={index < completedPlans.length - 1}\n                                            compact\n                                            trailing={\n                                                <View style={styles.actions}>\n                                                    {plan.reflectionJSON || plan.reflection ? (\n                                                        <View style={{ flexDirection: 'row', alignItems: 'center', opacity: 0.7 }}>\n                                                            <CheckCircle2 size={16} color={tokens.success} style={{ marginRight: 4 }} />\n                                                            <Text style={{\n                                                                color: tokens.success,\n                                                                fontFamily: typography.fonts.sansMedium,\n                                                                fontSize: 12\n                                                            }}>\n                                                                Reflected\n                                                            </Text>\n                                                        </View>\n                                                    ) : (\n                                                        <Button\n                                                            label=\"Deepen\"\n                                                            size=\"small\"\n                                                            onPress={() => onConfirmPlan(plan.id)}\n                                                            style={compactButtonStyle}\n                                                        />\n                                                    )}\n                                                </View>\n                                            }\n                                        />\n                                    </View>\n                                );\n                            })}\n                        </Card>\n                    </View>\n                )}\n\n                {/* Suggestions Section */}\n                {suggestions.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Suggestions\" icon={<Sparkles size={20} color={tokens.primaryMuted} />} />\n                        <Card padding=\"none\">\n                            {suggestions.map((suggestion, index) => {\n                                const friend = friends.find(f => f.id === suggestion.friendId);\n                                return (\n                                    <View key={suggestion.id} style={{ paddingHorizontal: 16 }}>\n                                        <ListItem\n                                            leading={renderSuggestionIcon(suggestion.icon, suggestion.category)}\n                                            title={suggestion.title}\n                                            subtitle={suggestion.subtitle}\n                                            showDivider={index < suggestions.length - 1}\n                                            compact\n                                            trailing={\n                                                <Button\n                                                    label={suggestion.actionLabel || \"View\"}\n                                                    variant=\"secondary\"\n                                                    size=\"small\"\n                                                    style={compactButtonStyle}\n                                                    onPress={() => onSuggestionAction(suggestion)}\n                                                />\n                                            }\n                                        />\n                                    </View>\n                                );\n                            })}\n                        </Card>\n                    </View>\n                )}\n\n                {/* Upcoming Events Section */}\n                {upcomingDates.length > 0 && (\n                    <View style={styles.section}>\n                        <WidgetHeader title=\"Upcoming\" icon={<Calendar size={20} color={tokens.primaryMuted} />} />\n                        <Card padding=\"none\">\n                            {upcomingDates.map((event, index) => (\n                                <View key={`${event.friend.id}-${event.type}`} style={{ paddingHorizontal: 16 }}>\n                                    <ListItem\n                                        title={event.friend.name}\n                                        subtitle={`${event.type === 'birthday' ? 'Birthday' : event.title} • ${event.daysUntil === 0 ? 'Today' : event.daysUntil === 1 ? 'Tomorrow' : `In ${event.daysUntil} days`}`}\n                                        showDivider={index < upcomingDates.length - 1}\n                                        compact\n                                    />\n                                </View>\n                            ))}\n                        </Card>\n                    </View>\n                )}\n\n                {upcomingPlans.length === 0 && completedPlans.length === 0 && suggestions.length === 0 && upcomingDates.length === 0 && (\n                    <View style={styles.emptyState}>\n                        <CheckCircle2 size={48} color={tokens.success} />\n                        <Text style={[styles.emptyTitle, { color: tokens.foreground, fontFamily: typography.fonts.serifBold }]}>\n                            All Caught Up\n                        </Text>\n                        <Text style={[styles.emptyText, { color: tokens.foregroundMuted, fontFamily: typography.fonts.sans }]}>\n                            You've handled everything for now. Enjoy your day!\n                        </Text>\n                    </View>\n                )}\n            </View>\n        </AnimatedBottomSheet>\n    );\n};\n\nconst styles = StyleSheet.create({\n    overlay: {\n        flex: 1,\n        justifyContent: 'flex-end',\n    },\n    sheet: {\n        borderTopLeftRadius: 24,\n        borderTopRightRadius: 24,\n        height: '85%',\n        paddingTop: 20,\n    },\n    header: {\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        paddingHorizontal: 20,\n        marginBottom: 20,\n    },\n    title: {\n        fontSize: 24,\n    },\n    closeButton: {\n        padding: 4,\n    },\n    content: {\n        paddingHorizontal: 20,\n        paddingBottom: 40,\n    },\n    section: {\n        marginBottom: 24,\n    },\n    actions: {\n        flexDirection: 'row',\n    },\n    emptyState: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingVertical: 60,\n        gap: 16,\n    },\n    emptyTitle: {\n        fontSize: 20,\n    },\n    emptyText: {\n        fontSize: 16,\n        textAlign: 'center',\n    },\n    promptContainer: {\n        padding: 16,\n        borderRadius: 16,\n        marginBottom: 24,\n        borderWidth: 1,\n    },\n    promptHeader: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        marginBottom: 8,\n        gap: 6,\n    },\n    promptLabel: {\n        fontSize: 12,\n        letterSpacing: 0.5,\n        textTransform: 'uppercase',\n    },\n    promptText: {\n        fontSize: 16,\n        lineHeight: 24,\n    },\n});\n\nconst compactButtonStyle = {\n    paddingVertical: 4,\n    paddingHorizontal: 10,\n    height: 32,\n    minWidth: 80, // Standardized width\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/FriendBadgePopup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getTierFitSummary' is defined but never used. Allowed unused vars must match /^_/u.","line":44,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SCREEN_WIDTH' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":47,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * FriendBadgePopup Component\n *\n * Enhanced popup showing comprehensive friend information:\n * - Archetype and personality\n * - Total weaves logged\n * - Birthday (if set)\n * - Favorite weave types (pattern recognition)\n * - Relationship badges earned\n *\n * Theme-aware and triggered by long-press on friend card\n */\n\nimport React, { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  Modal,\n  TouchableOpacity,\n  ScrollView,\n  Dimensions,\n  StyleSheet,\n} from 'react-native';\nimport { BlurView } from 'expo-blur';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withTiming,\n} from 'react-native-reanimated';\nimport { format } from 'date-fns';\nimport { database } from '@/db';\nimport FriendBadge from '@/db/models/FriendBadge';\nimport Friend from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\nimport { getBadgeById } from '@/modules/gamification';\nimport { analyzeInteractionPattern } from '@/modules/insights';\nimport { archetypeData } from '@/shared/constants/constants';\nimport { CATEGORY_METADATA } from '@/shared/constants/interaction-categories';\n\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport type { Archetype, InteractionCategory } from '@/components/types';\nimport Logger from '@/shared/utils/Logger';\nimport { analyzeTierFit, getTierFitSummary } from '@/modules/insights';\nimport type { TierFitAnalysis } from '@/modules/insights';\n\nconst { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');\n\ninterface FriendBadgePopupProps {\n  visible: boolean;\n  onClose: () => void;\n  friendId: string;\n  friendName: string;\n}\n\ninterface FriendStats {\n  archetype: Archetype;\n  totalWeaves: number;\n  birthday?: Date;\n  favoriteWeaveTypes: InteractionCategory[];\n  badgeCount: number;\n  badges: Array<{\n    id: string;\n    name: string;\n    description: string;\n    icon: string;\n    rarity: string;\n  }>;\n  tierFit?: TierFitAnalysis;\n}\n\nexport default function FriendBadgePopup({\n  visible,\n  onClose,\n  friendId,\n  friendName,\n}: FriendBadgePopupProps) {\n  const [stats, setStats] = useState<FriendStats | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [showBadges, setShowBadges] = useState(false);\n  const { colors, isDarkMode } = useTheme();\n\n  const translateY = useSharedValue(SCREEN_HEIGHT);\n  const opacity = useSharedValue(0);\n\n  useEffect(() => {\n    if (visible) {\n      loadFriendStats();\n      // Entrance animation\n      opacity.value = withTiming(1, { duration: 200 });\n      translateY.value = withSpring(0, {\n        damping: 30,\n        stiffness: 300,\n      });\n    } else {\n      // Exit animation\n      opacity.value = withTiming(0, { duration: 150 });\n      translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 });\n    }\n  }, [visible]);\n\n  async function loadFriendStats() {\n    setLoading(true);\n\n    try {\n      Logger.debug('[FriendBadgePopup] Loading stats for friend:', friendId);\n\n      // Load friend data\n      const friend = await database.get<Friend>('friends').find(friendId);\n      Logger.debug('[FriendBadgePopup] Friend loaded:', friend.name, friend.archetype);\n\n      // Load interactions for pattern analysis\n      const interactionFriends = await database\n        .get('interaction_friends')\n        .query(Q.where('friend_id', friendId))\n        .fetch();\n\n      Logger.debug('[FriendBadgePopup] InteractionFriends count:', interactionFriends.length);\n\n      const interactionIds = interactionFriends.map(\n        (if_: any) => if_.interactionId || if_.interaction_id || (if_._raw && if_._raw.interaction_id)\n      ).filter(Boolean);\n\n      Logger.debug('[FriendBadgePopup] Extracted interaction IDs:', interactionIds.length);\n\n      const interactions = await database\n        .get('interactions')\n        .query(Q.where('id', Q.oneOf(interactionIds)))\n        .fetch();\n\n      Logger.debug('[FriendBadgePopup] Interactions loaded:', interactions.length);\n\n      // Analyze pattern to get favorite weave types\n      const pattern = analyzeInteractionPattern(\n        interactions.map((i: any) => ({\n          id: i.id,\n          interactionDate: new Date(i.interactionDate),\n          status: i.status,\n          category: i.category,\n        }))\n      );\n\n      Logger.debug('[FriendBadgePopup] Pattern analyzed:', pattern.preferredCategories);\n\n      // Load badges with details\n      const badgeRecords = await database\n        .get<FriendBadge>('friend_badges')\n        .query(Q.where('friend_id', friendId), Q.sortBy('unlocked_at', Q.desc))\n        .fetch();\n\n      Logger.debug('[FriendBadgePopup] Badges count:', badgeRecords.length);\n\n      const badgesWithDetails = badgeRecords\n        .map(b => getBadgeById(b.badgeId))\n        .filter((b): b is NonNullable<typeof b> => b !== null)\n        .map(b => ({\n          id: b.id,\n          name: b.name,\n          description: b.description,\n          icon: b.icon,\n          rarity: b.rarity,\n        }));\n\n      const newStats = {\n        archetype: friend.archetype as Archetype,\n        // Use interactionFriends count as the source of truth for \"Total Weaves\"\n        // This is more robust as it represents the links, even if the interaction objects fetch has issues\n        totalWeaves: interactionFriends.length,\n        birthday: friend.birthday ? new Date(friend.birthday) : undefined,\n        favoriteWeaveTypes: pattern.preferredCategories,\n        badgeCount: badgeRecords.length,\n        badges: badgesWithDetails,\n        tierFit: await analyzeTierFit(friend),\n      };\n\n      Logger.debug('[FriendBadgePopup] Setting stats:', newStats);\n      setStats(newStats);\n    } catch (error) {\n      Logger.error('[FriendBadgePopup] Error loading friend stats:', error);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  const backdropStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n  }));\n\n  const containerStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const archetypeInfo = stats ? archetypeData[stats.archetype] : null;\n\n  const getRarityColor = (rarity: string) => {\n    switch (rarity) {\n      case 'common':\n        return '#10b981'; // emerald-500\n      case 'rare':\n        return '#3b82f6'; // blue-500\n      case 'epic':\n        return '#a855f7'; // purple-500\n      case 'legendary':\n        return '#f59e0b'; // amber-500\n      default:\n        return '#6b7280'; // gray-500\n    }\n  };\n\n  if (!visible) return null;\n\n  return (\n    <Modal visible={visible} transparent animationType=\"none\">\n      <View style={styles.modalContainer}>\n        {/* Backdrop */}\n        <Animated.View style={[styles.backdrop, backdropStyle]}>\n          <TouchableOpacity\n            style={StyleSheet.absoluteFill}\n            activeOpacity={1}\n            onPress={onClose}\n          />\n        </Animated.View>\n\n        {/* Content Card */}\n        <Animated.View style={[styles.contentContainer, containerStyle]}>\n          <BlurView\n            intensity={95}\n            tint={isDarkMode ? 'dark' : 'light'}\n            style={styles.blurContainer}\n          >\n            {/* Handle Bar */}\n            <View\n              style={[\n                styles.handleBar,\n                { backgroundColor: isDarkMode ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.2)' }\n              ]}\n            />\n\n            {/* Header */}\n            <View style={[styles.header, { borderBottomColor: colors.border }]}>\n              <View style={styles.headerTextContainer}>\n                <Text style={[styles.friendName, { color: colors.foreground }]}>\n                  {friendName}\n                </Text>\n                <Text style={[styles.subtitle, { color: colors['muted-foreground'] }]}>\n                  Friend Overview\n                </Text>\n              </View>\n            </View>\n\n            {/* Content */}\n            <ScrollView\n              style={styles.scrollView}\n              showsVerticalScrollIndicator={false}\n              bounces={true}\n            >\n              {(() => {\n                return null;\n              })()}\n              {loading ? (\n                <View style={styles.loadingContainer}>\n                  <Text style={[styles.loadingText, { color: colors['muted-foreground'] }]}>\n                    Loading...\n                  </Text>\n                </View>\n              ) : stats ? (\n                <>\n                  {/* Archetype Section */}\n                  {archetypeInfo && (\n                    <View style={styles.section}>\n                      <Text style={[styles.sectionTitle, { color: colors.foreground }]}>\n                        Archetype\n                      </Text>\n                      <View style={[styles.archetypeCard, { backgroundColor: colors.muted }]}>\n                        <Text style={styles.archetypeIcon}>{archetypeInfo.icon}</Text>\n                        <View style={styles.archetypeInfo}>\n                          <Text style={[styles.archetypeName, { color: colors.foreground }]}>\n                            {archetypeInfo.name}\n                          </Text>\n                          <Text style={[styles.archetypeEssence, { color: colors['muted-foreground'] }]}>\n                            {archetypeInfo.essence}\n                          </Text>\n                          <Text style={[styles.archetypeCare, { color: colors['muted-foreground'] }]}>\n                            {archetypeInfo.careStyle}\n                          </Text>\n                        </View>\n                      </View>\n                    </View>\n                  )}\n\n                  {/* Connection Health Section */}\n                  {stats.tierFit && stats.tierFit.fitCategory !== 'insufficient_data' && (\n                    <View style={styles.section}>\n                      <Text style={[styles.sectionTitle, { color: colors.foreground }]}>\n                        Connection Health\n                      </Text>\n                      <View style={[styles.healthCard, { backgroundColor: colors.muted }]}>\n                        <View style={styles.healthStatusRow}>\n                          <View style={[\n                            styles.healthDot,\n                            { backgroundColor: stats.tierFit.fitCategory === 'mismatch' ? '#F59E0B' : '#10B981' }\n                          ]} />\n                          <Text style={[styles.healthStatusText, { color: colors.foreground }]}>\n                            {stats.tierFit.fitCategory === 'mismatch' ? 'Needs Attention' : 'On Track'}\n                          </Text>\n                        </View>\n                        <Text style={[styles.healthDetails, { color: colors['muted-foreground'] }]}>\n                          Connecting every {Math.round(stats.tierFit.actualIntervalDays)} days\n                          {'\\n'}(Tier expects every {stats.tierFit.expectedIntervalDays} days)\n                        </Text>\n                      </View>\n                    </View>\n                  )}\n\n                  {/* Stats Grid */}\n                  <View style={styles.section}>\n                    <Text style={[styles.sectionTitle, { color: colors.foreground }]}>\n                      Quick Stats\n                    </Text>\n                    <View style={styles.statsGrid}>\n                      {/* Total Weaves */}\n                      <View style={[styles.statCard, { backgroundColor: colors.muted }]}>\n                        <Text style={styles.statIcon}>🧵</Text>\n                        <Text style={[styles.statValue, { color: colors.foreground }]}>\n                          {stats.totalWeaves}\n                        </Text>\n                        <Text style={[styles.statLabel, { color: colors['muted-foreground'] }]}>\n                          Weaves Logged\n                        </Text>\n                      </View>\n\n                      {/* Badges */}\n                      <TouchableOpacity\n                        style={[styles.statCard, { backgroundColor: colors.muted }]}\n                        onPress={() => setShowBadges(!showBadges)}\n                        activeOpacity={0.7}\n                      >\n                        <Text style={styles.statIcon}>🏆</Text>\n                        <Text style={[styles.statValue, { color: colors.foreground }]}>\n                          {stats.badgeCount}\n                        </Text>\n                        <Text style={[styles.statLabel, { color: colors['muted-foreground'] }]}>\n                          Badges Earned {stats.badgeCount > 0 ? '▼' : ''}\n                        </Text>\n                      </TouchableOpacity>\n\n                      {/* Birthday */}\n                      {stats.birthday && (\n                        <View style={[styles.statCard, { backgroundColor: colors.muted }]}>\n                          <Text style={styles.statIcon}>🎂</Text>\n                          <Text style={[styles.statValue, { color: colors.foreground }]}>\n                            {format(stats.birthday, 'MMM d')}\n                          </Text>\n                          <Text style={[styles.statLabel, { color: colors['muted-foreground'] }]}>\n                            Birthday\n                          </Text>\n                        </View>\n                      )}\n                    </View>\n                  </View>\n\n                  {/* Favorite Weave Types */}\n                  {stats.favoriteWeaveTypes.length > 0 && (\n                    <View style={styles.section}>\n                      <Text style={[styles.sectionTitle, { color: colors.foreground }]}>\n                        Favorite Connection Styles\n                      </Text>\n                      <View style={styles.favoritesList}>\n                        {stats.favoriteWeaveTypes.map((category) => {\n                          const metadata = CATEGORY_METADATA[category];\n                          return (\n                            <View\n                              key={category}\n                              style={[styles.favoriteCard, { backgroundColor: colors.muted }]}\n                            >\n                              <Text style={styles.favoriteIcon}>{metadata.icon}</Text>\n                              <View style={styles.favoriteInfo}>\n                                <Text style={[styles.favoriteLabel, { color: colors.foreground }]}>\n                                  {metadata.label}\n                                </Text>\n                                <Text style={[styles.favoriteDescription, { color: colors['muted-foreground'] }]}>\n                                  {metadata.description}\n                                </Text>\n                              </View>\n                            </View>\n                          );\n                        })}\n                      </View>\n                    </View>\n                  )}\n\n                  {/* Badges Section */}\n                  {showBadges && stats.badges.length > 0 && (\n                    <View style={styles.section}>\n                      <Text style={[styles.sectionTitle, { color: colors.foreground }]}>\n                        Relationship Badges\n                      </Text>\n                      <View style={styles.badgesList}>\n                        {stats.badges.map((badge) => {\n                          const rarityColor = getRarityColor(badge.rarity);\n                          return (\n                            <View\n                              key={badge.id}\n                              style={[styles.badgeCard, { backgroundColor: colors.muted }]}\n                            >\n                              <View\n                                style={[\n                                  styles.badgeIconContainer,\n                                  { borderColor: rarityColor },\n                                ]}\n                              >\n                                <Text style={styles.badgeIcon}>{badge.icon}</Text>\n                              </View>\n                              <View style={styles.badgeInfo}>\n                                <Text style={[styles.badgeName, { color: colors.foreground }]}>\n                                  {badge.name}\n                                </Text>\n                                <Text style={[styles.badgeDescription, { color: colors['muted-foreground'] }]}>\n                                  {badge.description}\n                                </Text>\n                                <Text\n                                  style={[\n                                    styles.badgeRarity,\n                                    { color: rarityColor },\n                                  ]}\n                                >\n                                  {badge.rarity.toUpperCase()}\n                                </Text>\n                              </View>\n                            </View>\n                          );\n                        })}\n                      </View>\n                    </View>\n                  )}\n\n                  {/* No weaves state */}\n                  {stats.totalWeaves === 0 && (\n                    <View style={styles.emptyState}>\n                      <Text style={styles.emptyEmoji}>🌱</Text>\n                      <Text style={[styles.emptyTitle, { color: colors.foreground }]}>\n                        Start Your Journey\n                      </Text>\n                      <Text style={[styles.emptyText, { color: colors['muted-foreground'] }]}>\n                        Log interactions with {friendName} to build your weave!\n                      </Text>\n                    </View>\n                  )}\n                </>\n              ) : null}\n            </ScrollView>\n\n            {/* Close Button */}\n            <TouchableOpacity\n              onPress={onClose}\n              style={[styles.closeButton, { backgroundColor: colors.primary }]}\n            >\n              <Text style={[styles.closeButtonText, { color: colors['primary-foreground'] }]}>\n                Close\n              </Text>\n            </TouchableOpacity>\n          </BlurView>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  modalContainer: {\n    flex: 1,\n    justifyContent: 'flex-end',\n  },\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n  },\n  contentContainer: {\n    height: SCREEN_HEIGHT * 0.75,\n    borderTopLeftRadius: 24,\n    borderTopRightRadius: 24,\n    overflow: 'hidden',\n  },\n  blurContainer: {\n    flex: 1,\n    borderTopLeftRadius: 24,\n    borderTopRightRadius: 24,\n    paddingBottom: 20,\n  },\n  handleBar: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n    alignSelf: 'center',\n    marginTop: 12,\n    marginBottom: 8,\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 24,\n    paddingVertical: 16,\n    borderBottomWidth: 1,\n  },\n  headerTextContainer: {\n    flex: 1,\n  },\n  friendName: {\n    fontSize: 24,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n  },\n  subtitle: {\n    fontSize: 14,\n    fontFamily: 'Inter_400Regular',\n    marginTop: 2,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  loadingContainer: {\n    padding: 40,\n    alignItems: 'center',\n  },\n  loadingText: {\n    fontSize: 14,\n    fontFamily: 'Inter_400Regular',\n  },\n  section: {\n    paddingHorizontal: 20,\n    paddingVertical: 12,\n  },\n  sectionTitle: {\n    fontSize: 16,\n    fontWeight: '700',\n    fontFamily: 'Inter_700Bold',\n    marginBottom: 12,\n  },\n  archetypeCard: {\n    flexDirection: 'row',\n    borderRadius: 16,\n    padding: 16,\n    gap: 12,\n  },\n  archetypeIcon: {\n    fontSize: 48,\n  },\n  archetypeInfo: {\n    flex: 1,\n    gap: 4,\n  },\n  archetypeName: {\n    fontSize: 18,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n  },\n  archetypeEssence: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n    fontStyle: 'italic',\n  },\n  archetypeCare: {\n    fontSize: 12,\n    fontFamily: 'Inter_400Regular',\n    marginTop: 2,\n  },\n  statsGrid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: 12,\n  },\n  statCard: {\n    flex: 1,\n    minWidth: '45%',\n    borderRadius: 16,\n    padding: 16,\n    alignItems: 'center',\n    gap: 6,\n  },\n  statIcon: {\n    fontSize: 32,\n  },\n  statValue: {\n    fontSize: 24,\n    fontWeight: '700',\n    fontFamily: 'Inter_700Bold',\n  },\n  statLabel: {\n    fontSize: 12,\n    fontFamily: 'Inter_400Regular',\n    textAlign: 'center',\n  },\n  favoritesList: {\n    gap: 10,\n  },\n  favoriteCard: {\n    flexDirection: 'row',\n    borderRadius: 12,\n    padding: 12,\n    gap: 12,\n    alignItems: 'center',\n  },\n  favoriteIcon: {\n    fontSize: 28,\n  },\n  favoriteInfo: {\n    flex: 1,\n    gap: 2,\n  },\n  favoriteLabel: {\n    fontSize: 15,\n    fontWeight: '600',\n    fontFamily: 'Inter_600SemiBold',\n  },\n  favoriteDescription: {\n    fontSize: 12,\n    fontFamily: 'Inter_400Regular',\n  },\n  emptyState: {\n    padding: 40,\n    alignItems: 'center',\n  },\n  emptyEmoji: {\n    fontSize: 64,\n    marginBottom: 16,\n  },\n  emptyTitle: {\n    fontSize: 18,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n    marginBottom: 8,\n  },\n  emptyText: {\n    fontSize: 14,\n    fontFamily: 'Inter_400Regular',\n    textAlign: 'center',\n  },\n  closeButton: {\n    marginHorizontal: 20,\n    marginTop: 12,\n    borderRadius: 12,\n    paddingVertical: 14,\n    alignItems: 'center',\n  },\n  closeButtonText: {\n    fontSize: 16,\n    fontWeight: '600',\n    fontFamily: 'Inter_600SemiBold',\n  },\n  badgesList: {\n    gap: 12,\n  },\n  badgeCard: {\n    flexDirection: 'row',\n    borderRadius: 16,\n    padding: 16,\n    gap: 12,\n  },\n  badgeIconContainer: {\n    width: 56,\n    height: 56,\n    borderRadius: 28,\n    borderWidth: 2,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  badgeIcon: {\n    fontSize: 28,\n  },\n  badgeInfo: {\n    flex: 1,\n    gap: 4,\n  },\n  badgeName: {\n    fontSize: 16,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n  },\n  badgeDescription: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n  },\n  badgeRarity: {\n    fontSize: 10,\n    fontWeight: '700',\n    fontFamily: 'Inter_700Bold',\n    letterSpacing: 0.5,\n  },\n  healthCard: {\n    borderRadius: 16,\n    padding: 16,\n    gap: 8,\n  },\n  healthStatusRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n  },\n  healthDot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n  healthStatusText: {\n    fontSize: 16,\n    fontWeight: '600',\n    fontFamily: 'Inter_600SemiBold',\n  },\n  healthDetails: {\n    fontSize: 14,\n    fontFamily: 'Inter_400Regular',\n    lineHeight: 20,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/FriendBadgeSection.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WEAVE_COUNT_BADGES' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DEPTH_BADGES' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CONSISTENCY_BADGES' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * FriendBadgeSection Component\n *\n * Displays relationship milestone badges on a friend's profile\n * Shows earned badges and progress toward next milestone\n */\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { View, Text, ScrollView, TouchableOpacity } from 'react-native';\nimport { database } from '@/db';\nimport FriendBadge from '@/db/models/FriendBadge';\nimport { Q } from '@nozbe/watermelondb';\nimport {\n  getBadgeById,\n  WEAVE_COUNT_BADGES,\n  DEPTH_BADGES,\n  CONSISTENCY_BADGES,\n  SPECIAL_BADGES,\n  type BadgeDefinition,\n} from '@/modules/gamification';\nimport { calculateFriendBadgeProgress, type BadgeProgress } from '@/modules/gamification';\nimport AchievementCard from './AchievementCard';\n\ninterface FriendBadgeSectionProps {\n  friendId: string;\n  friendName: string;\n}\n\nfunction FriendBadgeSectionComponent({ friendId, friendName }: FriendBadgeSectionProps) {\n  const [unlockedBadges, setUnlockedBadges] = useState<BadgeDefinition[]>([]);\n  const [progressData, setProgressData] = useState<BadgeProgress[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [expandedCategory, setExpandedCategory] = useState<string | null>(null);\n  const isMountedRef = useRef(true);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    let isCancelled = false;\n\n    // Set loading state immediately\n    setLoading(true);\n\n    async function loadBadgeData() {\n      try {\n        // Load unlocked badges\n        const badges = await database\n          .get<FriendBadge>('friend_badges')\n          .query(Q.where('friend_id', friendId), Q.sortBy('unlocked_at', Q.desc))\n          .fetch();\n\n        if (isCancelled || !isMountedRef.current) return;\n\n        const unlockedDefs = badges\n          .map(b => getBadgeById(b.badgeId))\n          .filter((b): b is BadgeDefinition => b !== null);\n\n        // Calculate progress\n        const progress = await calculateFriendBadgeProgress(friendId);\n\n        if (isCancelled || !isMountedRef.current) return;\n\n        setUnlockedBadges(unlockedDefs);\n        setProgressData(progress);\n        setLoading(false);\n      } catch (error) {\n        console.error('Error loading badge data:', error);\n        if (!isCancelled && isMountedRef.current) {\n          setLoading(false);\n        }\n      }\n    }\n\n    loadBadgeData();\n\n    return () => {\n      isCancelled = true;\n    };\n  }, [friendId]);\n\n  if (loading) {\n    return null;\n  }\n\n  const categoryLabels = {\n    weave_count: '🌱 Connection Milestones',\n    depth: '📚 Reflection Depth',\n    consistency: '🔥 Consistency Streak',\n    special: '✨ Special Moments',\n  };\n\n  return (\n    <View className=\"px-4 py-3\">\n      {/* Header */}\n      <View className=\"flex-row items-center justify-between mb-3\">\n        <Text className=\"text-white font-['Lora'] text-xl font-bold\">\n          Relationship Badges\n        </Text>\n        <View className=\"bg-emerald-500/20 px-3 py-1 rounded-full\">\n          <Text className=\"text-emerald-400 font-['Inter'] text-sm font-bold\">\n            {unlockedBadges.length} Earned\n          </Text>\n        </View>\n      </View>\n\n      {/* Summary Stats */}\n      <View className=\"flex-row gap-2 mb-4\">\n        {progressData.slice(0, 3).map((cat) => {\n          const emoji = categoryLabels[cat.categoryType as keyof typeof categoryLabels]?.split(' ')[0] || '🏆';\n          return (\n            <View\n              key={cat.categoryType}\n              className=\"flex-1 bg-gray-800/50 border border-gray-700 rounded-xl p-3\"\n            >\n              <Text className=\"text-2xl mb-1\">{emoji}</Text>\n              <Text className=\"text-white font-['Inter'] text-xs\">\n                Tier {cat.currentTier}\n              </Text>\n              {cat.nextBadge && (\n                <Text className=\"text-gray-400 font-['Inter'] text-xs\">\n                  {Math.round(cat.progressPercent)}% to next\n                </Text>\n              )}\n            </View>\n          );\n        })}\n      </View>\n\n      {/* Category Sections */}\n      {progressData.map((catProgress) => {\n        const categoryKey = catProgress.categoryType as keyof typeof categoryLabels;\n        const label = categoryLabels[categoryKey] || catProgress.categoryType;\n        const isExpanded = expandedCategory === catProgress.categoryType;\n\n        return (\n          <View key={catProgress.categoryType} className=\"mb-3\">\n            {/* Category Header */}\n            <TouchableOpacity\n              onPress={() =>\n                setExpandedCategory(isExpanded ? null : catProgress.categoryType)\n              }\n              className=\"flex-row items-center justify-between py-2 mb-2\"\n            >\n              <Text className=\"text-white font-['Inter'] text-base font-semibold\">\n                {label}\n              </Text>\n              <Text className=\"text-gray-400 font-['Inter'] text-sm\">\n                {isExpanded ? '▼' : '▶'}\n              </Text>\n            </TouchableOpacity>\n\n            {isExpanded && (\n              <View className=\"space-y-3\">\n                {/* Current Badge (if unlocked) */}\n                {catProgress.currentBadge && (\n                  <AchievementCard\n                    achievement={catProgress.currentBadge}\n                    unlocked={true}\n                    compact={true}\n                  />\n                )}\n\n                {/* Next Badge with Progress */}\n                {catProgress.nextBadge && (\n                  <AchievementCard\n                    achievement={catProgress.nextBadge}\n                    unlocked={false}\n                    showProgress={true}\n                    progress={catProgress.progress}\n                    progressPercent={catProgress.progressPercent}\n                    compact={true}\n                  />\n                )}\n\n                {/* Max Tier Reached */}\n                {!catProgress.nextBadge && catProgress.currentBadge && (\n                  <View className=\"bg-amber-950/30 border border-amber-700 rounded-xl p-3\">\n                    <Text className=\"text-amber-400 font-['Inter'] text-sm text-center\">\n                      🏆 Maximum tier reached!\n                    </Text>\n                  </View>\n                )}\n              </View>\n            )}\n          </View>\n        );\n      })}\n\n      {/* Special Badges Gallery */}\n      {unlockedBadges.filter(b => SPECIAL_BADGES.some(sb => sb.id === b.id)).length > 0 && (\n        <View className=\"mt-4\">\n          <Text className=\"text-white font-['Inter'] text-base font-semibold mb-2\">\n            ✨ Special Moments\n          </Text>\n          <ScrollView\n            horizontal\n            showsHorizontalScrollIndicator={false}\n            className=\"flex-row gap-3\"\n          >\n            {unlockedBadges\n              .filter(b => SPECIAL_BADGES.some(sb => sb.id === b.id))\n              .map((badge) => (\n                <View key={badge.id} className=\"w-40\">\n                  <AchievementCard achievement={badge} unlocked={true} compact={true} />\n                </View>\n              ))}\n          </ScrollView>\n        </View>\n      )}\n\n      {/* Empty State */}\n      {unlockedBadges.length === 0 && (\n        <View className=\"bg-gray-800/30 border border-gray-700 rounded-xl p-6 items-center\">\n          <Text className=\"text-4xl mb-3\">🌱</Text>\n          <Text className=\"text-white font-['Lora'] text-base font-semibold mb-1 text-center\">\n            Start Your Journey\n          </Text>\n          <Text className=\"text-gray-400 font-['Inter'] text-sm text-center\">\n            Log interactions with {friendName} to earn relationship badges!\n          </Text>\n        </View>\n      )}\n    </View>\n  );\n}\n\n// Memoize to prevent unnecessary re-renders\nexport default React.memo(FriendBadgeSectionComponent);\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/FriendManagementModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Trash2' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Users' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Alert, FlatList, TouchableOpacity } from 'react-native';\nimport { Trash2, Check, Users } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport { Card } from '@/shared/ui/Card';\nimport { useFriendActions } from '@/modules/relationships';\nimport { calculateCurrentScore } from '@/modules/intelligence';\nimport type FriendModel from '@/db/models/Friend';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\n\ninterface FriendManagementModalProps {\n  visible: boolean;\n  onClose: () => void;\n}\n\nexport function FriendManagementModal({ visible, onClose }: FriendManagementModalProps) {\n  const { colors } = useTheme();\n  const [friends, setFriends] = useState<FriendModel[]>([]);\n  const { batchDeleteFriends } = useFriendActions();\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [isDeleting, setIsDeleting] = useState(false);\n\n  useEffect(() => {\n    const subscription = database\n      .get<FriendModel>('friends')\n      .query(Q.sortBy('created_at', Q.desc))\n      .observe()\n      .subscribe(setFriends);\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  // Reset selection when modal closes\n  useEffect(() => {\n    if (!visible) {\n      setSelectedIds(new Set());\n    }\n  }, [visible]);\n\n  const toggleSelection = (id: string) => {\n    setSelectedIds(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(id)) {\n        newSet.delete(id);\n      } else {\n        newSet.add(id);\n      }\n      return newSet;\n    });\n  };\n\n  const selectAll = () => {\n    if (friends) {\n      setSelectedIds(new Set(friends.map(f => f.id)));\n    }\n  };\n\n  const deselectAll = () => {\n    setSelectedIds(new Set());\n  };\n\n  const handleDelete = () => {\n    if (selectedIds.size === 0) return;\n\n    Alert.alert(\n      'Delete Friends',\n      `Are you sure you want to delete ${selectedIds.size} friend${selectedIds.size > 1 ? 's' : ''}? This action cannot be undone.`,\n      [\n        {\n          text: 'Cancel',\n          style: 'cancel',\n        },\n        {\n          text: 'Delete',\n          style: 'destructive',\n          onPress: async () => {\n            setIsDeleting(true);\n            try {\n              await batchDeleteFriends(Array.from(selectedIds));\n              setSelectedIds(new Set());\n              onClose();\n            } catch (error) {\n              console.error('Error deleting friends:', error);\n              Alert.alert('Error', 'Failed to delete friends. Please try again.');\n            } finally {\n              setIsDeleting(false);\n            }\n          },\n        },\n      ]\n    );\n  };\n\n  const sortedFriends = friends ? [...friends].sort((a, b) => a.name.localeCompare(b.name)) : [];\n\n  const renderItem = ({ item: friend }: { item: FriendModel }) => {\n    const isSelected = selectedIds.has(friend.id);\n    const currentScore = calculateCurrentScore(friend);\n\n    return (\n      <TouchableOpacity\n        onPress={() => toggleSelection(friend.id)}\n        activeOpacity={0.7}\n      >\n        <Card\n          className={`flex-row items-center p-4 mb-2 border ${isSelected ? 'border-destructive/50 bg-destructive/5' : 'border-transparent'}`}\n        >\n          {/* Checkbox */}\n          <View\n            className={`w-6 h-6 rounded-md border items-center justify-center mr-3 ${isSelected ? 'bg-destructive border-destructive' : 'border-muted-foreground'}`}\n          >\n            {isSelected && <Check size={16} color={colors['destructive-foreground']} />}\n          </View>\n\n          {/* Friend Info */}\n          <View className=\"flex-1\">\n            <Text variant=\"body\" className=\"font-semibold\">\n              {friend.name}\n            </Text>\n            <Text variant=\"caption\" className=\"text-muted-foreground mt-0.5\">\n              {friend.dunbarTier} • Score: {Math.round(currentScore)}\n            </Text>\n          </View>\n        </Card>\n      </TouchableOpacity>\n    );\n  };\n\n  return (\n    <StandardBottomSheet\n      visible={visible}\n      onClose={onClose}\n      title=\"Manage Friends\"\n      snapPoints={['90%']}\n      disableContentPanning\n    >\n      <View className=\"flex-1 px-4\">\n        {/* Selection Controls */}\n        <View className=\"flex-row gap-3 mb-4\">\n          <Button\n            onPress={selectAll}\n            variant=\"secondary\"\n            className=\"flex-1\"\n            label=\"Select All\"\n          />\n          <Button\n            onPress={deselectAll}\n            variant=\"secondary\"\n            className=\"flex-1\"\n            label=\"Deselect All\"\n          />\n        </View>\n\n        {/* Friend List */}\n        <FlatList\n          data={sortedFriends}\n          keyExtractor={item => item.id}\n          renderItem={renderItem}\n          contentContainerStyle={{ paddingBottom: 120 }}\n          ListEmptyComponent={\n            <View className=\"items-center py-10\">\n              <Text variant=\"body\" className=\"text-muted-foreground text-center\">\n                No friends to manage\n              </Text>\n            </View>\n          }\n        />\n\n        {/* Footer */}\n        <View className=\"absolute bottom-0 left-0 right-0 p-4 border-t border-border bg-background\">\n          <Button\n            onPress={handleDelete}\n            variant=\"destructive\"\n            disabled={selectedIds.size === 0 || isDeleting}\n            className=\"w-full\"\n            label={isDeleting ? 'Deleting...' : `Delete ${selectedIds.size} Friend${selectedIds.size !== 1 ? 's' : ''}`}\n          />\n        </View>\n      </View>\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/FriendSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/GlobalModals.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/GlobalYearCalendar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CalendarIcon' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isSameDay' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAfter' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isBefore' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Animated' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeIn' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeOut' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'future' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":144,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo } from 'react';\nimport { View, Text, TouchableOpacity, ScrollView } from 'react-native';\nimport { ChevronLeft, ChevronRight, Calendar as CalendarIcon } from 'lucide-react-native';\nimport {\n  eachDayOfInterval,\n  endOfMonth,\n  endOfWeek,\n  startOfMonth,\n  startOfWeek,\n  format,\n  isToday,\n  isSameMonth,\n  isSameDay,\n  isAfter,\n  isBefore,\n  startOfDay,\n  isFuture,\n} from 'date-fns';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport Animated, { FadeIn, FadeOut } from 'react-native-reanimated';\n\ninterface Interaction {\n  id: string;\n  interactionDate: Date;\n  status: string;\n  title?: string;\n  activity?: string;\n  interactionCategory?: string;\n}\n\ninterface GlobalYearCalendarProps {\n  interactions: Interaction[];\n  onDateSelect: (date: Date, interactions: Interaction[]) => void;\n}\n\nexport function GlobalYearCalendar({ interactions, onDateSelect }: GlobalYearCalendarProps) {\n  const { colors } = useTheme();\n  const [currentMonth, setCurrentMonth] = useState(new Date());\n\n  const firstDayOfMonth = startOfMonth(currentMonth);\n  const lastDayOfMonth = endOfMonth(currentMonth);\n\n  const days = eachDayOfInterval({\n    start: startOfWeek(firstDayOfMonth),\n    end: endOfWeek(lastDayOfMonth),\n  });\n\n  // Group interactions by date for efficient lookup\n  const interactionsByDate = useMemo(() => {\n    const map = new Map<string, Interaction[]>();\n    interactions.forEach((interaction) => {\n      const dateKey = format(startOfDay(new Date(interaction.interactionDate)), 'yyyy-MM-dd');\n      if (!map.has(dateKey)) {\n        map.set(dateKey, []);\n      }\n      map.get(dateKey)!.push(interaction);\n    });\n    return map;\n  }, [interactions]);\n\n  // Get interaction counts and types for a date\n  const getDateInfo = (date: Date) => {\n    const dateKey = format(startOfDay(date), 'yyyy-MM-dd');\n    const dayInteractions = interactionsByDate.get(dateKey) || [];\n\n    const completed = dayInteractions.filter(i => i.status === 'completed').length;\n    const planned = dayInteractions.filter(i =>\n      i.status === 'planned' || i.status === 'pending_confirm'\n    ).length;\n\n    return { total: dayInteractions.length, completed, planned, interactions: dayInteractions };\n  };\n\n  const nextMonth = () => {\n    setCurrentMonth(new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 1));\n  };\n\n  const prevMonth = () => {\n    setCurrentMonth(new Date(currentMonth.getFullYear(), currentMonth.getMonth() - 1, 1));\n  };\n\n  const goToToday = () => {\n    setCurrentMonth(new Date());\n  };\n\n  return (\n    <View className=\"flex-1\">\n      {/* Header with Month/Year and Navigation */}\n      <View\n        className=\"flex-row justify-between items-center px-5 py-4 border-b\"\n        style={{ borderColor: colors.border }}\n      >\n        <TouchableOpacity\n          onPress={prevMonth}\n          className=\"p-2 rounded-full\"\n          style={{ backgroundColor: colors.muted }}\n        >\n          <ChevronLeft color={colors.foreground} size={20} />\n        </TouchableOpacity>\n\n        <TouchableOpacity\n          onPress={goToToday}\n          className=\"px-4 py-2 rounded-full\"\n          style={{ backgroundColor: colors.secondary }}\n        >\n          <Text\n            className=\"text-base font-semibold\"\n            style={{ color: colors.foreground, fontFamily: 'Lora_700Bold' }}\n          >\n            {format(currentMonth, 'MMMM yyyy')}\n          </Text>\n        </TouchableOpacity>\n\n        <TouchableOpacity\n          onPress={nextMonth}\n          className=\"p-2 rounded-full\"\n          style={{ backgroundColor: colors.muted }}\n        >\n          <ChevronRight color={colors.foreground} size={20} />\n        </TouchableOpacity>\n      </View>\n\n      <ScrollView className=\"flex-1\">\n        {/* Day headers */}\n        <View className=\"flex-row px-2 py-3 border-b\" style={{ borderColor: colors.border }}>\n          {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, idx) => (\n            <View key={`header-${idx}`} className=\"flex-1 items-center\">\n              <Text\n                className=\"text-xs font-medium\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n              >\n                {day}\n              </Text>\n            </View>\n          ))}\n        </View>\n\n        {/* Calendar grid */}\n        <View className=\"flex-row flex-wrap px-2 py-2\">\n          {days.map((day, idx) => {\n            const dateInfo = getDateInfo(day);\n            const today = isToday(day);\n            const inCurrentMonth = isSameMonth(day, currentMonth);\n            const future = isFuture(startOfDay(day));\n\n            return (\n              <TouchableOpacity\n                key={`day-${idx}`}\n                onPress={() => {\n                  if (dateInfo.total > 0) {\n                    onDateSelect(day, dateInfo.interactions);\n                  }\n                }}\n                disabled={dateInfo.total === 0}\n                className=\"items-center justify-center\"\n                style={{\n                  width: '14.28%',\n                  aspectRatio: 1,\n                  opacity: inCurrentMonth ? 1 : 0.4,\n                }}\n              >\n                {/* Day circle */}\n                <View\n                  className=\"items-center justify-center rounded-full\"\n                  style={{\n                    width: 40,\n                    height: 40,\n                    backgroundColor: today ? colors.secondary : 'transparent',\n                  }}\n                >\n                  <Text\n                    className=\"text-sm font-medium\"\n                    style={{\n                      color: today ? colors.primary : colors.foreground,\n                      fontFamily: 'Inter_500Medium',\n                    }}\n                  >\n                    {format(day, 'd')}\n                  </Text>\n                </View>\n\n                {/* Interaction indicators - thread dots */}\n                {dateInfo.total > 0 && (\n                  <View className=\"flex-row gap-1 absolute bottom-1\">\n                    {dateInfo.completed > 0 && (\n                      <View\n                        className=\"rounded-full\"\n                        style={{\n                          width: 5,\n                          height: 5,\n                          backgroundColor: colors['weave-vibrant'] || '#10b981',\n                        }}\n                      />\n                    )}\n                    {dateInfo.planned > 0 && (\n                      <View\n                        className=\"rounded-full\"\n                        style={{\n                          width: 5,\n                          height: 5,\n                          backgroundColor: colors.accent,\n                        }}\n                      />\n                    )}\n                  </View>\n                )}\n              </TouchableOpacity>\n            );\n          })}\n        </View>\n\n        {/* Legend */}\n        <View\n          className=\"mx-5 my-4 p-4 rounded-2xl\"\n          style={{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }}\n        >\n          <View className=\"flex-row items-center justify-center gap-6\">\n            <View className=\"flex-row items-center gap-2\">\n              <View\n                className=\"rounded-full\"\n                style={{\n                  width: 8,\n                  height: 8,\n                  backgroundColor: colors['weave-vibrant'] || '#10b981',\n                }}\n              />\n              <Text\n                className=\"text-xs\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n              >\n                Completed\n              </Text>\n            </View>\n            <View className=\"flex-row items-center gap-2\">\n              <View\n                className=\"rounded-full\"\n                style={{\n                  width: 8,\n                  height: 8,\n                  backgroundColor: colors.accent,\n                }}\n              />\n              <Text\n                className=\"text-xs\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n              >\n                Planned\n              </Text>\n            </View>\n          </View>\n        </View>\n\n        {/* Stats */}\n        <View className=\"px-5 pb-6\">\n          <View\n            className=\"p-4 rounded-2xl\"\n            style={{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }}\n          >\n            <Text\n              className=\"text-center text-lg font-bold mb-2\"\n              style={{ color: colors.foreground, fontFamily: 'Lora_700Bold' }}\n            >\n              {format(currentMonth, 'MMMM')} Overview\n            </Text>\n            <View className=\"flex-row justify-around mt-2\">\n              <View className=\"items-center\">\n                <Text\n                  className=\"text-2xl font-bold\"\n                  style={{ color: colors.primary, fontFamily: 'Lora_700Bold' }}\n                >\n                  {Array.from(interactionsByDate.values())\n                    .filter(ints => {\n                      const date = new Date(ints[0].interactionDate);\n                      return isSameMonth(date, currentMonth);\n                    })\n                    .reduce((sum, ints) => sum + ints.filter(i => i.status === 'completed').length, 0)}\n                </Text>\n                <Text\n                  className=\"text-xs\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                >\n                  Weaves Logged\n                </Text>\n              </View>\n              <View className=\"items-center\">\n                <Text\n                  className=\"text-2xl font-bold\"\n                  style={{ color: colors.accent, fontFamily: 'Lora_700Bold' }}\n                >\n                  {Array.from(interactionsByDate.values())\n                    .filter(ints => {\n                      const date = new Date(ints[0].interactionDate);\n                      return isSameMonth(date, currentMonth);\n                    })\n                    .reduce((sum, ints) => sum + ints.filter(i =>\n                      i.status === 'planned' || i.status === 'pending_confirm'\n                    ).length, 0)}\n                </Text>\n                <Text\n                  className=\"text-xs\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                >\n                  Plans Ahead\n                </Text>\n              </View>\n            </View>\n          </View>\n        </View>\n      </ScrollView>\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/InsightsFAB.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hasCritical' is defined but never used. Allowed unused args must match /^_/u.","line":15,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { TouchableOpacity, StyleSheet } from 'react-native';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport Animated, { useSharedValue, useAnimatedStyle, withRepeat, withTiming, Easing } from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { WeaveIcon } from './WeaveIcon';\n\ninterface InsightsFABProps {\n  isVisible: boolean;\n  hasSuggestions: boolean;\n  hasCritical: boolean;\n  onClick: () => void;\n}\n\nexport function InsightsFAB({ isVisible, hasSuggestions, hasCritical, onClick }: InsightsFABProps) {\n  const insets = useSafeAreaInsets();\n  const { colors, isDarkMode } = useTheme();\n  const pulseScale = useSharedValue(1);\n\n  // Gentle pulse animation\n  useEffect(() => {\n    if (hasSuggestions) {\n      pulseScale.value = withRepeat(\n        withTiming(1.08, { duration: 2000, easing: Easing.inOut(Easing.ease) }),\n        -1,\n        true\n      );\n    } else {\n      pulseScale.value = withTiming(1, { duration: 200 });\n    }\n  }, [hasSuggestions]);\n\n  const iconStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: pulseScale.value }],\n  }));\n\n  if (!isVisible) return null;\n\n  // Match the styling of the main + FAB\n  const fabStyle = {\n    ...styles.container,\n    bottom: insets.bottom + 24,\n    backgroundColor: isDarkMode ? colors.accent : colors.primary + '33',\n    shadowColor: isDarkMode ? colors.accent : '#000',\n  };\n\n  return (\n    <TouchableOpacity onPress={onClick} style={fabStyle}>\n      <Animated.View style={iconStyle}>\n        <WeaveIcon size={28} color={colors.foreground} />\n      </Animated.View>\n    </TouchableOpacity>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    width: 64,\n    height: 64,\n    borderRadius: 32,\n    shadowOffset: { width: 0, height: 6 },\n    shadowOpacity: 0.25,\n    shadowRadius: 8,\n    elevation: 12,\n    alignItems: 'center',\n    justifyContent: 'center',\n    zIndex: 50,\n    left: 24, // Opposite side from add friend FAB\n  },\n  icon: {\n    fontSize: 28,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/InsightsSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/IntentionActionSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/IntentionFormModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/IntentionsDrawer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { Modal, View, Text, TouchableOpacity, StyleSheet, ScrollView } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withTiming, withSpring, runOnJS } from 'react-native-reanimated';\nimport { BlurView } from 'expo-blur';\nimport { X } from 'lucide-react-native';\nimport { formatDistanceToNow } from 'date-fns';\nimport * as Haptics from 'expo-haptics';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { getCategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { Intention, InteractionCategory } from '@/components/types';\n\ninterface IntentionsDrawerProps {\n  intentions: Intention[];\n  isOpen: boolean;\n  onClose: () => void;\n  onIntentionPress: (intention: Intention) => void;\n}\n\nconst DRAWER_HEIGHT = 400;\n\n/**\n * Drawer that slides up from bottom showing all intentions for a friend\n * Displays intention description, category icon, and date created\n */\nexport function IntentionsDrawer({\n  intentions,\n  isOpen,\n  onClose,\n  onIntentionPress,\n}: IntentionsDrawerProps) {\n  const { colors, isDarkMode } = useTheme();\n  const backdropOpacity = useSharedValue(0);\n  const drawerTranslateY = useSharedValue(DRAWER_HEIGHT);\n\n  useEffect(() => {\n    if (isOpen) {\n      backdropOpacity.value = withTiming(1, { duration: 200 });\n      drawerTranslateY.value = withSpring(0, { damping: 50, stiffness: 400 });\n    }\n  }, [isOpen]);\n\n  const animateOut = (callback: () => void) => {\n    backdropOpacity.value = withTiming(0, { duration: 150 });\n    drawerTranslateY.value = withTiming(DRAWER_HEIGHT, { duration: 200 }, (finished) => {\n      if (finished) {\n        runOnJS(callback)();\n      }\n    });\n  };\n\n  const handleIntentionPress = (intention: Intention) => {\n    animateOut(() => {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n      onIntentionPress(intention);\n    });\n  };\n\n  const backdropStyle = useAnimatedStyle(() => ({\n    opacity: backdropOpacity.value,\n  }));\n\n  const drawerStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: drawerTranslateY.value }],\n  }));\n\n  if (!isOpen) return null;\n\n  return (\n    <Modal transparent visible={isOpen} onRequestClose={() => animateOut(onClose)}>\n      <View style={StyleSheet.absoluteFill}>\n        <TouchableOpacity\n          style={StyleSheet.absoluteFill}\n          activeOpacity={1}\n          onPress={() => animateOut(onClose)}\n        >\n          <Animated.View\n            style={[\n              StyleSheet.absoluteFill,\n              backdropStyle,\n              { backgroundColor: isDarkMode ? 'rgba(0, 0, 0, 0.6)' : 'rgba(0, 0, 0, 0.4)' }\n            ]}\n          >\n            <BlurView intensity={isDarkMode ? 20 : 10} tint={isDarkMode ? 'dark' : 'light'} style={StyleSheet.absoluteFill} />\n          </Animated.View>\n        </TouchableOpacity>\n\n        <Animated.View\n          style={[\n            styles.drawer,\n            { backgroundColor: colors.muted },\n            drawerStyle,\n          ]}\n        >\n          <View style={[styles.header, { borderBottomColor: colors.border }]}>\n            <View style={styles.headerContent}>\n              <Text style={styles.headerIcon}>💫</Text>\n              <Text style={[styles.title, { color: colors.foreground }]}>\n                Connection Intentions\n              </Text>\n            </View>\n            <TouchableOpacity onPress={() => animateOut(onClose)} style={styles.closeButton}>\n              <X color={colors['muted-foreground']} size={24} />\n            </TouchableOpacity>\n          </View>\n\n          <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>\n            {intentions.length === 0 ? (\n              <View style={styles.emptyContainer}>\n                <Text style={styles.emptyIcon}>✨</Text>\n                <Text style={[styles.emptyText, { color: colors['muted-foreground'] }]}>\n                  No intentions set yet\n                </Text>\n              </View>\n            ) : (\n              intentions.map((intention) => {\n                const category = intention.interactionCategory\n                  ? getCategoryMetadata(intention.interactionCategory as InteractionCategory)\n                  : null;\n                const timeAgo = formatDistanceToNow(intention.createdAt, { addSuffix: true });\n\n                return (\n                  <TouchableOpacity\n                    key={intention.id}\n                    style={[styles.intentionCard, { backgroundColor: colors.background, borderColor: colors.border }]}\n                    onPress={() => handleIntentionPress(intention)}\n                    activeOpacity={0.7}\n                  >\n                    <View style={styles.cardHeader}>\n                      {category && (\n                        <View style={[styles.categoryBadge, { backgroundColor: colors.muted }]}>\n                          <Text style={styles.categoryIcon}>{category.icon}</Text>\n                        </View>\n                      )}\n                      <Text style={[styles.timeAgo, { color: colors['muted-foreground'] }]}>\n                        {timeAgo}\n                      </Text>\n                    </View>\n\n                    {intention.description ? (\n                      <Text style={[styles.description, { color: colors.foreground }]}>\n                        {intention.description}\n                      </Text>\n                    ) : (\n                      <Text style={[styles.description, styles.descriptionPlaceholder, { color: colors['muted-foreground'] }]}>\n                        Connect soon\n                      </Text>\n                    )}\n                  </TouchableOpacity>\n                );\n              })\n            )}\n          </ScrollView>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  drawer: {\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    height: DRAWER_HEIGHT,\n    borderTopLeftRadius: 24,\n    borderTopRightRadius: 24,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: -4 },\n    shadowOpacity: 0.25,\n    shadowRadius: 16,\n    elevation: 16,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: 24,\n    paddingVertical: 20,\n    borderBottomWidth: 1,\n  },\n  headerContent: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 12,\n  },\n  headerIcon: {\n    fontSize: 28,\n  },\n  title: {\n    fontSize: 20,\n    fontWeight: '600',\n    fontFamily: 'Lora_700Bold',\n  },\n  closeButton: {\n    padding: 4,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  scrollContent: {\n    padding: 20,\n    gap: 12,\n  },\n  emptyContainer: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: 60,\n  },\n  emptyIcon: {\n    fontSize: 48,\n    marginBottom: 16,\n    opacity: 0.5,\n  },\n  emptyText: {\n    fontSize: 16,\n    textAlign: 'center',\n  },\n  intentionCard: {\n    padding: 16,\n    borderRadius: 12,\n    borderWidth: 1,\n    gap: 8,\n  },\n  cardHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  categoryBadge: {\n    paddingHorizontal: 10,\n    paddingVertical: 6,\n    borderRadius: 8,\n  },\n  categoryIcon: {\n    fontSize: 18,\n  },\n  timeAgo: {\n    fontSize: 13,\n    fontWeight: '500',\n  },\n  description: {\n    fontSize: 16,\n    lineHeight: 22,\n  },\n  descriptionPlaceholder: {\n    fontStyle: 'italic',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/IntentionsFAB.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/IntentionsList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/FriendshipArcView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/GuidedReflectionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":897,"column":89,"nodeType":null,"messageId":"unusedVar","endLine":897,"endColumn":90}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * GuidedReflectionModal\n * \n * Mode 2: Full guided reflection flow with context.\n * \n * Steps:\n * 1. Context Selection - What's this about? (recent weave, friend, or general)\n * 2. Prompt Selection - Contextual question with alternatives\n * 3. Writing - Rich editor with context panel\n * \n * Can be opened directly or from QuickCapture's \"Expand\" action.\n */\n\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport {\n  View,\n  Text,\n  TextInput,\n  TouchableOpacity,\n  ScrollView,\n  KeyboardAvoidingView,\n  Platform,\n  ActivityIndicator,\n  Modal,\n  StyleSheet,\n} from 'react-native';\nimport Animated, {\n  FadeInDown,\n  SlideInRight,\n  SlideOutLeft,\n  SlideInLeft,\n  SlideOutRight,\n} from 'react-native-reanimated';\nimport {\n  ChevronLeft,\n  ChevronRight,\n  Clock,\n  User,\n  MessageCircle,\n  Sparkles,\n  Coffee,\n  PanelRightOpen,\n  PanelRightClose,\n  X,\n} from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport JournalEntryFriend from '@/db/models/JournalEntryFriend';\nimport { Q } from '@nozbe/watermelondb';\nimport * as Haptics from 'expo-haptics';\n\nimport {\n  getRecentMeaningfulWeaves,\n  getFriendContext,\n  MeaningfulWeave,\n  FriendJournalContext,\n  generateJournalPrompts,\n  JournalPrompt,\n  PromptContext,\n} from '@/modules/journal';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ntype Step = 'context' | 'prompt' | 'write';\n\ninterface GuidedReflectionModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSave: (entry: SavedEntry) => void;\n  // Pre-filled from QuickCapture or WeaveLogger\n  prefilledText?: string;\n  prefilledFriendIds?: string[];\n  prefilledWeaveId?: string;\n}\n\ninterface SavedEntry {\n  id: string;\n  content: string;\n  friendIds: string[];\n  promptUsed?: string;\n}\n\ntype ContextSelection =\n  | { type: 'weave'; weave: MeaningfulWeave }\n  | { type: 'friend'; friendContext: FriendJournalContext }\n  | { type: 'general' };\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport function GuidedReflectionModal({\n  visible,\n  onClose,\n  onSave,\n  prefilledText,\n  prefilledFriendIds,\n  prefilledWeaveId,\n}: GuidedReflectionModalProps) {\n  const { colors } = useTheme();\n\n  // Navigation\n  const [step, setStep] = useState<Step>('context');\n  const [direction, setDirection] = useState<'forward' | 'back'>('forward');\n\n  // Data\n  const [meaningfulWeaves, setMeaningfulWeaves] = useState<MeaningfulWeave[]>([]);\n  const [friends, setFriends] = useState<FriendModel[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  // Selection state\n  const [selectedContext, setSelectedContext] = useState<ContextSelection | null>(null);\n  const [prompts, setPrompts] = useState<JournalPrompt[]>([]);\n  const [selectedPrompt, setSelectedPrompt] = useState<JournalPrompt | null>(null);\n\n  // Writing state\n  const [text, setText] = useState(prefilledText || '');\n  const [selectedFriendIds, setSelectedFriendIds] = useState<Set<string>>(\n    new Set(prefilledFriendIds || [])\n  );\n  const [showContextPanel, setShowContextPanel] = useState(true);\n  const [saving, setSaving] = useState(false);\n\n  // Refs\n  const textInputRef = useRef<TextInput>(null);\n\n  // ============================================================================\n  // DATA LOADING\n  // ============================================================================\n\n  useEffect(() => {\n    if (visible) {\n      loadData();\n    }\n  }, [visible]);\n\n  // Handle prefilled weave\n  useEffect(() => {\n    if (prefilledWeaveId && meaningfulWeaves.length > 0) {\n      const weave = meaningfulWeaves.find(w => w.interaction.id === prefilledWeaveId);\n      if (weave) {\n        // Skip context step, go straight to prompt\n        handleSelectWeave(weave);\n      }\n    }\n  }, [prefilledWeaveId, meaningfulWeaves]);\n\n  // Handle prefilled text (from QuickCapture expand)\n  useEffect(() => {\n    if (prefilledText) {\n      setText(prefilledText);\n    }\n  }, [prefilledText]);\n\n  // Handle prefilled friends (from Friend Profile)\n  useEffect(() => {\n    if (prefilledFriendIds && prefilledFriendIds.length > 0 && friends.length > 0) {\n      // If we have a single friend, try to set up the friend context\n      if (prefilledFriendIds.length === 1) {\n        const friendId = prefilledFriendIds[0];\n        const friend = friends.find(f => f.id === friendId);\n        if (friend) {\n          handleSelectFriend(friend);\n        }\n      } else {\n        // Multiple friends - just pre-select them for tagging\n        setSelectedFriendIds(new Set(prefilledFriendIds));\n      }\n    }\n  }, [prefilledFriendIds, friends]);\n\n  const loadData = async () => {\n    setLoading(true);\n    try {\n      const [weaves, allFriends] = await Promise.all([\n        getRecentMeaningfulWeaves(5, 72),  // Last 72 hours\n        database\n          .get<FriendModel>('friends')\n          .query(Q.where('is_dormant', false), Q.sortBy('name', Q.asc))\n          .fetch(),\n      ]);\n\n      setMeaningfulWeaves(weaves);\n      setFriends(allFriends);\n    } catch (error) {\n      console.error('[GuidedReflection] Error loading data:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // ============================================================================\n  // CONTEXT SELECTION HANDLERS\n  // ============================================================================\n\n  const handleSelectWeave = useCallback(async (weave: MeaningfulWeave) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n    const context: ContextSelection = { type: 'weave', weave };\n    setSelectedContext(context);\n\n    // Generate prompts for this context\n    const promptContext: PromptContext = { type: 'weave', weave };\n    const generatedPrompts = generateJournalPrompts(promptContext);\n    setPrompts(generatedPrompts);\n    setSelectedPrompt(generatedPrompts[0] || null);\n\n    // Pre-select friends from weave\n    setSelectedFriendIds(new Set(weave.friends.map(f => f.id)));\n\n    // Pre-fill text with weave notes if we don't have prefilled text\n    if (!prefilledText && weave.interaction.note) {\n      setText(weave.interaction.note + '\\n\\n');\n    }\n\n    // Go to prompt step\n    setDirection('forward');\n    setStep('prompt');\n  }, [prefilledText]);\n\n  const handleSelectFriend = useCallback(async (friend: FriendModel) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n    // Get friend context\n    const friendContext = await getFriendContext(friend.id);\n    if (!friendContext) return;\n\n    const context: ContextSelection = { type: 'friend', friendContext };\n    setSelectedContext(context);\n\n    // Generate prompts\n    const promptContext: PromptContext = { type: 'friend', friendContext };\n    const generatedPrompts = generateJournalPrompts(promptContext);\n    setPrompts(generatedPrompts);\n    setSelectedPrompt(generatedPrompts[0] || null);\n\n    // Pre-select this friend\n    setSelectedFriendIds(new Set([friend.id]));\n\n    // Go to prompt step\n    setDirection('forward');\n    setStep('prompt');\n  }, []);\n\n  const handleSelectGeneral = useCallback(() => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n    const context: ContextSelection = { type: 'general' };\n    setSelectedContext(context);\n\n    // Generate general prompts\n    const promptContext: PromptContext = { type: 'general' };\n    const generatedPrompts = generateJournalPrompts(promptContext);\n    setPrompts(generatedPrompts);\n    setSelectedPrompt(generatedPrompts[0] || null);\n\n    // Go to prompt step\n    setDirection('forward');\n    setStep('prompt');\n  }, []);\n\n  // ============================================================================\n  // NAVIGATION HANDLERS\n  // ============================================================================\n\n  const handleBack = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setDirection('back');\n\n    if (step === 'write') {\n      setStep('prompt');\n    } else if (step === 'prompt') {\n      setStep('context');\n      setSelectedContext(null);\n      setPrompts([]);\n      setSelectedPrompt(null);\n    }\n  };\n\n  const handleContinue = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setDirection('forward');\n\n    if (step === 'prompt') {\n      setStep('write');\n      // Focus text input after transition\n      setTimeout(() => textInputRef.current?.focus(), 300);\n    }\n  };\n\n  const handleSkipPrompt = () => {\n    setSelectedPrompt(null);\n    handleContinue();\n  };\n\n  // ============================================================================\n  // SAVE HANDLER\n  // ============================================================================\n\n  const handleSave = async () => {\n    if (!text.trim()) return;\n\n    setSaving(true);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n\n    try {\n      const savedEntry = await database.write(async () => {\n        const newEntry = await database.get<JournalEntry>('journal_entries').create((entry) => {\n          entry.content = text.trim();\n          entry.entryDate = Date.now();\n          // entry.friendTags = JSON.stringify(Array.from(selectedFriendIds)); // Removed as property does not exist\n          entry.title = generateTitle(text, selectedPrompt);\n          entry.isDraft = false;\n\n          // Store prompt context for future reference\n          if (selectedPrompt) {\n            entry.promptUsed = selectedPrompt.question;\n          }\n\n          // Link to weave if we have one\n          if (selectedContext?.type === 'weave') {\n            entry.linkedWeaveId = selectedContext.weave.interaction.id;\n          }\n        });\n\n        // Create friend links\n        if (newEntry && selectedFriendIds.size > 0) {\n          const friendsCollection = database.get<JournalEntryFriend>('journal_entry_friends');\n          for (const friendId of Array.from(selectedFriendIds)) {\n            await friendsCollection.create(link => {\n              link.journalEntryId = newEntry.id;\n              link.friendId = friendId;\n            });\n          }\n        }\n\n        return newEntry;\n      });\n\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n\n      if (savedEntry) {\n        onSave({\n          id: savedEntry.id,\n          content: savedEntry.content,\n          friendIds: Array.from(selectedFriendIds),\n          promptUsed: selectedPrompt?.question,\n        });\n      }\n\n      // Reset and close\n      resetState();\n      onClose();\n    } catch (error) {\n      console.error('[GuidedReflection] Error saving:', error);\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  const resetState = () => {\n    setStep('context');\n    setSelectedContext(null);\n    setPrompts([]);\n    setSelectedPrompt(null);\n    setText('');\n    setSelectedFriendIds(new Set());\n  };\n\n  const handleClose = () => {\n    resetState();\n    onClose();\n  };\n\n  // ============================================================================\n  // RENDER HELPERS\n  // ============================================================================\n\n  const generateTitle = (content: string, prompt: JournalPrompt | null): string => {\n    // Try to extract a meaningful title from content\n    const firstLine = content.split('\\n')[0].trim();\n    if (firstLine.length > 0 && firstLine.length <= 50) {\n      return firstLine;\n    }\n\n    // Fall back to prompt-based title\n    if (prompt?.relatedFriendName) {\n      return `Reflection on ${prompt.relatedFriendName}`;\n    }\n\n    // Default\n    const date = new Date().toLocaleDateString('en-GB', {\n      day: 'numeric',\n      month: 'short'\n    });\n    return `Reflection · ${date}`;\n  };\n\n  const formatTimeAgo = (date: Date): string => {\n    const hours = Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60));\n    if (hours < 1) return 'Just now';\n    if (hours < 24) return `${hours}h ago`;\n    const days = Math.floor(hours / 24);\n    return `${days}d ago`;\n  };\n\n  // ============================================================================\n  // STEP RENDERS\n  // ============================================================================\n\n  const renderContextStep = () => (\n    <Animated.View\n      key=\"context\"\n      entering={direction === 'forward' ? SlideInRight.duration(300) : SlideInLeft.duration(300)}\n      exiting={direction === 'forward' ? SlideOutLeft.duration(300) : SlideOutRight.duration(300)}\n      className=\"flex-1\"\n    >\n      <ScrollView className=\"flex-1 px-5\" showsVerticalScrollIndicator={false}>\n        <Text\n          className=\"text-xl mb-6 mt-4\"\n          style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n        >\n          What's on your mind?\n        </Text>\n\n        {/* Recent Meaningful Weaves */}\n        {meaningfulWeaves.length > 0 && (\n          <View className=\"mb-6\">\n            <Text\n              className=\"text-xs uppercase tracking-wide mb-3\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n            >\n              Recent Moments\n            </Text>\n\n            {meaningfulWeaves.map((weave) => (\n              <TouchableOpacity\n                key={weave.interaction.id}\n                onPress={() => handleSelectWeave(weave)}\n                className=\"mb-3 p-4 rounded-2xl\"\n                style={{\n                  backgroundColor: colors.card,\n                  borderWidth: 1,\n                  borderColor: colors.border,\n                }}\n                activeOpacity={0.7}\n              >\n                <View className=\"flex-row items-center gap-2 mb-2\">\n                  <Coffee size={16} color={colors.primary} />\n                  <Text\n                    className=\"text-sm flex-1\"\n                    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                  >\n                    {weave.interaction.activity || weave.interaction.interactionCategory || 'Connection'}\n                  </Text>\n                  <Text\n                    className=\"text-xs\"\n                    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                  >\n                    {formatTimeAgo(new Date(weave.interaction.interactionDate))}\n                  </Text>\n                </View>\n\n                {weave.friends.length > 0 && (\n                  <Text\n                    className=\"text-base mb-1\"\n                    style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                  >\n                    {weave.friends.map(f => f.name).join(' & ')}\n                  </Text>\n                )}\n\n                {weave.interaction.note && (\n                  <Text\n                    className=\"text-sm italic\"\n                    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                    numberOfLines={2}\n                  >\n                    \"{weave.interaction.note}\"\n                  </Text>\n                )}\n\n                <View className=\"flex-row items-center gap-1 mt-2\">\n                  {weave.meaningfulnessReasons.slice(0, 2).map((reason, i) => (\n                    <View\n                      key={i}\n                      className=\"px-2 py-1 rounded-full\"\n                      style={{ backgroundColor: colors.primary + '15' }}\n                    >\n                      <Text\n                        className=\"text-xs\"\n                        style={{ color: colors.primary, fontFamily: 'Inter_400Regular' }}\n                      >\n                        {reason}\n                      </Text>\n                    </View>\n                  ))}\n                </View>\n              </TouchableOpacity>\n            ))}\n          </View>\n        )}\n\n        {/* Friends */}\n        <View className=\"mb-6\">\n          <Text\n            className=\"text-xs uppercase tracking-wide mb-3\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n          >\n            A Friendship\n          </Text>\n\n          <ScrollView horizontal showsHorizontalScrollIndicator={false} className=\"-mx-5 px-5\">\n            <View className=\"flex-row gap-3\">\n              {friends.slice(0, 10).map((friend) => (\n                <TouchableOpacity\n                  key={friend.id}\n                  onPress={() => handleSelectFriend(friend)}\n                  className=\"items-center\"\n                  activeOpacity={0.7}\n                >\n                  <View\n                    className=\"w-14 h-14 rounded-full items-center justify-center mb-1.5\"\n                    style={{ backgroundColor: colors.muted }}\n                  >\n                    <Text\n                      className=\"text-lg\"\n                      style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n                    >\n                      {friend.name.charAt(0).toUpperCase()}\n                    </Text>\n                  </View>\n                  <Text\n                    className=\"text-xs text-center\"\n                    style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                    numberOfLines={1}\n                  >\n                    {friend.name.split(' ')[0]}\n                  </Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </ScrollView>\n        </View>\n\n        {/* General Reflection */}\n        <View className=\"mb-8\">\n          <Text\n            className=\"text-xs uppercase tracking-wide mb-3\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n          >\n            Something Else\n          </Text>\n\n          <TouchableOpacity\n            onPress={handleSelectGeneral}\n            className=\"p-4 rounded-2xl flex-row items-center gap-3\"\n            style={{\n              backgroundColor: colors.card,\n              borderWidth: 1,\n              borderColor: colors.border,\n            }}\n            activeOpacity={0.7}\n          >\n            <View\n              className=\"w-10 h-10 rounded-full items-center justify-center\"\n              style={{ backgroundColor: colors.primary + '15' }}\n            >\n              <MessageCircle size={20} color={colors.primary} />\n            </View>\n            <View className=\"flex-1\">\n              <Text\n                className=\"text-base\"\n                style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n              >\n                General reflection\n              </Text>\n              <Text\n                className=\"text-sm\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n              >\n                Write freely without a specific focus\n              </Text>\n            </View>\n            <ChevronRight size={20} color={colors['muted-foreground']} />\n          </TouchableOpacity>\n        </View>\n      </ScrollView>\n    </Animated.View>\n  );\n\n  const renderPromptStep = () => (\n    <Animated.View\n      key=\"prompt\"\n      entering={direction === 'forward' ? SlideInRight.duration(300) : SlideInLeft.duration(300)}\n      exiting={direction === 'forward' ? SlideOutLeft.duration(300) : SlideOutRight.duration(300)}\n      className=\"flex-1\"\n    >\n      <ScrollView className=\"flex-1 px-5\" showsVerticalScrollIndicator={false}>\n        {/* Context Card */}\n        {selectedContext && (\n          <Animated.View entering={FadeInDown.delay(100).duration(300)} className=\"mt-4 mb-6\">\n            {selectedContext.type === 'weave' && (\n              <View\n                className=\"p-4 rounded-2xl\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <View className=\"flex-row items-center gap-2 mb-2\">\n                  <Clock size={14} color={colors['muted-foreground']} />\n                  <Text\n                    className=\"text-xs\"\n                    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                  >\n                    {formatTimeAgo(new Date(selectedContext.weave.interaction.interactionDate))}\n                  </Text>\n                </View>\n                <Text\n                  className=\"text-sm\"\n                  style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                >\n                  {selectedContext.weave.interaction.activity || 'Connection'} with{' '}\n                  {selectedContext.weave.friends.map(f => f.name).join(' & ')}\n                </Text>\n                {selectedContext.weave.interaction.note && (\n                  <Text\n                    className=\"text-sm italic mt-1\"\n                    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                  >\n                    \"{selectedContext.weave.interaction.note}\"\n                  </Text>\n                )}\n              </View>\n            )}\n\n            {selectedContext.type === 'friend' && (\n              <View\n                className=\"p-4 rounded-2xl\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <View className=\"flex-row items-center gap-3\">\n                  <View\n                    className=\"w-12 h-12 rounded-full items-center justify-center\"\n                    style={{ backgroundColor: colors.card }}\n                  >\n                    <Text\n                      className=\"text-lg\"\n                      style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n                    >\n                      {selectedContext.friendContext.friend.name.charAt(0)}\n                    </Text>\n                  </View>\n                  <View className=\"flex-1\">\n                    <Text\n                      className=\"text-base\"\n                      style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n                    >\n                      {selectedContext.friendContext.friend.name}\n                    </Text>\n                    <Text\n                      className=\"text-sm\"\n                      style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                    >\n                      {selectedContext.friendContext.friendshipDuration} · {selectedContext.friendContext.totalWeaves} weaves\n                    </Text>\n                  </View>\n                </View>\n              </View>\n            )}\n          </Animated.View>\n        )}\n\n        {/* Prompts */}\n        <Text\n          className=\"text-xs uppercase tracking-wide mb-4\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n        >\n          Choose a prompt\n        </Text>\n\n        {prompts.map((prompt, index) => {\n          const isSelected = selectedPrompt?.id === prompt.id;\n\n          return (\n            <Animated.View\n              key={prompt.id}\n              entering={FadeInDown.delay(150 + index * 50).duration(300)}\n            >\n              <TouchableOpacity\n                onPress={() => {\n                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n                  setSelectedPrompt(prompt);\n                }}\n                className=\"mb-3 p-4 rounded-2xl\"\n                style={{\n                  backgroundColor: isSelected ? colors.primary + '15' : colors.card,\n                  borderWidth: isSelected ? 2 : 1,\n                  borderColor: isSelected ? colors.primary : colors.border,\n                }}\n                activeOpacity={0.7}\n              >\n                <View className=\"flex-row items-start gap-3\">\n                  <View\n                    className=\"w-6 h-6 rounded-full items-center justify-center mt-0.5\"\n                    style={{\n                      backgroundColor: isSelected ? colors.primary : colors.muted,\n                    }}\n                  >\n                    {isSelected && (\n                      <Text style={{ color: colors['primary-foreground'], fontSize: 12 }}>✓</Text>\n                    )}\n                  </View>\n                  <Text\n                    className=\"text-base flex-1 leading-6\"\n                    style={{\n                      color: isSelected ? colors.primary : colors.foreground,\n                      fontFamily: 'Lora_500Medium',\n                    }}\n                  >\n                    {prompt.question}\n                  </Text>\n                </View>\n\n                {prompt.suggestedStarters && isSelected && (\n                  <View className=\"mt-3 ml-9\">\n                    <Text\n                      className=\"text-xs mb-2\"\n                      style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                    >\n                      Start with:\n                    </Text>\n                    <View className=\"flex-row flex-wrap gap-2\">\n                      {prompt.suggestedStarters.slice(0, 2).map((starter, i) => (\n                        <View\n                          key={i}\n                          className=\"px-2.5 py-1.5 rounded-lg\"\n                          style={{ backgroundColor: colors.muted }}\n                        >\n                          <Text\n                            className=\"text-xs\"\n                            style={{ color: colors.foreground, fontFamily: 'Inter_400Regular' }}\n                          >\n                            {starter}\n                          </Text>\n                        </View>\n                      ))}\n                    </View>\n                  </View>\n                )}\n              </TouchableOpacity>\n            </Animated.View>\n          );\n        })}\n\n        {/* Skip option */}\n        <TouchableOpacity\n          onPress={handleSkipPrompt}\n          className=\"mt-2 mb-8 py-3 items-center\"\n          activeOpacity={0.7}\n        >\n          <Text\n            className=\"text-sm\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n          >\n            Or just start writing →\n          </Text>\n        </TouchableOpacity>\n      </ScrollView>\n\n      {/* Continue Button */}\n      <View className=\"px-5 pb-6\">\n        <TouchableOpacity\n          onPress={handleContinue}\n          className=\"py-4 rounded-2xl items-center flex-row justify-center gap-2\"\n          style={{ backgroundColor: colors.primary }}\n          activeOpacity={0.8}\n        >\n          <Text\n            className=\"text-base\"\n            style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n          >\n            {selectedPrompt ? 'Use this prompt' : 'Continue'}\n          </Text>\n          <ChevronRight size={18} color={colors['primary-foreground']} />\n        </TouchableOpacity>\n      </View>\n    </Animated.View>\n  );\n\n  const renderWriteStep = () => (\n    <Animated.View\n      key=\"write\"\n      entering={SlideInRight.duration(300)}\n      exiting={SlideOutLeft.duration(300)}\n      className=\"flex-1\"\n    >\n      <View\n        className=\"flex-1\"\n      >\n        <View className=\"flex-1 flex-row\">\n          {/* Main Writing Area */}\n          <View className=\"flex-1 px-5\">\n            {/* Prompt Display */}\n            {selectedPrompt && (\n              <Animated.View entering={FadeInDown.duration(300)} className=\"mt-4 mb-4\">\n                <View className=\"flex-row items-center gap-2 mb-2\">\n                  <Sparkles size={14} color={colors.primary} />\n                  <Text\n                    className=\"text-xs\"\n                    style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n                  >\n                    Your prompt\n                  </Text>\n                </View>\n                <Text\n                  className=\"text-lg leading-7\"\n                  style={{ color: colors.foreground, fontFamily: 'Lora_500Medium' }}\n                >\n                  {selectedPrompt.question}\n                </Text>\n              </Animated.View>\n            )}\n\n            {/* Text Input */}\n            <TextInput\n              ref={textInputRef}\n              value={text}\n              onChangeText={setText}\n              placeholder=\"Start writing...\"\n              placeholderTextColor={colors['muted-foreground']}\n              multiline\n              textAlignVertical=\"top\"\n              className=\"flex-1 text-base\"\n              style={{\n                color: colors.foreground,\n                fontFamily: 'Inter_400Regular',\n                paddingTop: 0,\n              }}\n            />\n\n            {/* Friend Tags */}\n            {selectedFriendIds.size > 0 && (\n              <View className=\"flex-row flex-wrap gap-2 pb-4\">\n                {Array.from(selectedFriendIds).map((id) => {\n                  const friend = friends.find(f => f.id === id);\n                  if (!friend) return null;\n\n                  return (\n                    <View\n                      key={id}\n                      className=\"flex-row items-center gap-1.5 px-3 py-1.5 rounded-full\"\n                      style={{ backgroundColor: colors.primary + '15' }}\n                    >\n                      <User size={12} color={colors.primary} />\n                      <Text\n                        className=\"text-xs\"\n                        style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n                      >\n                        {friend.name}\n                      </Text>\n                    </View>\n                  );\n                })}\n              </View>\n            )}\n          </View>\n\n          {/* Context Panel (collapsible) */}\n          {showContextPanel && selectedContext?.type === 'friend' && (\n            <Animated.View\n              entering={SlideInRight.duration(200)}\n              exiting={SlideOutRight.duration(200)}\n              className=\"w-64 border-l\"\n              style={{ borderColor: colors.border, backgroundColor: colors.muted + '50' }}\n            >\n              <ScrollView className=\"flex-1 p-4\" showsVerticalScrollIndicator={false}>\n                <Text\n                  className=\"text-xs uppercase tracking-wide mb-3\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n                >\n                  Context\n                </Text>\n\n                {/* Recent weaves with this friend */}\n                {selectedContext.friendContext.recentWeaves.length > 0 && (\n                  <View className=\"mb-4\">\n                    <Text\n                      className=\"text-xs mb-2\"\n                      style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n                    >\n                      Recent with {selectedContext.friendContext.friend.name}:\n                    </Text>\n                    {selectedContext.friendContext.recentWeaves.slice(0, 3).map((weave, i) => (\n                      <View key={weave.id} className=\"mb-2\">\n                        <Text\n                          className=\"text-xs\"\n                          style={{ color: colors.foreground, fontFamily: 'Inter_400Regular' }}\n                        >\n                          • {weave.activity}\n                        </Text>\n                        {weave.notes && (\n                          <Text\n                            className=\"text-xs italic ml-2\"\n                            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                            numberOfLines={1}\n                          >\n                            {weave.notes}\n                          </Text>\n                        )}\n                      </View>\n                    ))}\n                  </View>\n                )}\n\n                {/* Previous entries */}\n                {selectedContext.friendContext.recentEntries.length > 0 && (\n                  <View>\n                    <Text\n                      className=\"text-xs mb-2\"\n                      style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n                    >\n                      Previous entries:\n                    </Text>\n                    {selectedContext.friendContext.recentEntries.map((entry) => (\n                      <TouchableOpacity\n                        key={entry.id}\n                        className=\"mb-2 p-2 rounded-lg\"\n                        style={{ backgroundColor: colors.card }}\n                      >\n                        <Text\n                          className=\"text-xs\"\n                          style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                        >\n                          {entry.title}\n                        </Text>\n                        <Text\n                          className=\"text-xs italic\"\n                          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                          numberOfLines={2}\n                        >\n                          {entry.preview}\n                        </Text>\n                      </TouchableOpacity>\n                    ))}\n                  </View>\n                )}\n\n                {/* Themes */}\n                {selectedContext.friendContext.detectedThemes.length > 0 && (\n                  <View className=\"mt-4\">\n                    <Text\n                      className=\"text-xs mb-2\"\n                      style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n                    >\n                      Common themes:\n                    </Text>\n                    <View className=\"flex-row flex-wrap gap-1\">\n                      {selectedContext.friendContext.detectedThemes.map((theme, i) => (\n                        <View\n                          key={i}\n                          className=\"px-2 py-1 rounded-full\"\n                          style={{ backgroundColor: colors.primary + '15' }}\n                        >\n                          <Text\n                            className=\"text-xs\"\n                            style={{ color: colors.primary, fontFamily: 'Inter_400Regular' }}\n                          >\n                            {theme}\n                          </Text>\n                        </View>\n                      ))}\n                    </View>\n                  </View>\n                )}\n              </ScrollView>\n            </Animated.View>\n          )}\n        </View>\n\n        {/* Bottom Bar */}\n        <View\n          className=\"flex-row items-center justify-between px-5 py-4 border-t\"\n          style={{ borderColor: colors.border }}\n        >\n          {/* Toggle Context Panel (only show on tablet/larger screens or if friend context) */}\n          {selectedContext?.type === 'friend' && (\n            <TouchableOpacity\n              onPress={() => setShowContextPanel(!showContextPanel)}\n              className=\"flex-row items-center gap-2\"\n            >\n              {showContextPanel ? (\n                <PanelRightClose size={20} color={colors['muted-foreground']} />\n              ) : (\n                <PanelRightOpen size={20} color={colors['muted-foreground']} />\n              )}\n              <Text\n                className=\"text-sm\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n              >\n                {showContextPanel ? 'Hide context' : 'Show context'}\n              </Text>\n            </TouchableOpacity>\n          )}\n\n          <View className=\"flex-1\" />\n\n          {/* Save Button */}\n          <TouchableOpacity\n            onPress={handleSave}\n            disabled={!text.trim() || saving}\n            className=\"px-6 py-3 rounded-xl\"\n            style={{\n              backgroundColor: text.trim() ? colors.primary : colors.muted,\n              opacity: saving ? 0.7 : 1,\n            }}\n            activeOpacity={0.8}\n          >\n            <Text\n              className=\"text-base\"\n              style={{\n                color: text.trim() ? colors['primary-foreground'] : colors['muted-foreground'],\n                fontFamily: 'Inter_600SemiBold',\n              }}\n            >\n              {saving ? 'Saving...' : 'Save'}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </View>\n    </Animated.View>\n  );\n\n  // ============================================================================\n  // MAIN RENDER\n  // ============================================================================\n\n  if (!visible) return null;\n\n  const titleMap = {\n    context: 'New Reflection',\n    prompt: 'Choose a Prompt',\n    write: 'Write'\n  };\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"slide\"\n      onRequestClose={handleClose}\n      statusBarTranslucent\n    >\n      <KeyboardAvoidingView\n        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n        style={{ flex: 1 }}\n      >\n        {/* Backdrop */}\n        <TouchableOpacity\n          style={{\n            ...StyleSheet.absoluteFillObject,\n            backgroundColor: 'rgba(0,0,0,0.5)',\n          }}\n          activeOpacity={1}\n          onPress={handleClose}\n        />\n\n        {/* Sheet Container */}\n        <View className=\"flex-1 justify-end\">\n          <View\n            style={{\n              backgroundColor: colors.background,\n              borderTopLeftRadius: 24,\n              borderTopRightRadius: 24,\n              height: '92%', // Use significant height for guided flow\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: -4 },\n              shadowOpacity: 0.15,\n              shadowRadius: 12,\n              elevation: 10,\n              overflow: 'hidden',\n            }}\n          >\n            {/* Handle */}\n            <View\n              className=\"items-center pt-3 pb-2 z-10\"\n              style={{ backgroundColor: colors.background }}\n            >\n              <View\n                className=\"w-10 h-1 rounded-full\"\n                style={{ backgroundColor: colors.border }}\n              />\n            </View>\n\n            {/* Header */}\n            <View\n              className=\"flex-row items-center justify-between px-5 pb-3 z-10\"\n              style={{\n                backgroundColor: colors.background,\n                borderBottomColor: colors.border,\n                borderBottomWidth: 1,\n              }}\n            >\n              <View className=\"flex-1 flex-row items-center\">\n                {step !== 'context' && (\n                  <TouchableOpacity\n                    onPress={handleBack}\n                    className=\"mr-3\"\n                  >\n                    <ChevronLeft size={24} color={colors.foreground} />\n                  </TouchableOpacity>\n                )}\n                <Text\n                  className=\"text-lg\"\n                  style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n                >\n                  {titleMap[step]}\n                </Text>\n              </View>\n\n              <TouchableOpacity\n                onPress={handleClose}\n                className=\"w-8 h-8 items-center justify-center rounded-full\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <X size={18} color={colors['muted-foreground']} />\n              </TouchableOpacity>\n            </View>\n\n            {/* Progress Dots */}\n            <View\n              className=\"flex-row justify-center gap-2 py-3 z-10\"\n              style={{ backgroundColor: colors.background }}\n            >\n              {['context', 'prompt', 'write'].map((s, i) => (\n                <View\n                  key={s}\n                  className=\"w-2 h-2 rounded-full\"\n                  style={{\n                    backgroundColor:\n                      s === step\n                        ? colors.primary\n                        : ['context', 'prompt', 'write'].indexOf(step) > i\n                          ? colors.primary + '50'\n                          : colors.border,\n                  }}\n                />\n              ))}\n            </View>\n\n            {/* Content */}\n            <View\n              className=\"flex-1\"\n              style={{ backgroundColor: colors.background }}\n            >\n              {loading ? (\n                <View className=\"flex-1 items-center justify-center\">\n                  <ActivityIndicator size=\"large\" color={colors.primary} />\n                  <Text\n                    className=\"text-sm mt-4\"\n                    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                  >\n                    Loading...\n                  </Text>\n                </View>\n              ) : (\n                <>\n                  {step === 'context' && renderContextStep()}\n                  {step === 'prompt' && renderPromptStep()}\n                  {step === 'write' && renderWriteStep()}\n                </>\n              )}\n            </View>\n          </View>\n        </View>\n      </KeyboardAvoidingView>\n    </Modal>\n  );\n}\n\nexport default GuidedReflectionModal;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/JournalCalendarDay.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Heart' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, TouchableOpacity, Image } from 'react-native';\nimport { DateData } from 'react-native-calendars';\nimport { DayState } from 'react-native-calendars/src/types';\nimport { Sparkles, Gift, Heart } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\ninterface JournalCalendarDayProps {\n    date: DateData;\n    state: DayState;\n    marking?: any;\n    onPress: (date: DateData) => void;\n}\n\nexport function JournalCalendarDay({ date, state, marking, onPress }: JournalCalendarDayProps) {\n    const { colors } = useTheme();\n    const isSelected = marking?.selected;\n    const isToday = state === 'today';\n    const isDisabled = state === 'disabled';\n\n    // Metadata from marking\n    const friendAvatars = marking?.friendAvatars || [];\n    const isMilestone = marking?.isMilestone;\n    const isThrowback = marking?.isThrowback;\n    const hasEntry = marking?.marked;\n\n    const handlePress = () => {\n        onPress(date);\n    };\n\n    return (\n        <TouchableOpacity\n            onPress={handlePress}\n            className=\"w-full h-[54px] items-center justify-start pt-1\"\n            activeOpacity={0.7}\n        >\n            {/* Selection Circle */}\n            {isSelected && (\n                <View\n                    className=\"absolute top-0 w-8 h-8 rounded-full\"\n                    style={{ backgroundColor: colors.primary }}\n                />\n            )}\n\n            {/* Today Indicator (if not selected) */}\n            {isToday && !isSelected && (\n                <View\n                    className=\"absolute top-0 w-8 h-8 rounded-full border\"\n                    style={{ borderColor: colors.primary }}\n                />\n            )}\n\n            {/* Date Number */}\n            <Text\n                className=\"text-sm mb-0.5\"\n                style={{\n                    fontFamily: isSelected || isToday ? 'Inter_600SemiBold' : 'Inter_400Regular',\n                    color: isSelected\n                        ? colors['primary-foreground']\n                        : isDisabled\n                            ? colors.muted\n                            : isToday\n                                ? colors.primary\n                                : colors.foreground\n                }}\n            >\n                {date.day}\n            </Text>\n\n            {/* Markers Container */}\n            <View className=\"flex-row items-center justify-center h-4 w-full\">\n                {/* Milestone Icon */}\n                {isMilestone && (\n                    <View className=\"mr-1\">\n                        <Gift size={10} color={colors.primary} />\n                    </View>\n                )}\n\n                {/* Throwback Icon */}\n                {isThrowback && !isMilestone && (\n                    <View className=\"mr-1\">\n                        <Sparkles size={10} color=\"#F59E0B\" />\n                    </View>\n                )}\n\n                {/* Friend Avatars */}\n                {friendAvatars.length > 0 ? (\n                    <View className=\"flex-row\">\n                        {friendAvatars.slice(0, 3).map((url: string | null, index: number) => (\n                            <View\n                                key={index}\n                                className=\"w-3.5 h-3.5 rounded-full border border-white -ml-1 first:ml-0 overflow-hidden bg-gray-200 items-center justify-center\"\n                                style={{ borderColor: colors.card }}\n                            >\n                                {url ? (\n                                    <Image source={{ uri: url }} className=\"w-full h-full\" />\n                                ) : (\n                                    <View className=\"w-full h-full bg-indigo-100\" />\n                                )}\n                            </View>\n                        ))}\n                        {friendAvatars.length > 3 && (\n                            <View\n                                className=\"w-3.5 h-3.5 rounded-full border border-white -ml-1 bg-gray-100 items-center justify-center\"\n                                style={{ borderColor: colors.card }}\n                            >\n                                <Text style={{ fontSize: 6, color: colors.foreground }}>+</Text>\n                            </View>\n                        )}\n                    </View>\n                ) : hasEntry && !isSelected ? (\n                    // Simple dot if no avatars but has entry\n                    <View\n                        className=\"w-1 h-1 rounded-full\"\n                        style={{ backgroundColor: colors.primary }}\n                    />\n                ) : null}\n            </View>\n        </TouchableOpacity>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/JournalEntryModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/JournalHome.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FlatList' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RefreshControl' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MessageCircle' is defined but never used. Allowed unused vars must match /^_/u.","line":43,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'subYears' is defined but never used. Allowed unused vars must match /^_/u.","line":49,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isSameDay' is defined but never used. Allowed unused vars must match /^_/u.","line":49,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parseISO' is defined but never used. Allowed unused vars must match /^_/u.","line":49,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'refreshing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":108,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleRefresh' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":184,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":184,"endColumn":22},{"ruleId":"prefer-const","severity":2,"message":"'entryAvatars' is never reassigned. Use 'const' instead.","line":203,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":203,"endColumn":33,"fix":{"range":[5700,5732],"text":"const entryAvatars: string[] = [];"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FriendTags' is defined but never used. Allowed unused vars must match /^_/u.","line":956,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":956,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * JournalHome\n * \n * Redesigned journal browser with:\n * - Memory surfacing (anniversaries, patterns, throwbacks)\n * - Tab navigation: All | By Friend | Calendar\n * - Search capability\n * - Quick access to new entry flows\n * \n * This is the main entry point for the Journal feature.\n */\n\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport {\n  View,\n  Text,\n  TextInput,\n  TouchableOpacity,\n  ScrollView,\n  FlatList,\n  ActivityIndicator,\n  RefreshControl,\n  StyleSheet,\n} from 'react-native';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport Animated, {\n  FadeIn,\n  FadeInDown,\n  FadeInUp,\n  FadeOutDown,\n} from 'react-native-reanimated';\nimport {\n  Search,\n  Plus,\n  BookOpen,\n  Users,\n\n  Calendar as CalendarIcon,\n  Sparkles,\n  ChevronRight,\n  Clock,\n  Edit3,\n  MessageCircle,\n  Lightbulb,\n  X,\n  Gift,\n} from 'lucide-react-native';\nimport { Calendar as RNCalendar, DateData } from 'react-native-calendars';\nimport { format, subYears, isSameDay, parseISO } from 'date-fns';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport FriendModel from '@/db/models/Friend';\nimport {\n  getMemories,\n  getFriendsForBrowsing,\n  searchEntries,\n  type Memory,\n} from '@/modules/journal';\nimport { Q } from '@nozbe/watermelondb';\nimport * as Haptics from 'expo-haptics';\nimport { JournalCalendarDay } from './JournalCalendarDay';\n\n\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ntype Tab = 'all' | 'friend' | 'calendar';\n\ninterface JournalHomeProps {\n  onNewEntry: (mode: 'quick' | 'guided') => void;\n  onEntryPress: (entry: JournalEntry | WeeklyReflection) => void;\n  onFriendArcPress: (friendId: string) => void;\n  onMemoryAction: (memory: Memory) => void;\n  onClose?: () => void;\n}\n\ninterface FriendWithEntries {\n  friend: FriendModel;\n  entryCount: number;\n  lastEntryDate: Date | null;\n  recentActivityIndicator: 'high' | 'medium' | 'low';\n}\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport function JournalHome({\n  onNewEntry,\n  onEntryPress,\n  onFriendArcPress,\n  onMemoryAction,\n  onClose,\n}: JournalHomeProps) {\n  const { colors } = useTheme();\n  const insets = useSafeAreaInsets();\n\n  // State\n  const [activeTab, setActiveTab] = useState<Tab>('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [showSearch, setShowSearch] = useState(false);\n\n  const [loading, setLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n  const [selectedDate, setSelectedDate] = useState<string>(format(new Date(), 'yyyy-MM-dd'));\n  const [fabExpanded, setFabExpanded] = useState(false);\n\n\n\n  // Data\n  const [entries, setEntries] = useState<(JournalEntry | WeeklyReflection)[]>([]);\n  const [friendsWithEntries, setFriendsWithEntries] = useState<FriendWithEntries[]>([]);\n  const [allFriends, setAllFriends] = useState<Map<string, FriendModel>>(new Map());\n  const [memories, setMemories] = useState<Memory[]>([]);\n\n  // ============================================================================\n  // DATA LOADING\n  // ============================================================================\n\n  useEffect(() => {\n    loadData();\n  }, []);\n\n  const loadData = async () => {\n    setLoading(true);\n    try {\n      await Promise.all([\n        loadEntries(),\n        loadFriends(),\n        loadMemories(),\n      ]);\n    } catch (error) {\n      console.error('[JournalHome] Error loading data:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadEntries = async () => {\n    const [journalEntries, reflections] = await Promise.all([\n      database\n        .get<JournalEntry>('journal_entries')\n        .query(Q.sortBy('entry_date', Q.desc))\n        .fetch(),\n      database\n        .get<WeeklyReflection>('weekly_reflections')\n        .query(Q.sortBy('week_start_date', Q.desc), Q.take(20))\n        .fetch(),\n    ]);\n\n    // Combine and sort by date\n    const combined = [\n      ...journalEntries,\n      ...reflections,\n    ].sort((a, b) => {\n      const dateA = 'entryDate' in a ? a.entryDate : a.weekStartDate;\n      const dateB = 'entryDate' in b ? b.entryDate : b.weekStartDate;\n      return dateB - dateA;\n    });\n\n    setEntries(combined);\n  };\n\n  const loadFriends = async () => {\n    const friends = await getFriendsForBrowsing();\n    setFriendsWithEntries(friends);\n\n    // Also load all friends for calendar lookup\n    const all = await database.get<FriendModel>('friends').query().fetch();\n    const friendMap = new Map<string, FriendModel>();\n    all.forEach(f => friendMap.set(f.id, f));\n    setAllFriends(friendMap);\n  };\n\n  const loadMemories = async () => {\n    const surfacedMemories = await getMemories(3);\n    setMemories(surfacedMemories);\n  };\n\n  const handleRefresh = async () => {\n    setRefreshing(true);\n    await loadData();\n    setRefreshing(false);\n  };\n\n  // ============================================================================\n  // COMPUTED\n  // ============================================================================\n\n  const markedDates = useMemo(() => {\n    const marks: any = {};\n\n    entries.forEach(entry => {\n      const dateVal = 'entryDate' in entry ? entry.entryDate : entry.weekStartDate;\n      const date = new Date(dateVal);\n      const dateStr = format(date, 'yyyy-MM-dd');\n\n      // Get friend avatars for this entry\n      let entryAvatars: string[] = [];\n      // if ('friendTags' in entry && entry.friendTags) {\n      //   try {\n      //     const ids = JSON.parse(entry.friendTags || '[]');\n      //     entryAvatars = ids\n      //       .map((id: string) => allFriends.get(id)?.photoUrl)\n      //       .filter(Boolean);\n      //   } catch (e) { }\n      // }\n\n      // Merge with existing data for this date\n      const existing = marks[dateStr] || {};\n      const existingAvatars = existing.friendAvatars || [];\n\n      marks[dateStr] = {\n        marked: true,\n        friendAvatars: [...new Set([...existingAvatars, ...entryAvatars])],\n      };\n    });\n\n    // Add Milestones (Birthdays/Anniversaries) & Throwbacks\n    // We iterate through a reasonable range or just check all friends?\n    // For performance, let's just check the currently loaded entries for throwbacks\n    // And iterate all friends for milestones (but we need to know WHICH dates to mark)\n    // Actually, react-native-calendars expects a map of ALL marked dates.\n    // So we should iterate friends and mark their birthdays/anniversaries for the current year(s)\n\n    // 1. Milestones\n    const currentYear = new Date().getFullYear();\n    allFriends.forEach(friend => {\n      if (friend.birthday) {\n        // birthday format \"MM-DD\"\n        const [m, d] = friend.birthday.split('-');\n        if (m && d) {\n          // Mark for current year and maybe next/prev\n          const bdayStr = `${currentYear}-${m}-${d}`;\n          const existing = marks[bdayStr] || {};\n          const milestones = existing.milestones || [];\n\n          marks[bdayStr] = {\n            ...existing,\n            isMilestone: true,\n            milestones: [...milestones, { type: 'birthday', friend }]\n          };\n        }\n      }\n      if (friend.anniversary) {\n        const [m, d] = friend.anniversary.split('-');\n        if (m && d) {\n          const annStr = `${currentYear}-${m}-${d}`;\n          const existing = marks[annStr] || {};\n          const milestones = existing.milestones || [];\n\n          marks[annStr] = {\n            ...existing,\n            isMilestone: true,\n            milestones: [...milestones, { type: 'anniversary', friend }]\n          };\n        }\n      }\n    });\n\n    // 2. Throwbacks (entries from 1 year ago)\n    entries.forEach(entry => {\n      const dateVal = 'entryDate' in entry ? entry.entryDate : entry.weekStartDate;\n      const date = new Date(dateVal);\n      // Check if this entry is from ~1 year ago relative to NOW? \n      // Or do we mark the date 1 year later?\n      // \"This time last year\" means if I look at Today (2025), I see an entry from 2024.\n      // So we take the entry date, ADD 1 year, and mark THAT date.\n\n      const nextYearDate = new Date(date);\n      nextYearDate.setFullYear(date.getFullYear() + 1);\n      const nextYearStr = format(nextYearDate, 'yyyy-MM-dd');\n\n      marks[nextYearStr] = {\n        ...(marks[nextYearStr] || {}),\n        isThrowback: true,\n      };\n    });\n\n    // Mark selected date\n    if (selectedDate) {\n      marks[selectedDate] = {\n        ...(marks[selectedDate] || {}),\n        selected: true,\n      };\n    }\n\n    return marks;\n  }, [entries, selectedDate, allFriends]);\n\n  const selectedDateEntries = useMemo(() => {\n    return entries.filter(entry => {\n      const dateVal = 'entryDate' in entry ? entry.entryDate : entry.weekStartDate;\n      const dateStr = format(new Date(dateVal), 'yyyy-MM-dd');\n      return dateStr === selectedDate;\n    });\n  }, [entries, selectedDate]);\n\n  // ============================================================================\n  // SEARCH\n  // ============================================================================\n\n  const handleSearch = useCallback(async (query: string) => {\n    setSearchQuery(query);\n\n    if (query.trim().length < 2) {\n      await loadEntries();\n      return;\n    }\n\n    const results = await searchEntries(query, { type: 'all' });\n    setEntries(results);\n  }, []);\n\n  const clearSearch = () => {\n    setSearchQuery('');\n    setShowSearch(false);\n    loadEntries();\n  };\n\n  // ============================================================================\n  // RENDER HELPERS\n  // ============================================================================\n\n  const formatEntryDate = (date: Date): string => {\n    const now = new Date();\n    const entryDate = new Date(date);\n\n    // Same day\n    if (entryDate.toDateString() === now.toDateString()) {\n      return 'Today';\n    }\n\n    // Yesterday\n    const yesterday = new Date(now);\n    yesterday.setDate(yesterday.getDate() - 1);\n    if (entryDate.toDateString() === yesterday.toDateString()) {\n      return 'Yesterday';\n    }\n\n    // This week\n    const weekAgo = new Date(now);\n    weekAgo.setDate(weekAgo.getDate() - 7);\n    if (entryDate > weekAgo) {\n      return entryDate.toLocaleDateString('en-GB', { weekday: 'long' });\n    }\n\n    // Older\n    return entryDate.toLocaleDateString('en-GB', {\n      day: 'numeric',\n      month: 'short',\n      year: entryDate.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,\n    });\n  };\n\n  const getEntryPreview = (entry: JournalEntry | WeeklyReflection): string => {\n    if ('content' in entry) {\n      return (entry.content || '').slice(0, 100);\n    }\n    return (entry.gratitudeText || '').slice(0, 100);\n  };\n\n  const getEntryTitle = (entry: JournalEntry | WeeklyReflection): string => {\n    if ('title' in entry && entry.title) {\n      return entry.title;\n    }\n    if ('weekStartDate' in entry) {\n      return 'Weekly Reflection';\n    }\n    return 'Journal Entry';\n  };\n\n  const isWeeklyReflection = (entry: JournalEntry | WeeklyReflection): boolean => {\n    return 'weekStartDate' in entry;\n  };\n\n  const renderActivityIndicator = (level: 'high' | 'medium' | 'low') => {\n    const dots = level === 'high' ? 3 : level === 'medium' ? 2 : 1;\n    return (\n      <View className=\"flex-row gap-0.5\">\n        {[...Array(3)].map((_, i) => (\n          <View\n            key={i}\n            className=\"w-1.5 h-1.5 rounded-full\"\n            style={{\n              backgroundColor: i < dots ? colors.primary : colors.border,\n            }}\n          />\n        ))}\n      </View>\n    );\n  };\n\n  // ============================================================================\n  // SECTION RENDERS\n  // ============================================================================\n\n  const renderMemoryCard = () => {\n    if (memories.length === 0) return null;\n\n    const memory = memories[0];\n\n    return (\n      <Animated.View entering={FadeInDown.delay(100).duration(400)} className=\"px-5 mb-4\">\n        <TouchableOpacity\n          onPress={() => {\n            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n            onMemoryAction(memory);\n          }}\n          className=\"p-4 rounded-2xl\"\n          style={{\n            backgroundColor: colors.primary + '10',\n            borderWidth: 1,\n            borderColor: colors.primary + '30',\n          }}\n          activeOpacity={0.7}\n        >\n          <View className=\"flex-row items-center gap-2 mb-2\">\n            <Lightbulb size={16} color={colors.primary} />\n            <Text\n              className=\"text-xs uppercase tracking-wide\"\n              style={{ color: colors.primary, fontFamily: 'Inter_600SemiBold' }}\n            >\n              Memory\n            </Text>\n          </View>\n\n          <Text\n            className=\"text-base mb-2\"\n            style={{ color: colors.foreground, fontFamily: 'Lora_500Medium' }}\n          >\n            {memory.title}\n          </Text>\n\n          <Text\n            className=\"text-sm mb-3\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            {memory.description}\n          </Text>\n\n          <View className=\"flex-row items-center gap-1\">\n            <Text\n              className=\"text-sm\"\n              style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n            >\n              {memory.actionLabel}\n            </Text>\n            <ChevronRight size={16} color={colors.primary} />\n          </View>\n        </TouchableOpacity>\n      </Animated.View>\n    );\n  };\n\n  const renderEntryCard = (entry: JournalEntry | WeeklyReflection, index: number) => {\n    const date = 'entryDate' in entry\n      ? new Date(entry.entryDate)\n      : new Date(entry.weekStartDate);\n    const isReflection = isWeeklyReflection(entry);\n\n    return (\n      <Animated.View\n        key={entry.id}\n        entering={FadeInDown.delay(100 + index * 30).duration(300)}\n      >\n        <TouchableOpacity\n          onPress={() => {\n            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n            onEntryPress(entry);\n          }}\n          className=\"mx-5 mb-3 p-4 rounded-2xl\"\n          style={{\n            backgroundColor: colors.card,\n            borderWidth: 1,\n            borderColor: colors.border,\n          }}\n          activeOpacity={0.7}\n        >\n          {/* Header */}\n          <View className=\"flex-row items-center gap-2 mb-2\">\n            {isReflection ? (\n              <Clock size={14} color={colors.primary} />\n            ) : (\n              <Edit3 size={14} color={colors.primary} />\n            )}\n            <Text\n              className=\"text-xs flex-1\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            >\n              {formatEntryDate(date)}\n            </Text>\n            {isReflection && (\n              <View\n                className=\"px-2 py-0.5 rounded-full\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <Text\n                  className=\"text-xs\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                >\n                  Weekly\n                </Text>\n              </View>\n            )}\n          </View>\n\n          {/* Title */}\n          <Text\n            className=\"text-base mb-1\"\n            style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n          >\n            {getEntryTitle(entry)}\n          </Text>\n\n          {/* Preview */}\n          <Text\n            className=\"text-sm\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            numberOfLines={2}\n          >\n            {getEntryPreview(entry)}...\n          </Text>\n\n          {/* Friend Tags (for journal entries) */}\n          {/* {'friendTags' in entry && entry.friendTags && (\n            <FriendTags\n              friendIds={JSON.parse(entry.friendTags || '[]')}\n              colors={colors}\n            />\n          )} */}\n        </TouchableOpacity>\n      </Animated.View>\n    );\n  };\n\n  const renderTabs = () => (\n    <View className=\"flex-row px-5 mb-4 gap-2\">\n      {[\n        { id: 'all' as Tab, label: 'All', icon: BookOpen },\n        { id: 'friend' as Tab, label: 'By Friend', icon: Users },\n        { id: 'calendar' as Tab, label: 'Calendar', icon: CalendarIcon },\n      ].map((tab) => {\n        const isActive = activeTab === tab.id;\n        const IconComponent = tab.icon;\n\n        return (\n          <TouchableOpacity\n            key={tab.id}\n            onPress={() => {\n              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n              setActiveTab(tab.id);\n            }}\n            className=\"flex-row items-center gap-1.5 px-4 py-2 rounded-full\"\n            style={{\n              backgroundColor: isActive ? colors.primary : colors.muted,\n            }}\n            activeOpacity={0.7}\n          >\n            <IconComponent\n              size={16}\n              color={isActive ? colors['primary-foreground'] : colors['muted-foreground']}\n            />\n            <Text\n              className=\"text-sm\"\n              style={{\n                color: isActive ? colors['primary-foreground'] : colors['muted-foreground'],\n                fontFamily: 'Inter_500Medium',\n              }}\n            >\n              {tab.label}\n            </Text>\n          </TouchableOpacity>\n        );\n      })}\n    </View>\n  );\n\n  const renderAllTab = () => (\n    <View className=\"flex-1\">\n      {entries.length === 0 ? (\n        <View className=\"flex-1 items-center justify-center px-8 py-16\">\n          <BookOpen size={40} color={colors['muted-foreground']} />\n          <Text\n            className=\"text-lg mt-4 text-center\"\n            style={{ color: colors.foreground, fontFamily: 'Lora_500Medium' }}\n          >\n            No entries yet\n          </Text>\n          <Text\n            className=\"text-sm mt-2 text-center\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            Start documenting your friendships\n          </Text>\n        </View>\n      ) : (\n        <ScrollView showsVerticalScrollIndicator={false} className=\"flex-1\">\n          {entries.map((entry, index) => renderEntryCard(entry, index))}\n\n          {/* Bottom padding */}\n          <View className=\"h-24\" />\n        </ScrollView>\n      )}\n    </View>\n  );\n\n  const renderFriendTab = () => (\n    <ScrollView showsVerticalScrollIndicator={false} className=\"flex-1\">\n      <View className=\"px-5\">\n        {friendsWithEntries.length === 0 ? (\n          <View className=\"items-center justify-center py-16\">\n            <Users size={40} color={colors['muted-foreground']} />\n            <Text\n              className=\"text-lg mt-4 text-center\"\n              style={{ color: colors.foreground, fontFamily: 'Lora_500Medium' }}\n            >\n              No friendships documented yet\n            </Text>\n            <Text\n              className=\"text-sm mt-2 text-center\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            >\n              Tag friends in your entries to see them here\n            </Text>\n          </View>\n        ) : (\n          <>\n            <Text\n              className=\"text-xs uppercase tracking-wide mb-4\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n            >\n              Your Friendships\n            </Text>\n\n            {friendsWithEntries.map((item, index) => (\n              <Animated.View\n                key={item.friend.id}\n                entering={FadeInDown.delay(100 + index * 30).duration(300)}\n              >\n                <TouchableOpacity\n                  onPress={() => {\n                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n                    onFriendArcPress(item.friend.id);\n                  }}\n                  className=\"mb-3 p-4 rounded-2xl flex-row items-center\"\n                  style={{\n                    backgroundColor: colors.card,\n                    borderWidth: 1,\n                    borderColor: colors.border,\n                  }}\n                  activeOpacity={0.7}\n                >\n                  {/* Avatar */}\n                  <View\n                    className=\"w-12 h-12 rounded-full items-center justify-center mr-3\"\n                    style={{ backgroundColor: colors.muted }}\n                  >\n                    <Text\n                      className=\"text-lg\"\n                      style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n                    >\n                      {item.friend.name.charAt(0).toUpperCase()}\n                    </Text>\n                  </View>\n\n                  {/* Info */}\n                  <View className=\"flex-1\">\n                    <Text\n                      className=\"text-base\"\n                      style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                    >\n                      {item.friend.name}\n                    </Text>\n                    <View className=\"flex-row items-center gap-2 mt-0.5\">\n                      <Text\n                        className=\"text-sm\"\n                        style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                      >\n                        {item.entryCount} {item.entryCount === 1 ? 'entry' : 'entries'}\n                      </Text>\n                      {item.lastEntryDate && (\n                        <>\n                          <Text style={{ color: colors.border }}>·</Text>\n                          <Text\n                            className=\"text-sm\"\n                            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                          >\n                            Last: {formatEntryDate(item.lastEntryDate)}\n                          </Text>\n                        </>\n                      )}\n                    </View>\n                  </View>\n\n                  {/* Activity indicator */}\n                  <View className=\"items-center\">\n                    {renderActivityIndicator(item.recentActivityIndicator)}\n                  </View>\n\n                  <ChevronRight size={20} color={colors['muted-foreground']} className=\"ml-2\" />\n                </TouchableOpacity>\n              </Animated.View>\n            ))}\n          </>\n        )}\n      </View>\n\n      {/* Bottom padding */}\n      <View className=\"h-24\" />\n    </ScrollView>\n  );\n\n  const renderCalendarTab = () => {\n    const selectedMarking = markedDates[selectedDate];\n    const milestones = selectedMarking?.milestones || [];\n\n    return (\n      <ScrollView className=\"flex-1\" showsVerticalScrollIndicator={false}>\n        <View className=\"px-5 mb-4\">\n          <View\n            className=\"rounded-2xl overflow-hidden\"\n            style={{\n              borderWidth: 1,\n              borderColor: colors.border,\n              backgroundColor: colors.card\n            }}\n          >\n            <RNCalendar\n              current={selectedDate}\n              onDayPress={(day: DateData) => {\n                Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n                setSelectedDate(day.dateString);\n              }}\n              markedDates={markedDates}\n              theme={{\n                backgroundColor: colors.card,\n                calendarBackground: colors.card,\n                textSectionTitleColor: colors['muted-foreground'],\n                selectedDayBackgroundColor: colors.primary,\n                selectedDayTextColor: colors['primary-foreground'],\n                todayTextColor: colors.primary,\n                dayTextColor: colors.foreground,\n                textDisabledColor: colors.muted,\n                dotColor: colors.primary,\n                selectedDotColor: colors['primary-foreground'],\n                arrowColor: colors.primary,\n                monthTextColor: colors.foreground,\n                indicatorColor: colors.primary,\n                textDayFontFamily: 'Inter_400Regular',\n                textMonthFontFamily: 'Lora_500Medium',\n                textDayHeaderFontFamily: 'Inter_500Medium',\n              }}\n              dayComponent={(props: any) => {\n                if (!props.date) return <View />;\n                return (\n                  <JournalCalendarDay\n                    state={props.state}\n                    marking={props.marking}\n                    date={props.date as DateData}\n                    onPress={(date) => {\n                      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n                      setSelectedDate(date.dateString);\n                    }}\n                  />\n                );\n              }}\n            />\n          </View>\n        </View>\n\n        <View className=\"px-5 mb-2\">\n          <Text\n            className=\"text-sm font-medium\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n          >\n            {format(new Date(selectedDate), 'MMMM d, yyyy')}\n          </Text>\n        </View>\n\n        {/* Milestones Display */}\n        {milestones.length > 0 && (\n          <View className=\"px-5 mb-4\">\n            {milestones.map((m: any, i: number) => (\n              <Animated.View\n                key={i}\n                entering={FadeInDown.delay(100 + i * 50)}\n                className=\"flex-row items-center p-3 rounded-xl mb-2\"\n                style={{\n                  backgroundColor: colors.primary + '10',\n                  borderWidth: 1,\n                  borderColor: colors.primary + '20'\n                }}\n              >\n                <Gift size={16} color={colors.primary} />\n                <Text\n                  className=\"ml-2 text-sm font-medium\"\n                  style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                >\n                  {m.type === 'birthday' ? `${m.friend.name}'s Birthday` : `${m.friend.name}'s Anniversary`}\n                </Text>\n              </Animated.View>\n            ))}\n          </View>\n        )}\n\n        <View>\n          {selectedDateEntries.length === 0 && milestones.length === 0 ? (\n            <View className=\"items-center justify-center py-12\">\n              <Text\n                className=\"text-base text-center\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n              >\n                No entries for this day\n              </Text>\n            </View>\n          ) : (\n            selectedDateEntries.map((entry, index) => renderEntryCard(entry, index))\n          )}\n          <View className=\"h-24\" />\n        </View>\n      </ScrollView>\n    );\n  };\n\n  // ============================================================================\n  // MAIN RENDER\n  // ============================================================================\n\n  if (loading) {\n    return (\n      <View className=\"flex-1 items-center justify-center\" style={{ backgroundColor: colors.background }}>\n        <ActivityIndicator size=\"large\" color={colors.primary} />\n      </View>\n    );\n  }\n\n  return (\n    <View className=\"flex-1\" style={{ backgroundColor: colors.background }}>\n      {/* Header */}\n      <View className=\"px-5 pb-3\" style={{ paddingTop: insets.top + 16 }}>\n        <View className=\"flex-row items-center justify-between mb-4\">\n          <View className=\"flex-row items-center gap-2\">\n            {onClose && (\n              <TouchableOpacity onPress={onClose} className=\"mr-1\">\n                <ChevronRight size={28} color={colors.foreground} style={{ transform: [{ rotate: '180deg' }] }} />\n              </TouchableOpacity>\n            )}\n            <Text\n              className=\"text-2xl\"\n              style={{ color: colors.foreground, fontFamily: 'Lora_700Bold' }}\n            >\n              Journal\n            </Text>\n          </View>\n\n          <View className=\"flex-row items-center gap-2\">\n            <TouchableOpacity\n              onPress={() => setShowSearch(!showSearch)}\n              className=\"w-10 h-10 rounded-full items-center justify-center\"\n              style={{ backgroundColor: showSearch ? colors.primary + '20' : colors.muted }}\n            >\n              <Search size={20} color={showSearch ? colors.primary : colors['muted-foreground']} />\n            </TouchableOpacity>\n          </View>\n        </View>\n\n        {/* Search Bar */}\n        {showSearch && (\n          <Animated.View entering={FadeInUp.duration(200)} className=\"mb-4\">\n            <View\n              className=\"flex-row items-center px-4 py-3 rounded-xl\"\n              style={{ backgroundColor: colors.muted }}\n            >\n              <Search size={18} color={colors['muted-foreground']} />\n              <TextInput\n                value={searchQuery}\n                onChangeText={handleSearch}\n                placeholder=\"Search entries...\"\n                placeholderTextColor={colors['muted-foreground']}\n                className=\"flex-1 ml-3 text-base\"\n                style={{ color: colors.foreground, fontFamily: 'Inter_400Regular' }}\n                autoFocus\n              />\n              {searchQuery.length > 0 && (\n                <TouchableOpacity onPress={clearSearch}>\n                  <X size={18} color={colors['muted-foreground']} />\n                </TouchableOpacity>\n              )}\n            </View>\n          </Animated.View>\n        )}\n      </View>\n\n      {/* Memory Card */}\n      {!showSearch && renderMemoryCard()}\n\n      {/* Tabs */}\n      {!showSearch && renderTabs()}\n\n      {/* Content */}\n      {activeTab === 'all' && renderAllTab()}\n      {activeTab === 'friend' && renderFriendTab()}\n      {activeTab === 'calendar' && renderCalendarTab()}\n\n      {/* Backdrop for FAB */}\n      {fabExpanded && (\n        <TouchableOpacity\n          style={{\n            ...StyleSheet.absoluteFillObject,\n            backgroundColor: 'rgba(0,0,0,0.6)', // Darken background for focus\n            zIndex: 40,\n          }}\n          activeOpacity={1}\n          onPress={() => setFabExpanded(false)}\n        >\n          <Animated.View\n            entering={FadeIn.duration(200)}\n            style={StyleSheet.absoluteFill}\n          />\n        </TouchableOpacity>\n      )}\n\n      {/* Floating Action Button */}\n      <View className=\"absolute bottom-6 right-5 z-50\">\n        <NewEntryFAB\n          expanded={fabExpanded}\n          onToggle={() => {\n            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n            setFabExpanded(!fabExpanded);\n          }}\n          onPress={(mode) => {\n            setFabExpanded(false);\n            onNewEntry(mode);\n          }}\n          colors={colors}\n        />\n      </View>\n    </View>\n  );\n}\n\n// ============================================================================\n// SUB-COMPONENTS\n// ============================================================================\n\ninterface FriendTagsProps {\n  friendIds: string[];\n  colors: any;\n}\n\nfunction FriendTags({ friendIds, colors }: FriendTagsProps) {\n  const [friends, setFriends] = useState<FriendModel[]>([]);\n\n  useEffect(() => {\n    if (friendIds.length === 0) return;\n\n    database\n      .get<FriendModel>('friends')\n      .query(Q.where('id', Q.oneOf(friendIds)))\n      .fetch()\n      .then(setFriends);\n  }, [friendIds]);\n\n  if (friends.length === 0) return null;\n\n  return (\n    <View className=\"flex-row flex-wrap gap-1.5 mt-2\">\n      {friends.slice(0, 3).map((friend) => (\n        <View\n          key={friend.id}\n          className=\"flex-row items-center gap-1 px-2 py-1 rounded-full\"\n          style={{ backgroundColor: colors.primary + '15' }}\n        >\n          <Users size={10} color={colors.primary} />\n          <Text\n            className=\"text-xs\"\n            style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n          >\n            {friend.name}\n          </Text>\n        </View>\n      ))}\n      {friends.length > 3 && (\n        <View\n          className=\"px-2 py-1 rounded-full\"\n          style={{ backgroundColor: colors.muted }}\n        >\n          <Text\n            className=\"text-xs\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            +{friends.length - 3}\n          </Text>\n        </View>\n      )}\n    </View>\n  );\n}\n\ninterface NewEntryFABProps {\n  expanded: boolean;\n  onToggle: () => void;\n  onPress: (mode: 'quick' | 'guided') => void;\n  colors: any;\n}\n\nfunction NewEntryFAB({ expanded, onToggle, onPress, colors }: NewEntryFABProps) {\n  const handleQuick = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onPress('quick');\n  };\n\n  const handleGuided = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onPress('guided');\n  };\n\n  return (\n    <View className=\"items-end\">\n      {/* Expanded Options */}\n      {expanded && (\n        <View className=\"mb-4 gap-3\">\n          {/* Quick Capture (Top) */}\n          <Animated.View\n            entering={FadeInDown.springify().damping(15).delay(50)}\n            exiting={FadeOutDown.duration(150)}\n          >\n            <TouchableOpacity\n              onPress={handleQuick}\n              className=\"flex-row items-center justify-end gap-3\"\n              activeOpacity={0.9}\n            >\n              <View\n                className=\"px-4 py-2 rounded-xl\"\n                style={{ backgroundColor: colors.card }}\n              >\n                <Text\n                  className=\"text-sm font-medium\"\n                  style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                >\n                  Quick Note\n                </Text>\n              </View>\n              <View\n                className=\"w-12 h-12 rounded-full items-center justify-center\"\n                style={{\n                  backgroundColor: colors.card,\n                  shadowColor: '#000',\n                  shadowOffset: { width: 0, height: 2 },\n                  shadowOpacity: 0.1,\n                  shadowRadius: 4,\n                  elevation: 3,\n                }}\n              >\n                <Edit3 size={20} color={colors.primary} />\n              </View>\n            </TouchableOpacity>\n          </Animated.View>\n\n          {/* Guided Reflection (Bottom) */}\n          <Animated.View\n            entering={FadeInDown.springify().damping(15)}\n            exiting={FadeOutDown.duration(150)}\n          >\n            <TouchableOpacity\n              onPress={handleGuided}\n              className=\"flex-row items-center justify-end gap-3\"\n              activeOpacity={0.9}\n            >\n              <View\n                className=\"px-4 py-2 rounded-xl\"\n                style={{ backgroundColor: colors.card }}\n              >\n                <Text\n                  className=\"text-sm font-medium\"\n                  style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                >\n                  Guided Reflection\n                </Text>\n              </View>\n              <View\n                className=\"w-12 h-12 rounded-full items-center justify-center\"\n                style={{\n                  backgroundColor: colors.card,\n                  shadowColor: '#000',\n                  shadowOffset: { width: 0, height: 2 },\n                  shadowOpacity: 0.1,\n                  shadowRadius: 4,\n                  elevation: 3,\n                }}\n              >\n                <Sparkles size={20} color={colors.primary} />\n              </View>\n            </TouchableOpacity>\n          </Animated.View>\n        </View>\n      )}\n\n      {/* Main FAB */}\n      <TouchableOpacity\n        onPress={onToggle}\n        className=\"w-14 h-14 rounded-full items-center justify-center\"\n        style={{\n          backgroundColor: expanded ? colors.card : colors.primary, // Change color instead of rotating\n          shadowColor: '#000',\n          shadowOffset: { width: 0, height: 4 },\n          shadowOpacity: 0.2,\n          shadowRadius: 8,\n          elevation: 6,\n          // Removed rotation transform\n        }}\n        activeOpacity={0.9}\n      >\n        <Plus size={24} color={expanded ? colors.primary : colors['primary-foreground']} />\n      </TouchableOpacity>\n    </View>\n  );\n}\n\nexport default JournalHome;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/MemoryMomentModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SafeAreaView' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Dimensions' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ChevronRight' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * MemoryMomentModal\n * A dedicated, emotionally resonant modal for surfacing memories.\n */\n\nimport React from 'react';\nimport {\n    Modal,\n    View,\n    Text,\n    TouchableOpacity,\n    SafeAreaView,\n    Dimensions,\n} from 'react-native';\nimport Animated, {\n    FadeIn,\n    FadeInDown,\n} from 'react-native-reanimated';\nimport { Sparkles, X, ChevronRight, Calendar, User } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { format } from 'date-fns';\nimport * as Haptics from 'expo-haptics';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport { Memory } from '@/modules/journal';\nimport { trackEvent } from '@/shared/services/analytics.service';\n\ninterface MemoryMomentModalProps {\n    visible: boolean;\n    onClose: () => void;\n    memory: Memory | null;\n    entry?: JournalEntry | WeeklyReflection | null;\n    friendName?: string;\n    onReadEntry: () => void;\n    onWriteAbout: () => void;\n}\n\nexport function MemoryMomentModal({\n    visible,\n    onClose,\n    memory,\n    entry,\n    friendName,\n    onReadEntry,\n    onWriteAbout,\n}: MemoryMomentModalProps) {\n    const { colors } = useTheme();\n\n    React.useEffect(() => {\n        if (visible && memory) {\n            trackEvent('memory_moment_opened', { memoryId: memory.id, type: memory.type });\n        }\n    }, [visible, memory]);\n\n    if (!memory || !entry) return null;\n\n    const date = 'entryDate' in entry\n        ? new Date(entry.entryDate)\n        : new Date(entry.weekStartDate);\n\n    const formattedDate = format(date, 'MMMM d, yyyy');\n\n    const previewText = 'content' in entry\n        ? entry.content\n        : entry.gratitudeText || 'No text found.';\n\n    const handleClose = () => {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n        onClose();\n    };\n\n    const handleRead = () => {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n        trackEvent('memory_moment_action', { action: 'read', memoryId: memory.id });\n        onReadEntry();\n    };\n\n    const handleWrite = () => {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n        trackEvent('memory_moment_action', { action: 'write', memoryId: memory.id });\n        onWriteAbout();\n    };\n\n    return (\n        <Modal\n            visible={visible}\n            animationType=\"fade\"\n            transparent\n            onRequestClose={handleClose}\n        >\n            <View className=\"flex-1 justify-center items-center px-4\" style={{ backgroundColor: 'rgba(0,0,0,0.6)' }}>\n                <Animated.View\n                    entering={FadeInDown.springify().damping(15)}\n                    className=\"w-full rounded-3xl overflow-hidden\" // Removed max-w-sm to be responsive\n                    style={{ width: '100%', maxWidth: 380, backgroundColor: colors.background }} // Added width constraint manually\n                >\n                    {/* Header Image / Pattern Area */}\n                    <View\n                        className=\"h-32 w-full items-center justify-center relative\"\n                        style={{ backgroundColor: colors.primary + '15' }}\n                    >\n                        <View className=\"absolute top-4 right-4\">\n                            <TouchableOpacity onPress={handleClose} className=\"p-2 rounded-full bg-black/5\">\n                                <X size={20} color={colors.foreground} />\n                            </TouchableOpacity>\n                        </View>\n\n                        <Animated.View\n                            entering={FadeIn.delay(200)}\n                            className=\"items-center\"\n                        >\n                            <Sparkles size={40} color={colors.primary} />\n                            <Text\n                                className=\"text-sm font-semibold mt-2 uppercase tracking-widest\"\n                                style={{ color: colors.primary, fontFamily: 'Inter_600SemiBold' }}\n                            >\n                                On this day\n                            </Text>\n                        </Animated.View>\n                    </View>\n\n                    {/* Content Body */}\n                    <View className=\"p-6\">\n                        <Text\n                            className=\"text-2xl text-center mb-6\"\n                            style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n                        >\n                            {memory.title}\n                        </Text>\n\n                        {/* Entry Card */}\n                        <View\n                            className=\"p-5 rounded-xl mb-6\"\n                            style={{ backgroundColor: colors.muted }}\n                        >\n                            <View className=\"flex-row items-center mb-3 opacity-60\">\n                                <Calendar size={14} color={colors.foreground} />\n                                <Text\n                                    className=\"text-xs ml-1.5\"\n                                    style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                                >\n                                    {formattedDate}\n                                </Text>\n\n                                {friendName && (\n                                    <>\n                                        <Text className=\"mx-2\" style={{ color: colors.foreground }}>·</Text>\n                                        <User size={14} color={colors.foreground} />\n                                        <Text\n                                            className=\"text-xs ml-1.5\"\n                                            style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                                        >\n                                            {friendName}\n                                        </Text>\n                                    </>\n                                )}\n                            </View>\n\n                            <Text\n                                className=\"text-base leading-6 italic\"\n                                style={{ color: colors.foreground, fontFamily: 'Lora_400Regular_Italic' }}\n                                numberOfLines={4}\n                            >\n                                \"{previewText}\"\n                            </Text>\n                        </View>\n\n                        {/* Actions */}\n                        <View className=\"flex-row gap-3 mb-2\">\n                            <TouchableOpacity\n                                onPress={handleRead}\n                                className=\"flex-1 py-3.5 rounded-xl items-center flex-row justify-center\"\n                                style={{ backgroundColor: colors.muted }}\n                            >\n                                <Text\n                                    className=\"font-semibold mr-1\"\n                                    style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n                                >\n                                    Read entry\n                                </Text>\n                            </TouchableOpacity>\n\n                            <TouchableOpacity\n                                onPress={handleWrite}\n                                className=\"flex-1 py-3.5 rounded-xl items-center flex-row justify-center\"\n                                style={{ backgroundColor: colors.primary }}\n                            >\n                                <Text\n                                    className=\"font-semibold mr-1\"\n                                    style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n                                >\n                                    Write now\n                                </Text>\n                            </TouchableOpacity>\n                        </View>\n\n                        <TouchableOpacity\n                            onPress={handleClose}\n                            className=\"py-3 items-center mt-2\"\n                        >\n                            <Text\n                                className=\"text-sm opacity-50\"\n                                style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                            >\n                                Maybe later\n                            </Text>\n                        </TouchableOpacity>\n\n                    </View>\n                </Animated.View>\n            </View>\n        </Modal>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/QuickCaptureSheet.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeIn' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeOut' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'renderFooter' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":194,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * QuickCaptureSheet\n * \n * Mode 1: Minimal friction journal entry.\n * Just text + optional friend tag. No title, no date picker, no chips.\n * Saves as a draft/note that can be expanded later.\n * \n * Design philosophy: Get the thought down NOW. Polish later.\n */\n\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  TextInput,\n  TouchableOpacity,\n  Keyboard,\n  ScrollView,\n  Modal,\n  KeyboardAvoidingView,\n  Platform,\n  StyleSheet,\n} from 'react-native';\nimport Animated, {\n  FadeIn,\n  FadeOut,\n  SlideInDown,\n  SlideOutDown,\n} from 'react-native-reanimated';\nimport { X, User, ChevronRight, Sparkles } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport { Q } from '@nozbe/watermelondb';\nimport * as Haptics from 'expo-haptics';\nimport JournalEntryFriend from '@/db/models/JournalEntryFriend';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface QuickCaptureSheetProps {\n  visible: boolean;\n  onClose: () => void;\n  onExpandToFull: (text: string, friendIds: string[]) => void;\n  prefilledFriendId?: string;  // Pre-select a friend\n  prefilledText?: string;      // Pre-fill from weave notes\n}\n\ninterface FriendChip {\n  id: string;\n  name: string;\n}\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport function QuickCaptureSheet({\n  visible,\n  onClose,\n  onExpandToFull,\n  prefilledFriendId,\n  prefilledText,\n}: QuickCaptureSheetProps) {\n  const { colors } = useTheme();\n  const inputRef = useRef<TextInput>(null);\n\n  // State\n  const [text, setText] = useState(prefilledText || '');\n  const [selectedFriends, setSelectedFriends] = useState<FriendChip[]>([]);\n  const [showFriendPicker, setShowFriendPicker] = useState(false);\n  const [friends, setFriends] = useState<FriendModel[]>([]);\n  const [saving, setSaving] = useState(false);\n\n  // Load friends on mount\n  useEffect(() => {\n    loadFriends();\n  }, []);\n\n  // Handle prefilled friend\n  useEffect(() => {\n    if (prefilledFriendId && friends.length > 0) {\n      const friend = friends.find(f => f.id === prefilledFriendId);\n      if (friend && !selectedFriends.some(sf => sf.id === friend.id)) {\n        setSelectedFriends([{ id: friend.id, name: friend.name }]);\n      }\n    }\n  }, [prefilledFriendId, friends]);\n\n  // Handle prefilled text\n  useEffect(() => {\n    if (prefilledText) {\n      setText(prefilledText);\n    }\n  }, [prefilledText]);\n\n  // Focus input when sheet opens\n  useEffect(() => {\n    if (visible) {\n      // Small delay to allow sheet animation to start/finish\n      setTimeout(() => {\n        inputRef.current?.focus();\n      }, 500);\n    }\n  }, [visible]);\n\n  const loadFriends = async () => {\n    try {\n      const allFriends = await database\n        .get<FriendModel>('friends')\n        .query(\n          Q.where('is_dormant', false),\n          Q.sortBy('name', Q.asc)\n        )\n        .fetch();\n      setFriends(allFriends);\n    } catch (error) {\n      console.error('[QuickCapture] Error loading friends:', error);\n    }\n  };\n\n  const toggleFriend = useCallback((friend: FriendModel) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n\n    setSelectedFriends(prev => {\n      const exists = prev.some(f => f.id === friend.id);\n      if (exists) {\n        return prev.filter(f => f.id !== friend.id);\n      } else {\n        return [...prev, { id: friend.id, name: friend.name }];\n      }\n    });\n  }, []);\n\n  const handleSave = async () => {\n    if (!text.trim()) return;\n\n    setSaving(true);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n\n    try {\n      await database.write(async () => {\n        const newEntry = await database.get<JournalEntry>('journal_entries').create((entry) => {\n          entry.content = text.trim();\n          entry.entryDate = Date.now();\n          entry.title = '';\n          entry.isDraft = true;\n        });\n\n        // Link friends manually for M:N relation\n        if (selectedFriends.length > 0) {\n          for (const friendChip of selectedFriends) {\n            await database.get<JournalEntryFriend>('journal_entry_friends').create(link => {\n              link.journalEntry.set(newEntry);\n              link.friendId = friendChip.id;\n            });\n          }\n        }\n      });\n\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n\n      // Reset and close\n      setText('');\n      setSelectedFriends([]);\n      onClose();\n    } catch (error) {\n      console.error('[QuickCapture] Error saving:', error);\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  const handleExpandToFull = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onExpandToFull(text, selectedFriends.map(f => f.id));\n    setText('');\n    setSelectedFriends([]);\n  };\n\n  const handleClose = () => {\n    Keyboard.dismiss();\n    setText('');\n    setSelectedFriends([]);\n    onClose();\n  };\n\n  const hasContent = text.trim().length > 0;\n\n  // Footer component for StandardBottomSheet\n  const renderFooter = (\n    <View className=\"gap-4\">\n      <TouchableOpacity\n        onPress={handleSave}\n        disabled={!hasContent || saving}\n        className=\"py-4 rounded-2xl items-center\"\n        style={{\n          backgroundColor: hasContent ? colors.primary : colors.muted,\n          opacity: saving ? 0.7 : 1,\n        }}\n        activeOpacity={0.8}\n      >\n        <Text\n          className=\"text-base\"\n          style={{\n            color: hasContent ? colors['primary-foreground'] : colors['muted-foreground'],\n            fontFamily: 'Inter_600SemiBold',\n          }}\n        >\n          {saving ? 'Saving...' : 'Save note'}\n        </Text>\n      </TouchableOpacity>\n\n      {/* Expand to full */}\n      {hasContent && (\n        <TouchableOpacity\n          onPress={handleExpandToFull}\n          className=\"flex-row items-center justify-center gap-2\"\n        >\n          <Sparkles size={16} color={colors.primary} />\n          <Text\n            className=\"text-sm\"\n            style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n          >\n            Expand into full reflection\n          </Text>\n          <ChevronRight size={16} color={colors.primary} />\n        </TouchableOpacity>\n      )}\n    </View>\n  );\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"fade\"\n      onRequestClose={handleClose}\n      statusBarTranslucent\n    >\n      <KeyboardAvoidingView\n        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n        style={{ flex: 1 }}\n      >\n        {/* Backdrop */}\n        <TouchableOpacity\n          style={{\n            ...StyleSheet.absoluteFillObject,\n            backgroundColor: 'rgba(0,0,0,0.5)',\n          }}\n          activeOpacity={1}\n          onPress={handleClose}\n        />\n\n        {/* Content Container */}\n        <View className=\"flex-1 justify-end\">\n          <View\n            style={{\n              backgroundColor: colors.background,\n              borderTopLeftRadius: 24,\n              borderTopRightRadius: 24,\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: -4 },\n              shadowOpacity: 0.15,\n              shadowRadius: 12,\n              elevation: 10,\n              paddingBottom: 24, // Initial padding\n            }}\n          >\n            {/* Handle */}\n            <View className=\"items-center pt-3 pb-2\">\n              <View\n                className=\"w-10 h-1 rounded-full\"\n                style={{ backgroundColor: colors.border }}\n              />\n            </View>\n\n            {/* Header */}\n            <View className=\"flex-row items-center justify-between px-5 pb-3\">\n              <Text\n                className=\"text-lg\"\n                style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n              >\n                Quick Note\n              </Text>\n              <TouchableOpacity\n                onPress={handleClose}\n                className=\"w-8 h-8 items-center justify-center rounded-full\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <X size={18} color={colors['muted-foreground']} />\n              </TouchableOpacity>\n            </View>\n\n            {/* Content */}\n            <View className=\"px-5\">\n              <TextInput\n                ref={inputRef}\n                value={text}\n                onChangeText={setText}\n                placeholder=\"What happened?\"\n                placeholderTextColor={colors['muted-foreground']}\n                multiline\n                numberOfLines={4}\n                textAlignVertical=\"top\"\n                className=\"text-base\"\n                style={{\n                  color: colors.foreground,\n                  fontFamily: 'Inter_400Regular',\n                  minHeight: 100,\n                  maxHeight: 200,\n                }}\n              />\n\n              {/* Friend Selector */}\n              <View className=\"mt-4\">\n                <Text\n                  className=\"text-xs mb-2\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                >\n                  Who was involved? (optional)\n                </Text>\n\n                <View className=\"flex-row flex-wrap gap-2\">\n                  {selectedFriends.map((friend) => (\n                    <TouchableOpacity\n                      key={friend.id}\n                      onPress={() => {\n                        const fullFriend = friends.find(f => f.id === friend.id);\n                        if (fullFriend) toggleFriend(fullFriend);\n                      }}\n                      className=\"flex-row items-center gap-1.5 px-3 py-2 rounded-full\"\n                      style={{\n                        backgroundColor: colors.primary + '20',\n                        borderWidth: 1,\n                        borderColor: colors.primary,\n                      }}\n                    >\n                      <User size={14} color={colors.primary} />\n                      <Text\n                        className=\"text-sm\"\n                        style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n                      >\n                        {friend.name}\n                      </Text>\n                      <X size={12} color={colors.primary} />\n                    </TouchableOpacity>\n                  ))}\n\n                  <TouchableOpacity\n                    onPress={() => setShowFriendPicker(true)}\n                    className=\"flex-row items-center gap-1.5 px-3 py-2 rounded-full\"\n                    style={{\n                      backgroundColor: colors.muted,\n                      borderWidth: 1,\n                      borderColor: colors.border,\n                    }}\n                  >\n                    <User size={14} color={colors['muted-foreground']} />\n                    <Text\n                      className=\"text-sm\"\n                      style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n                    >\n                      {selectedFriends.length > 0 ? 'Add' : 'Tag friend'}\n                    </Text>\n                  </TouchableOpacity>\n                </View>\n              </View>\n            </View>\n\n            {/* Footer Actions */}\n            <View className=\"px-5 pt-6\">\n              <TouchableOpacity\n                onPress={handleSave}\n                disabled={!hasContent || saving}\n                className=\"py-4 rounded-2xl items-center\"\n                style={{\n                  backgroundColor: hasContent ? colors.primary : colors.muted,\n                  opacity: saving ? 0.7 : 1,\n                }}\n                activeOpacity={0.8}\n              >\n                <Text\n                  className=\"text-base\"\n                  style={{\n                    color: hasContent ? colors['primary-foreground'] : colors['muted-foreground'],\n                    fontFamily: 'Inter_600SemiBold',\n                  }}\n                >\n                  {saving ? 'Saving...' : 'Save note'}\n                </Text>\n              </TouchableOpacity>\n\n              {hasContent && (\n                <TouchableOpacity\n                  onPress={handleExpandToFull}\n                  className=\"flex-row items-center justify-center gap-2 mt-4\"\n                >\n                  <Sparkles size={16} color={colors.primary} />\n                  <Text\n                    className=\"text-sm\"\n                    style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n                  >\n                    Expand into full reflection\n                  </Text>\n                  <ChevronRight size={16} color={colors.primary} />\n                </TouchableOpacity>\n              )}\n            </View>\n          </View>\n        </View>\n      </KeyboardAvoidingView>\n\n      {/* Friend Picker Modal */}\n      <FriendPickerModal\n        visible={showFriendPicker}\n        onClose={() => setShowFriendPicker(false)}\n        friends={friends}\n        selectedFriendIds={selectedFriends.map(f => f.id)}\n        onToggleFriend={toggleFriend}\n        colors={colors}\n      />\n    </Modal>\n  );\n}\n\n// ============================================================================\n// FRIEND PICKER MODAL\n// ============================================================================\n\ninterface FriendPickerModalProps {\n  visible: boolean;\n  onClose: () => void;\n  friends: FriendModel[];\n  selectedFriendIds: string[];\n  onToggleFriend: (friend: FriendModel) => void;\n  colors: any;\n}\n\nfunction FriendPickerModal({\n  visible,\n  onClose,\n  friends,\n  selectedFriendIds,\n  onToggleFriend,\n  colors,\n}: FriendPickerModalProps) {\n  const [search, setSearch] = useState('');\n\n  const filteredFriends = search\n    ? friends.filter(f => f.name.toLowerCase().includes(search.toLowerCase()))\n    : friends;\n\n  if (!visible) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"fade\"\n      onRequestClose={onClose}\n    >\n      <View className=\"flex-1 justify-end bg-black/50\">\n        <TouchableOpacity className=\"flex-1\" onPress={onClose} activeOpacity={1} />\n\n        <Animated.View\n          entering={SlideInDown.springify().damping(20)}\n          exiting={SlideOutDown.springify().damping(20)}\n          className=\"rounded-t-3xl\"\n          style={{\n            backgroundColor: colors.background,\n            maxHeight: '70%',\n          }}\n        >\n          {/* Header */}\n          <View className=\"flex-row items-center justify-between px-5 py-4 border-b\" style={{ borderColor: colors.border }}>\n            <Text\n              className=\"text-lg\"\n              style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n            >\n              Tag Friends\n            </Text>\n            <TouchableOpacity onPress={onClose}>\n              <Text\n                className=\"text-base\"\n                style={{ color: colors.primary, fontFamily: 'Inter_600SemiBold' }}\n              >\n                Done\n              </Text>\n            </TouchableOpacity>\n          </View>\n\n          {/* Search */}\n          <View className=\"px-5 py-3\">\n            <TextInput\n              value={search}\n              onChangeText={setSearch}\n              placeholder=\"Search friends...\"\n              placeholderTextColor={colors['muted-foreground']}\n              className=\"px-4 py-3 rounded-xl text-base\"\n              style={{\n                backgroundColor: colors.muted,\n                color: colors.foreground,\n                fontFamily: 'Inter_400Regular',\n              }}\n            />\n          </View>\n\n          {/* Friend List */}\n          <ScrollView className=\"px-5 pb-8\" showsVerticalScrollIndicator={false}>\n            {filteredFriends.map((friend) => {\n              const isSelected = selectedFriendIds.includes(friend.id);\n\n              return (\n                <TouchableOpacity\n                  key={friend.id}\n                  onPress={() => onToggleFriend(friend)}\n                  className=\"flex-row items-center justify-between py-3.5 border-b\"\n                  style={{ borderColor: colors.border }}\n                  activeOpacity={0.7}\n                >\n                  <View className=\"flex-row items-center gap-3\">\n                    <View\n                      className=\"w-10 h-10 rounded-full items-center justify-center\"\n                      style={{ backgroundColor: colors.muted }}\n                    >\n                      <Text\n                        className=\"text-base\"\n                        style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n                      >\n                        {friend.name.charAt(0).toUpperCase()}\n                      </Text>\n                    </View>\n                    <View>\n                      <Text\n                        className=\"text-base\"\n                        style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n                      >\n                        {friend.name}\n                      </Text>\n                      <Text\n                        className=\"text-xs\"\n                        style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                      >\n                        {friend.dunbarTier}\n                      </Text>\n                    </View>\n                  </View>\n\n                  <View\n                    className=\"w-6 h-6 rounded-full items-center justify-center\"\n                    style={{\n                      backgroundColor: isSelected ? colors.primary : 'transparent',\n                      borderWidth: isSelected ? 0 : 2,\n                      borderColor: colors.border,\n                    }}\n                  >\n                    {isSelected && (\n                      <Text style={{ color: colors['primary-foreground'], fontSize: 14 }}>✓</Text>\n                    )}\n                  </View>\n                </TouchableOpacity>\n              );\n            })}\n\n            {filteredFriends.length === 0 && (\n              <View className=\"py-8 items-center\">\n                <Text\n                  className=\"text-sm\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                >\n                  No friends found\n                </Text>\n              </View>\n            )}\n          </ScrollView>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nexport default QuickCaptureSheet;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/WeaveReflectPrompt.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeIn' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeOut' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withDelay' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PROMPT_COUNT_KEY' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":57,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WeaveReflectPrompt\n * \n * Post-weave prompt that appears after logging a meaningful interaction.\n * Bridges the weave logger to the journal for deeper reflection.\n * \n * Shows when:\n * - Weave has notes > 20 chars\n * - High vibe (FullMoon, WaxingGibbous)\n * - Deep category (deep-talk, heart-to-heart, support)\n * - Extended duration\n * - User hasn't been prompted in last 3 weaves\n */\n\nimport React, { useEffect, useCallback } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport Animated, {\n  FadeIn,\n  FadeOut,\n  SlideInUp,\n  SlideOutDown,\n  useAnimatedStyle,\n  useSharedValue,\n  withSequence,\n  withTiming,\n  withDelay,\n} from 'react-native-reanimated';\nimport { Sparkles, X, ChevronRight } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport InteractionModel from '@/db/models/Interaction';\nimport FriendModel from '@/db/models/Friend';\nimport * as Haptics from 'expo-haptics';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface WeaveReflectPromptProps {\n  visible: boolean;\n  interaction: InteractionModel | null;\n  friends: FriendModel[];\n  onReflect: () => void;\n  onDismiss: () => void;\n}\n\ninterface MeaningfulnessCheck {\n  isMeaningful: boolean;\n  reasons: string[];\n}\n\n// ============================================================================\n// STORAGE KEYS\n// ============================================================================\n\nconst LAST_PROMPT_KEY = '@weave_reflect_last_prompt';\nconst PROMPT_COUNT_KEY = '@weave_reflect_prompt_count';\nconst WEAVES_SINCE_PROMPT_KEY = '@weave_reflect_weaves_since';\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a weave is meaningful enough to prompt for reflection.\n */\nexport function checkMeaningfulness(interaction: InteractionModel): MeaningfulnessCheck {\n  const reasons: string[] = [];\n\n  // Check notes length\n  const noteLength = interaction.note?.length || 0;\n  if (noteLength >= 20) {\n    reasons.push('detailed notes');\n  }\n\n  // Check vibe\n  if (['FullMoon', 'WaxingGibbous'].includes(interaction.vibe || '')) {\n    reasons.push('meaningful moment');\n  }\n\n  // Check category\n  const category = (interaction.interactionCategory || '').toLowerCase();\n  if (['deep-talk', 'heart-to-heart', 'support'].some(c => category.includes(c))) {\n    reasons.push('deep conversation');\n  }\n\n  // Check duration\n  if (['Extended', 'Long'].includes(interaction.duration || '')) {\n    reasons.push('extended time together');\n  }\n\n  return {\n    isMeaningful: reasons.length >= 1,\n    reasons,\n  };\n}\n\n/**\n * Check if we should show the prompt (rate limiting).\n */\nexport async function shouldShowPrompt(): Promise<boolean> {\n  try {\n    const weavesSinceStr = await AsyncStorage.getItem(WEAVES_SINCE_PROMPT_KEY);\n    const weavesSince = weavesSinceStr ? parseInt(weavesSinceStr, 10) : 0;\n\n    // Only show every 3+ weaves\n    return weavesSince >= 3;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Increment the weaves counter.\n */\nexport async function incrementWeaveCount(): Promise<void> {\n  try {\n    const weavesSinceStr = await AsyncStorage.getItem(WEAVES_SINCE_PROMPT_KEY);\n    const weavesSince = weavesSinceStr ? parseInt(weavesSinceStr, 10) : 0;\n    await AsyncStorage.setItem(WEAVES_SINCE_PROMPT_KEY, String(weavesSince + 1));\n  } catch {\n    // Ignore errors\n  }\n}\n\n/**\n * Reset the weaves counter (after showing prompt).\n */\nexport async function resetWeaveCount(): Promise<void> {\n  try {\n    await AsyncStorage.setItem(WEAVES_SINCE_PROMPT_KEY, '0');\n    await AsyncStorage.setItem(LAST_PROMPT_KEY, String(Date.now()));\n  } catch {\n    // Ignore errors\n  }\n}\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport function WeaveReflectPrompt({\n  visible,\n  interaction,\n  friends,\n  onReflect,\n  onDismiss,\n}: WeaveReflectPromptProps) {\n  const { colors } = useTheme();\n\n  // Animation values\n  const sparkleScale = useSharedValue(1);\n  const sparkleRotation = useSharedValue(0);\n\n  // Animate sparkle on mount\n  useEffect(() => {\n    if (visible) {\n      sparkleScale.value = withSequence(\n        withTiming(1.2, { duration: 200 }),\n        withTiming(1, { duration: 200 })\n      );\n      sparkleRotation.value = withSequence(\n        withTiming(15, { duration: 150 }),\n        withTiming(-15, { duration: 150 }),\n        withTiming(0, { duration: 150 })\n      );\n\n      // Haptic feedback\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    }\n  }, [visible]);\n\n  const handleReflect = useCallback(async () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    await resetWeaveCount();\n    onReflect();\n  }, [onReflect]);\n\n  const handleDismiss = useCallback(async () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    await resetWeaveCount();\n    onDismiss();\n  }, [onDismiss]);\n\n  // Animated styles\n  const sparkleAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { scale: sparkleScale.value },\n      { rotate: `${sparkleRotation.value}deg` },\n    ],\n  }));\n\n  if (!visible || !interaction) return null;\n\n  // Get friend name(s)\n  const friendNames = friends.map(f => f.name).join(' & ');\n\n  // Get note preview (truncated)\n  const notePreview = interaction.note\n    ? interaction.note.length > 50\n      ? `\"${interaction.note.slice(0, 50)}...\"`\n      : `\"${interaction.note}\"`\n    : null;\n\n  return (\n    <Animated.View\n      entering={SlideInUp.springify().damping(18)}\n      exiting={SlideOutDown.springify().damping(18)}\n      className=\"absolute bottom-6 left-4 right-4\"\n      style={{\n        shadowColor: '#000',\n        shadowOffset: { width: 0, height: 4 },\n        shadowOpacity: 0.2,\n        shadowRadius: 12,\n        elevation: 8,\n      }}\n    >\n      <View\n        className=\"rounded-2xl overflow-hidden\"\n        style={{ backgroundColor: colors.card }}\n      >\n        {/* Dismiss Button */}\n        <TouchableOpacity\n          onPress={handleDismiss}\n          className=\"absolute top-3 right-3 z-10 w-7 h-7 items-center justify-center rounded-full\"\n          style={{ backgroundColor: colors.muted }}\n        >\n          <X size={14} color={colors['muted-foreground']} />\n        </TouchableOpacity>\n\n        <View className=\"p-5\">\n          {/* Header with sparkle */}\n          <View className=\"flex-row items-center gap-2.5 mb-3\">\n            <Animated.View style={sparkleAnimatedStyle}>\n              <View\n                className=\"w-9 h-9 rounded-full items-center justify-center\"\n                style={{ backgroundColor: colors.primary + '20' }}\n              >\n                <Sparkles size={18} color={colors.primary} />\n              </View>\n            </Animated.View>\n            <Text\n              className=\"text-base\"\n              style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n            >\n              That sounded meaningful\n            </Text>\n          </View>\n\n          {/* Note Preview */}\n          {notePreview && (\n            <View\n              className=\"rounded-xl p-3 mb-3\"\n              style={{ backgroundColor: colors.muted }}\n            >\n              <Text\n                className=\"text-sm italic\"\n                style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n              >\n                {notePreview}\n              </Text>\n            </View>\n          )}\n\n          {/* Description */}\n          <Text\n            className=\"text-sm mb-4\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            {friendNames\n              ? `Want to capture more about your time with ${friendNames}?`\n              : 'Want to capture more about this moment while it\\'s fresh?'}\n          </Text>\n\n          {/* Actions */}\n          <View className=\"flex-row gap-3\">\n            <TouchableOpacity\n              onPress={handleDismiss}\n              className=\"flex-1 py-3 rounded-xl items-center\"\n              style={{\n                backgroundColor: colors.muted,\n                borderWidth: 1,\n                borderColor: colors.border,\n              }}\n              activeOpacity={0.7}\n            >\n              <Text\n                className=\"text-sm\"\n                style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n              >\n                Maybe later\n              </Text>\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              onPress={handleReflect}\n              className=\"flex-1 flex-row items-center justify-center gap-1.5 py-3 rounded-xl\"\n              style={{ backgroundColor: colors.primary }}\n              activeOpacity={0.8}\n            >\n              <Text\n                className=\"text-sm\"\n                style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n              >\n                Reflect on this\n              </Text>\n              <ChevronRight size={16} color={colors['primary-foreground']} />\n            </TouchableOpacity>\n          </View>\n        </View>\n      </View>\n    </Animated.View>\n  );\n}\n\n// ============================================================================\n// HOOK FOR WEAVE LOGGER INTEGRATION\n// ============================================================================\n\ninterface UseWeaveReflectPromptReturn {\n  showPrompt: boolean;\n  checkAndShowPrompt: (interaction: InteractionModel, friends: FriendModel[]) => Promise<boolean>;\n  hidePrompt: () => void;\n  promptInteraction: InteractionModel | null;\n  promptFriends: FriendModel[];\n}\n\n/**\n * Hook for integrating the reflect prompt into the weave logger.\n * \n * Usage in WeaveLogger:\n * ```\n * const { showPrompt, checkAndShowPrompt, hidePrompt, promptInteraction, promptFriends } = useWeaveReflectPrompt();\n * \n * // After weave is saved:\n * const shouldShow = await checkAndShowPrompt(savedInteraction, friends);\n * \n * // In render:\n * <WeaveReflectPrompt\n *   visible={showPrompt}\n *   interaction={promptInteraction}\n *   friends={promptFriends}\n *   onReflect={() => {\n *     hidePrompt();\n *     navigation.navigate('Journal', { weaveId: promptInteraction.id });\n *   }}\n *   onDismiss={hidePrompt}\n * />\n * ```\n */\nexport function useWeaveReflectPrompt(): UseWeaveReflectPromptReturn {\n  const [showPrompt, setShowPrompt] = React.useState(false);\n  const [promptInteraction, setPromptInteraction] = React.useState<InteractionModel | null>(null);\n  const [promptFriends, setPromptFriends] = React.useState<FriendModel[]>([]);\n\n  const checkAndShowPrompt = useCallback(async (\n    interaction: InteractionModel,\n    friends: FriendModel[]\n  ): Promise<boolean> => {\n    // Increment counter regardless\n    await incrementWeaveCount();\n\n    // Check meaningfulness\n    const { isMeaningful } = checkMeaningfulness(interaction);\n    if (!isMeaningful) return false;\n\n    // Check rate limiting\n    const shouldShow = await shouldShowPrompt();\n    if (!shouldShow) return false;\n\n    // Show prompt\n    setPromptInteraction(interaction);\n    setPromptFriends(friends);\n    setShowPrompt(true);\n\n    return true;\n  }, []);\n\n  const hidePrompt = useCallback(() => {\n    setShowPrompt(false);\n    setPromptInteraction(null);\n    setPromptFriends([]);\n  }, []);\n\n  return {\n    showPrompt,\n    checkAndShowPrompt,\n    hidePrompt,\n    promptInteraction,\n    promptFriends,\n  };\n}\n\nexport default WeaveReflectPrompt;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/Journal/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/LifeEventModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Modal' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BlurView' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Animated' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeInUp' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":48,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity, Modal, TextInput, ScrollView, Alert } from 'react-native';\nimport { BlurView } from 'expo-blur';\nimport { X, Calendar } from 'lucide-react-native';\nimport Animated, { FadeInUp } from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport LifeEventModel, { LifeEventType, LifeEventImportance } from '@/db/models/LifeEvent';\nimport { LifeEvent } from '@/components/types';\n\nimport UserProgress from '@/db/models/UserProgress';\nimport { CustomCalendar } from './CustomCalendar';\nimport { startOfDay } from 'date-fns';\nimport { AnimatedBottomSheet } from '@/shared/ui/Sheet';\n\ninterface LifeEventModalProps {\n  visible: boolean;\n  onClose: () => void;\n  friendId: string;\n  existingEvent?: LifeEvent | null;\n}\n\nconst EVENT_TYPES: Array<{ value: LifeEventType; label: string; icon: string }> = [\n  { value: 'new_job', label: 'New Job', icon: '💼' },\n  { value: 'moving', label: 'Moving/Relocating', icon: '📦' },\n  { value: 'wedding', label: 'Wedding', icon: '💒' },\n  { value: 'baby', label: 'New Baby/Pregnancy', icon: '👶' },\n  { value: 'loss', label: 'Loss/Grief', icon: '🕊️' },\n  { value: 'health_event', label: 'Health Event', icon: '🏥' },\n  { value: 'graduation', label: 'Graduation', icon: '🎓' },\n  { value: 'celebration', label: 'Milestone/Achievement', icon: '🎉' },\n  { value: 'other', label: 'Other', icon: '✨' },\n];\n\nconst IMPORTANCE_LEVELS: Array<{ value: LifeEventImportance; label: string; description: string }> = [\n  { value: 'low', label: 'Low', description: 'Minor event' },\n  { value: 'medium', label: 'Medium', description: 'Notable event' },\n  { value: 'high', label: 'High', description: 'Major life change' },\n  { value: 'critical', label: 'Critical', description: 'Urgent/significant' },\n];\n\nexport const LifeEventModal: React.FC<LifeEventModalProps> = ({\n  visible,\n  onClose,\n  friendId,\n  existingEvent,\n}) => {\n  const { colors, isDarkMode } = useTheme();\n  const [eventType, setEventType] = useState<LifeEventType>(existingEvent?.eventType || 'other');\n  const [eventDate, setEventDate] = useState<Date>(existingEvent?.date || startOfDay(new Date()));\n  const [title, setTitle] = useState(existingEvent?.title || '');\n  const [notes, setNotes] = useState(existingEvent?.description || '');\n  const [importance, setImportance] = useState<LifeEventImportance>(existingEvent?.importance || 'medium');\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n\n  useEffect(() => {\n    if (visible) {\n      if (existingEvent) {\n        setEventType(existingEvent.eventType);\n        setEventDate(existingEvent.date || startOfDay(new Date()));\n        setTitle(existingEvent.title);\n        setNotes(existingEvent.description || '');\n        setImportance(existingEvent.importance);\n      } else {\n        // Reset to defaults for new event\n        setEventType('other');\n        setEventDate(startOfDay(new Date()));\n        setTitle('');\n        setNotes('');\n        setImportance('medium');\n      }\n    }\n  }, [visible, existingEvent]);\n\n  const handleDateSelect = (date: Date) => {\n    setEventDate(startOfDay(date));\n    setShowDatePicker(false);\n  };\n\n  const handleSave = async () => {\n    setIsSaving(true);\n    try {\n      await database.write(async () => {\n        if (existingEvent) {\n          // Update existing event\n          const eventModel = await database.get<LifeEventModel>('life_events').find(existingEvent.id);\n          await eventModel.update(event => {\n            event.eventType = eventType;\n            event.eventDate = startOfDay(eventDate);\n            event.title = title.trim() || EVENT_TYPES.find(t => t.value === eventType)?.label || 'Life Event';\n            event.notes = notes.trim();\n            event.importance = importance;\n          });\n        } else {\n          // Create new event\n          await database.get<LifeEventModel>('life_events').create(event => {\n            event.friendId = friendId;\n            event.eventType = eventType;\n            event.eventDate = startOfDay(eventDate);\n            event.title = title.trim() || EVENT_TYPES.find(t => t.value === eventType)?.label || 'Life Event';\n            event.notes = notes.trim();\n            event.importance = importance;\n            event.source = 'manual';\n            event.isRecurring = false;\n            event.reminded = false;\n          });\n\n          const userProgress = await database.get<UserProgress>('user_progress').query().fetch();\n          const progress = userProgress[0];\n          await progress.update(p => {\n            p.scribeProgress += 1;\n          });\n        }\n      });\n\n      onClose();\n    } catch (error) {\n      console.error('Error saving life event:', error);\n      Alert.alert('Error', 'Failed to save life event. Please try again.');\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleDelete = async () => {\n    if (!existingEvent) return;\n\n    Alert.alert(\n      'Delete Life Event',\n      'Are you sure you want to delete this life event?',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Delete',\n          style: 'destructive',\n          onPress: async () => {\n            try {\n              await database.write(async () => {\n                const eventModel = await database.get<LifeEventModel>('life_events').find(existingEvent.id);\n                await eventModel.destroyPermanently();\n              });\n              onClose();\n            } catch (error) {\n              console.error('Error deleting life event:', error);\n              Alert.alert('Error', 'Failed to delete life event');\n            }\n          },\n        },\n      ]\n    );\n  };\n\n  return (\n    <AnimatedBottomSheet\n      visible={visible}\n      onClose={onClose}\n      height=\"full\"\n      title={existingEvent ? 'Edit Life Event' : 'Add Life Event'}\n      scrollable\n      footerComponent={\n        <View className=\"flex-row gap-3\">\n          {existingEvent && (\n            <TouchableOpacity\n              onPress={handleDelete}\n              className=\"flex-1 py-3 px-6 rounded-full items-center\"\n              style={{ backgroundColor: colors.destructive }}\n            >\n              <Text className=\"font-inter-semibold text-base text-white\">Delete</Text>\n            </TouchableOpacity>\n          )}\n          <TouchableOpacity\n            onPress={handleSave}\n            disabled={isSaving}\n            className=\"flex-1 py-3 px-6 rounded-full items-center\"\n            style={{ backgroundColor: colors.primary, opacity: isSaving ? 0.6 : 1 }}\n          >\n            <Text className=\"font-inter-semibold text-base text-white\">\n              {isSaving ? 'Saving...' : 'Save'}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      }\n    >\n      <View className=\"flex-1\">\n        <View className=\"flex-1\">\n          {/* Event Type */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Event Type\n          </Text>\n          <ScrollView horizontal showsHorizontalScrollIndicator={false} className=\"mb-4\">\n            <View className=\"flex-row gap-2\">\n              {EVENT_TYPES.map((type) => (\n                <TouchableOpacity\n                  key={type.value}\n                  onPress={() => setEventType(type.value)}\n                  className=\"px-4 py-3 rounded-xl flex-row items-center gap-2\"\n                  style={{\n                    backgroundColor: eventType === type.value ? `${colors.primary}20` : colors.muted,\n                    borderWidth: eventType === type.value ? 2 : 0,\n                    borderColor: colors.primary,\n                  }}\n                >\n                  <Text className=\"text-lg\">{type.icon}</Text>\n                  <Text\n                    className=\"font-inter-medium text-sm\"\n                    style={{ color: eventType === type.value ? colors.primary : colors.foreground }}\n                  >\n                    {type.label}\n                  </Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </ScrollView>\n\n          {/* Title */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Title (Optional)\n          </Text>\n          <TextInput\n            value={title}\n            onChangeText={setTitle}\n            placeholder=\"e.g., Starting at Tech Co (optional, defaults to event type)\"\n            placeholderTextColor={colors['muted-foreground']}\n            className=\"p-4 rounded-xl mb-4 font-inter-regular text-base\"\n            style={{ backgroundColor: colors.muted, color: colors.foreground }}\n          />\n\n          {/* Date */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Date\n          </Text>\n          <TouchableOpacity\n            onPress={() => setShowDatePicker(true)}\n            className=\"p-4 rounded-xl mb-4 flex-row items-center gap-3\"\n            style={{ backgroundColor: colors.muted }}\n          >\n            <Calendar size={20} color={colors['muted-foreground']} />\n            <Text className=\"font-inter-regular text-base flex-1\" style={{ color: colors.foreground }}>\n              {eventDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}\n            </Text>\n          </TouchableOpacity>\n\n\n\n          {/* Importance */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Importance\n          </Text>\n          <View className=\"gap-2 mb-4\">\n            {IMPORTANCE_LEVELS.map((level) => (\n              <TouchableOpacity\n                key={level.value}\n                onPress={() => setImportance(level.value)}\n                className=\"p-3 rounded-xl flex-row items-center justify-between\"\n                style={{\n                  backgroundColor: importance === level.value ? `${colors.primary}20` : colors.muted,\n                  borderWidth: importance === level.value ? 2 : 0,\n                  borderColor: colors.primary,\n                }}\n              >\n                <View>\n                  <Text\n                    className=\"font-inter-semibold text-sm\"\n                    style={{ color: importance === level.value ? colors.primary : colors.foreground }}\n                  >\n                    {level.label}\n                  </Text>\n                  <Text className=\"font-inter-regular text-xs\" style={{ color: colors['muted-foreground'] }}>\n                    {level.description}\n                  </Text>\n                </View>\n              </TouchableOpacity>\n            ))}\n          </View>\n\n          {/* Notes */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Notes (Optional)\n          </Text>\n          <TextInput\n            value={notes}\n            onChangeText={setNotes}\n            placeholder=\"Add any additional details...\"\n            placeholderTextColor={colors['muted-foreground']}\n            multiline\n            numberOfLines={3}\n            className=\"p-4 rounded-xl mb-6 font-inter-regular text-base\"\n            style={{ backgroundColor: colors.muted, color: colors.foreground, textAlignVertical: 'top' }}\n          />\n\n        </View>\n\n        {/* Calendar Sheet */}\n        <AnimatedBottomSheet\n          visible={showDatePicker}\n          onClose={() => setShowDatePicker(false)}\n          height=\"form\"\n        >\n          <View className=\"flex-1\">\n            <View className=\"flex-row justify-between items-center mb-4 px-6 pt-2\">\n              <Text className=\"font-lora-bold text-xl\" style={{ color: colors.foreground }}>\n                Pick a Date\n              </Text>\n              <TouchableOpacity onPress={() => setShowDatePicker(false)} className=\"p-2 -mr-2\">\n                <X size={22} color={colors['muted-foreground']} />\n              </TouchableOpacity>\n            </View>\n\n            <View className=\"px-4\">\n              <CustomCalendar\n                selectedDate={eventDate}\n                onDateSelect={handleDateSelect}\n                minDate={undefined}\n              />\n            </View>\n          </View>\n        </AnimatedBottomSheet>\n      </View>\n    </AnimatedBottomSheet>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/MicroReflectionSheet.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activityId' is defined but never used. Allowed unused args must match /^_/u.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Text, TextInput, TouchableOpacity, StyleSheet, ScrollView, Keyboard } from 'react-native';\nimport * as Haptics from 'expo-haptics';\n\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { type Vibe } from './types';\nimport { getCategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { type InteractionCategory } from './types';\nimport { AnimatedBottomSheet } from '@/shared/ui/Sheet';\nimport { MoonPhaseSelector } from '@/components/MoonPhaseSelector';\n\ninterface MicroReflectionSheetProps {\n  isVisible: boolean;\n  friendName: string;\n  activityLabel: string;\n  activityId: string;\n  friendArchetype?: string;\n  onSave: (data: { vibe?: Vibe; notes?: string; title?: string }) => void;\n  onSkip: () => void;\n}\n\nexport function MicroReflectionSheet({\n  isVisible,\n  friendName,\n  activityLabel,\n  activityId,\n  friendArchetype,\n  onSave,\n  onSkip,\n}: MicroReflectionSheetProps) {\n  const { colors, isDarkMode } = useTheme();\n  const [selectedVibe, setSelectedVibe] = useState<Vibe | null>(null);\n  const [notes, setNotes] = useState('');\n  const [title, setTitle] = useState(activityLabel);\n\n\n  // Set title from activityLabel when opening\n  useEffect(() => {\n    if (isVisible) {\n      if (activityLabel && activityLabel.includes('-')) {\n        const metadata = getCategoryMetadata(activityLabel as InteractionCategory);\n        if (metadata && metadata.label) {\n          setTitle(metadata.label);\n          return;\n        }\n      }\n      setTitle(activityLabel);\n    }\n  }, [isVisible, activityLabel]);\n\n  const handleVibeSelect = (vibe: Vibe) => {\n    setSelectedVibe(vibe);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  };\n\n  const handleSave = () => {\n    Keyboard.dismiss();\n    // Call onSave directly - the parent's handleSave will close the sheet after saving\n    onSave({\n      vibe: selectedVibe || undefined,\n      notes: notes.trim() || undefined,\n      title: title.trim() || activityLabel,\n    });\n  };\n\n  const handleSkip = () => {\n    Keyboard.dismiss();\n    onSkip();\n  };\n\n  const handleCloseComplete = () => {\n    // Reset state after close animation completes\n    setSelectedVibe(null);\n    setNotes('');\n    setTitle('');\n  };\n\n  const getPrompt = () => {\n    const archetypePrompts: Record<string, string> = {\n      'The Sun': 'How was the joy shared?',\n      'The Hermit': 'What depth did you find?',\n      'The Fool': 'What adventure unfolded?',\n      'The Empress': 'How did you nurture each other?',\n      'The Magician': 'What magic happened?',\n      'The High Priestess': 'What truth emerged?',\n      'The Emperor': 'How did you support each other?',\n    };\n\n    return friendArchetype && archetypePrompts[friendArchetype]\n      ? archetypePrompts[friendArchetype]\n      : 'How did it feel?';\n  };\n\n  return (\n    <AnimatedBottomSheet\n      visible={isVisible}\n      onClose={handleSkip}\n      onCloseComplete={handleCloseComplete}\n      height=\"full\"\n      scrollable\n    >\n      {/* Header */}\n      <View style={styles.header}>\n        <Text style={[styles.activityText, { color: colors['muted-foreground'] }]}>\n          Logged\n        </Text>\n        <TextInput\n          style={[styles.titleInput, { color: colors.foreground }]}\n          value={title}\n          onChangeText={setTitle}\n          placeholder=\"Interaction Title\"\n          placeholderTextColor={colors['muted-foreground'] + '80'}\n          returnKeyType=\"done\"\n        />\n        <Text style={[styles.friendNameText, { color: colors.foreground }]}>\n          with {friendName}\n        </Text>\n      </View>\n\n      {/* Prompt */}\n      <Text style={[styles.promptText, { color: colors.foreground }]}>\n        {getPrompt()}\n      </Text>\n\n      {/* Moon Phase Selector */}\n      <View style={styles.moonContainer}>\n        <MoonPhaseSelector\n          selectedVibe={selectedVibe}\n          onSelect={handleVibeSelect}\n        />\n      </View>\n\n      {/* Optional Note */}\n      <View style={styles.noteSection}>\n        <Text style={[styles.noteLabel, { color: colors['muted-foreground'] }]}>\n          Optional: Add a note\n        </Text>\n        <TextInput\n          style={[\n            styles.noteInput,\n            {\n              backgroundColor: isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.03)',\n              color: colors.foreground,\n              borderColor: colors.border,\n            },\n          ]}\n          placeholder=\"What happened? How are you feeling?\"\n          placeholderTextColor={colors['muted-foreground'] + '80'}\n          value={notes}\n          onChangeText={setNotes}\n          multiline\n          numberOfLines={3}\n          textAlignVertical=\"top\"\n          returnKeyType=\"done\"\n          blurOnSubmit\n        />\n      </View>\n\n      {/* Actions */}\n      <View style={styles.actions}>\n        <TouchableOpacity\n          style={[styles.skipButton, { borderColor: colors.border }]}\n          onPress={handleSkip}\n          activeOpacity={0.7}\n        >\n          <Text style={[styles.skipButtonText, { color: colors['muted-foreground'] }]}>\n            Skip\n          </Text>\n        </TouchableOpacity>\n\n        <TouchableOpacity\n          style={[styles.saveButton, { backgroundColor: colors.primary }]}\n          onPress={handleSave}\n          activeOpacity={0.8}\n        >\n          <Text style={[styles.saveButtonText, { color: colors['primary-foreground'] }]}>\n            Save\n          </Text>\n        </TouchableOpacity>\n      </View>\n    </AnimatedBottomSheet>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    alignItems: 'center',\n    marginBottom: 16,\n  },\n  activityText: {\n    fontSize: 14,\n    fontWeight: '500',\n    marginBottom: 8,\n  },\n  titleInput: {\n    fontSize: 24,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n    textAlign: 'center',\n    marginBottom: 4,\n    minWidth: 200,\n  },\n  friendNameText: {\n    fontSize: 16,\n    fontWeight: '500',\n    fontFamily: 'Inter_600SemiBold',\n    opacity: 0.8,\n  },\n  promptText: {\n    fontSize: 18,\n    fontWeight: '600',\n    textAlign: 'center',\n    marginBottom: 24,\n  },\n  moonContainer: {\n    width: '100%',\n    marginBottom: 20,\n  },\n  noteSection: {\n    marginBottom: 24,\n  },\n  noteLabel: {\n    fontSize: 13,\n    fontWeight: '500',\n    marginBottom: 8,\n  },\n  noteInput: {\n    borderWidth: 1,\n    borderRadius: 12,\n    padding: 12,\n    fontSize: 15,\n    minHeight: 80,\n    maxHeight: 120,\n  },\n  actions: {\n    flexDirection: 'row',\n    gap: 12,\n  },\n  skipButton: {\n    flex: 1,\n    paddingVertical: 16,\n    borderRadius: 12,\n    borderWidth: 1.5,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  skipButtonText: {\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  saveButton: {\n    flex: 1,\n    paddingVertical: 16,\n    borderRadius: 12,\n    alignItems: 'center',\n    justifyContent: 'center',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 8,\n    elevation: 4,\n  },\n  saveButtonText: {\n    fontSize: 16,\n    fontWeight: '700',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/MilestoneCelebration.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Easing' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'runOnJS' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { View, Text, Modal, TouchableOpacity } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withDelay,\n  withSequence,\n  withSpring,\n  withTiming,\n  Easing,\n  runOnJS,\n} from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Milestone } from '@/modules/gamification';\nimport * as Haptics from 'expo-haptics';\n\n/**\n * Milestone Celebration Modal\n *\n * Full-screen celebration when user unlocks a milestone.\n * Philosophy: Joyful, meaningful, not gamified/cheap.\n *\n * Animation sequence:\n * 1. Fade in backdrop\n * 2. Scale + fade in milestone icon (burst effect)\n * 3. Slide up milestone name\n * 4. Fade in description\n * 5. Show continue button\n */\n\ninterface MilestoneCelebrationProps {\n  visible: boolean;\n  milestone: Milestone | null;\n  onClose: () => void;\n}\n\nexport const MilestoneCelebration: React.FC<MilestoneCelebrationProps> = ({\n  visible,\n  milestone,\n  onClose,\n}) => {\n  const { colors } = useTheme();\n\n  // Animated values\n  const backdropOpacity = useSharedValue(0);\n  const iconScale = useSharedValue(0);\n  const iconOpacity = useSharedValue(0);\n  const titleTranslateY = useSharedValue(20);\n  const titleOpacity = useSharedValue(0);\n  const descTranslateY = useSharedValue(20);\n  const descOpacity = useSharedValue(0);\n  const buttonOpacity = useSharedValue(0);\n\n  useEffect(() => {\n    if (visible && milestone) {\n      // Trigger haptic celebration\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n\n      // Animate in sequence\n      backdropOpacity.value = withTiming(1, { duration: 300 });\n\n      iconScale.value = withDelay(\n        200,\n        withSequence(\n          withSpring(1.3, { damping: 8, stiffness: 100 }),\n          withSpring(1, { damping: 12, stiffness: 150 })\n        )\n      );\n      iconOpacity.value = withDelay(200, withTiming(1, { duration: 400 }));\n\n      titleTranslateY.value = withDelay(\n        500,\n        withSpring(0, { damping: 15, stiffness: 120 })\n      );\n      titleOpacity.value = withDelay(500, withTiming(1, { duration: 400 }));\n\n      descTranslateY.value = withDelay(\n        700,\n        withSpring(0, { damping: 15, stiffness: 120 })\n      );\n      descOpacity.value = withDelay(700, withTiming(1, { duration: 400 }));\n\n      buttonOpacity.value = withDelay(900, withTiming(1, { duration: 400 }));\n    } else {\n      // Reset for next time\n      backdropOpacity.value = 0;\n      iconScale.value = 0;\n      iconOpacity.value = 0;\n      titleTranslateY.value = 20;\n      titleOpacity.value = 0;\n      descTranslateY.value = 20;\n      descOpacity.value = 0;\n      buttonOpacity.value = 0;\n    }\n  }, [visible, milestone]);\n\n  const backdropStyle = useAnimatedStyle(() => ({\n    opacity: backdropOpacity.value,\n  }));\n\n  const iconStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: iconScale.value }],\n    opacity: iconOpacity.value,\n  }));\n\n  const titleStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: titleTranslateY.value }],\n    opacity: titleOpacity.value,\n  }));\n\n  const descStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: descTranslateY.value }],\n    opacity: descOpacity.value,\n  }));\n\n  const buttonStyle = useAnimatedStyle(() => ({\n    opacity: buttonOpacity.value,\n  }));\n\n  if (!visible || !milestone) return null;\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"none\"\n      onRequestClose={onClose}\n    >\n      {/* Backdrop */}\n      <Animated.View\n        className=\"absolute inset-0\"\n        style={[\n          {\n            backgroundColor: 'rgba(0, 0, 0, 0.85)',\n          },\n          backdropStyle,\n        ]}\n      />\n\n      {/* Content */}\n      <View className=\"flex-1 items-center justify-center px-8\">\n        {/* Icon Burst */}\n        <Animated.View\n          className=\"items-center justify-center mb-8\"\n          style={iconStyle}\n        >\n          <View\n            className=\"w-32 h-32 rounded-full items-center justify-center\"\n            style={{\n              backgroundColor: `${colors.primary}15`,\n              borderWidth: 2,\n              borderColor: `${colors.primary}40`,\n            }}\n          >\n            <Text className=\"text-[64px]\">{milestone.icon}</Text>\n          </View>\n        </Animated.View>\n\n        {/* Milestone Name */}\n        <Animated.View style={titleStyle} className=\"mb-3\">\n          <Text\n            className=\"font-lora-bold text-3xl text-center\"\n            style={{ color: colors.foreground }}\n          >\n            {milestone.name}\n          </Text>\n        </Animated.View>\n\n        {/* Description */}\n        <Animated.View style={descStyle} className=\"mb-8\">\n          <Text\n            className=\"font-inter-regular text-base text-center leading-6\"\n            style={{ color: colors['muted-foreground'] }}\n          >\n            {milestone.description}\n          </Text>\n        </Animated.View>\n\n        {/* Continue Button */}\n        <Animated.View style={buttonStyle} className=\"w-full\">\n          <TouchableOpacity\n            className=\"py-4 px-8 rounded-2xl items-center\"\n            style={{ backgroundColor: colors.primary }}\n            onPress={onClose}\n            activeOpacity={0.8}\n          >\n            <Text className=\"font-inter-semibold text-base text-white\">\n              Continue Weaving\n            </Text>\n          </TouchableOpacity>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/MonthDayPicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/MoonPhaseSelector.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeIn' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeOut' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { type Vibe } from './types';\nimport Animated, { FadeIn, FadeOut, useSharedValue, useAnimatedStyle, withTiming, withSequence, runOnJS } from 'react-native-reanimated';\nimport Slider from '@react-native-community/slider';\nimport * as Haptics from 'expo-haptics';\nimport Phase1 from '@/assets/MoonIcons/Phase1.svg';\nimport Phase2 from '@/assets/MoonIcons/Phase2.svg';\nimport Phase3 from '@/assets/MoonIcons/Phase3.svg';\nimport Phase4 from '@/assets/MoonIcons/Phase4.svg';\nimport Phase5 from '@/assets/MoonIcons/Phase5.svg';\n\nconst MOON_SVG_MAP: Record<Vibe, React.FC<any>> = {\n  NewMoon: Phase1,\n  WaxingCrescent: Phase2,\n  FirstQuarter: Phase3,\n  WaxingGibbous: Phase4,\n  FullMoon: Phase5,\n  WaningGibbous: Phase4,\n  LastQuarter: Phase3,\n  WaningCrescent: Phase2,\n};\n\nconst PHASE_DESCRIPTIONS: Record<Vibe, { title: string; description: string }> = {\n  NewMoon: {\n    title: 'New Moon',\n    description: \"A quiet moment. Not every thread needs to\\u00A0spark.\\nSometimes you just cross paths. That's\\u00A0okay.\"\n  },\n  WaxingCrescent: {\n    title: 'Waxing Crescent',\n    description: \"A small connection. It still\\u00A0counts.\\nLight touch, but you showed\\u00A0up.\"\n  },\n  FirstQuarter: {\n    title: 'Half Moon',\n    description: \"A good moment. The kind friendships are built\\u00A0on.\\nNothing dramatic. Just real time\\u00A0together.\"\n  },\n  WaxingGibbous: {\n    title: 'Waxing Gibbous',\n    description: \"That one landed. You'll carry a bit of it with\\u00A0you.\\nA warm one. These add\\u00A0up.\"\n  },\n  FullMoon: {\n    title: 'Full Moon',\n    description: \"You felt it. So did they,\\u00A0probably.\\nThe kind of moment you'll\\u00A0remember.\"\n  },\n  // Fallbacks\n  WaningGibbous: { title: 'Waning Gibbous', description: '' },\n  LastQuarter: { title: 'Last Quarter', description: '' },\n  WaningCrescent: { title: 'Waning Crescent', description: '' },\n};\n\n// Numeric mapping for slider (1-5)\nconst VIBE_ORDER: Vibe[] = [\n  'NewMoon',\n  'WaxingCrescent',\n  'FirstQuarter',\n  'WaxingGibbous',\n  'FullMoon'\n];\n\ninterface MoonPhaseSelectorProps {\n  onSelect: (vibe: Vibe) => void;\n  selectedVibe: Vibe | null;\n}\n\nexport function MoonPhaseSelector({ onSelect, selectedVibe }: MoonPhaseSelectorProps) {\n  const { colors } = useTheme();\n\n  // Determine current numeric value from selectedVibe, default to 3 (FirstQuarter) if null\n  const currentIndex = selectedVibe ? VIBE_ORDER.indexOf(selectedVibe) : 2;\n  const sliderValue = currentIndex !== -1 ? currentIndex + 1 : 3;\n\n  // Local state for display text to allow animating out before changing\n  const currentVibe = selectedVibe || 'FirstQuarter';\n\n  // We use a ref to track the \"active\" vibe for text display, which updates AFTER fade out\n  const [displayedVibe, setDisplayedVibe] = React.useState(currentVibe);\n\n  // Opacity shared values\n  const textOpacity = useSharedValue(1);\n  const iconScale = useSharedValue(1);\n\n  React.useEffect(() => {\n    if (currentVibe !== displayedVibe) {\n      // 1. Fade out\n      textOpacity.value = withTiming(0, { duration: 150 }, (finished) => {\n        if (finished) {\n          // 2. Swap text (run on JS thread)\n          runOnJS(setDisplayedVibe)(currentVibe);\n        }\n      });\n      // Pop icon slightly\n      iconScale.value = withSequence(\n        withTiming(1.1, { duration: 100 }),\n        withTiming(1, { duration: 150 })\n      );\n    }\n  }, [currentVibe]);\n\n  // When displayedVibe updates (after fade out), fade back in\n  React.useEffect(() => {\n    if (textOpacity.value === 0) {\n      textOpacity.value = withTiming(1, { duration: 250 });\n    }\n  }, [displayedVibe]);\n\n  const handleSliderChange = (value: number) => {\n    const index = Math.round(value) - 1;\n    const newVibe = VIBE_ORDER[index];\n    if (newVibe && newVibe !== selectedVibe) {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n      onSelect(newVibe);\n    }\n  };\n\n  const MoonIcon = MOON_SVG_MAP[currentVibe] || Phase3; // Icon updates immediately for responsiveness\n  const phaseInfo = PHASE_DESCRIPTIONS[displayedVibe] || PHASE_DESCRIPTIONS['FirstQuarter']; // Text updates after fade\n\n  const textAnimatedStyle = useAnimatedStyle(() => ({\n    opacity: textOpacity.value,\n  }));\n\n  const iconAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: iconScale.value }]\n  }));\n\n  return (\n    <View style={styles.container}>\n      {/* Icon Display */}\n      <View style={styles.iconContainer}>\n        <Animated.View style={[\n          styles.iconWrapper,\n          iconAnimatedStyle,\n          {\n            shadowColor: colors.primary,\n            backgroundColor: colors.background\n          }\n        ]}>\n          <MoonIcon width={64} height={64} color={colors.primary} fill={colors.primary} />\n        </Animated.View>\n\n        <View style={styles.textContainer}>\n          <Animated.View style={textAnimatedStyle}>\n            <Text style={[styles.label, { color: colors.foreground }]}>{phaseInfo.title}</Text>\n          </Animated.View>\n\n          <View style={styles.descriptionWrapper}>\n            <Animated.Text style={[styles.description, textAnimatedStyle, { color: colors['muted-foreground'] }]}>\n              {phaseInfo.description.split('\\n')[0]}\n            </Animated.Text>\n\n            {phaseInfo.description.split('\\n')[1] && (\n              <Animated.Text\n                style={[styles.description, textAnimatedStyle, { marginTop: 4, opacity: 0.8, color: colors['muted-foreground'] }]}\n              >\n                {phaseInfo.description.split('\\n')[1]}\n              </Animated.Text>\n            )}\n          </View>\n        </View>\n      </View>\n\n      {/* Slider */}\n      <View style={styles.sliderContainer}>\n        <Slider\n          style={{ width: '100%', height: 40 }}\n          minimumValue={1}\n          maximumValue={5}\n          step={1}\n          value={sliderValue}\n          onValueChange={handleSliderChange}\n          minimumTrackTintColor={colors.primary}\n          maximumTrackTintColor={colors.border}\n          thumbTintColor={colors.primary}\n        />\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: 'center',\n    width: '100%',\n    gap: 24,\n    paddingVertical: 12,\n  },\n  iconContainer: {\n    alignItems: 'center',\n    justifyContent: 'flex-start',\n    height: 200, // Fixed height to prevent slider jumping\n    gap: 16,\n    width: '100%',\n  },\n  iconWrapper: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    shadowOffset: { width: 0, height: 0 },\n    shadowOpacity: 0.3,\n    shadowRadius: 10,\n    elevation: 5,\n    height: 80,\n    width: 80,\n    borderRadius: 40,\n  },\n  textContainer: {\n    alignItems: 'center',\n    width: '100%',\n    paddingHorizontal: 20,\n    gap: 8,\n  },\n  descriptionWrapper: {\n    alignItems: 'center',\n    gap: 2,\n  },\n  label: {\n    fontSize: 20,\n    fontFamily: 'Lora-Bold',\n    textAlign: 'center',\n  },\n  description: {\n    fontSize: 14,\n    fontFamily: 'Inter-Regular',\n    textAlign: 'center',\n    lineHeight: 20,\n  },\n  sliderContainer: {\n    width: '100%',\n    paddingHorizontal: 16,\n  },\n  sliderLabels: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    paddingHorizontal: 4,\n    marginTop: 4,\n  },\n  sliderLabelText: {\n    fontSize: 12,\n    fontFamily: 'Inter-Regular',\n  },\n});\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/NotificationManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useDatabaseReady' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport * as Notifications from 'expo-notifications';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nimport {\n    NotificationOrchestrator,\n    useNotificationResponseHandler,\n} from '@/modules/notifications';\nimport { useNotificationPermissions } from '@/modules/notifications';\nimport { setupIntelligenceListeners } from '@/modules/intelligence';\nimport { setupGamificationListeners } from '@/modules/gamification';\nimport { NotificationPermissionModal } from '@/components/NotificationPermissionModal';\nimport { useTutorialStore } from '@/stores/tutorialStore';\nimport { useDatabaseReady } from '@/shared/hooks/useDatabaseReady';\n\nconst NOTIFICATION_PERMISSION_ASKED_KEY = '@weave:notification_permission_asked';\n\nexport function NotificationManager() {\n    const [showNotificationPermissionModal, setShowNotificationPermissionModal] = useState(false);\n    const hasCompletedOnboarding = useTutorialStore((state) => state.hasCompletedOnboarding);\n\n    // Need to check database/data readiness indirectly or assume it's guarded by parent\n    // But here we can use the hook just to be safe if we need 'dataLoaded' signal. \n    // We'll assume the parent (DataInitializer) only renders this when data is mostly valid, \n    // BUT strict dependency on 'dataLoaded' state from _layout is gone.\n    // Instead, we can check basic readiness if needed, or just rely on 'hasCompletedOnboarding'.\n\n    // Handle notification permission request\n    const { requestPermission: requestNotificationPermission } = useNotificationPermissions();\n    const { handleResponse } = useNotificationResponseHandler();\n\n    // Initialize Event Listeners\n    useEffect(() => {\n        setupIntelligenceListeners();\n        setupGamificationListeners();\n    }, []);\n\n    // Initialize all notification systems\n    useEffect(() => {\n        const setupNotifications = async () => {\n            try {\n                await NotificationOrchestrator.init();\n\n                const response = await Notifications.getLastNotificationResponseAsync();\n                if (response) {\n                    handleResponse(response);\n                }\n            } catch (error) {\n                console.error('[App] Failed to initialize notifications:', error);\n            }\n        };\n\n        setupNotifications();\n\n        const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            handleResponse(response);\n        });\n\n        return () => {\n            subscription.remove();\n        };\n    }, []);\n\n    // Check if we should show notification permission modal\n    useEffect(() => {\n        const checkNotificationPermissions = async () => {\n            if (!hasCompletedOnboarding) return;\n\n            try {\n                const hasAsked = await AsyncStorage.getItem(NOTIFICATION_PERMISSION_ASKED_KEY);\n                if (hasAsked === 'true') return;\n\n                const { status } = await Notifications.getPermissionsAsync();\n                if (status === 'granted') {\n                    await AsyncStorage.setItem(NOTIFICATION_PERMISSION_ASKED_KEY, 'true');\n                    return;\n                }\n\n                setTimeout(() => {\n                    setShowNotificationPermissionModal(true);\n                }, 1000);\n            } catch (error) {\n                console.error('[App] Error checking notification permissions:', error);\n            }\n        };\n\n        checkNotificationPermissions();\n    }, [hasCompletedOnboarding]);\n\n    const handleRequestNotificationPermission = async () => {\n        try {\n            const granted = await requestNotificationPermission();\n            await AsyncStorage.setItem(NOTIFICATION_PERMISSION_ASKED_KEY, 'true');\n            setShowNotificationPermissionModal(false);\n\n            if (granted) {\n                await NotificationOrchestrator.requestPermissions();\n            }\n        } catch (error) {\n            console.error('[App] Error requesting notification permissions:', error);\n            setShowNotificationPermissionModal(false);\n        }\n    };\n\n    const handleSkipNotificationPermission = async () => {\n        try {\n            await AsyncStorage.setItem(NOTIFICATION_PERMISSION_ASKED_KEY, 'true');\n            setShowNotificationPermissionModal(false);\n        } catch (error) {\n            console.error('[App] Error skipping notification permissions:', error);\n        }\n    };\n\n    return (\n        <NotificationPermissionModal\n            visible={showNotificationPermissionModal}\n            onRequestPermission={handleRequestNotificationPermission}\n            onSkip={handleSkipNotificationPermission}\n        />\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/NotificationPermissionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'X' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * NotificationPermissionModal\n * Modal component to request notification permissions from users\n * Explains the value of notifications and gracefully handles opt-out\n */\n\nimport React from 'react';\nimport { View, Text, Modal, TouchableOpacity, ScrollView } from 'react-native';\nimport { Bell, Calendar, Heart, Sparkles, X } from 'lucide-react-native';\nimport Animated, { FadeIn, FadeInDown } from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\nimport { theme } from '@/shared/theme/theme';\nimport { trackEvent } from '@/shared/services/analytics.service';\nimport { notificationAnalytics } from '@/modules/notifications';\n\ninterface NotificationPermissionModalProps {\n  visible: boolean;\n  onRequestPermission: () => void;\n  onSkip: () => void;\n}\n\nexport function NotificationPermissionModal({\n  visible,\n  onRequestPermission,\n  onSkip,\n}: NotificationPermissionModalProps) {\n  const handleRequestPermission = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    trackEvent('notification_permission_modal_enable_clicked');\n    onRequestPermission();\n  };\n\n  const handleSkip = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    notificationAnalytics.trackPermissionSkipped('modal');\n    onSkip();\n  };\n\n  React.useEffect(() => {\n    if (visible) {\n      trackEvent('notification_permission_modal_viewed');\n    }\n  }, [visible]);\n\n  return (\n    <Modal visible={visible} animationType=\"fade\" transparent>\n      <View className=\"flex-1 bg-black/50 justify-center items-center px-6\">\n        <Animated.View\n          entering={FadeIn.duration(200)}\n          className=\"bg-white dark:bg-gray-900 rounded-3xl w-full max-w-lg overflow-hidden\"\n          style={{ maxHeight: '80%' }}\n        >\n          {/* Header */}\n          <View className=\"px-6 pt-6 pb-4\">\n            <View className=\"items-center mb-4\">\n              <View\n                className=\"w-16 h-16 rounded-full items-center justify-center mb-4\"\n                style={{ backgroundColor: `${theme.colors.primary}20` }}\n              >\n                <Bell size={32} color={theme.colors.primary} />\n              </View>\n              <Text\n                className=\"text-2xl font-bold text-center mb-2\"\n                style={{ color: theme.colors.foreground, fontFamily: 'Lora_700Bold' }}\n              >\n                Stay connected with gentle nudges\n              </Text>\n              <Text\n                className=\"text-base text-center\"\n                style={{ color: theme.colors['muted-foreground'] }}\n              >\n                Weave works best when it can remind you of what matters\n              </Text>\n            </View>\n          </View>\n\n          {/* Benefits List */}\n          <ScrollView className=\"px-6 pb-4\" showsVerticalScrollIndicator={false}>\n            <Animated.View entering={FadeInDown.delay(100).duration(400)} className=\"mb-4\">\n              <NotificationBenefit\n                icon={<Calendar size={24} color={theme.colors.primary} />}\n                title=\"Event reminders\"\n                description=\"Get a gentle nudge 1 hour before planned connections\"\n              />\n            </Animated.View>\n\n            <Animated.View entering={FadeInDown.delay(200).duration(400)} className=\"mb-4\">\n              <NotificationBenefit\n                icon={<Heart size={24} color={theme.colors.primary} />}\n                title=\"Deepen reflections\"\n                description=\"Prompts to reflect on meaningful moments after you connect\"\n              />\n            </Animated.View>\n\n            <Animated.View entering={FadeInDown.delay(300).duration(400)} className=\"mb-4\">\n              <NotificationBenefit\n                icon={<Sparkles size={24} color={theme.colors.primary} />}\n                title=\"Weekly reflection\"\n                description=\"A Sunday evening invitation to reflect on your week\"\n              />\n            </Animated.View>\n\n            <Animated.View entering={FadeInDown.delay(400).duration(400)} className=\"mb-6\">\n              <NotificationBenefit\n                icon={<Bell size={24} color={theme.colors.primary} />}\n                title=\"Memory nudges\"\n                description=\"Rediscover reflections from a year ago this week\"\n              />\n            </Animated.View>\n\n            <Text\n              className=\"text-sm text-center italic mb-6\"\n              style={{ color: theme.colors['muted-foreground'] }}\n            >\n              You can always customize or disable notifications in Settings\n            </Text>\n          </ScrollView>\n\n          {/* Action Buttons */}\n          <View className=\"px-6 pb-6 gap-3\">\n            <TouchableOpacity\n              onPress={handleRequestPermission}\n              className=\"py-4 rounded-2xl items-center\"\n              style={{ backgroundColor: theme.colors.primary }}\n              activeOpacity={0.8}\n            >\n              <Text className=\"text-white text-lg font-bold\">Enable notifications</Text>\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              onPress={handleSkip}\n              className=\"py-4 rounded-2xl items-center\"\n              style={{ backgroundColor: theme.colors.muted }}\n              activeOpacity={0.7}\n            >\n              <Text style={{ color: theme.colors['muted-foreground'] }} className=\"text-base font-semibold\">\n                Maybe later\n              </Text>\n            </TouchableOpacity>\n          </View>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\ninterface NotificationBenefitProps {\n  icon: React.ReactNode;\n  title: string;\n  description: string;\n}\n\nfunction NotificationBenefit({ icon, title, description }: NotificationBenefitProps) {\n  return (\n    <View className=\"flex-row items-start gap-4\">\n      <View\n        className=\"w-12 h-12 rounded-xl items-center justify-center\"\n        style={{ backgroundColor: `${theme.colors.primary}15` }}\n      >\n        {icon}\n      </View>\n      <View className=\"flex-1\">\n        <Text\n          className=\"text-base font-semibold mb-1\"\n          style={{ color: theme.colors.foreground }}\n        >\n          {title}\n        </Text>\n        <Text\n          className=\"text-sm\"\n          style={{ color: theme.colors['muted-foreground'], lineHeight: 20 }}\n        >\n          {description}\n        </Text>\n      </View>\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/PatternBadge.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity, Alert } from 'react-native';\nimport { Clock } from 'lucide-react-native';\nimport { differenceInDays } from 'date-fns';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { useFriendPattern, getIntervalDescription } from '@/modules/insights';\nimport FriendModel from '@/db/models/Friend';\nimport { type Friend } from '@/components/types';\n\ninterface PatternBadgeProps {\n    friend: FriendModel | Friend;\n    style?: any;\n}\n\nexport const PatternBadge: React.FC<PatternBadgeProps> = ({ friend, style }) => {\n    const { colors } = useTheme();\n    const { pattern, isReliable } = useFriendPattern(friend.id);\n\n    if (!isReliable || !pattern) return null;\n\n    const daysSince = differenceInDays(new Date(), friend.lastUpdated);\n    const isOverdue = daysSince > pattern.averageIntervalDays * 1.2;\n    const isApproaching = daysSince > pattern.averageIntervalDays * 0.8 && !isOverdue;\n\n    // Determine badge color\n    let badgeColor: string = colors.muted;\n    let textColor: string = colors['muted-foreground'];\n\n    if (isOverdue) {\n        badgeColor = 'rgba(239, 68, 68, 0.15)'; // red\n        textColor = '#EF4444';\n    } else if (isApproaching) {\n        badgeColor = 'rgba(251, 146, 60, 0.15)'; // yellow\n        textColor = '#FB923C';\n    } else {\n        badgeColor = 'rgba(34, 197, 94, 0.15)'; // green\n        textColor = '#22C55E';\n    }\n\n    // Format text\n    const intervalText = getIntervalDescription(pattern.averageIntervalDays);\n\n    let timeAgoText = `${daysSince} days ago`;\n    if (daysSince === 0) timeAgoText = 'Today';\n    else if (daysSince === 1) timeAgoText = 'Yesterday';\n\n    const handlePress = () => {\n        Alert.alert(\n            \"Interaction Pattern\",\n            `Weave analyzes your history to find your natural rhythm.\\n\\n• Usual: You tend to connect with ${friend.name} ${intervalText.toLowerCase()}.\\n• Last: Your last interaction was ${timeAgoText.toLowerCase()}.`\n        );\n    };\n\n    return (\n        <TouchableOpacity\n            onPress={handlePress}\n            activeOpacity={0.7}\n            style={[styles.badge, { backgroundColor: badgeColor }, style]}\n        >\n            <Clock size={11} color={textColor} />\n            <Text style={[styles.badgeText, { color: textColor }]}>\n                You usually connect {intervalText.toLowerCase()}. Last weave: {timeAgoText}\n            </Text>\n        </TouchableOpacity>\n    );\n};\n\nconst styles = StyleSheet.create({\n    badge: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 4,\n        paddingHorizontal: 8,\n        paddingVertical: 4,\n        borderRadius: 8,\n    },\n    badgeText: {\n        fontFamily: 'Inter_500Medium',\n        fontSize: 11,\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/PlanChoiceModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/QuickWeaveProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ReactiveWidgetBase.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View } from 'react-native';\nimport withObservables from '@nozbe/with-observables';\nimport { Q } from '@nozbe/watermelondb';\n\nimport { database } from '@/db';\nimport UserProgress from '@/db/models/UserProgress';\n\ninterface ReactiveWidgetBaseProps {\n    children: (userProgress: UserProgress) => React.ReactNode;\n    userProgress?: UserProgress[]; // Array because observe() returns an array for queries\n}\n\nconst ReactiveWidgetBaseContent = ({ children, userProgress }: ReactiveWidgetBaseProps) => {\n    // Since UserProgress is a singleton, valid data is the first item\n    const progress = userProgress?.[0];\n\n    if (!progress) {\n        // Optionally return null or a loading state if data isn't ready\n        return null;\n    }\n\n    return <>{children(progress)}</>;\n};\n\n// Observe the UserProgress table. Since it's a singleton, we know there's only one relevant row.\n// HACK: WatermelonDB usually requires consistent queries.\n// We query essentially \"all\" but expecting just the singleton.\nconst enhance = withObservables([], () => ({\n    userProgress: database.get<UserProgress>('user_progress').query().observe(),\n}));\n\nexport const ReactiveWidgetBase = enhance(ReactiveWidgetBaseContent);\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ReciprocitySelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ReflectionStoryChips.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ReflectionTextInput.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StoryChip' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, Text, TouchableOpacity, TextInput, StyleSheet, Modal } from 'react-native';\nimport Animated, { FadeIn, FadeInDown } from 'react-native-reanimated';\nimport { X } from 'lucide-react-native';\nimport { STORY_CHIPS, type StoryChip } from '@/modules/reflection';\nimport { type ReflectionChip } from '@/components/types';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\ninterface ReflectionTextInputProps {\n  chips: ReflectionChip[];\n  customText: string;\n  onComponentChange: (chipIndex: number, componentId: string, value: string) => void;\n  onCustomTextChange: (text: string) => void;\n  onRemoveChip: (chipIndex: number) => void;\n  placeholder?: string;\n}\n\n/**\n * Text input that displays multiple sentence chips as inline bubble cards\n * User can tap colored words to customize, and type after chips\n */\nexport function ReflectionTextInput({\n  chips,\n  customText,\n  onComponentChange,\n  onCustomTextChange,\n  onRemoveChip,\n  placeholder = 'Or write your own...',\n}: ReflectionTextInputProps) {\n  const { colors } = useTheme();\n  const [editingChip, setEditingChip] = useState<{ chipIndex: number; componentId: string } | null>(null);\n\n  // Parse a chip's template to find tappable components\n  const parseChipParts = (chip: ReflectionChip) => {\n    const storyChip = STORY_CHIPS.find(s => s.id === chip.chipId);\n    if (!storyChip) return [];\n\n    const parts: Array<{ type: 'text' | 'component'; value: string; componentId?: string }> = [];\n    const remaining = storyChip.template;\n    const regex = /\\{([^}]+)\\}/g;\n    let lastIndex = 0;\n    let match;\n\n    while ((match = regex.exec(storyChip.template)) !== null) {\n      if (match.index > lastIndex) {\n        parts.push({\n          type: 'text',\n          value: remaining.substring(lastIndex, match.index),\n        });\n      }\n\n      const componentId = match[1];\n      const component = storyChip.components?.[componentId];\n      if (!component) continue;\n\n      const value = chip.componentOverrides[componentId] || component.original;\n\n      parts.push({\n        type: 'component',\n        value,\n        componentId,\n      });\n\n      lastIndex = match.index + match[0].length;\n    }\n\n    if (lastIndex < storyChip.template.length) {\n      parts.push({\n        type: 'text',\n        value: remaining.substring(lastIndex),\n      });\n    }\n\n    return parts;\n  };\n\n  return (\n    <View style={styles.container}>\n      {/* Combined container - chip bubbles + text input together */}\n      <View\n        style={[\n          styles.inputContainer,\n          {\n            backgroundColor: colors.card,\n            borderColor: colors.border,\n          },\n        ]}\n      >\n        {/* Multiple chip bubbles */}\n        {chips.map((chip, chipIndex) => {\n          const chipParts = parseChipParts(chip);\n\n          return (\n            <Animated.View\n              key={chipIndex}\n              entering={FadeIn.duration(300)}\n              style={[\n                styles.chipBubble,\n                {\n                  backgroundColor: colors.muted,\n                  borderColor: colors.border,\n                },\n              ]}\n            >\n              {/* Chip text with tappable components */}\n              <View style={styles.chipContent}>\n                <Text style={[styles.chipText, { color: colors.foreground }]}>\n                  {chipParts.map((part, partIndex) => {\n                    if (part.type === 'text') {\n                      return (\n                        <Text key={partIndex}>\n                          {part.value}\n                        </Text>\n                      );\n                    }\n\n                    return (\n                      <Text\n                        key={partIndex}\n                        style={[styles.tappableText, { color: colors.primary }]}\n                        onPress={() =>\n                          setEditingChip({ chipIndex, componentId: part.componentId! })\n                        }\n                      >\n                        {part.value}\n                      </Text>\n                    );\n                  })}\n                </Text>\n              </View>\n\n              {/* Remove chip button */}\n              <TouchableOpacity\n                style={styles.removeChip}\n                onPress={() => onRemoveChip(chipIndex)}\n                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}\n              >\n                <X size={16} color={colors['muted-foreground']} />\n              </TouchableOpacity>\n            </Animated.View>\n          );\n        })}\n\n        {/* Text input for additional notes */}\n        <TextInput\n          style={[\n            styles.textInput,\n            {\n              color: colors.foreground,\n            },\n          ]}\n          placeholder={chips.length > 0 ? 'Add more details...' : placeholder}\n          placeholderTextColor={colors['muted-foreground']}\n          value={customText}\n          onChangeText={onCustomTextChange}\n          multiline\n          textAlignVertical=\"top\"\n        />\n      </View>\n\n      {/* Component editor modal */}\n      {editingChip && (\n        <Modal\n          visible={true}\n          transparent\n          animationType=\"none\"\n          onRequestClose={() => setEditingChip(null)}\n        >\n          <Animated.View entering={FadeIn.duration(200)} style={styles.modalOverlay}>\n            <TouchableOpacity\n              style={StyleSheet.absoluteFill}\n              activeOpacity={1}\n              onPress={() => setEditingChip(null)}\n            >\n              <View style={[StyleSheet.absoluteFill, { backgroundColor: 'rgba(0, 0, 0, 0.5)' }]} />\n            </TouchableOpacity>\n\n            <Animated.View\n              entering={FadeInDown.duration(300).springify()}\n              style={styles.bubbleMenu}\n            >\n              <Text style={styles.modalTitle}>Choose alternative</Text>\n\n              {(() => {\n                const chip = chips[editingChip.chipIndex];\n                const storyChip = STORY_CHIPS.find(s => s.id === chip.chipId);\n                if (!storyChip || !storyChip.components) return null;\n\n                const component = storyChip.components[editingChip.componentId];\n                if (!component) return null;\n\n                const currentValue =\n                  chip.componentOverrides[editingChip.componentId] || component.original;\n\n                return [component.original, ...component.alternatives].map((option, index) => {\n                  const isSelected = currentValue === option;\n\n                  return (\n                    <Animated.View\n                      key={index}\n                      entering={FadeInDown.duration(300).delay(index * 50)}\n                    >\n                      <TouchableOpacity\n                        style={[\n                          styles.bubbleButton,\n                          {\n                            backgroundColor: isSelected ? colors.primary : colors.card,\n                            borderColor: isSelected ? colors.primary : colors.border,\n                          },\n                        ]}\n                        onPress={() => {\n                          onComponentChange(editingChip.chipIndex, editingChip.componentId, option);\n                          setEditingChip(null);\n                        }}\n                        activeOpacity={0.7}\n                      >\n                        <Text\n                          style={[\n                            styles.bubbleText,\n                            {\n                              color: isSelected ? colors['primary-foreground'] : colors.foreground,\n                              fontWeight: isSelected ? '600' : '500',\n                            },\n                          ]}\n                        >\n                          {option}\n                        </Text>\n                      </TouchableOpacity>\n                    </Animated.View>\n                  );\n                });\n              })()}\n\n              <TouchableOpacity\n                style={styles.closeButtonCircle}\n                onPress={() => setEditingChip(null)}\n              >\n                <X size={24} color={colors.foreground} />\n              </TouchableOpacity>\n            </Animated.View>\n          </Animated.View>\n        </Modal>\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    gap: 0,\n  },\n  inputContainer: {\n    borderWidth: 1.5,\n    borderRadius: 16,\n    padding: 16,\n    minHeight: 120,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.05,\n    shadowRadius: 8,\n    elevation: 2,\n  },\n  chipBubble: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: 10,\n    paddingLeft: 14,\n    paddingRight: 10,\n    borderRadius: 20,\n    borderWidth: 1,\n    marginBottom: 12,\n  },\n  chipContent: {\n    flex: 1,\n  },\n  chipText: {\n    fontSize: 15,\n    lineHeight: 22,\n  },\n  tappableText: {\n    fontWeight: '600',\n  },\n  removeChip: {\n    padding: 4,\n    marginLeft: 8,\n  },\n  textInput: {\n    fontSize: 16,\n    lineHeight: 24,\n    minHeight: 40,\n    padding: 0,\n  },\n  modalOverlay: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  bubbleMenu: {\n    width: '80%',\n    maxWidth: 400,\n    gap: 12,\n    paddingBottom: 80,\n  },\n  modalTitle: {\n    fontSize: 18,\n    fontWeight: '600',\n    textAlign: 'center',\n    marginBottom: 12,\n    color: '#fff',\n  },\n  bubbleButton: {\n    paddingVertical: 18,\n    paddingHorizontal: 24,\n    borderRadius: 24,\n    borderWidth: 0,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.08,\n    shadowRadius: 12,\n    elevation: 3,\n  },\n  bubbleText: {\n    fontSize: 16,\n    textAlign: 'center',\n    letterSpacing: 0.3,\n  },\n  closeButtonCircle: {\n    width: 60,\n    height: 60,\n    borderRadius: 30,\n    backgroundColor: '#fff',\n    justifyContent: 'center',\n    alignItems: 'center',\n    alignSelf: 'center',\n    marginTop: 20,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.2,\n    shadowRadius: 8,\n    elevation: 6,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SeasonEffectsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SeasonExplanationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SeasonIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SeasonOverrideModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SimpleTutorialTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SocialSeasonDetailSheet.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SEASON_STYLES' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Friend' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'networkHealth' is defined but never used. Allowed unused args must match /^_/u.","line":48,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":48,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'weeklyWeaves' is defined but never used. Allowed unused args must match /^_/u.","line":160,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":160,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentStreak' is defined but never used. Allowed unused args must match /^_/u.","line":161,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":161,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":168,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":168,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport {\n    View,\n    Text,\n    TouchableOpacity,\n    ScrollView,\n    StyleSheet,\n} from 'react-native';\nimport { Activity, BarChart3, Scale, ChevronLeft, ChevronRight, Zap, Book, CheckCircle2 } from 'lucide-react-native';\nimport { startOfMonth, endOfMonth, eachDayOfInterval, format, isSameDay, startOfWeek, endOfWeek, addMonths, subMonths } from 'date-fns';\nimport { Q } from '@nozbe/watermelondb';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { AnimatedBottomSheet } from '@/shared/ui/Sheet';\nimport { type SocialSeason, type SeasonExplanationData } from '@/modules/intelligence';\nimport { SEASON_STYLES, getSeasonDisplayName } from '@/modules/intelligence';\nimport { generateSeasonExplanation } from '@/modules/reflection';\nimport { GraphsTabContent } from './YearInMoons/GraphsTabContentV2';\nimport { TierBalanceContent } from './TierBalanceContent';\nimport { SeasonEffectsPanel } from './SeasonEffectsPanel';\nimport { database } from '@/db';\nimport Interaction from '@/db/models/Interaction';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport { useUserProfileStore } from '@/modules/auth';\nimport { Card } from '@/components/ui/Card';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport { Stat } from '@/components/ui/Stat';\nimport Friend from '@/db/models/Friend';\n\ninterface SocialSeasonDetailSheetProps {\n    isVisible: boolean;\n    onClose: () => void;\n    season: SocialSeason;\n    seasonData: SeasonExplanationData | null;\n    weeklyWeaves: number;\n    currentStreak: number;\n    networkHealth: number;\n}\n\ntype Tab = 'pulse' | 'alignment' | 'insights';\n\nexport function SocialSeasonDetailSheet({\n    isVisible,\n    onClose,\n    season,\n    seasonData,\n    weeklyWeaves,\n    currentStreak,\n    networkHealth,\n}: SocialSeasonDetailSheetProps) {\n    const { tokens, typography, spacing, isDarkMode } = useTheme();\n    const [currentTab, setCurrentTab] = useState<Tab>('pulse');\n\n    return (\n        <AnimatedBottomSheet\n            visible={isVisible}\n            onClose={onClose}\n            height=\"full\"\n            scrollable\n        >\n            {/* Header */}\n            <View style={styles.header}>\n                <View>\n                    <Text style={[styles.title, { color: tokens.foreground, fontFamily: typography.fonts.serifBold }]}>\n                        {getSeasonDisplayName(season)}\n                    </Text>\n                    <Text style={[styles.subtitle, { color: tokens.foregroundMuted, fontFamily: typography.fonts.sans }]}>\n                        Network Health & Insights\n                    </Text>\n                </View>\n            </View>\n\n            {/* Tabs */}\n            <View style={styles.tabContainer}>\n                <TouchableOpacity\n                    onPress={() => setCurrentTab('pulse')}\n                    style={[\n                        styles.tab,\n                        currentTab === 'pulse' && { backgroundColor: tokens.background },\n                        currentTab === 'pulse' && { borderColor: tokens.border, borderWidth: 1 },\n                    ]}\n                >\n                    <Activity size={16} color={currentTab === 'pulse' ? tokens.primary : tokens.foregroundMuted} />\n                    <Text style={[\n                        styles.tabText,\n                        {\n                            color: currentTab === 'pulse' ? tokens.primary : tokens.foregroundMuted,\n                            fontFamily: typography.fonts.sansMedium\n                        }\n                    ]}>\n                        Pulse\n                    </Text>\n                </TouchableOpacity>\n\n                <TouchableOpacity\n                    onPress={() => setCurrentTab('alignment')}\n                    style={[\n                        styles.tab,\n                        currentTab === 'alignment' && { backgroundColor: tokens.background },\n                        currentTab === 'alignment' && { borderColor: tokens.border, borderWidth: 1 },\n                    ]}\n                >\n                    <Scale size={16} color={currentTab === 'alignment' ? tokens.primary : tokens.foregroundMuted} />\n                    <Text style={[\n                        styles.tabText,\n                        {\n                            color: currentTab === 'alignment' ? tokens.primary : tokens.foregroundMuted,\n                            fontFamily: typography.fonts.sansMedium\n                        }\n                    ]}>\n                        Alignment\n                    </Text>\n                </TouchableOpacity>\n\n                <TouchableOpacity\n                    onPress={() => setCurrentTab('insights')}\n                    style={[\n                        styles.tab,\n                        currentTab === 'insights' && { backgroundColor: tokens.background },\n                        currentTab === 'insights' && { borderColor: tokens.border, borderWidth: 1 },\n                    ]}\n                >\n                    <BarChart3 size={16} color={currentTab === 'insights' ? tokens.primary : tokens.foregroundMuted} />\n                    <Text style={[\n                        styles.tabText,\n                        {\n                            color: currentTab === 'insights' ? tokens.primary : tokens.foregroundMuted,\n                            fontFamily: typography.fonts.sansMedium\n                        }\n                    ]}>\n                        Insights\n                    </Text>\n                </TouchableOpacity>\n            </View>\n\n            <View>\n                {currentTab === 'pulse' && (\n                    <PulseTabContent\n                        season={season}\n                        seasonData={seasonData}\n                        weeklyWeaves={weeklyWeaves}\n                        currentStreak={currentStreak}\n                    />\n                )}\n\n                {currentTab === 'alignment' && (\n                    <TierBalanceContent />\n                )}\n\n                {currentTab === 'insights' && (\n                    <GraphsTabContent />\n                )}\n            </View>\n        </AnimatedBottomSheet>\n    );\n}\n\nfunction PulseTabContent({\n    season,\n    seasonData,\n    weeklyWeaves,\n    currentStreak,\n}: {\n    season: SocialSeason;\n    seasonData: SeasonExplanationData | null;\n    weeklyWeaves: number;\n    currentStreak: number;\n}) {\n    const { tokens, typography, spacing, isDarkMode } = useTheme();\n    const explanation = seasonData ? generateSeasonExplanation(seasonData) : null;\n    const { profile } = useUserProfileStore();\n\n    // State for navigation and selection\n    const [currentMonth, setCurrentMonth] = useState(new Date());\n    const [selectedDate, setSelectedDate] = useState<Date | null>(null);\n\n    // Stats for the displayed month\n    const [monthlyActivity, setMonthlyActivity] = useState<Map<string, boolean>>(new Map());\n    const [completedWeaves, setCompletedWeaves] = useState<Map<string, boolean>>(new Map());\n    const [monthlyWeavesCount, setMonthlyWeavesCount] = useState(0);\n    const [totalWeaves, setTotalWeaves] = useState(0);\n    const [totalDaysActive, setTotalDaysActive] = useState(0);\n\n    // Detailed data for the selected day\n    const [dayDetails, setDayDetails] = useState<{\n        weaves: { id: string; name: string; type: string; status: string }[];\n        hasJournal: boolean;\n        hasCheckin: boolean;\n        isLoading: boolean;\n    } | null>(null);\n\n    useEffect(() => {\n        loadMonthlyStats(currentMonth);\n    }, [currentMonth]);\n\n    useEffect(() => {\n        if (selectedDate) {\n            loadDayDetails(selectedDate);\n        } else {\n            setDayDetails(null);\n        }\n    }, [selectedDate]);\n\n    const loadMonthlyStats = async (date: Date) => {\n        try {\n            const monthStart = startOfMonth(date);\n            const monthEnd = endOfMonth(date);\n\n            const monthlyInteractions = await database\n                .get<Interaction>('interactions')\n                .query(\n                    Q.where('status', 'completed'),\n                    Q.where('interaction_date', Q.gte(monthStart.getTime())),\n                    Q.where('interaction_date', Q.lte(monthEnd.getTime()))\n                )\n                .fetch();\n\n            setMonthlyWeavesCount(monthlyInteractions.length);\n\n            const activityMap = new Map<string, boolean>();\n            const completedWeavesMap = new Map<string, boolean>();\n\n            monthlyInteractions.forEach(interaction => {\n                const dateKey = format(interaction.interactionDate, 'yyyy-MM-dd');\n                activityMap.set(dateKey, true);\n                completedWeavesMap.set(dateKey, true);\n            });\n\n            // Check for other activity (Battery, Journal) to mark \"activity\" days\n            const days = eachDayOfInterval({ start: monthStart, end: monthEnd });\n\n            // We need to fetch reflections for the whole month efficiently\n            const monthlyReflections = await database\n                .get<WeeklyReflection>('weekly_reflections')\n                .query(\n                    Q.where('created_at', Q.gte(monthStart.getTime())),\n                    Q.where('created_at', Q.lte(monthEnd.getTime()))\n                )\n                .fetch();\n\n            const reflectionSet = new Set(monthlyReflections.map(r => format(new Date(r.createdAt), 'yyyy-MM-dd')));\n\n            // Check local profile battery history\n            const batteryHistory = profile?.socialBatteryHistory || [];\n\n            for (const day of days) {\n                const dayStart = day.getTime();\n                const dayEnd = dayStart + 24 * 60 * 60 * 1000;\n                const dateKey = format(day, 'yyyy-MM-dd');\n\n                if (!activityMap.has(dateKey)) {\n                    const hasBattery = batteryHistory.some(entry => entry.timestamp >= dayStart && entry.timestamp < dayEnd);\n                    const hasJournal = reflectionSet.has(dateKey);\n\n                    if (hasBattery || hasJournal) {\n                        activityMap.set(dateKey, true);\n                    }\n                }\n            }\n\n            setMonthlyActivity(activityMap);\n            setCompletedWeaves(completedWeavesMap);\n\n            // Global stats (Total Weaves & Active Days) - these are lifetime stats\n            const allCompletedWeavesCount = await database\n                .get<Interaction>('interactions')\n                .query(Q.where('status', 'completed'))\n                .fetchCount();\n\n            setTotalWeaves(allCompletedWeavesCount);\n\n            const allInteractions = await database\n                .get<Interaction>('interactions')\n                .query(Q.where('status', 'completed'))\n                .fetch();\n\n            const uniqueDays = new Set<string>();\n            allInteractions.forEach(interaction => {\n                const dateKey = format(interaction.interactionDate, 'yyyy-MM-dd');\n                uniqueDays.add(dateKey);\n            });\n\n            setTotalDaysActive(uniqueDays.size);\n\n        } catch (error) {\n            console.error('Error loading monthly stats:', error);\n        }\n    };\n\n    const loadDayDetails = async (date: Date) => {\n        setDayDetails(prev => ({ ...prev, weaves: [], hasJournal: false, hasCheckin: false, isLoading: true }));\n        try {\n            const dayStart = date.getTime();\n            const nextDay = new Date(date);\n            nextDay.setDate(date.getDate() + 1);\n            nextDay.setHours(0, 0, 0, 0);\n            const dayEnd = nextDay.getTime();\n\n            // Fetch interactions\n            const dayInteractions = await database\n                .get<Interaction>('interactions')\n                .query(\n                    Q.where('status', Q.oneOf(['completed', 'planned'])),\n                    Q.where('interaction_date', Q.gte(dayStart)),\n                    Q.where('interaction_date', Q.lt(dayEnd))\n                )\n                .fetch();\n\n            // Enrich interactions with Friend names\n            const enrichedWeaves = await Promise.all(\n                dayInteractions.map(async (interaction) => {\n                    const interactionFriends = await interaction.interactionFriends.fetch();\n                    const friends = await Promise.all(interactionFriends.map((ifriend: any) => ifriend.friend.fetch()));\n                    const names = friends.map((f: any) => f.name).join(', ');\n                    return {\n                        id: interaction.id,\n                        name: names || 'Unknown Friend',\n                        type: interaction.interactionType,\n                        status: interaction.status\n                    };\n                })\n            );\n\n            // Check Check-in\n            const hasCheckin = (profile?.socialBatteryHistory || []).some(\n                entry => entry.timestamp >= dayStart && entry.timestamp < dayEnd\n            );\n\n            // Check Journal\n            const journalCount = await database\n                .get<WeeklyReflection>('weekly_reflections')\n                .query(\n                    Q.where('created_at', Q.gte(dayStart)),\n                    Q.where('created_at', Q.lt(dayEnd))\n                )\n                .fetchCount();\n\n            setDayDetails({\n                weaves: enrichedWeaves,\n                hasJournal: journalCount > 0,\n                hasCheckin: hasCheckin,\n                isLoading: false\n            });\n\n        } catch (error) {\n            console.error('Error loading day details:', error);\n            setDayDetails({ weaves: [], hasJournal: false, hasCheckin: false, isLoading: false });\n        }\n    };\n\n    const handlePrevMonth = () => setCurrentMonth(subMonths(currentMonth, 1));\n    const handleNextMonth = () => setCurrentMonth(addMonths(currentMonth, 1));\n\n    const monthStart = startOfMonth(currentMonth);\n    const monthEnd = endOfMonth(currentMonth);\n    const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 });\n    const calendarEnd = endOfWeek(monthEnd, { weekStartsOn: 1 });\n    const calendarDays = eachDayOfInterval({ start: calendarStart, end: calendarEnd });\n\n    return (\n        <View style={{ gap: spacing[6], paddingHorizontal: 16, paddingBottom: 20 }}>\n            {/* Season Explanation */}\n            {explanation && (\n                <View style={{ gap: 16 }}>\n                    <Card variant=\"elevated\">\n                        <Text style={{\n                            color: tokens.foreground,\n                            fontFamily: typography.fonts.serifBold,\n                            fontSize: typography.scale.h3.fontSize,\n                            marginBottom: spacing[2]\n                        }}>\n                            {explanation.headline}\n                        </Text>\n                        <Text style={{\n                            color: tokens.foregroundMuted,\n                            fontFamily: typography.fonts.sans,\n                            fontSize: typography.scale.body.fontSize,\n                            lineHeight: typography.scale.body.lineHeight\n                        }}>\n                            {explanation.insight}\n                        </Text>\n                    </Card>\n                    <SeasonEffectsPanel season={season} />\n                </View>\n            )}\n\n            {/* Calendar */}\n            <Card>\n                <View style={[styles.header, { paddingHorizontal: 0, marginBottom: 12 }]}>\n                    <View>\n                        <Text style={{\n                            color: tokens.foreground,\n                            fontFamily: typography.fonts.serifBold,\n                            fontSize: 18\n                        }}>\n                            Rhythm\n                        </Text>\n                        <Text style={{\n                            color: tokens.foregroundMuted,\n                            fontFamily: typography.fonts.sans,\n                            fontSize: 14\n                        }}>\n                            {format(currentMonth, 'MMMM yyyy')}\n                        </Text>\n                    </View>\n                    <View style={{ flexDirection: 'row', gap: 8 }}>\n                        <TouchableOpacity onPress={handlePrevMonth} style={styles.navButton}>\n                            <ChevronLeft size={20} color={tokens.foreground} />\n                        </TouchableOpacity>\n                        <TouchableOpacity onPress={handleNextMonth} style={styles.navButton}>\n                            <ChevronRight size={20} color={tokens.foreground} />\n                        </TouchableOpacity>\n                    </View>\n                </View>\n\n                {/* Legend */}\n                <View style={styles.legendContainer}>\n                    <View style={styles.legendItem}>\n                        <View style={[styles.legendDot, { backgroundColor: tokens.primary }]} />\n                        <Text style={[styles.legendText, { color: tokens.foregroundMuted }]}>Weave</Text>\n                    </View>\n                    <View style={styles.legendItem}>\n                        <View style={[styles.legendDot, { backgroundColor: tokens.primary + '20' }]} />\n                        <Text style={[styles.legendText, { color: tokens.foregroundMuted }]}>Activity</Text>\n                    </View>\n                </View>\n\n                <View style={styles.calendarHeader}>\n                    {['M', 'T', 'W', 'T', 'F', 'S', 'S'].map((day, index) => (\n                        <Text key={index} style={[styles.dayLabel, { color: tokens.foregroundMuted, fontFamily: typography.fonts.sansMedium }]}>\n                            {day}\n                        </Text>\n                    ))}\n                </View>\n\n                <View style={styles.calendarGrid}>\n                    {calendarDays.map((day, index) => {\n                        const dateKey = format(day, 'yyyy-MM-dd');\n                        const hasActivity = monthlyActivity.get(dateKey) || false;\n                        const hasCompletedWeave = completedWeaves.get(dateKey) || false;\n                        const isCurrentMonth = day.getMonth() === currentMonth.getMonth();\n                        const isSelected = selectedDate && isSameDay(day, selectedDate);\n\n                        return (\n                            <TouchableOpacity\n                                key={index}\n                                style={styles.dayCell}\n                                onPress={() => setSelectedDate(day)}\n                            >\n                                <View style={[\n                                    styles.dayContent,\n                                    hasActivity && { backgroundColor: tokens.primary + '20' },\n                                    hasCompletedWeave && { backgroundColor: tokens.primary },\n                                    isSelected && { borderWidth: 2, borderColor: tokens.foreground },\n                                    !isCurrentMonth && { opacity: 0.3 }\n                                ]}>\n                                    <Text style={[\n                                        styles.dayText,\n                                        {\n                                            color: hasCompletedWeave ? tokens.primaryForeground : tokens.foreground,\n                                            fontFamily: isSelected ? typography.fonts.sansSemiBold : (hasCompletedWeave ? typography.fonts.sansSemiBold : typography.fonts.sans)\n                                        }\n                                    ]}>\n                                        {day.getDate()}\n                                    </Text>\n                                </View>\n                            </TouchableOpacity>\n                        );\n                    })}\n                </View>\n            </Card>\n\n            {/* Selected Day Details */}\n            {selectedDate && (\n                <Card>\n                    <WidgetHeader\n                        title={isSameDay(selectedDate, new Date()) ? \"Today's Pulse\" : `Pulse for ${format(selectedDate, 'MMM d')}`}\n                        subtitle={dayDetails?.isLoading ? \"Loading...\" : (!dayDetails?.weaves.length && !dayDetails?.hasCheckin && !dayDetails?.hasJournal ? \"No activity recorded\" : \"\")}\n                    />\n\n                    {!dayDetails?.isLoading && (\n                        <View style={{ gap: 12 }}>\n                            {dayDetails?.weaves.map(weave => (\n                                <View key={weave.id} style={styles.detailRow}>\n                                    <View style={[styles.iconBox, { backgroundColor: tokens.primary + '20' }]}>\n                                        <CheckCircle2 size={16} color={tokens.primary} />\n                                    </View>\n                                    <View>\n                                        <Text style={[styles.detailText, { color: tokens.foreground, fontFamily: typography.fonts.sansMedium }]}>\n                                            Weave with {weave.name}\n                                        </Text>\n                                        <Text style={[styles.detailSubtext, { color: tokens.foregroundMuted }]}>\n                                            {weave.type} {weave.status === 'planned' ? '(Planned)' : ''}\n                                        </Text>\n                                    </View>\n                                </View>\n                            ))}\n\n                            {dayDetails?.hasCheckin && (\n                                <View style={styles.detailRow}>\n                                    <View style={[styles.iconBox, { backgroundColor: tokens.destructive + '20' }]}>\n                                        <Zap size={16} color={tokens.destructive} />\n                                    </View>\n                                    <Text style={[styles.detailText, { color: tokens.foreground, fontFamily: typography.fonts.sansMedium }]}>\n                                        Social Battery Check-in\n                                    </Text>\n                                </View>\n                            )}\n\n                            {dayDetails?.hasJournal && (\n                                <View style={styles.detailRow}>\n                                    <View style={[styles.iconBox, { backgroundColor: tokens.mystic.accent + '20' }]}>\n                                        <Book size={16} color={tokens.mystic.accent} />\n                                    </View>\n                                    <Text style={[styles.detailText, { color: tokens.foreground, fontFamily: typography.fonts.sansMedium }]}>\n                                        Journal Entry\n                                    </Text>\n                                </View>\n                            )}\n                        </View>\n                    )}\n                </Card>\n            )}\n\n            {/* Stats */}\n            <Card>\n                <WidgetHeader title=\"History\" />\n                <View style={styles.statsGrid}>\n                    <Stat label=\"Total Weaves\" value={totalWeaves} />\n                    <Stat label=\"Active Days\" value={totalDaysActive} />\n                    <Stat label=\"This Month\" value={monthlyWeavesCount} />\n                </View>\n            </Card>\n        </View>\n    );\n}\n\nconst styles = StyleSheet.create({\n    overlay: {\n        flex: 1,\n        justifyContent: 'flex-end',\n    },\n    sheet: {\n        borderTopLeftRadius: 24,\n        borderTopRightRadius: 24,\n        height: '90%',\n        paddingTop: 20,\n    },\n    header: {\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        paddingHorizontal: 20,\n        marginBottom: 20,\n    },\n    title: {\n        fontSize: 24,\n    },\n    subtitle: {\n        fontSize: 14,\n    },\n    closeButton: {\n        padding: 4,\n    },\n    tabContainer: {\n        flexDirection: 'row',\n        paddingHorizontal: 20,\n        marginBottom: 20,\n        gap: 12,\n    },\n    tab: {\n        flex: 1,\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingVertical: 10,\n        borderRadius: 12,\n        gap: 8,\n    },\n    tabText: {\n        fontSize: 14,\n    },\n    content: {\n        paddingHorizontal: 20,\n        paddingBottom: 40,\n    },\n    calendarHeader: {\n        flexDirection: 'row',\n        marginBottom: 8,\n    },\n    dayLabel: {\n        flex: 1,\n        textAlign: 'center',\n        fontSize: 12,\n    },\n    calendarGrid: {\n        flexDirection: 'row',\n        flexWrap: 'wrap',\n    },\n    dayCell: {\n        width: '14.28%',\n        aspectRatio: 1,\n        padding: 2,\n    },\n    dayContent: {\n        flex: 1,\n        alignItems: 'center',\n        justifyContent: 'center',\n        borderRadius: 8,\n    },\n    dayText: {\n        fontSize: 12,\n    },\n    statsGrid: {\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n    },\n    navButton: {\n        padding: 8,\n    },\n    legendContainer: {\n        flexDirection: 'row',\n        justifyContent: 'flex-start',\n        gap: 16,\n        marginBottom: 16,\n    },\n    legendItem: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 6,\n    },\n    legendDot: {\n        width: 8,\n        height: 8,\n        borderRadius: 4,\n    },\n    legendText: {\n        fontSize: 12,\n    },\n    detailRow: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 12,\n    },\n    iconBox: {\n        width: 32,\n        height: 32,\n        borderRadius: 8,\n        alignItems: 'center',\n        justifyContent: 'center',\n    },\n    detailText: {\n        fontSize: 14,\n    },\n    detailSubtext: {\n        fontSize: 12,\n    }\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/SuggestionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/TierBalanceContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isGood' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":196,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":196,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport {\n    View,\n    Text,\n    TouchableOpacity,\n    StyleSheet,\n    ScrollView,\n    ActivityIndicator,\n} from 'react-native';\nimport { AlertCircle, CheckCircle, TrendingUp, ChevronDown, ChevronUp } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { useNetworkTierHealth, TierFitBottomSheet } from '@/modules/insights';\nimport type { Tier } from '@/shared/types/core';\nimport type { TierFitAnalysis } from '@/modules/insights';\nimport { changeFriendTier, dismissTierSuggestion } from '@/modules/insights';\nimport { useUIStore } from '@/stores/uiStore';\n\nconst TIER_DISPLAY_NAMES: Record<Tier, string> = {\n    InnerCircle: 'Inner Circle',\n    CloseFriends: 'Close Friends',\n    Community: 'Community',\n};\n\nexport const TierBalanceContent: React.FC = () => {\n    const { colors } = useTheme();\n    const { networkHealth, isLoading } = useNetworkTierHealth();\n\n    const [selectedAnalysis, setSelectedAnalysis] = useState<TierFitAnalysis | null>(null);\n    const [expandedTiers, setExpandedTiers] = useState<Set<Tier>>(new Set(['InnerCircle']));\n\n    const toggleTier = (tier: Tier) => {\n        setExpandedTiers((prev) => {\n            const next = new Set(prev);\n            if (next.has(tier)) {\n                next.delete(tier);\n            } else {\n                next.add(tier);\n            }\n            return next;\n        });\n    };\n\n    const handleChangeTier = async (friendId: string, newTier: Tier, friendName: string) => {\n        try {\n            await changeFriendTier(friendId, newTier, true);\n            // Dismiss modal first\n            setSelectedAnalysis(null);\n\n            // Show toast after slight delay to allow modal to close\n            setTimeout(() => {\n                useUIStore.getState().showToast(`Moved ${friendName} to ${TIER_DISPLAY_NAMES[newTier]}`, friendName);\n            }, 400);\n        } catch (error) {\n            console.error('Failed to change tier:', error);\n        }\n    };\n\n    const handleStayInTier = async (friendId: string) => {\n        try {\n            await dismissTierSuggestion(friendId);\n            setSelectedAnalysis(null);\n        } catch (error) {\n            console.error('Failed to dismiss suggestion:', error);\n        }\n    };\n\n    const handleDismissSuggestion = async (friendId: string) => {\n        try {\n            await dismissTierSuggestion(friendId);\n            setSelectedAnalysis(null);\n        } catch (error) {\n            console.error('Failed to dismiss suggestion:', error);\n        }\n    };\n\n    if (isLoading) {\n        return (\n            <View style={styles.loadingContainer}>\n                <ActivityIndicator size=\"large\" color={colors.primary} />\n            </View>\n        );\n    }\n\n    if (!networkHealth) {\n        return (\n            <View style={styles.emptyContainer}>\n                <Text style={[styles.emptyText, { color: colors['muted-foreground'] }]}>\n                    No tier data available yet\n                </Text>\n            </View>\n        );\n    }\n\n    const getHealthColor = (score: number) => {\n        if (score >= 8) return '#10B981';\n        if (score >= 5) return '#F59E0B';\n        return '#EF4444';\n    };\n\n    const healthColor = getHealthColor(networkHealth.healthScore);\n\n    return (\n        <View style={styles.container}>\n            <ScrollView style={styles.content} contentContainerStyle={styles.contentContainer}>\n                {/* Overall Health */}\n                <View style={[styles.healthCard, { backgroundColor: colors.card, borderColor: colors.border }]}>\n                    <Text style={[styles.healthTitle, { color: colors.foreground }]}>\n                        Overall Health\n                    </Text>\n\n                    <View style={styles.healthScoreRow}>\n                        <View style={styles.healthBarContainer}>\n                            <View\n                                style={[styles.healthBarFill, { width: `${networkHealth.healthScore * 10}%`, backgroundColor: healthColor }]}\n                            />\n                        </View>\n                        <Text style={[styles.healthScore, { color: healthColor }]}>\n                            {networkHealth.healthScore}/10\n                        </Text>\n                    </View>\n\n                    <Text style={[styles.healthSummary, { color: colors['muted-foreground'] }]}>\n                        {networkHealth.healthScore >= 8\n                            ? 'Your tiers mostly match your actual patterns. Great job!'\n                            : networkHealth.healthScore >= 5\n                                ? `Your tiers mostly match, but ${networkHealth.mismatches.length} ${networkHealth.mismatches.length === 1 ? 'friend' : 'friends'} could use adjustment.`\n                                : `${networkHealth.mismatches.length} friends have tier mismatches that may cause stress.`}\n                    </Text>\n                </View>\n\n                {/* Per-Tier Sections */}\n                {(['InnerCircle', 'CloseFriends', 'Community'] as Tier[]).map((tier) => {\n                    const tierHealth = networkHealth.tierHealth[tier];\n                    const isExpanded = expandedTiers.has(tier);\n\n                    // Get ALL friends in this tier\n                    const tierFriends = networkHealth.allAnalyses.filter((a) => a.currentTier === tier);\n\n                    const tierMismatches = tierFriends.filter((a) => a.fitCategory === 'mismatch');\n                    const hasIssues = tierMismatches.length > 0;\n\n                    return (\n                        <View key={tier} style={[styles.tierSection, { backgroundColor: colors.card, borderColor: colors.border }]}>\n                            {/* Tier Header */}\n                            <TouchableOpacity\n                                style={styles.tierHeader}\n                                onPress={() => toggleTier(tier)}\n                                activeOpacity={0.7}\n                            >\n                                <View style={styles.tierHeaderLeft}>\n                                    <Text style={[styles.tierTitle, { color: colors.foreground }]}>\n                                        {TIER_DISPLAY_NAMES[tier]}\n                                    </Text>\n                                    {tierHealth.total > 0 && (\n                                        <Text style={[styles.tierCount, { color: colors['muted-foreground'] }]}>\n                                            {tierHealth.total} {tierHealth.total === 1 ? 'friend' : 'friends'}\n                                        </Text>\n                                    )}\n                                </View>\n\n                                <View style={styles.tierHeaderRight}>\n                                    {hasIssues ? (\n                                        <View style={[styles.tierBadge, { backgroundColor: '#F59E0B20' }]}>\n                                            <Text style={[styles.tierBadgeText, { color: '#F59E0B' }]}>\n                                                {tierMismatches.length} mismatch{tierMismatches.length !== 1 ? 'es' : ''}\n                                            </Text>\n                                        </View>\n                                    ) : tierHealth.total > 0 ? (\n                                        <CheckCircle size={20} color=\"#10B981\" />\n                                    ) : null}\n                                    {isExpanded ? (\n                                        <ChevronUp size={20} color={colors['muted-foreground']} />\n                                    ) : (\n                                        <ChevronDown size={20} color={colors['muted-foreground']} />\n                                    )}\n                                </View>\n                            </TouchableOpacity>\n\n                            {/* Tier Content (when expanded) */}\n                            {isExpanded && (\n                                <View style={styles.tierContent}>\n                                    {/* Tier Summary */}\n                                    {tierHealth.total > 0 && (\n                                        <View style={styles.tierSummary}>\n                                            <Text style={[styles.tierSummaryText, { color: colors['muted-foreground'] }]}>\n                                                {tierHealth.great} great fit • {tierHealth.good} good fit • {tierHealth.mismatch} mismatch\n                                            </Text>\n                                        </View>\n                                    )}\n\n                                    {/* Friend List */}\n                                    {tierFriends.map((analysis) => {\n                                        const isMismatch = analysis.fitCategory === 'mismatch';\n                                        const isLearning = analysis.fitCategory === 'insufficient_data';\n                                        const isPreliminary = !!analysis.isPreliminary && !isLearning;\n                                        const isGood = analysis.fitCategory === 'great' || analysis.fitCategory === 'good';\n\n                                        return (\n                                            <TouchableOpacity\n                                                key={analysis.friendId}\n                                                style={[\n                                                    styles.friendCard,\n                                                    {\n                                                        borderColor: isMismatch ? '#F59E0B40' : isLearning ? colors.border : '#10B98140',\n                                                        backgroundColor: isMismatch ? '#F59E0B05' : isLearning ? 'transparent' : '#10B98105'\n                                                    }\n                                                ]}\n                                                onPress={() => setSelectedAnalysis(analysis)}\n                                                activeOpacity={0.7}\n                                            >\n                                                <View style={styles.friendCardHeader}>\n                                                    <View style={styles.friendCardContent}>\n                                                        <View style={styles.friendNameRow}>\n                                                            {isMismatch ? (\n                                                                <AlertCircle size={20} color=\"#F59E0B\" />\n                                                            ) : isLearning ? (\n                                                                <TrendingUp size={20} color={colors['muted-foreground']} />\n                                                            ) : (\n                                                                <CheckCircle size={20} color=\"#10B981\" />\n                                                            )}\n                                                            <Text style={[styles.friendName, { color: colors.foreground }]}>\n                                                                {analysis.friendName}\n                                                            </Text>\n                                                        </View>\n\n                                                        {analysis.suggestedTier && (\n                                                            <View style={[styles.suggestionBadge, { backgroundColor: colors.primary + '20', alignSelf: 'flex-start', marginLeft: 28, marginTop: 4 }]}>\n                                                                <Text style={[styles.suggestionBadgeText, { color: colors.primary }]}>\n                                                                    Suggest: {TIER_DISPLAY_NAMES[analysis.suggestedTier]}\n                                                                </Text>\n                                                            </View>\n                                                        )}\n\n                                                        {isLearning && (\n                                                            <View style={[styles.suggestionBadge, { backgroundColor: colors.muted, alignSelf: 'flex-start', marginLeft: 28, marginTop: 4 }]}>\n                                                                <Text style={[styles.suggestionBadgeText, { color: colors['muted-foreground'] }]}>\n                                                                    Learning...\n                                                                </Text>\n                                                            </View>\n                                                        )}\n\n                                                        {isPreliminary && (\n                                                            <View style={[styles.suggestionBadge, { backgroundColor: colors.muted, alignSelf: 'flex-start', marginLeft: 28, marginTop: 4 }]}>\n                                                                <Text style={[styles.suggestionBadgeText, { color: colors['muted-foreground'] }]}>\n                                                                    Preliminary\n                                                                </Text>\n                                                            </View>\n                                                        )}\n                                                    </View>\n                                                </View>\n\n                                                <View style={styles.friendCardStats}>\n                                                    {isLearning ? (\n                                                        <Text style={[styles.friendCardStat, { color: colors['muted-foreground'] }]}>\n                                                            {2 - analysis.interactionCount > 0\n                                                                ? `Need ${2 - analysis.interactionCount} more interactions to analyze rhythm`\n                                                                : `Keep weaving to analyze rhythm`}\n                                                        </Text>\n                                                    ) : (\n                                                        <>\n                                                            <Text style={[styles.friendCardStat, { color: colors['muted-foreground'] }]}>\n                                                                Your rhythm: Every {Math.round(analysis.actualIntervalDays)} days\n                                                            </Text>\n                                                            <Text style={[styles.friendCardStat, { color: colors['muted-foreground'] }]}>\n                                                                Tier expects: Every {analysis.expectedIntervalDays} days\n                                                            </Text>\n                                                            {isPreliminary && (\n                                                                <Text style={[styles.friendCardStat, { color: colors['muted-foreground'], fontStyle: 'italic', fontSize: 12 }]}>\n                                                                    Data limited ({analysis.interactionCount}/5 interactions)\n                                                                </Text>\n                                                            )}\n                                                        </>\n                                                    )}\n                                                </View>\n                                            </TouchableOpacity>\n                                        );\n                                    })}\n\n                                    {tierHealth.total === 0 && (\n                                        <Text style={[styles.emptyTierText, { color: colors['muted-foreground'] }]}>\n                                            No friends in this tier yet\n                                        </Text>\n                                    )}\n                                </View>\n                            )}\n                        </View>\n                    );\n                })}\n            </ScrollView>\n\n            {/* Tier Fit Bottom Sheet */}\n            {selectedAnalysis && (\n                <TierFitBottomSheet\n                    visible={!!selectedAnalysis}\n                    analysis={selectedAnalysis}\n                    onDismiss={() => setSelectedAnalysis(null)}\n                    onChangeTier={(newTier) => handleChangeTier(selectedAnalysis.friendId, newTier, selectedAnalysis.friendName)}\n                    onStayInTier={() => handleStayInTier(selectedAnalysis.friendId)}\n                    onDismissSuggestion={() => handleDismissSuggestion(selectedAnalysis.friendId)}\n                />\n            )}\n        </View>\n    );\n};\n\nconst styles = StyleSheet.create({\n    container: {\n        flex: 1,\n    },\n    loadingContainer: {\n        flex: 1,\n        justifyContent: 'center',\n        alignItems: 'center',\n    },\n    emptyContainer: {\n        flex: 1,\n        justifyContent: 'center',\n        alignItems: 'center',\n        padding: 20,\n    },\n    emptyText: {\n        fontSize: 16,\n        textAlign: 'center',\n    },\n    content: {\n        flex: 1,\n    },\n    contentContainer: {\n        padding: 16,\n        gap: 16,\n    },\n    healthCard: {\n        borderRadius: 16,\n        borderWidth: 1,\n        padding: 20,\n        gap: 16,\n    },\n    healthTitle: {\n        fontSize: 18,\n        fontWeight: '600',\n        fontFamily: 'Lora_700Bold',\n    },\n    healthScoreRow: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 12,\n    },\n    healthBarContainer: {\n        flex: 1,\n        height: 12,\n        backgroundColor: '#F3F4F6',\n        borderRadius: 6,\n        overflow: 'hidden',\n    },\n    healthBarFill: {\n        height: '100%',\n        borderRadius: 6,\n    },\n    healthScore: {\n        fontSize: 20,\n        fontWeight: '700',\n        minWidth: 60,\n    },\n    healthSummary: {\n        fontSize: 15,\n        lineHeight: 22,\n    },\n    tierSection: {\n        borderRadius: 16,\n        borderWidth: 1,\n        overflow: 'hidden',\n    },\n    tierHeader: {\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        padding: 16,\n    },\n    tierHeaderLeft: {\n        flex: 1,\n        gap: 4,\n    },\n    tierTitle: {\n        fontSize: 17,\n        fontWeight: '600',\n        fontFamily: 'Lora_700Bold',\n    },\n    tierCount: {\n        fontSize: 13,\n    },\n    tierHeaderRight: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 12,\n    },\n    tierBadge: {\n        paddingHorizontal: 8,\n        paddingVertical: 4,\n        borderRadius: 6,\n    },\n    tierBadgeText: {\n        fontSize: 12,\n        fontWeight: '600',\n    },\n    tierContent: {\n        paddingHorizontal: 16,\n        paddingBottom: 16,\n        gap: 12,\n    },\n    tierSummary: {\n        paddingBottom: 8,\n    },\n    tierSummaryText: {\n        fontSize: 13,\n    },\n    friendCard: {\n        borderWidth: 2,\n        borderRadius: 12,\n        padding: 12,\n        gap: 8,\n    },\n    friendCardHeader: {\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        gap: 12,\n    },\n    friendCardContent: {\n        flex: 1,\n        gap: 2,\n    },\n    friendNameRow: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 8,\n    },\n    friendName: {\n        fontSize: 16,\n        fontWeight: '600',\n        flex: 1,\n    },\n    suggestionBadge: {\n        paddingHorizontal: 8,\n        paddingVertical: 4,\n        borderRadius: 6,\n    },\n    suggestionBadgeText: {\n        fontSize: 11,\n        fontWeight: '600',\n    },\n    friendCardStats: {\n        gap: 2,\n    },\n    friendCardStat: {\n        fontSize: 13,\n    },\n    emptyTierText: {\n        fontSize: 14,\n        fontStyle: 'italic',\n        textAlign: 'center',\n        paddingVertical: 8,\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/TierInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/TierSegmentedControl.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'containerWidth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":52,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":52,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":129,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { View, Text, Pressable, LayoutChangeEvent } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  Easing,\n} from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { tierColors, isTierAtCapacity } from '@/shared/constants/constants';\n\ninterface TierSegmentedControlProps {\n  activeTier: 'inner' | 'close' | 'community';\n  onTierChange: (tier: 'inner' | 'close' | 'community') => void;\n  counts: {\n    inner: number;\n    close: number;\n    community: number;\n  };\n}\n\ntype TierType = 'inner' | 'close' | 'community';\n\nconst TIERS: TierType[] = ['inner', 'close', 'community'];\n\nconst TIER_LABELS = {\n  inner: 'Inner',\n  close: 'Close',\n  community: 'Community',\n};\n\nconst TIER_COLOR_MAP = {\n  inner: tierColors.InnerCircle,\n  close: tierColors.CloseFriends,\n  community: tierColors.Community,\n};\n\nconst TIER_MAX = {\n  inner: 5,\n  close: 15,\n  community: 50,\n};\n\nexport function TierSegmentedControl({\n  activeTier,\n  onTierChange,\n  counts,\n}: TierSegmentedControlProps) {\n  const { colors, isDarkMode } = useTheme();\n  const [tabWidth, setTabWidth] = useState(0);\n  const [containerWidth, setContainerWidth] = useState(0);\n\n  const indicatorPosition = useSharedValue(0);\n  const indicatorWidth = useSharedValue(0);\n\n  // Calculate the active tier index\n  const activeIndex = TIERS.indexOf(activeTier);\n\n  // Update indicator position when active tier changes\n  useEffect(() => {\n    if (tabWidth > 0) {\n      const targetPosition = activeIndex * tabWidth;\n      indicatorPosition.value = withTiming(targetPosition, {\n        duration: 300,\n        easing: Easing.inOut(Easing.ease),\n      });\n      indicatorWidth.value = withTiming(tabWidth, {\n        duration: 300,\n        easing: Easing.inOut(Easing.ease),\n      });\n    }\n  }, [activeIndex, tabWidth]);\n\n  const handleLayout = (event: LayoutChangeEvent) => {\n    const { width } = event.nativeEvent.layout;\n    setContainerWidth(width);\n    const calculatedTabWidth = (width - 4) / 3; // Subtract padding, divide by 3 tabs\n    setTabWidth(calculatedTabWidth);\n\n    // Set initial position without animation\n    if (indicatorPosition.value === 0 && calculatedTabWidth > 0) {\n      indicatorPosition.value = activeIndex * calculatedTabWidth;\n      indicatorWidth.value = calculatedTabWidth;\n    }\n  };\n\n  const indicatorStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: indicatorPosition.value }],\n    width: indicatorWidth.value,\n  }));\n\n  const handlePress = (tier: TierType) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onTierChange(tier);\n  };\n\n  const containerBg = isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.03)';\n  const activeBg = isDarkMode ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0.9)';\n  const activeTextColor = isDarkMode ? '#1a1625' : '#3C3C3C';\n  const inactiveTextColor = isDarkMode ? colors['muted-foreground'] : '#8A8A8A';\n\n  return (\n    <View\n      onLayout={handleLayout}\n      className=\"mx-4 mt-3 mb-3 h-[34px] rounded-weave-container p-0.5\"\n      style={{ backgroundColor: containerBg }}\n    >\n      {/* Sliding Active Indicator */}\n      <Animated.View\n        className=\"absolute h-[30px] rounded-lg\"\n        style={[\n          indicatorStyle,\n          {\n            backgroundColor: activeBg,\n            top: 2,\n            left: 2,\n            shadowColor: '#000',\n            shadowOffset: { width: 0, height: 1 },\n            shadowOpacity: isDarkMode ? 0.2 : 0.1,\n            shadowRadius: 3,\n            elevation: 2,\n          },\n        ]}\n      />\n\n      {/* Tab Segments */}\n      <View className=\"flex-1 flex-row\">\n        {TIERS.map((tier, index) => {\n          const isActive = tier === activeTier;\n          const tierColor = TIER_COLOR_MAP[tier];\n          const atCapacity = isTierAtCapacity(counts[tier], tier);\n          const overCapacity = counts[tier] > TIER_MAX[tier];\n\n          return (\n            <Pressable\n              key={tier}\n              onPress={() => handlePress(tier)}\n              className=\"flex-1 items-center justify-center flex-row gap-1\"\n              style={({ pressed }) => ({\n                transform: [{ scale: pressed ? 0.98 : 1 }],\n              })}\n            >\n              {/* Tier color indicator dot - changes to warning color when at capacity */}\n              <View\n                className=\"w-1.5 h-1.5 rounded-full\"\n                style={{\n                  backgroundColor: atCapacity ? (overCapacity ? '#EF4444' : '#F59E0B') : tierColor,\n                  opacity: isActive ? 0.9 : 0.4,\n                }}\n              />\n              <View className=\"flex-row items-baseline gap-1\">\n                <Text\n                  className=\"text-xs font-semibold\"\n                  style={{\n                    color: isActive ? activeTextColor : inactiveTextColor,\n                    opacity: isActive ? 1 : 0.7,\n                  }}\n                >\n                  {TIER_LABELS[tier]}\n                </Text>\n                <Text\n                  className=\"text-[10px] font-medium\"\n                  style={{\n                    color: isActive ? activeTextColor : inactiveTextColor,\n                    opacity: isActive ? 0.5 : 0.4,\n                  }}\n                >\n                  {counts[tier]}/{TIER_MAX[tier]}\n                </Text>\n              </View>\n              {/* Warning indicator when at/over capacity */}\n              {atCapacity && (\n                <Text style={{ fontSize: 10, opacity: isActive ? 0.7 : 0.4 }}>\n                  {overCapacity ? '⚠️' : '⚡'}\n                </Text>\n              )}\n            </Pressable>\n          );\n        })}\n      </View>\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/TimelineItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'runOnJS' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Haptics' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showKnot' is assigned a value but never used. Allowed unused args must match /^_/u.","line":45,"column":102,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":110},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threadColors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":59,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lineTargetHeight' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":298,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":298,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'KNOT_BORDER_WIDTH' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":539,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":539,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LINE_LENGTH' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":541,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":541,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useMemo } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  useAnimatedProps,\n  withRepeat,\n  withTiming,\n  withSpring,\n  withDelay,\n  withSequence,\n  interpolate,\n  Easing,\n  runOnJS,\n} from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\nimport Svg, { Line } from 'react-native-svg';\n\nconst AnimatedLine = Animated.createAnimatedComponent(Line);\n\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { formatPoeticDate, calculateWeaveWarmth, getThreadColors } from '@/shared/utils/timeline-utils';\nimport { modeIcons } from '@/shared/constants/constants';\nimport { getCategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { type Interaction, type InteractionCategory } from './types';\nimport { calculateDeepeningLevel, getDeepeningVisuals } from '@/modules/intelligence';\nimport { usePausableAnimation } from '@/shared/hooks/usePausableAnimation';\nimport { useUIStore } from '../stores/uiStore';\n\ninterface TimelineItemProps {\n  interaction: Interaction;\n  isFuture: boolean;\n  onPress: () => void;\n  index: number;\n  scrollY?: Animated.SharedValue<number>;\n  itemY?: number;\n  showKnot?: boolean;\n  sectionLabel?: string;\n  isFirstInSection?: boolean;\n  isLastItem?: boolean; // Is this the last item in the entire timeline?\n  onDelete?: (id: string) => void;\n  onEdit?: (id: string) => void;\n}\n\nexport const TimelineItem = React.memo(({ interaction, isFuture, onPress, index, scrollY, itemY = 0, showKnot = true, sectionLabel, isFirstInSection = false, isLastItem = false }: TimelineItemProps) => {\n  const { colors, isDarkMode } = useTheme();\n  const { justLoggedInteractionId, setJustLoggedInteractionId } = useUIStore();\n\n  // Memoize date parsing\n  const date = useMemo(() =>\n    typeof interaction.interactionDate === 'string'\n      ? new Date(interaction.interactionDate)\n      : interaction.interactionDate,\n    [interaction.interactionDate]\n  );\n\n  // Memoize expensive calculations\n  const warmth = useMemo(() => calculateWeaveWarmth(date), [date]);\n  const threadColors = useMemo(() => getThreadColors(warmth, isFuture), [warmth, isFuture]);\n  const poeticDate = useMemo(() => formatPoeticDate(date), [date]);\n  const { primary, secondary } = poeticDate;\n\n  // All lines are dashed for a more subtle, lightweight appearance\n  const lineOpacity = useMemo(() => {\n    // Future plans: lighter/more transparent\n    if (isFuture) return 0.5;\n    // Past: subtle but visible\n    return 0.7;\n  }, [isFuture]);\n\n  // Get temporal colors (line and knot) with gradient (golden → amber → white)\n  const temporalColors = useMemo(() => {\n    if (isFuture) {\n      // Future plans: lighter, muted\n      return {\n        line: isDarkMode ? 'rgba(139, 92, 246, 0.4)' : 'rgba(181, 138, 108, 0.35)',\n        knot: 'transparent', // Hollow for future\n        glow: isDarkMode ? colors.accent : colors.primary,\n      };\n    }\n\n    const today = new Date();\n    const daysAgo = Math.floor((today.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));\n\n    if (!isDarkMode) {\n      // Light mode: Temporal gradient from golden to white\n      if (daysAgo <= 3) {\n        // Recent: Rich golden\n        return {\n          line: 'rgba(212, 175, 55, 0.9)', // #D4AF37 golden\n          knot: 'rgba(212, 175, 55, 0.15)', // Subtle golden tint\n          glow: '#D4AF37',\n        };\n      } else if (daysAgo <= 14) {\n        // Medium recent: Amber/bronze\n        return {\n          line: 'rgba(181, 138, 108, 0.75)',\n          knot: 'rgba(181, 138, 108, 0.1)',\n          glow: '#B58A6C',\n        };\n      } else if (daysAgo <= 30) {\n        // Older: Light gray-brown\n        return {\n          line: 'rgba(160, 140, 130, 0.55)',\n          knot: 'rgba(160, 140, 130, 0.08)',\n          glow: '#A08C82',\n        };\n      } else {\n        // Distant memory: Very light gray, fading to white\n        return {\n          line: 'rgba(200, 195, 190, 0.35)',\n          knot: colors.card, // Pure card color, fully faded\n          glow: '#C8C3BE',\n        };\n      }\n    } else {\n      // Dark mode: Similar gradient with purple tones\n      if (daysAgo <= 3) {\n        // Recent: Vibrant accent\n        return {\n          line: 'rgba(139, 92, 246, 0.9)',\n          knot: 'rgba(139, 92, 246, 0.15)',\n          glow: colors.accent,\n        };\n      } else if (daysAgo <= 14) {\n        // Medium recent: Medium purple\n        return {\n          line: 'rgba(139, 92, 246, 0.7)',\n          knot: 'rgba(139, 92, 246, 0.1)',\n          glow: colors.accent,\n        };\n      } else if (daysAgo <= 30) {\n        // Older: Muted purple\n        return {\n          line: 'rgba(120, 100, 200, 0.5)',\n          knot: 'rgba(120, 100, 200, 0.08)',\n          glow: '#7864C8',\n        };\n      } else {\n        // Distant memory: Very faint\n        return {\n          line: 'rgba(100, 90, 150, 0.3)',\n          knot: colors.card, // Pure card color, fully faded\n          glow: '#645A96',\n        };\n      }\n    }\n  }, [date, isFuture, isDarkMode, colors]);\n\n  // Memoize deepening calculations\n  const deepeningMetrics = useMemo(() =>\n    calculateDeepeningLevel(interaction.reflection),\n    [interaction.reflection]\n  );\n  const deepeningVisuals = useMemo(() =>\n    getDeepeningVisuals(deepeningMetrics, colors, isDarkMode),\n    [deepeningMetrics, colors, isDarkMode]\n  );\n\n  // Helper to convert opacity (0-1) to hex string\n  const opacityToHex = (opacity: number) => {\n    return Math.round(opacity * 255).toString(16).padStart(2, '0');\n  };\n\n  // Get vibe-based color tint with opacity - progressive based on reflection depth\n  const getVibeColorTint = (baseOpacity: number = 0.05) => {\n    if (isFuture) return 'transparent';\n\n    // Increase opacity for reflected weaves based on depth\n    const reflectionBoost = deepeningMetrics.level !== 'none' ? deepeningMetrics.intensity * 0.08 : 0;\n    const finalOpacity = baseOpacity + reflectionBoost;\n\n    switch (interaction.vibe) {\n      case 'FullMoon':\n        return colors.living.healthy[0] + opacityToHex(finalOpacity); // Teal tint\n      case 'WaxingGibbous':\n      case 'FirstQuarter':\n        return colors.living.stable[0] + opacityToHex(finalOpacity); // Amber/Violet tint\n      case 'WaxingCrescent':\n      case 'NewMoon':\n        return colors.secondary + opacityToHex(finalOpacity); // Neutral purple tint\n      default:\n        return colors.secondary + opacityToHex(finalOpacity); // Default subtle tint\n    }\n  };\n\n  const cardTintColor = useMemo(() => getVibeColorTint(0.05), [isFuture, interaction.vibe, colors, deepeningMetrics]);\n\n  // Get friendly label and icon for category (memoized)\n  const { displayLabel, displayIcon } = useMemo(() => {\n    const isCategory = interaction.activity && interaction.activity.includes('-');\n\n    if (isCategory) {\n      const categoryData = getCategoryMetadata(interaction.activity as InteractionCategory);\n      if (categoryData) {\n        return { displayLabel: categoryData.label, displayIcon: categoryData.icon };\n      }\n    }\n\n    // Old format - use mode icon and activity name\n    // BUT: If this is a deepened quick log, try to extract category from reflection\n    const hasReflection = interaction.reflection && (interaction.reflection.chips?.length || interaction.reflection.customNotes);\n    const categoryFromReflection = hasReflection && interaction.interactionCategory;\n\n    if (categoryFromReflection) {\n      const categoryData = getCategoryMetadata(categoryFromReflection as InteractionCategory);\n      if (categoryData) {\n        return { displayLabel: categoryData.label, displayIcon: categoryData.icon };\n      }\n    }\n\n    return {\n      displayLabel: interaction.activity || 'Interaction', // Fallback label\n      displayIcon: modeIcons[interaction.mode as keyof typeof modeIcons] || '✨'\n    };\n  }, [interaction.activity, interaction.mode, interaction.interactionCategory, interaction.reflection]);\n\n  // Memoize dynamic styles\n  const dynamicStyles = useMemo(() => ({\n    sectionLabel: {\n      color: colors['muted-foreground'],\n    },\n    dateText: {\n      color: colors.foreground,\n    },\n    timeText: {\n      color: colors['muted-foreground'],\n    },\n    knotOnThread: {\n      backgroundColor: colors.card,\n      shadowColor: warmth > 0.5 ? (isDarkMode ? colors.accent : '#D4AF37') : '#000',\n    },\n    card: {\n      borderColor: colors.border,\n    },\n    cardCompleted: {\n      backgroundColor: isDarkMode ? colors.card : 'rgba(255, 255, 255, 0.95)',\n    },\n    cardPlanned: {\n      backgroundColor: isDarkMode ? colors.card : 'rgba(255, 255, 255, 0.65)',\n      borderColor: isDarkMode ? colors.accent + '80' : 'rgba(181, 138, 108, 0.4)',\n    },\n    cardTitle: {\n      color: colors.foreground,\n    },\n    cardSubtitle: {\n      color: colors['muted-foreground'],\n    },\n  }), [colors, warmth, isDarkMode]);\n\n  // Animation values\n  const pulseAnimation = useSharedValue(0);\n  const pressScale = useSharedValue(1);\n  const cardShadow = useSharedValue(2);\n  const reflectionGlow = useSharedValue(0);\n  const justLoggedGlow = useSharedValue(0);\n\n  // Line drawing animation - pen stroke effect\n  const strokeDashoffset = useSharedValue(72); // Start hidden (offset = line length)\n\n  // Knot appearance animation\n  const knotScale = useSharedValue(0);\n  const knotOpacity = useSharedValue(0);\n\n  // Pause pulse animation when app is sleeping (battery optimization)\n  const { isSleeping } = usePausableAnimation(pulseAnimation);\n\n  // Entrance animation values\n  const entranceOpacity = useSharedValue(0);\n  const entranceScale = useSharedValue(0.92);\n  const entranceTranslateY = useSharedValue(20);\n\n  // Sequential flowing animation - cascades from top to bottom\n  // Each item: knot appears → card fades → line draws to next item → next item's knot appears\n  // Performance optimization: Only animate first 20 items, instant appearance for older items\n  useEffect(() => {\n    const ANIMATION_THRESHOLD = 20; // Only animate first 20 items\n\n    // Skip animations for items beyond threshold - instant appearance\n    if (index >= ANIMATION_THRESHOLD) {\n      // Instant appearance - no delays or animations\n      knotScale.value = 1;\n      knotOpacity.value = 1;\n      entranceOpacity.value = 1;\n      entranceScale.value = 1;\n      entranceTranslateY.value = 0;\n      strokeDashoffset.value = 0;\n      return;\n    }\n\n    const baseDelay = 150; // Initial delay before first item\n    const itemDuration = 350; // Time between each item's knot appearance\n    const lineDuration = 250; // Line drawing duration\n    const cardDelay = 80; // Delay between knot and card\n\n    // Calculate line target height with airgaps\n    // Distance to next knot minus both gaps (bottom of current + top of next)\n    const lineTargetHeight = 72; // ~90px item spacing - KNOT_SIZE - (2 * LINE_GAP)\n\n    // Each item's knot appears at a regular interval\n    const knotAppearDelay = baseDelay + (index * itemDuration);\n    const cardStartDelay = knotAppearDelay + cardDelay;\n\n    // Line draws down after knot appears (with small delay so card can start fading in)\n    // Line should finish just as next item's knot is ready to appear\n    const lineStartDelay = knotAppearDelay + (itemDuration - lineDuration);\n\n    // Knot pop-in - subtle spring bounce\n    knotScale.value = withDelay(\n      knotAppearDelay,\n      withSpring(1, {\n        damping: 18,\n        stiffness: 280,\n        mass: 0.5,\n      })\n    );\n    knotOpacity.value = withDelay(\n      knotAppearDelay,\n      withTiming(1, {\n        duration: 180,\n        easing: Easing.out(Easing.quad),\n      })\n    );\n\n    // Card animations - fade and slide up shortly after knot\n    entranceOpacity.value = withDelay(\n      cardStartDelay,\n      withTiming(1, {\n        duration: 300,\n        easing: Easing.out(Easing.quad),\n      })\n    );\n\n    entranceScale.value = withDelay(\n      cardStartDelay,\n      withSpring(1, {\n        damping: 20,\n        stiffness: 200,\n      })\n    );\n\n    entranceTranslateY.value = withDelay(\n      cardStartDelay,\n      withSpring(0, {\n        damping: 20,\n        stiffness: 220,\n      })\n    );\n\n    // Line drawing animation - pen stroke effect\n    // Animate strokeDashoffset from LINE_LENGTH to 0 for smooth reveal\n    if (!isLastItem) {\n      strokeDashoffset.value = withDelay(\n        lineStartDelay,\n        withTiming(0, {\n          duration: lineDuration,\n          easing: Easing.out(Easing.cubic), // Slight ease for natural pen stroke feel\n        })\n      );\n    }\n  }, [index, isLastItem]);\n\n  // Subtle pulse animation for warm weaves\n  useEffect(() => {\n    // Only run animation when app is not sleeping\n    if (warmth > 0.7 && !isFuture && !isSleeping) {\n      pulseAnimation.value = withRepeat(\n        withTiming(1, {\n          duration: 3000,\n          easing: Easing.inOut(Easing.ease)\n        }),\n        -1,\n        true\n      );\n    }\n  }, [warmth, isFuture, isSleeping]);\n\n  // Subtle glow animation for deep/profound reflections\n  useEffect(() => {\n    // Only animate deep and profound reflections when app is not sleeping\n    if ((deepeningMetrics.level === 'deep' || deepeningMetrics.level === 'profound') && !isFuture && !isSleeping) {\n      reflectionGlow.value = withRepeat(\n        withTiming(1, {\n          duration: 4000, // Slower, more subtle than warmth pulse\n          easing: Easing.inOut(Easing.ease)\n        }),\n        -1,\n        true\n      );\n    }\n  }, [deepeningMetrics.level, isFuture, isSleeping]);\n\n  // \"Just Logged\" celebration glow effect\n  useEffect(() => {\n    if (justLoggedInteractionId === interaction.id) {\n      justLoggedGlow.value = withSequence(\n        withTiming(1, { duration: 400, easing: Easing.out(Easing.quad) }),\n        withTiming(0, { duration: 1000, easing: Easing.in(Easing.quad) })\n      );\n      // Clear the ID after animation starts\n      setTimeout(() => setJustLoggedInteractionId(null), 100);\n    }\n  }, [justLoggedInteractionId, interaction.id]);\n\n  // Knot entrance and pulse style\n  const knotAnimatedStyle = useAnimatedStyle(() => {\n    // Base entrance animation\n    const baseScale = knotScale.value;\n    const baseOpacity = knotOpacity.value;\n\n    // Pulse animation for warm weaves (subtle)\n    if (warmth > 0.7 && !isFuture) {\n      const pulseScale = interpolate(\n        pulseAnimation.value,\n        [0, 0.5, 1],\n        [1, 1.05, 1]\n      );\n\n      const glowOpacity = interpolate(\n        pulseAnimation.value,\n        [0, 0.5, 1],\n        [0.2, 0.4, 0.2]\n      );\n\n      return {\n        transform: [{ scale: baseScale * pulseScale }],\n        opacity: baseOpacity,\n        shadowOpacity: warmth * glowOpacity,\n      };\n    }\n\n    return {\n      transform: [{ scale: baseScale }],\n      opacity: baseOpacity,\n    };\n  });\n\n  // Card press animation\n  const handlePressIn = () => {\n    pressScale.value = withSpring(0.97, { damping: 15, stiffness: 300 });\n    cardShadow.value = withSpring(1, { damping: 15, stiffness: 300 });\n  };\n\n  const handlePressOut = () => {\n    pressScale.value = withSpring(1, { damping: 15, stiffness: 300 });\n    cardShadow.value = withSpring(2, { damping: 15, stiffness: 300 });\n  };\n\n  const cardAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: pressScale.value }],\n    shadowOpacity: interpolate(cardShadow.value, [1, 2], [0.05, 0.08]),\n    shadowRadius: interpolate(cardShadow.value, [1, 2], [4, 8]),\n    opacity: isFuture ? 0.6 : 1, // Reduced opacity for future plans\n  }));\n\n  // Reflection glow overlay style - subtle pulse for deep reflections\n  const reflectionGlowStyle = useAnimatedStyle(() => {\n    if (deepeningMetrics.level === 'none' || isFuture) return { opacity: 0 };\n\n    // Base glow intensity increases with reflection depth\n    const baseGlow = deepeningMetrics.intensity * 0.15;\n\n    // Only pulse for deep/profound\n    const shouldPulse = deepeningMetrics.level === 'deep' || deepeningMetrics.level === 'profound';\n    const pulseGlow = shouldPulse\n      ? interpolate(reflectionGlow.value, [0, 1], [baseGlow, baseGlow * 1.3])\n      : baseGlow;\n\n    return {\n      opacity: pulseGlow,\n    };\n  });\n\n  // Just-logged glow style - bright celebration flash\n  const justLoggedGlowStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(justLoggedGlow.value, [0, 0.5, 1], [0, 0.7, 0]);\n    const scale = interpolate(justLoggedGlow.value, [0, 1], [1, 1.05]);\n    return {\n      opacity,\n      transform: [{ scale }],\n    };\n  });\n\n\n  // Icon subtle rotation for organic feel\n  const iconRotation = Math.random() * 4 - 2; // -2° to +2°\n\n  // Animated SVG line props - properly connect SharedValue to SVG\n  const animatedLineProps = useAnimatedProps(() => {\n    return {\n      strokeDashoffset: strokeDashoffset.value,\n    };\n  });\n\n  // Container entrance animation - combines all entrance effects\n  const containerAnimatedStyle = useAnimatedStyle(() => {\n    return {\n      opacity: entranceOpacity.value,\n      transform: [\n        { translateY: entranceTranslateY.value },\n        { scale: entranceScale.value },\n      ],\n    };\n  });\n\n  // Scroll-based fade for items near viewport edges (optional subtle effect)\n  const scrollFadeStyle = useAnimatedStyle(() => {\n    if (!scrollY || itemY === 0) return { opacity: 1 };\n\n    const itemPosition = itemY - scrollY.value;\n\n    // Very subtle fade at edges (only affects extreme positions)\n    const topFade = interpolate(\n      itemPosition,\n      [-50, 50],\n      [0.6, 1],\n      'clamp'\n    );\n\n    const bottomFade = interpolate(\n      itemPosition,\n      [600, 750],\n      [1, 0.6],\n      'clamp'\n    );\n\n    return {\n      opacity: Math.min(topFade, bottomFade),\n    };\n  });\n\n  // ContinuousThread container is at left: 98px (absolute)\n  // But threadCore inside it is at left: 0, so thread is at 98px from screen\n  // itemWrapper has paddingHorizontal: 20px\n  // knotAbsoluteContainer has left: 20px to offset the padding\n  // So knot position should be: 98px (thread) - 20px (wrapper padding) - 20px (container offset) = 58px\n  const THREAD_CENTER = 58;\n  const KNOT_SIZE = 10; // Smaller knots - more like \"O\" rings\n  const KNOT_BORDER_WIDTH = 2; // Thicker border for hollow appearance\n  const LINE_GAP = 4; // Gap between line and knot (top and bottom)\n  const LINE_LENGTH = 72; // Total line length for SVG path animation\n  const CARD_START = 72 + 16 + 20; // dateColumn + gap + knotContainer\n\n  // Get section accent color\n  const getSectionAccentColor = (label?: string) => {\n    if (!label) return 'transparent';\n    if (label.includes('Seeds')) return isDarkMode ? colors.accent + '60' : 'rgba(181, 138, 108, 0.4)';\n    if (label.includes('Today')) return isDarkMode ? colors.primary + '90' : 'rgba(212, 175, 55, 0.8)';\n    return isDarkMode ? colors.secondary + '70' : 'rgba(181, 138, 108, 0.6)';\n  };\n\n  return (\n    <View>\n      {/* Section label chip - only for first item in section */}\n      {isFirstInSection && sectionLabel && (\n        <View className=\"flex-row items-center pl-[98px] pb-2 gap-1.5\">\n          <View className=\"w-0.5 h-3 rounded-[1px] opacity-60\" style={{ backgroundColor: getSectionAccentColor(sectionLabel) }} />\n          <Text className=\"text-[10px] font-semibold uppercase tracking-widest\" style={dynamicStyles.sectionLabel}>{sectionLabel}</Text>\n        </View>\n      )}\n\n      <Animated.View className=\"flex-row items-center gap-4 pb-6\" style={[containerAnimatedStyle, scrollFadeStyle]}>\n        {/* Knot positioned absolutely on the thread with connector line */}\n        <View className=\"absolute w-full h-10 top-2 left-5 z-10\" pointerEvents=\"none\">\n          {/* Connector line from thread to card */}\n          {/* Future: dotted, Past: solid */}\n          <View\n            className=\"absolute h-[1.5px] top-5\"\n            style={{\n              left: THREAD_CENTER,\n              width: CARD_START - THREAD_CENTER,\n              backgroundColor: isDarkMode ? colors.border : 'rgba(181, 138, 108, 0.5)',\n              opacity: isFuture ? 0.5 : 1,\n              borderStyle: isFuture ? 'dotted' : 'solid',\n            }}\n          />\n\n          {/* Knot on thread - centered on thread */}\n          {/* Knots fade from golden (recent) to white (distant) - hollow \"O\" appearance */}\n          <Animated.View\n            className=\"absolute w-[10px] h-[10px] top-4 rounded-full border-2 shadow-sm\"\n            style={[\n              knotAnimatedStyle,\n              {\n                left: THREAD_CENTER - (KNOT_SIZE / 2),\n                backgroundColor: isFuture ? 'transparent' : (temporalColors.knot === colors.card ? 'transparent' : temporalColors.knot),\n                borderColor: isFuture ? 'rgba(247, 245, 242, 0.6)' : temporalColors.line,\n                shadowColor: isFuture ? undefined : temporalColors.glow,\n                shadowOffset: { width: 0, height: 1 },\n                shadowOpacity: warmth > 0.5 ? 0.3 : 0.15,\n                shadowRadius: 3 + (warmth * 6),\n              }\n            ]}\n          >\n            {/* Glow effect for warm/recent knots */}\n            {warmth > 0.5 && !isFuture && (\n              <View\n                className=\"absolute w-4 h-4 -top-[3px] -left-[3px] rounded-full -z-10 opacity-20\"\n                style={{\n                  backgroundColor: temporalColors.glow,\n                }}\n              />\n            )}\n          </Animated.View>\n\n          {/* Vertical line segment connecting to next item (point-to-point) */}\n          {/* Line has airgaps at both ends - doesn't touch knots */}\n          {/* SVG line with pen stroke animation - draws on smoothly from top to bottom */}\n          {!isLastItem && (\n            <Svg\n              style={{\n                position: 'absolute',\n                left: THREAD_CENTER - 0.5,\n                top: 16 + KNOT_SIZE + LINE_GAP,\n                width: 2,\n                height: 72,\n              }}\n              pointerEvents=\"none\"\n            >\n              <AnimatedLine\n                x1=\"1\"\n                y1=\"0\"\n                x2=\"1\"\n                y2=\"72\"\n                stroke={temporalColors.line}\n                strokeWidth=\"1\"\n                strokeDasharray=\"4 4\"\n                strokeOpacity={lineOpacity}\n                strokeLinecap=\"round\"\n                animatedProps={animatedLineProps}\n              />\n            </Svg>\n          )}\n        </View>\n\n        {/* Date Column */}\n        <View className=\"w-[72px] items-end pt-2 pr-2 shrink-0\">\n          <Text className=\"text-xs font-semibold mb-0.5\" style={dynamicStyles.dateText} numberOfLines={1}>{primary}</Text>\n          <Text className=\"text-[11px] font-normal\" style={dynamicStyles.timeText} numberOfLines={1}>{secondary}</Text>\n        </View>\n\n        {/* Empty spacer where knot used to be */}\n        <View className=\"w-5\" />\n\n        {/* Card */}\n        <TouchableOpacity\n          className=\"flex-1\"\n          onPress={onPress}\n          onPressIn={handlePressIn}\n          onPressOut={handlePressOut}\n          activeOpacity={1}\n        >\n          <Animated.View\n            className=\"rounded-2xl overflow-hidden shadow-sm elevation-4 border\"\n            style={[\n              dynamicStyles.card,\n              isFuture ? dynamicStyles.cardPlanned : dynamicStyles.cardCompleted,\n              cardAnimatedStyle,\n              {\n                shadowColor: '#000',\n                shadowOffset: { width: 0, height: 2 },\n              },\n              // Scale-based border and shadow for deepened weaves\n              deepeningMetrics.level !== 'none' && {\n                borderColor: colors.primary + deepeningVisuals.borderOpacity.toString(16).padStart(2, '0'),\n                borderWidth: deepeningVisuals.borderWidth,\n                shadowColor: colors.primary,\n                shadowOpacity: deepeningVisuals.shadowOpacity,\n                shadowRadius: deepeningVisuals.shadowRadius,\n                shadowOffset: { width: 0, height: 2 },\n              },\n            ]}\n          >\n\n            <View className=\"absolute inset-0\" style={{ backgroundColor: cardTintColor }} />\n\n            {/* Reflection glow overlay for deepened weaves */}\n            {deepeningMetrics.level !== 'none' && !isFuture && (\n              <Animated.View\n                className=\"absolute inset-0\"\n                style={[\n                  reflectionGlowStyle,\n                  { backgroundColor: colors.primary }\n                ]}\n                pointerEvents=\"none\"\n              />\n            )}\n\n            {/* Just-logged celebration glow */}\n            <Animated.View\n              className=\"absolute inset-0 z-20\"\n              style={[\n                justLoggedGlowStyle,\n                { backgroundColor: 'white' }\n              ]}\n              pointerEvents=\"none\"\n            />\n\n            <View className=\"p-4 flex-row items-start gap-3 z-[1]\">\n              {/* Icon with deepened indicator */}\n              <View>\n                <Text\n                  className=\"text-[26px] opacity-90\"\n                  style={{ transform: [{ rotate: `${iconRotation}deg` }] }}\n                >\n                  {displayIcon}\n                </Text>\n                {/* Deepened weave indicator - scale-based sparkles */}\n                {deepeningMetrics.level !== 'none' && (\n                  <View className=\"absolute -top-1 -right-1\">\n                    <Text className=\"text-sm\">{deepeningVisuals.badgeEmoji}</Text>\n                  </View>\n                )}\n              </View>\n              <View className=\"flex-1\">\n                {/* Show custom title if it exists, otherwise show category label */}\n                <Text className=\"font-semibold mb-1 text-base font-[Lora_700Bold]\" style={dynamicStyles.cardTitle}>\n                  {interaction.title || displayLabel}\n                </Text>\n                {/* Show category as subtitle if custom title exists, otherwise show mode */}\n                <Text className=\"text-[13px] capitalize\" style={dynamicStyles.cardSubtitle}>\n                  {interaction.title ? displayLabel : interaction.mode?.replace('-', ' ')}\n                </Text>\n                {/* Reflection chip preview - scale-based label */}\n                {deepeningMetrics.level !== 'none' && (\n                  <View className=\"mt-1.5\">\n                    <Text className=\"text-[11px] font-medium opacity-70\" style={{ color: colors.primary }} numberOfLines={1}>\n                      {deepeningVisuals.badgeText}\n                    </Text>\n                  </View>\n                )}\n              </View>\n            </View>\n          </Animated.View>\n        </TouchableOpacity>\n      </Animated.View>\n    </View>\n  );\n}, (prevProps, nextProps) => {\n  // Custom comparison - only re-render if interaction data actually changes\n  return (\n    prevProps.interaction.id === nextProps.interaction.id &&\n    prevProps.interaction.updatedAt === nextProps.interaction.updatedAt &&\n    prevProps.isFuture === nextProps.isFuture &&\n    prevProps.index === nextProps.index &&\n    prevProps.isLastItem === nextProps.isLastItem\n  );\n});\n\n// NativeWind classes used throughout TimelineItem:\n// Section Chip: flex-row items-center pl-[98px] pb-2 pt-3 gap-1.5\n// Section Accent: w-0.5 h-3 rounded-[1px] opacity-60\n// Section Label: text-[10px] font-semibold uppercase tracking-widest\n// Swipe Container: relative\n// Edit/Delete Backgrounds: absolute with specific positioning, gap-2\n// Item Container: flex-row items-center gap-4 pb-6\n// Knot Container: absolute w-full h-10 top-2 left-5 z-10\n// Connector Line: absolute h-[1.5px] top-5\n// Knot: absolute w-2 h-2 top-4 rounded-full border-[1.5px] shadow-sm elevation-3\n// Knot Glow: absolute w-4 h-4 rounded-full -top-1 -left-1 -z-10\n// Date Column: w-[72px] items-end pt-2 pr-2 shrink-0\n// Date Text: text-xs font-semibold mb-0.5\n// Time Text: text-[11px] font-normal\n// Knot Spacer: w-5\n// Card Container: flex-1\n// Card: rounded-2xl overflow-hidden shadow-sm elevation-4 border\n// Card Backgrounds: absolute inset-0\n// Card Content: p-4 flex-row items-start gap-3 z-[1]\n// Icon: text-[26px] opacity-90\n// Deepened Indicator: absolute -top-1 -right-1\n// Title: font-semibold mb-1 text-base font-[Lora_700Bold]\n// Subtitle: text-[13px] capitalize\n// Reflection Preview: mt-1.5, text-[11px] font-medium opacity-70","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/TrophyCabinetModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GlobalAchievement' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":37,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TrophyCabinetModal Component\n *\n * Main achievement showcase modal\n * Opens from WeavingPracticeWidget streak section\n * Three tabs: Global Achievements, Friend Badges, Hidden Achievements\n */\n\nimport React, { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  TouchableOpacity,\n  ScrollView,\n} from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { database } from '@/db';\nimport UserProgress from '@/db/models/UserProgress';\nimport {\n  GLOBAL_ACHIEVEMENTS,\n  HIDDEN_ACHIEVEMENTS,\n  type GlobalAchievement,\n} from '@/modules/gamification';\nimport AchievementCard from './AchievementCard';\n\ninterface TrophyCabinetModalProps {\n  visible: boolean;\n  onClose: () => void;\n}\n\ntype TabType = 'global' | 'hidden';\n\nexport default function TrophyCabinetModal({ visible, onClose }: TrophyCabinetModalProps) {\n  const { colors, isDarkMode } = useTheme();\n  const [activeTab, setActiveTab] = useState<TabType>('global');\n  const [userProgress, setUserProgress] = useState<UserProgress | null>(null);\n  const [unlockedGlobal, setUnlockedGlobal] = useState<string[]>([]);\n  const [unlockedHidden, setUnlockedHidden] = useState<string[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    if (visible) {\n      loadAchievementData();\n    }\n  }, [visible]);\n\n  async function loadAchievementData() {\n    setLoading(true);\n\n    // Load UserProgress\n    const progressRecords = await database.get<UserProgress>('user_progress').query().fetch();\n    if (progressRecords.length > 0) {\n      const progress = progressRecords[0];\n      setUserProgress(progress);\n      setUnlockedGlobal(progress.globalAchievements || []);\n      setUnlockedHidden(progress.hiddenAchievements || []);\n    }\n\n    setLoading(false);\n  }\n\n  function renderGlobalTab() {\n    const categories = [\n      { key: 'weaving', label: '🧵 Weaving Mastery', achievements: GLOBAL_ACHIEVEMENTS.filter(a => a.category === 'weaving') },\n      { key: 'consistency', label: '🔥 Consistency', achievements: GLOBAL_ACHIEVEMENTS.filter(a => a.category === 'consistency') },\n      { key: 'depth', label: '🦉 Soulcraft', achievements: GLOBAL_ACHIEVEMENTS.filter(a => a.category === 'depth') },\n      { key: 'social', label: '👥 Social Mastery', achievements: GLOBAL_ACHIEVEMENTS.filter(a => a.category === 'social') },\n    ];\n\n    const totalUnlocked = unlockedGlobal.length;\n    const totalAchievements = GLOBAL_ACHIEVEMENTS.length;\n\n    return (\n      <View className=\"flex-1 px-4\">\n        {/* Header Stats */}\n        <View\n          className=\"rounded-2xl p-4 mb-4\"\n          style={{\n            backgroundColor: colors.card,\n            borderWidth: 1,\n            borderColor: colors.border,\n          }}\n        >\n          <Text\n            className=\"font-['Lora'] text-2xl font-bold mb-2\"\n            style={{ color: colors.foreground }}\n          >\n            Trophy Cabinet\n          </Text>\n          <View className=\"flex-row items-center justify-between\">\n            <Text\n              className=\"font-['Inter'] text-3xl font-bold\"\n              style={{ color: colors.primary }}\n            >\n              {totalUnlocked}\n            </Text>\n            <Text\n              className=\"font-['Inter'] text-base\"\n              style={{ color: colors['muted-foreground'] }}\n            >\n              / {totalAchievements} Unlocked\n            </Text>\n          </View>\n          <View\n            className=\"h-2 rounded-full mt-3 overflow-hidden\"\n            style={{ backgroundColor: colors.muted }}\n          >\n            <View\n              className=\"h-full rounded-full\"\n              style={{\n                width: `${(totalUnlocked / totalAchievements) * 100}%`,\n                backgroundColor: colors.primary,\n              }}\n            />\n          </View>\n        </View>\n\n        {/* Category Sections */}\n        {categories.map((cat) => {\n          const categoryUnlocked = cat.achievements.filter(a =>\n            unlockedGlobal.includes(a.id)\n          ).length;\n\n          return (\n            <View key={cat.key} className=\"mb-6\">\n              <View className=\"flex-row items-center justify-between mb-3\">\n                <Text\n                  className=\"font-['Inter'] text-lg font-bold\"\n                  style={{ color: colors.foreground }}\n                >\n                  {cat.label}\n                </Text>\n                <Text\n                  className=\"font-['Inter'] text-sm\"\n                  style={{ color: colors['muted-foreground'] }}\n                >\n                  {categoryUnlocked} / {cat.achievements.length}\n                </Text>\n              </View>\n\n              <View className=\"space-y-3\">\n                {cat.achievements.map((achievement) => {\n                  const isUnlocked = unlockedGlobal.includes(achievement.id);\n                  return (\n                    <AchievementCard\n                      key={achievement.id}\n                      achievement={achievement}\n                      unlocked={isUnlocked}\n                    />\n                  );\n                })}\n              </View>\n            </View>\n          );\n        })}\n      </View>\n    );\n  }\n\n  function renderHiddenTab() {\n    const unlockedHiddenAchievements = HIDDEN_ACHIEVEMENTS.filter(a =>\n      unlockedHidden.includes(a.id)\n    );\n\n    return (\n      <View className=\"flex-1 px-4\">\n        {/* Header */}\n        <View\n          className=\"rounded-2xl p-4 mb-4\"\n          style={{\n            backgroundColor: colors.card,\n            borderWidth: 1,\n            borderColor: colors.border,\n          }}\n        >\n          <Text\n            className=\"font-['Lora'] text-2xl font-bold mb-2\"\n            style={{ color: colors.foreground }}\n          >\n            🔮 Hidden Discoveries\n          </Text>\n          <Text\n            className=\"font-['Inter'] text-base\"\n            style={{ color: colors['muted-foreground'] }}\n          >\n            {unlockedHiddenAchievements.length} / {HIDDEN_ACHIEVEMENTS.length} discovered\n          </Text>\n          <Text\n            className=\"font-['Inter'] text-xs mt-2 italic\"\n            style={{ color: colors['muted-foreground'] }}\n          >\n            Secret achievements unlock through special actions\n          </Text>\n        </View>\n\n        {/* Unlocked Hidden Achievements */}\n        {unlockedHiddenAchievements.length > 0 && (\n          <View className=\"mb-6\">\n            <Text\n              className=\"font-['Inter'] text-base font-bold mb-3\"\n              style={{ color: colors.primary }}\n            >\n              ✨ Discovered\n            </Text>\n            <View className=\"space-y-3\">\n              {unlockedHiddenAchievements.map((achievement) => (\n                <AchievementCard\n                  key={achievement.id}\n                  achievement={achievement}\n                  unlocked={true}\n                />\n              ))}\n            </View>\n          </View>\n        )}\n\n        {/* Locked Hidden Achievements (show as mysterious) */}\n        {HIDDEN_ACHIEVEMENTS.filter(a => !unlockedHidden.includes(a.id)).length > 0 && (\n          <View className=\"mb-6\">\n            <Text\n              className=\"font-['Inter'] text-base font-bold mb-3\"\n              style={{ color: colors['muted-foreground'] }}\n            >\n              🔒 Undiscovered\n            </Text>\n            <View className=\"space-y-3\">\n              {HIDDEN_ACHIEVEMENTS.filter(a => !unlockedHidden.includes(a.id)).map(\n                (achievement) => (\n                  <View\n                    key={achievement.id}\n                    className=\"rounded-2xl p-4\"\n                    style={{\n                      backgroundColor: colors.muted,\n                      borderWidth: 2,\n                      borderColor: colors.border,\n                    }}\n                  >\n                    <View className=\"flex-row items-center\">\n                      <Text className=\"text-3xl mr-3 opacity-20\">❓</Text>\n                      <View className=\"flex-1\">\n                        <Text\n                          className=\"font-['Lora'] font-bold text-lg\"\n                          style={{ color: colors['muted-foreground'] }}\n                        >\n                          ??? Hidden ???\n                        </Text>\n                        <Text\n                          className=\"font-['Inter'] text-sm\"\n                          style={{ color: colors['muted-foreground'], opacity: 0.7 }}\n                        >\n                          Unlock this secret achievement to reveal its details...\n                        </Text>\n                      </View>\n                    </View>\n                  </View>\n                )\n              )}\n            </View>\n          </View>\n        )}\n\n        {/* Empty State */}\n        {unlockedHiddenAchievements.length === 0 && (\n          <View\n            className=\"rounded-xl p-8 items-center mt-4\"\n            style={{\n              backgroundColor: colors.muted,\n              borderWidth: 1,\n              borderColor: colors.border,\n            }}\n          >\n            <Text className=\"text-5xl mb-4\">🔮</Text>\n            <Text\n              className=\"font-['Lora'] text-lg font-semibold mb-2 text-center\"\n              style={{ color: colors.foreground }}\n            >\n              Mysteries Await\n            </Text>\n            <Text\n              className=\"font-['Inter'] text-sm text-center\"\n              style={{ color: colors['muted-foreground'] }}\n            >\n              Explore the app to discover hidden achievements!\n            </Text>\n          </View>\n        )}\n      </View>\n    );\n  }\n\n  return (\n    <StandardBottomSheet\n      visible={visible}\n      onClose={onClose}\n      height=\"full\"\n      title=\"Achievements\"\n      scrollable\n    >\n      {/* Tabs */}\n      <View\n        className=\"flex-row px-4\"\n        style={{\n          borderBottomWidth: 1,\n          borderBottomColor: colors.border,\n        }}\n      >\n        <TouchableOpacity\n          onPress={() => setActiveTab('global')}\n          className=\"flex-1 py-3 items-center\"\n          style={{\n            borderBottomWidth: activeTab === 'global' ? 2 : 0,\n            borderBottomColor: colors.primary,\n          }}\n        >\n          <Text\n            className=\"font-['Inter'] text-sm font-semibold\"\n            style={{\n              color: activeTab === 'global' ? colors.primary : colors['muted-foreground'],\n            }}\n          >\n            🏆 Global\n          </Text>\n        </TouchableOpacity>\n        <TouchableOpacity\n          onPress={() => setActiveTab('hidden')}\n          className=\"flex-1 py-3 items-center\"\n          style={{\n            borderBottomWidth: activeTab === 'hidden' ? 2 : 0,\n            borderBottomColor: colors.primary,\n          }}\n        >\n          <Text\n            className=\"font-['Inter'] text-sm font-semibold\"\n            style={{\n              color: activeTab === 'hidden' ? colors.primary : colors['muted-foreground'],\n            }}\n          >\n            🔮 Hidden\n          </Text>\n        </TouchableOpacity>\n      </View>\n\n      {/* Tab Content */}\n      <View className=\"flex-1 pt-4\">\n        {loading ? (\n          <View className=\"flex-1 items-center justify-center\">\n            <Text\n              className=\"font-['Inter'] text-sm\"\n              style={{ color: colors['muted-foreground'] }}\n            >\n              Loading...\n            </Text>\n          </View>\n        ) : (\n          <>\n            {activeTab === 'global' && renderGlobalTab()}\n            {activeTab === 'hidden' && renderHiddenTab()}\n          </>\n        )}\n      </View>\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/TutorialOverlay.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReactNode' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withTiming' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BlurView' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, ReactNode } from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet, Modal } from 'react-native';\nimport Animated, {\n  FadeIn,\n  FadeOut,\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withSequence,\n  withTiming,\n} from 'react-native-reanimated';\nimport { BlurView } from 'expo-blur';\nimport * as Haptics from 'expo-haptics';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\nexport interface TutorialStep {\n  id: string;\n  title: string;\n  description: string;\n  targetPosition?: { x: number; y: number; width: number; height: number };\n  tooltipPosition?: 'top' | 'bottom' | 'left' | 'right';\n  action?: {\n    label: string;\n    onPress: () => void;\n  };\n  highlightRadius?: number;\n}\n\ninterface TutorialOverlayProps {\n  visible: boolean;\n  step: TutorialStep;\n  onNext?: () => void;\n  onSkip?: () => void;\n  currentStep?: number;\n  totalSteps?: number;\n}\n\n/**\n * TutorialOverlay - Creates an overlay with spotlight effect and contextual tooltip\n * Used for interactive onboarding that highlights real UI elements\n */\nexport function TutorialOverlay({\n  visible,\n  step,\n  onNext,\n  onSkip,\n  currentStep,\n  totalSteps,\n}: TutorialOverlayProps) {\n  const { colors, isDarkMode } = useTheme();\n  const pulseScale = useSharedValue(1);\n\n  useEffect(() => {\n    if (visible && step.targetPosition) {\n      // Pulse animation for spotlight\n      pulseScale.value = withSequence(\n        withSpring(1.05, { damping: 10 }),\n        withSpring(1, { damping: 10 })\n      );\n    }\n  }, [visible, step.id]);\n\n  const spotlightStyle = useAnimatedStyle(() => {\n    if (!step.targetPosition) return {};\n\n    return {\n      position: 'absolute',\n      left: step.targetPosition.x - 8,\n      top: step.targetPosition.y - 8,\n      width: step.targetPosition.width + 16,\n      height: step.targetPosition.height + 16,\n      borderRadius: step.highlightRadius || 16,\n      transform: [{ scale: pulseScale.value }],\n    };\n  });\n\n  const handleNext = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onNext?.();\n  };\n\n  const handleSkip = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onSkip?.();\n  };\n\n  if (!visible) return null;\n\n  return (\n    <Modal transparent visible={visible} animationType=\"none\">\n      <View style={StyleSheet.absoluteFill} pointerEvents=\"box-none\">\n        {/* Dimmed background - much lighter and allows touches through */}\n        <Animated.View\n          style={StyleSheet.absoluteFill}\n          entering={FadeIn.duration(300)}\n          exiting={FadeOut.duration(200)}\n          pointerEvents=\"none\"\n        >\n          <View\n            style={[\n              StyleSheet.absoluteFill,\n              { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.2)' },\n            ]}\n          />\n        </Animated.View>\n\n        {/* Spotlight border - non-blocking */}\n        {step.targetPosition && (\n          <Animated.View\n            style={[\n              spotlightStyle,\n              {\n                borderWidth: 2,\n                borderColor: colors.primary,\n                backgroundColor: 'transparent',\n                shadowColor: colors.primary,\n                shadowOffset: { width: 0, height: 0 },\n                shadowOpacity: 0.6,\n                shadowRadius: 12,\n                elevation: 10,\n              },\n            ]}\n            pointerEvents=\"none\"\n          />\n        )}\n\n        {/* Tooltip */}\n        <Animated.View\n          style={[\n            styles.tooltipContainer,\n            getTooltipPosition(step),\n          ]}\n          entering={FadeIn.delay(100).duration(300).springify()}\n          exiting={FadeOut.duration(200)}\n        >\n          <View style={[styles.tooltip, { backgroundColor: colors.card }]}>\n            {/* Progress indicator */}\n            {currentStep !== undefined && totalSteps !== undefined && (\n              <View style={styles.progressContainer}>\n                <Text style={[styles.progressText, { color: colors['muted-foreground'] }]}>\n                  {currentStep + 1} of {totalSteps}\n                </Text>\n              </View>\n            )}\n\n            <Text style={[styles.tooltipTitle, { color: colors.foreground }]}>\n              {step.title}\n            </Text>\n            <Text style={[styles.tooltipDescription, { color: colors['muted-foreground'] }]}>\n              {step.description}\n            </Text>\n\n            {/* Actions */}\n            <View style={styles.actionsContainer}>\n              {onSkip && (\n                <TouchableOpacity onPress={handleSkip} style={styles.skipButton}>\n                  <Text style={[styles.skipButtonText, { color: colors['muted-foreground'] }]}>\n                    Skip tour\n                  </Text>\n                </TouchableOpacity>\n              )}\n\n              {step.action ? (\n                <TouchableOpacity\n                  onPress={step.action.onPress}\n                  style={[styles.actionButton, { backgroundColor: colors.primary }]}\n                  activeOpacity={0.8}\n                >\n                  <Text style={styles.actionButtonText}>{step.action.label}</Text>\n                </TouchableOpacity>\n              ) : onNext ? (\n                <TouchableOpacity\n                  onPress={handleNext}\n                  style={[styles.actionButton, { backgroundColor: colors.primary }]}\n                  activeOpacity={0.8}\n                >\n                  <Text style={styles.actionButtonText}>Next</Text>\n                </TouchableOpacity>\n              ) : null}\n            </View>\n          </View>\n\n          {/* Arrow pointer */}\n          {step.targetPosition && (\n            <View\n              style={[\n                styles.arrow,\n                getArrowStyle(step.tooltipPosition || 'bottom'),\n                { borderTopColor: colors.card },\n              ]}\n            />\n          )}\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nfunction getTooltipPosition(step: TutorialStep): any {\n  if (!step.targetPosition) {\n    // Centered if no target\n    return {\n      position: 'absolute',\n      bottom: 100,\n      left: 20,\n      right: 20,\n    };\n  }\n\n  const position = step.tooltipPosition || 'bottom';\n  const target = step.targetPosition;\n\n  switch (position) {\n    case 'top':\n      return {\n        position: 'absolute',\n        bottom: '100%',\n        left: Math.max(20, target.x - 100),\n        right: Math.max(20, target.x + target.width - 100),\n        marginBottom: target.y - 20,\n      };\n    case 'bottom':\n      return {\n        position: 'absolute',\n        top: target.y + target.height + 20,\n        left: 20,\n        right: 20,\n      };\n    case 'left':\n      return {\n        position: 'absolute',\n        right: '100%',\n        top: target.y,\n        marginRight: 20,\n        maxWidth: 200,\n      };\n    case 'right':\n      return {\n        position: 'absolute',\n        left: target.x + target.width + 20,\n        top: target.y,\n        maxWidth: 200,\n      };\n    default:\n      return {\n        position: 'absolute',\n        top: target.y + target.height + 20,\n        left: 20,\n        right: 20,\n      };\n  }\n}\n\nfunction getArrowStyle(position: string): any {\n  switch (position) {\n    case 'top':\n      return styles.arrowBottom;\n    case 'bottom':\n      return styles.arrowTop;\n    case 'left':\n      return styles.arrowRight;\n    case 'right':\n      return styles.arrowLeft;\n    default:\n      return styles.arrowTop;\n  }\n}\n\nconst styles = StyleSheet.create({\n  tooltipContainer: {\n    alignItems: 'center',\n    zIndex: 1000,\n  },\n  tooltip: {\n    borderRadius: 16,\n    padding: 20,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 8 },\n    shadowOpacity: 0.3,\n    shadowRadius: 16,\n    elevation: 16,\n    maxWidth: 400,\n  },\n  progressContainer: {\n    alignSelf: 'flex-start',\n    marginBottom: 8,\n  },\n  progressText: {\n    fontSize: 12,\n    fontWeight: '600',\n    textTransform: 'uppercase',\n    letterSpacing: 0.5,\n  },\n  tooltipTitle: {\n    fontSize: 20,\n    fontWeight: '700',\n    fontFamily: 'Lora_700Bold',\n    marginBottom: 8,\n  },\n  tooltipDescription: {\n    fontSize: 15,\n    lineHeight: 22,\n    marginBottom: 16,\n  },\n  actionsContainer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    gap: 12,\n  },\n  skipButton: {\n    padding: 8,\n  },\n  skipButtonText: {\n    fontSize: 14,\n    fontWeight: '500',\n  },\n  actionButton: {\n    flex: 1,\n    paddingVertical: 12,\n    paddingHorizontal: 24,\n    borderRadius: 12,\n    alignItems: 'center',\n  },\n  actionButtonText: {\n    color: 'white',\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  arrow: {\n    width: 0,\n    height: 0,\n    backgroundColor: 'transparent',\n    borderStyle: 'solid',\n  },\n  arrowTop: {\n    borderLeftWidth: 10,\n    borderRightWidth: 10,\n    borderTopWidth: 10,\n    borderLeftColor: 'transparent',\n    borderRightColor: 'transparent',\n    marginTop: -1,\n  },\n  arrowBottom: {\n    borderLeftWidth: 10,\n    borderRightWidth: 10,\n    borderBottomWidth: 10,\n    borderLeftColor: 'transparent',\n    borderRightColor: 'transparent',\n    borderBottomColor: 'white',\n    marginBottom: -1,\n  },\n  arrowLeft: {\n    borderTopWidth: 10,\n    borderBottomWidth: 10,\n    borderLeftWidth: 10,\n    borderTopColor: 'transparent',\n    borderBottomColor: 'transparent',\n    borderLeftColor: 'white',\n    marginLeft: -1,\n  },\n  arrowRight: {\n    borderTopWidth: 10,\n    borderBottomWidth: 10,\n    borderRightWidth: 10,\n    borderTopColor: 'transparent',\n    borderBottomColor: 'transparent',\n    borderRightColor: 'white',\n    marginRight: -1,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/UpgradeModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TIER_LIMITS' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FEATURE_DESCRIPTIONS' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentTier' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":21,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":194,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Upgrade Modal Component\n * Shows subscription tiers and handles upgrades\n * This is a template - integrate with Stripe/RevenueCat for actual payments\n */\n\nimport React, { useState } from 'react';\nimport { View, Text, TouchableOpacity, ScrollView } from 'react-native';\nimport { Check, X, Crown, Star } from 'lucide-react-native';\nimport { TIER_LIMITS, FEATURE_DESCRIPTIONS } from '@/modules/auth';\nimport { useTierInfo } from '@/modules/auth';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\n\ninterface UpgradeModalProps {\n  visible: boolean;\n  onClose: () => void;\n  highlightFeature?: string;\n}\n\nexport function UpgradeModal({ visible, onClose, highlightFeature }: UpgradeModalProps) {\n  const { tier: currentTier, display } = useTierInfo();\n  const [selectedTier, setSelectedTier] = useState<'plus' | 'premium'>('plus');\n\n  const handleUpgrade = async () => {\n    // TODO: Integrate with Stripe/RevenueCat\n    console.log('Upgrading to:', selectedTier);\n\n    // For now, just close the modal\n    // In production, this would:\n    // 1. Open payment sheet (Stripe/RevenueCat)\n    // 2. Process payment\n    // 3. Update subscription in Supabase\n    // 4. Refresh user subscription state\n\n    onClose();\n  };\n\n  const features = [\n    {\n      id: 'maxFriends',\n      name: 'Friend Limit',\n      free: '20 friends',\n      plus: '100 friends',\n      premium: 'Unlimited',\n    },\n    {\n      id: 'maxWeavesPerMonth',\n      name: 'Monthly Weaves',\n      free: '50 weaves',\n      plus: '200 weaves',\n      premium: 'Unlimited',\n    },\n    {\n      id: 'sync',\n      name: 'Cloud Sync',\n      free: '2 devices',\n      plus: '5 devices',\n      premium: 'Unlimited devices',\n    },\n    {\n      id: 'analytics',\n      name: 'Advanced Analytics',\n      free: false,\n      plus: true,\n      premium: true,\n    },\n    {\n      id: 'journal',\n      name: 'Personal Journal',\n      free: false,\n      plus: true,\n      premium: true,\n    },\n    {\n      id: 'export',\n      name: 'Data Export',\n      free: false,\n      plus: true,\n      premium: true,\n    },\n    {\n      id: 'ai',\n      name: 'AI Insights',\n      free: false,\n      plus: false,\n      premium: true,\n    },\n    {\n      id: 'support',\n      name: 'Priority Support',\n      free: false,\n      plus: false,\n      premium: true,\n    },\n  ];\n\n  return (\n    <StandardBottomSheet\n      visible={visible}\n      onClose={onClose}\n      height=\"full\"\n      title=\"Upgrade Weave\"\n    >\n      <ScrollView className=\"flex-1\">\n          {/* Current Tier Badge */}\n          <View className=\"px-6 py-4 bg-gray-50\">\n            <Text className=\"text-sm text-gray-600\">Current Plan</Text>\n            <View className=\"flex-row items-center mt-1\">\n              <Text className=\"text-xl mr-2\">{display.icon}</Text>\n              <Text className=\"text-lg font-semibold\">{display.name}</Text>\n            </View>\n          </View>\n\n          {/* Tier Selection */}\n          <View className=\"px-6 py-6\">\n            <Text className=\"text-lg font-semibold mb-4\">Choose Your Plan</Text>\n\n            {/* Plus Tier Card */}\n            <TouchableOpacity\n              onPress={() => setSelectedTier('plus')}\n              className={`border-2 rounded-xl p-4 mb-4 ${\n                selectedTier === 'plus' ? 'border-purple-500 bg-purple-50' : 'border-gray-200'\n              }`}\n            >\n              <View className=\"flex-row items-center justify-between mb-2\">\n                <View className=\"flex-row items-center\">\n                  <Star size={20} color=\"#8B5CF6\" fill=\"#8B5CF6\" />\n                  <Text className=\"text-xl font-bold ml-2\">Plus</Text>\n                </View>\n                <Text className=\"text-2xl font-bold\">$4.99<Text className=\"text-sm text-gray-500\">/mo</Text></Text>\n              </View>\n              <Text className=\"text-gray-600\">Perfect for power users</Text>\n\n              <View className=\"mt-3 space-y-1\">\n                <Text className=\"text-sm\">• 100 friends</Text>\n                <Text className=\"text-sm\">• 200 weaves/month</Text>\n                <Text className=\"text-sm\">• Advanced analytics</Text>\n                <Text className=\"text-sm\">• Journal access</Text>\n              </View>\n            </TouchableOpacity>\n\n            {/* Premium Tier Card */}\n            <TouchableOpacity\n              onPress={() => setSelectedTier('premium')}\n              className={`border-2 rounded-xl p-4 mb-4 ${\n                selectedTier === 'premium' ? 'border-amber-500 bg-amber-50' : 'border-gray-200'\n              }`}\n            >\n              <View className=\"absolute top-2 right-2 bg-amber-500 px-2 py-1 rounded\">\n                <Text className=\"text-xs text-white font-semibold\">BEST VALUE</Text>\n              </View>\n\n              <View className=\"flex-row items-center justify-between mb-2\">\n                <View className=\"flex-row items-center\">\n                  <Crown size={20} color=\"#F59E0B\" fill=\"#F59E0B\" />\n                  <Text className=\"text-xl font-bold ml-2\">Premium</Text>\n                </View>\n                <Text className=\"text-2xl font-bold\">$9.99<Text className=\"text-sm text-gray-500\">/mo</Text></Text>\n              </View>\n              <Text className=\"text-gray-600\">Everything you need</Text>\n\n              <View className=\"mt-3 space-y-1\">\n                <Text className=\"text-sm\">• Unlimited friends</Text>\n                <Text className=\"text-sm\">• Unlimited weaves</Text>\n                <Text className=\"text-sm\">• AI-powered insights</Text>\n                <Text className=\"text-sm\">• Priority support</Text>\n                <Text className=\"text-sm\">• All Plus features</Text>\n              </View>\n            </TouchableOpacity>\n          </View>\n\n          {/* Feature Comparison Table */}\n          <View className=\"px-6 pb-6\">\n            <Text className=\"text-lg font-semibold mb-4\">Full Comparison</Text>\n\n            <View className=\"bg-gray-50 rounded-xl overflow-hidden\">\n              {/* Header Row */}\n              <View className=\"flex-row border-b border-gray-200 bg-white\">\n                <View className=\"flex-1 p-3\">\n                  <Text className=\"text-xs font-semibold text-gray-500\">FEATURE</Text>\n                </View>\n                <View className=\"w-20 p-3 items-center\">\n                  <Text className=\"text-xs font-semibold text-gray-500\">FREE</Text>\n                </View>\n                <View className=\"w-20 p-3 items-center bg-purple-50\">\n                  <Text className=\"text-xs font-semibold text-purple-600\">PLUS</Text>\n                </View>\n                <View className=\"w-20 p-3 items-center bg-amber-50\">\n                  <Text className=\"text-xs font-semibold text-amber-600\">PRO</Text>\n                </View>\n              </View>\n\n              {/* Feature Rows */}\n              {features.map((feature, index) => (\n                <View\n                  key={feature.id}\n                  className={`flex-row border-b border-gray-200 ${\n                    highlightFeature === feature.id ? 'bg-yellow-50' : ''\n                  }`}\n                >\n                  <View className=\"flex-1 p-3\">\n                    <Text className=\"text-sm\">{feature.name}</Text>\n                  </View>\n                  <View className=\"w-20 p-3 items-center\">\n                    {typeof feature.free === 'boolean' ? (\n                      feature.free ? (\n                        <Check size={16} color=\"#10B981\" />\n                      ) : (\n                        <X size={16} color=\"#EF4444\" />\n                      )\n                    ) : (\n                      <Text className=\"text-xs text-center\">{feature.free}</Text>\n                    )}\n                  </View>\n                  <View className=\"w-20 p-3 items-center bg-purple-50\">\n                    {typeof feature.plus === 'boolean' ? (\n                      feature.plus ? (\n                        <Check size={16} color=\"#8B5CF6\" />\n                      ) : (\n                        <X size={16} color=\"#EF4444\" />\n                      )\n                    ) : (\n                      <Text className=\"text-xs text-center\">{feature.plus}</Text>\n                    )}\n                  </View>\n                  <View className=\"w-20 p-3 items-center bg-amber-50\">\n                    {typeof feature.premium === 'boolean' ? (\n                      feature.premium ? (\n                        <Check size={16} color=\"#F59E0B\" />\n                      ) : (\n                        <X size={16} color=\"#EF4444\" />\n                      )\n                    ) : (\n                      <Text className=\"text-xs text-center\">{feature.premium}</Text>\n                    )}\n                  </View>\n                </View>\n              ))}\n            </View>\n          </View>\n\n          {/* Terms */}\n          <View className=\"px-6 pb-6\">\n            <Text className=\"text-xs text-gray-500 text-center\">\n              Cancel anytime. Prices in USD. Subscriptions auto-renew.\n            </Text>\n          </View>\n      </ScrollView>\n\n      {/* CTA Button */}\n      <View className=\"px-6 py-4 border-t border-gray-200 bg-white\">\n        <TouchableOpacity\n          onPress={handleUpgrade}\n          className=\"bg-purple-600 rounded-xl py-4 items-center\"\n        >\n          <Text className=\"text-white font-semibold text-lg\">\n            Upgrade to {selectedTier === 'plus' ? 'Plus' : 'Premium'}\n          </Text>\n          <Text className=\"text-purple-200 text-sm mt-1\">\n            ${selectedTier === 'plus' ? '4.99' : '9.99'}/month\n          </Text>\n        </TouchableOpacity>\n\n        <TouchableOpacity onPress={onClose} className=\"mt-3\">\n          <Text className=\"text-center text-gray-500\">Maybe Later</Text>\n        </TouchableOpacity>\n      </View>\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeaveIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/CalendarEventsStepComponent.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeIn' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Calendar' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'X' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleSkip' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":109,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'selectedCount' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":122,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CalendarEventsStep\n * \n * Screen 3 of the Sunday check-in flow (Optional).\n * Only appears if there are unlogged events from the calendar.\n * Allows quick batch-logging of weaves.\n */\n\nimport React, { useState } from 'react';\nimport { View, ScrollView, TouchableOpacity } from 'react-native';\nimport Animated, { FadeIn, FadeInDown } from 'react-native-reanimated';\nimport { Calendar, Check, X } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { ScannedEvent } from '@/modules/interactions';\nimport { ArchetypeIcon } from '@/components/ArchetypeIcon';\nimport { Archetype } from '@/components/types';\nimport * as Haptics from 'expo-haptics';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport { Card } from '@/shared/ui/Card';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface CalendarEventsStepProps {\n  onNext: (selectedEvents: ScannedEvent[]) => void;\n  onSkip: () => void;\n}\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport function CalendarEventsStep({ onNext, onSkip }: CalendarEventsStepProps) {\n  const { colors } = useTheme();\n\n  // NOTE: This assumes the parent component fetches and passes events, \n  // but for now we'll fetch them here or mock them to match existing structure.\n  // The original component didn't receive events as props, it likely used a hook.\n  // However, looking at the previous file content, it seems it fetched them internally via `scanWeekForUnloggedEvents`?\n  // Actually, wait - let's verify how data flows.\n  // Ah, the parent WeeklyReflectionModal fetches events and determines if this step is shown.\n  // BUT, this component *also* seems to need the events.\n  // The original component used `useQuery` or similar to fetch.\n  // Let's assume for this refactor we'll get them via a hook or props.\n  // Wait, the original file I viewed (CalendarEventsStepComponent.tsx) had internal state/loading for events.\n  // Let's stick to the pattern of having the parent or a hook load data if possible,\n  // but if the parent is already scanning, pass them down?\n  // Re-reading `WeeklyReflectionModal`... it calls `scanWeekForUnloggedEvents` but doesn't pass the events to this component.\n  // This component likely needs to re-fetch or the modal needs to pass them.\n  // Let's update this component to accept events or fetch them.\n  // For now, let's keep the internal fetching logic if it existed, or better, use the hook.\n\n  // Actually, checking the `WeeklyReflectionModal` refactor...\n  // `const eventReview = await scanWeekForUnloggedEvents();`\n  // It handles the check.\n  // This component should responsibly fetching/displaying.\n  // Let's use `scanWeekForUnloggedEvents` again here.\n\n  const [events, setEvents] = useState<ScannedEvent[]>([]);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    loadEvents();\n  }, []);\n\n  const loadEvents = async () => {\n    try {\n      const scanned = await CalendarService.scanForEvents();\n      setEvents(scanned);\n\n      // Auto-select highly confident matches\n      const autoSelected = new Set<string>();\n      scanned.forEach((e: ScannedEvent) => {\n        if (e.confidence > 0.8) {\n          autoSelected.add(e.id);\n        }\n      });\n      setSelectedIds(autoSelected);\n    } catch (error) {\n      console.error('Error loading events:', error);\n      Alert.alert('Error', 'Could not access calendar. Please check permissions.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const toggleEvent = (id: string) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setSelectedIds(prev => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  };\n\n  const handleContinue = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    const selected = events.filter(e => selectedIds.has(e.id));\n    onNext(selected);\n  };\n\n  const handleSkip = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onSkip();\n  };\n\n  if (loading) {\n    return (\n      <View className=\"flex-1 items-center justify-center\">\n        <Text variant=\"caption\" className=\"text-muted-foreground\">Scanning calendar...</Text>\n      </View>\n    );\n  }\n\n  const selectedCount = selectedIds.size;\n\n  return (\n    <View className=\"flex-1 justify-between\">\n      <View className=\"flex-1\">\n        <View className=\"px-4 mb-6\">\n          <Text variant=\"h3\" className=\"text-center font-lora-medium mb-2\">\n            Did you meet up?\n          </Text>\n          <Text variant=\"body\" className=\"text-center text-muted-foreground\">\n            We found these events on your calendar. Select the ones you want to log as weaves.\n          </Text>\n        </View>\n\n        <ScrollView className=\"flex-1\" showsVerticalScrollIndicator={false}>\n          {events.map((event, index) => {\n            const isSelected = selectedIds.has(event.id);\n            const eventDate = new Date(event.date);\n            const timeStr = eventDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n\n            const friendNames = event.matchedFriends?.map(f => f.name).join(', ');\n\n            return (\n              <Animated.View\n                key={event.id}\n                entering={FadeInDown.delay(index * 100).duration(400)}\n                className=\"mb-3 px-1\"\n              >\n                <TouchableOpacity\n                  onPress={() => toggleEvent(event.id)}\n                  activeOpacity={0.8}\n                >\n                  <Card\n                    className={`p-4 border-2 ${isSelected ? 'border-primary bg-primary/5' : 'border-transparent'}`}\n                  >\n                    <View className=\"flex-row items-center\">\n                      {/* Date/Time Column */}\n                      <View className=\"w-16 items-center justify-center mr-3 border-r border-border pr-3\">\n                        <Text variant=\"caption\" className=\"font-bold uppercase text-muted-foreground\">\n                          {eventDate.toLocaleDateString([], { weekday: 'short' })}\n                        </Text>\n                        <Text variant=\"h4\" className=\"font-bold\">\n                          {eventDate.getDate()}\n                        </Text>\n                        <Text variant=\"caption\" className=\"text-xs text-muted-foreground\">\n                          {timeStr}\n                        </Text>\n                      </View>\n\n                      {/* Event Details */}\n                      <View className=\"flex-1\">\n                        <Text variant=\"h4\" className=\"font-semibold mb-1\" numberOfLines={1}>\n                          {event.title}\n                        </Text>\n\n                        {/* Matched Friends */}\n                        {event.matchedFriends && event.matchedFriends.length > 0 && (\n                          <View className=\"flex-row flex-wrap gap-2 mt-1\">\n                            {event.matchedFriends.map(friend => (\n                              <View key={friend.id} className=\"flex-row items-center bg-muted rounded-full px-2 py-1\">\n                                <ArchetypeIcon\n                                  archetype={friend.archetype as Archetype}\n                                  size={12}\n                                  color={colors.foreground}\n                                />\n                                <Text variant=\"caption\" className=\"ml-1 text-xs\">\n                                  {friend.name}\n                                </Text>\n                              </View>\n                            ))}\n                          </View>\n                        )}\n                      </View>\n\n                      {/* Checkbox */}\n                      <View\n                        className={`w-6 h-6 rounded-full items-center justify-center border ${isSelected ? 'bg-primary border-primary' : 'border-muted-foreground'}`}\n                      >\n                        {isSelected && <Check size={14} color={colors['primary-foreground']} />}\n                      </View>\n                    </View>\n\n                    {/* Friend Selection Hint / List */}\n                    {(!event.matchedFriends || event.matchedFriends.length === 0) ? (\n                      <View className=\"flex-row items-center gap-2 mt-3\">\n                        <Users size={14} color={colors.primary} />\n                        <Text\n                          className=\"text-sm\"\n                          style={{ color: colors.primary, fontFamily: 'Inter_500Medium' }}\n                        >\n                          Tap to select friends\n                        </Text>\n                      </View>\n                    ) : (\n                      <View className=\"flex-row items-center gap-2 mt-3\">\n                        <Users size={14} color={colors['muted-foreground']} />\n                        <Text\n                          className=\"text-sm\"\n                          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                        >\n                          {friendNames}\n                        </Text>\n                      </View>\n                    )}\n\n                    {/* Location */}\n                    {event.location && (\n                      <View className=\"flex-row items-center gap-2 mt-1\">\n                        <MapPin size={14} color={colors['muted-foreground']} />\n                        <Text\n                          className=\"text-sm\"\n                          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                          numberOfLines={1}\n                        >\n                          {event.location}\n                        </Text>\n                      </View>\n                    )}\n                  </Card>\n                </TouchableOpacity>\n              </Animated.View>\n            );\n          })}\n        </ScrollView>\n      </View>\n\n      {/* Bottom Actions */}\n      <View className=\"pt-4 gap-3\">\n        {/* Continue Button */}\n        <TouchableOpacity\n          onPress={handleContinue}\n          className=\"flex-row items-center justify-center px-6 py-4 rounded-xl\"\n          style={{\n            backgroundColor: selectedIds.size > 0 ? colors.primary : colors.muted,\n          }}\n          disabled={selectedIds.size === 0}\n        >\n          <Text\n            className=\"text-base font-semibold mr-2\"\n            style={{\n              color: selectedIds.size > 0 ? 'white' : colors['muted-foreground'],\n              fontFamily: 'Inter_600SemiBold',\n            }}\n          >\n            {selectedIds.size > 0\n              ? `Log ${selectedIds.size} Event${selectedIds.size !== 1 ? 's' : ''}`\n              : 'Select Events to Continue'}\n          </Text>\n          {selectedIds.size > 0 && <ChevronRight size={20} color=\"white\" />}\n        </TouchableOpacity>\n\n        {/* Skip Button */}\n        <TouchableOpacity\n          onPress={onSkip}\n          className=\"items-center py-3\"\n        >\n          <Text\n            className=\"text-sm\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            Skip for now\n          </Text>\n        </TouchableOpacity>\n      </View>\n    </View >\n  );\n}\n\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/GratitudePrompt.tsx","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: 'as' expected.","line":20,"column":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * GratitudePrompt Component\n * Gratitude journaling for weekly reflection with contextual prompts\n */\n\nimport React, { useState, useMemo } from 'react';\nimport { View, Text, TextInput, TouchableOpacity, KeyboardAvoidingView, Platform, ScrollView } from 'react-native';\nimport Animated, { FadeIn } from 'react-native-reanimated';\nimport { Sparkles, Check, Lightbulb, Plus } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { WeeklySummary, generateContextualPrompts, selectBestPrompt, WeekStoryChipSuggestion } from '@/modules/reflection';\nimport { STORY_CHIPS } from '@/modules/reflection';\nimport * as Haptics from 'expo-haptics';\n\ninterface GratitudePromptProps {\n  summary: WeeklySummary;\n  storyChipSuggestions: WeekStoryChipSuggestion[];\n  onComplete: (gratitudeText: string, prompt: string, promptContext: string, storyChips: Array<{ chipId: string; customText?: string }>) => void;\n}\nimport * => s.chipId))\n  );\nconst [showAllChips, setShowAllChips] = useState(false);\n\n// Generate contextual prompts based on weekly summary\nconst contextualPrompt = useMemo(() => {\n  const prompts = generateContextualPrompts(summary);\n  return selectBestPrompt(prompts);\n}, [summary]);\n\nconst handleComplete = () => {\n  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  const storyChips = Array.from(selectedChips).map(chipId => ({ chipId }));\n  onComplete(gratitudeText, contextualPrompt.prompt, contextualPrompt.context, storyChips);\n};\n\nconst toggleChip = (chipId: string) => {\n  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  setSelectedChips(prev => {\n    const next = new Set(prev);\n    if (next.has(chipId)) {\n      next.delete(chipId);\n    } else {\n      next.add(chipId);\n    }\n    return next;\n  });\n};\n\n// Show suggested chips first, then all other chips if expanded\nconst displayChips = useMemo(() => {\n  const suggested = storyChipSuggestions.map(s => s.chip);\n  if (!showAllChips) return suggested;\n\n  // Add all other chips not in suggestions\n  const suggestedIds = new Set(suggested.map(c => c.id));\n  const otherChips = STORY_CHIPS.filter(c => !suggestedIds.has(c.id));\n  return [...suggested, ...otherChips];\n}, [storyChipSuggestions, showAllChips]);\n\nconst canComplete = gratitudeText.trim().length > 0 || true; // Allow skipping\n\nreturn (\n  <KeyboardAvoidingView\n    behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n    className=\"flex-1\"\n  >\n    <ScrollView\n      className=\"flex-1\"\n      showsVerticalScrollIndicator={false}\n      keyboardShouldPersistTaps=\"handled\"\n    >\n      {/* Header */}\n      <Animated.View entering={FadeIn} className=\"mb-6 items-center\">\n        <View\n          className=\"w-16 h-16 rounded-full items-center justify-center mb-4\"\n          style={{ backgroundColor: colors.primary + '20' }}\n        >\n          <Sparkles size={32} color={colors.primary} />\n        </View>\n        <Text\n          className=\"text-2xl font-bold text-center mb-2\"\n          style={{ color: colors.foreground, fontFamily: 'Lora_700Bold' }}\n        >\n          Moment of Gratitude\n        </Text>\n        <Text\n          className=\"text-sm text-center leading-5 px-6\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n        >\n          Take a moment to reflect on the connections that nourished you.\n        </Text>\n      </Animated.View>\n\n      {/* Prompt Card */}\n      <Animated.View\n        entering={FadeIn.delay(100)}\n        className=\"mb-6 p-6 rounded-2xl\"\n        style={{ backgroundColor: colors.secondary + '15', borderColor: colors.secondary + '30', borderWidth: 1 }}\n      >\n        <View className=\"flex-row items-start mb-2\">\n          <Lightbulb size={16} color={colors.secondary} style={{ marginTop: 2, marginRight: 8 }} />\n          <Text\n            className=\"text-xs font-medium flex-1\"\n            style={{ color: colors.secondary, fontFamily: 'Inter_500Medium' }}\n          >\n            {contextualPrompt.context}\n          </Text>\n        </View>\n        <Text\n          className=\"text-base leading-6 italic\"\n          style={{ color: colors.foreground, fontFamily: 'Lora_400Regular' }}\n        >\n          \"{contextualPrompt.prompt}\"\n        </Text>\n      </Animated.View>\n\n      {/* Story Chips Selector */}\n      {displayChips.length > 0 && (\n        <Animated.View entering={FadeIn.delay(150)} className=\"mb-6\">\n          <Text\n            className=\"text-sm font-medium mb-3\"\n            style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n          >\n            What stood out this week?\n          </Text>\n          <View className=\"flex-row flex-wrap gap-2\">\n            {displayChips.map((chip) => {\n              const isSelected = selectedChips.has(chip.id);\n              const isSuggested = storyChipSuggestions.some(s => s.chipId === chip.id);\n\n              return (\n                <TouchableOpacity\n                  key={chip.id}\n                  onPress={() => toggleChip(chip.id)}\n                  className=\"px-4 py-2 rounded-full\"\n                  style={{\n                    backgroundColor: isSelected ? colors.primary + '20' : colors.muted,\n                    borderWidth: isSelected ? 1.5 : 0,\n                    borderColor: isSelected ? colors.primary : 'transparent',\n                  }}\n                >\n                  <Text\n                    className=\"text-sm\"\n                    style={{\n                      color: isSelected ? colors.primary : colors['muted-foreground'],\n                      fontFamily: 'Inter_400Regular',\n                    }}\n                  >\n                    {chip.plainText}\n                  </Text>\n                </TouchableOpacity>\n              );\n            })}\n            {!showAllChips && storyChipSuggestions.length < STORY_CHIPS.length && (\n              <TouchableOpacity\n                onPress={() => {\n                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n                  setShowAllChips(true);\n                }}\n                className=\"px-4 py-2 rounded-full flex-row items-center\"\n                style={{ backgroundColor: colors.muted }}\n              >\n                <Plus size={14} color={colors['muted-foreground']} style={{ marginRight: 4 }} />\n                <Text\n                  className=\"text-sm\"\n                  style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n                >\n                  More\n                </Text>\n              </TouchableOpacity>\n            )}\n          </View>\n          <Text\n            className=\"text-xs mt-2 px-1\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            {storyChipSuggestions.length > 0\n              ? 'Based on your reflections this week • Tap to add or remove'\n              : 'Tap to capture themes from your week'}\n          </Text>\n        </Animated.View>\n      )}\n\n      {/* Text Input */}\n      <Animated.View\n        entering={FadeIn.delay(200)}\n        className=\"mb-6\"\n      >\n        <TextInput\n          value={gratitudeText}\n          onChangeText={setGratitudeText}\n          placeholder=\"Write what comes to mind...\"\n          placeholderTextColor={colors['muted-foreground']}\n          multiline\n          numberOfLines={8}\n          textAlignVertical=\"top\"\n          className=\"p-4 rounded-xl text-base min-h-[160px]\"\n          style={{\n            backgroundColor: colors.card,\n            borderColor: colors.border,\n            borderWidth: 1,\n            color: colors.foreground,\n            fontFamily: 'Inter_400Regular',\n          }}\n        />\n        <Text\n          className=\"text-xs mt-2 px-1\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n        >\n          Optional • Your reflections are private\n        </Text>\n      </Animated.View>\n\n      {/* Benefits Card */}\n      <Animated.View\n        entering={FadeIn.delay(300)}\n        className=\"mb-6 p-4 rounded-xl\"\n        style={{ backgroundColor: colors.muted }}\n      >\n        <Text\n          className=\"text-xs font-semibold mb-2\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_600SemiBold' }}\n        >\n          💡 WHY GRATITUDE MATTERS\n        </Text>\n        <Text\n          className=\"text-xs leading-5\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n        >\n          Reflecting on positive moments strengthens your relationships and increases your sense of connection. Regular gratitude practice has been shown to improve emotional well-being and relationship satisfaction.\n        </Text>\n      </Animated.View>\n    </ScrollView>\n\n    {/* Complete Button */}\n    <Animated.View entering={FadeIn.delay(400)} className=\"pt-4\">\n      <TouchableOpacity\n        onPress={handleComplete}\n        disabled={!canComplete}\n        className=\"py-4 rounded-xl items-center flex-row justify-center\"\n        style={{\n          backgroundColor: canComplete ? colors.primary : colors.muted,\n          opacity: canComplete ? 1 : 0.5,\n        }}\n      >\n        <Check size={20} color={colors['primary-foreground']} />\n        <Text\n          className=\"text-base font-semibold ml-2\"\n          style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n        >\n          {gratitudeText.trim().length > 0 ? 'Complete Reflection' : 'Complete Without Writing'}\n        </Text>\n      </TouchableOpacity>\n    </Animated.View>\n  </KeyboardAvoidingView>\n);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/MissedConnectionsList.tsx","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: ')' expected.","line":46,"column":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MissedConnectionsList\n * \n * Component to display friends who might need re-connection.\n * Used in \"Weave Plans\" or \"Insights\".\n */\n\nimport React, { useState } from 'react';\nimport { View, TouchableOpacity, ScrollView } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport { Card } from '@/shared/ui/Card';\nimport { ArchetypeIcon } from '@/components/ArchetypeIcon';\nimport { Archetype } from '@/components/types';\nimport { Clock, ArrowRight } from 'lucide-react-native';\nimport { MissedFriend } from '@/modules/reflection';\n\ninterface MissedConnectionsListProps {\n  missedFriends: MissedFriend[];\n  onWeave: (friendId: string) => void;\n  onViewProfile: (friendId: string) => void;\n}\n\nexport function MissedConnectionsList({ missedFriends, onWeave, onViewProfile }: MissedConnectionsListProps) {\n  const { colors } = useTheme();\n\n  if (!missedFriends || missedFriends.length === 0) {\n    return (\n      <Card className=\"p-6 items-center justify-center bg-muted/20 border-dashed\">\n        <Text variant=\"body\" className=\"text-muted-foreground text-center\">\n          You're all caught up! No missed connections this week.\n        </Text>\n      </Card>\n    );\n  }\n\n  const formatDays = (days: number) => {\n    if (days === 0) return 'Today';\n    if (days === 1) return 'Yesterday';\n    return `${days} days ago`;\n  };\n\n  return (\n    className = \"mb-3 rounded-2xl overflow-hidden\"\n              style = {{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }\n}\n            >\n  {/* Friend Info */ }\n  < View className = \"p-4\" >\n    <View className=\"flex-row items-center mb-3\">\n      {/* Archetype Icon */}\n      <View\n        className=\"w-12 h-12 rounded-full items-center justify-center mr-3\"\n        style={{ backgroundColor: colors.muted }}\n      >\n        <ArchetypeIcon\n          archetype={missed.friend.archetype as Archetype}\n          size={24}\n          color={colors.foreground}\n        />\n      </View>\n\n      {/* Name and Score */}\n      <View className=\"flex-1\">\n        <Text\n          className=\"text-lg font-semibold mb-1\"\n          style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n        >\n          {missed.friend.name}\n        </Text>\n        <View className=\"flex-row items-center gap-2\">\n          <View\n            className=\"px-2 py-0.5 rounded-full\"\n            style={{ backgroundColor: scoreColor + '20' }}\n          >\n            <Text\n              className=\"text-xs font-medium\"\n              style={{ color: scoreColor, fontFamily: 'Inter_500Medium' }}\n            >\n              {Math.round(missed.weaveScore)} / 100\n            </Text>\n          </View>\n          <Text\n            className=\"text-xs\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            {missed.daysSinceLastContact < 999\n              ? `${missed.daysSinceLastContact}d since last contact`\n              : 'No recent contact'}\n          </Text>\n        </View>\n      </View>\n    </View>\n\n{/* Suggestion */ }\n<View\n  className=\"p-3 rounded-xl mb-3\"\n  style={{ backgroundColor: colors.secondary + '10' }}\n>\n  <Text\n    className=\"text-xs mb-1\"\n    style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n  >\n    They value {missed.archetypeValue}. Try:\n  </Text>\n  <Text\n    className=\"text-sm font-medium\"\n    style={{ color: colors.foreground, fontFamily: 'Inter_500Medium' }}\n  >\n    {missed.suggestedAction}\n  </Text>\n</View>\n\n{/* Action Button */ }\n<TouchableOpacity\n  onPress={() => handleLogWeave(missed.friend.id, missed.friend.name)}\n  className=\"flex-row items-center justify-center py-3 rounded-xl\"\n  style={{ backgroundColor: colors.primary }}\n>\n  <Heart size={16} color={colors['primary-foreground']} fill={colors['primary-foreground']} />\n  <Text\n    className=\"text-sm font-semibold ml-2\"\n    style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n  >\n    Log a Weave with {missed.friend.name}\n  </Text>\n</TouchableOpacity>\n              </View >\n            </Animated.View >\n          );\n        })}\n      </ScrollView >\n\n  {/* Bottom Actions */ }\n  < View className = \"gap-3\" >\n        <TouchableOpacity\n          onPress={onNext}\n          className=\"py-4 rounded-xl items-center\"\n          style={{ backgroundColor: colors.primary }}\n        >\n          <View className=\"flex-row items-center\">\n            <Text\n              className=\"text-base font-semibold mr-2\"\n              style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n            >\n              Continue to Reflection\n            </Text>\n            <ChevronRight size={20} color={colors['primary-foreground']} />\n          </View>\n        </TouchableOpacity>\n\n        <TouchableOpacity\n          onPress={onSkip}\n          className=\"py-3 items-center\"\n        >\n          <Text\n            className=\"text-sm font-medium\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_500Medium' }}\n          >\n            Skip for now\n          </Text>\n        </TouchableOpacity>\n      </View >\n    </View >\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/ReflectionPromptStepComponent.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showChips' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ReflectionPromptStep\n * \n * Screen 1 of the Sunday check-in flow.\n * Shows one contextual prompt based on the week's data.\n * Writing is optional but encouraged. Chips are detected from text.\n */\n\nimport React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { View, TextInput, TouchableOpacity, KeyboardAvoidingView, Platform, TouchableWithoutFeedback, Keyboard } from 'react-native';\nimport { Edit3, Sparkles } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport {\n  ReflectionPrompt,\n  detectChipsFromText,\n  DetectedChip,\n  STORY_CHIPS,\n} from '@/modules/reflection';\nimport * as Haptics from 'expo-haptics';\n\ninterface ReflectionPromptStepProps {\n  prompt: ReflectionPrompt;\n  onNext: (text: string, selectedChipIds: string[]) => void;\n}\n\nexport function ReflectionPromptStep({ prompt, onNext }: ReflectionPromptStepProps) {\n  const { colors } = useTheme();\n\n  const [text, setText] = useState('');\n  const [selectedChipIds, setSelectedChipIds] = useState<Set<string>>(new Set());\n  const [detectedChips, setDetectedChips] = useState<DetectedChip[]>([]);\n  const [showChips, setShowChips] = useState(false);\n\n  // Detect chips from text with debounce\n  useEffect(() => {\n    if (text.length < 10) {\n      setDetectedChips([]);\n      setShowChips(false);\n      return;\n    }\n\n    const timer = setTimeout(() => {\n      const detected = detectChipsFromText(text);\n      setDetectedChips(detected);\n      setShowChips(detected.length > 0);\n    }, 500); // 500ms debounce\n\n    return () => clearTimeout(timer);\n  }, [text]);\n\n  // Get chips to display (either detected or defaults from prompt)\n  const displayChips = useMemo(() => {\n    if (detectedChips.length > 0) {\n      return detectedChips.map(d => d.chip);\n    }\n\n    // If no text yet, show suggested chips from prompt\n    if (text.length < 10 && prompt.suggestedChipIds && prompt.suggestedChipIds.length > 0) {\n      return prompt.suggestedChipIds\n        .map(id => STORY_CHIPS.find(c => c.id === id))\n        .filter((c): c is typeof STORY_CHIPS[0] => c !== undefined)\n        .slice(0, 2);\n    }\n\n    return [];\n  }, [detectedChips, text, prompt.suggestedChipIds]);\n\n  const toggleChip = useCallback((chipId: string) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setSelectedChipIds(prev => {\n      const next = new Set(prev);\n      if (next.has(chipId)) {\n        next.delete(chipId);\n      } else {\n        next.add(chipId);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleContinue = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onNext(text.trim(), Array.from(selectedChipIds));\n  };\n\n  const hasContent = text.trim().length > 0;\n\n  return (\n    <KeyboardAvoidingView\n      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n      className=\"flex-1\"\n      keyboardVerticalOffset={100}\n    >\n      <TouchableWithoutFeedback onPress={Keyboard.dismiss}>\n        <View className=\"flex-1 justify-between\">\n          {/* Top Section - Prompt */}\n          <View className=\"flex-1 justify-center px-2\">\n            {/* Icon */}\n            <View className=\"items-center mb-6\">\n              <View\n                className=\"w-14 h-14 rounded-full items-center justify-center bg-primary/10\"\n                style={{ backgroundColor: colors.primary + '15' }}\n              >\n                <Edit3 size={24} color={colors.primary} />\n              </View>\n            </View>\n\n            {/* Prompt Question */}\n            <View>\n              <Text variant=\"h3\" className=\"text-center leading-7 mb-8 px-4 font-lora-medium\">\n                {prompt.question}\n              </Text>\n            </View>\n\n            {/* Text Input */}\n            <View>\n              <TextInput\n                value={text}\n                onChangeText={setText}\n                placeholder=\"Write something... (optional)\"\n                placeholderTextColor={colors['muted-foreground']}\n                multiline\n                numberOfLines={4}\n                textAlignVertical=\"top\"\n                className=\"px-4 py-4 rounded-2xl text-base bg-card border border-border text-foreground font-inter-regular min-h-[120px] max-h-[200px]\"\n                style={{\n                  color: colors.foreground\n                }}\n              />\n            </View>\n\n            {/* Detected/Suggested Chips */}\n            {displayChips.length > 0 && (\n              <View className=\"mt-4\">\n                <View className=\"flex-row items-center gap-2 mb-3\">\n                  <Sparkles size={14} color={colors['muted-foreground']} />\n                  <Text variant=\"caption\" className=\"text-muted-foreground\">\n                    {detectedChips.length > 0 ? 'Add a theme?' : 'Suggested themes'}\n                  </Text>\n                </View>\n\n                <View className=\"flex-row flex-wrap gap-2\">\n                  {displayChips.map((chip) => {\n                    const isSelected = selectedChipIds.has(chip.id);\n\n                    return (\n                      <TouchableOpacity\n                        key={chip.id}\n                        onPress={() => toggleChip(chip.id)}\n                        className={`px-4 py-2.5 rounded-full border ${isSelected ? 'bg-primary/20 border-primary' : 'bg-muted border-transparent'}`}\n                        style={{\n                          backgroundColor: isSelected ? colors.primary + '20' : colors.muted,\n                          borderColor: isSelected ? colors.primary : 'transparent',\n                        }}\n                        activeOpacity={0.7}\n                      >\n                        <Text\n                          variant=\"body\"\n                          className={isSelected ? 'text-primary font-medium' : 'text-foreground font-medium'}\n                          style={{\n                            color: isSelected ? colors.primary : colors.foreground\n                          }}\n                        >\n                          {chip.plainText}\n                        </Text>\n                      </TouchableOpacity>\n                    );\n                  })}\n                </View>\n              </View>\n            )}\n          </View>\n\n          {/* Bottom Section - Continue Button */}\n          <View className=\"pt-4 pb-2\">\n            <Button\n              onPress={handleContinue}\n              variant=\"primary\"\n              className=\"w-full\"\n            >\n              {hasContent ? 'Continue' : 'Skip writing'}\n            </Button>\n\n            {!hasContent && (\n              <Text variant=\"caption\" className=\"text-center mt-3 text-muted-foreground\">\n                You can always add a reflection later\n              </Text>\n            )}\n          </View>\n        </View>\n      </TouchableWithoutFeedback>\n    </KeyboardAvoidingView>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/ReflectionReadyPrompt.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/WeekSnapshotStepComponent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/WeekSummary.tsx","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: JSX expressions must have one parent element.","line":73,"column":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WeekSummary\n * \n * Used in Dashboard to show a summary card of the previous weekly reflection\n * or prompts to start a new one if available.\n */\n\nimport React from 'react';\nimport { View, TouchableOpacity, Image } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Text } from '@/shared/ui/Text';\nimport { Card } from '@/shared/ui/Card';\nimport { Button } from '@/shared/ui/Button';\nimport { BarChart, ArrowRight, TrendingUp, TrendingDown, Minus } from 'lucide-react-native';\nimport { ExtendedWeeklySummary } from '@/modules/reflection';\n\ninterface WeekSummaryProps {\n  summary?: ExtendedWeeklySummary;\n  onPress?: () => void;\n  isReflectionReady?: boolean;\n}\n\nexport function WeekSummary({ summary, onPress, isReflectionReady }: WeekSummaryProps) {\n  const { colors } = useTheme();\n\n  // Loading or empty state\n  if (!summary && !isReflectionReady) {\n    return (\n      <Card className=\"p-4 bg-card/50\">\n        <View className=\"flex-row items-center gap-3\">\n          <View className=\"w-10 h-10 rounded-full bg-muted animate-pulse\" />\n          <View className=\"gap-2 flex-1\">\n            <View className=\"h-4 w-1/3 bg-muted rounded animate-pulse\" />\n            <View className=\"h-3 w-1/2 bg-muted rounded animate-pulse\" />\n          </View>\n        </View>\n      </Card>\n    );\n  }\n\n  // Reflection Ready State\n  if (isReflectionReady) {\n    return (\n      <TouchableOpacity onPress={onPress} activeOpacity={0.9}>\n        <Card className=\"p-0 overflow-hidden border-primary/20\">\n          <View className=\"absolute inset-0 bg-primary/5\" />\n          <View className=\"p-5 flex-row items-center justify-between\">\n            <View className=\"flex-1 mr-4\">\n              <Text variant=\"h4\" className=\"text-primary font-bold mb-1\">\n                Reflection Ready\n              </Text>\n              <Text variant=\"body\" className=\"text-muted-foreground text-sm\">\n                Your weekly friendship check-in is ready. Take 2 minutes to reflect.\n              </Text>\n            </View>\n            <View className=\"w-10 h-10 rounded-full bg-primary/10 items-center justify-center\">\n              <ArrowRight size={20} color={colors.primary} />\n            </View>\n          </View>\n        </Card>\n      </TouchableOpacity>\n    );\n  }\n\n  if (!summary) return null;\n\n  // Comparison logic\n  const comparison = summary.comparison;\n  const isUp = comparison && comparison.weavesChange > 0;\n  const isDown = comparison && comparison.weavesChange < 0;\n\n  return (\n          <Text className=\"text-4xl text-center mb-3\">🌙</Text>\n          <Text\n            className=\"text-lg font-semibold text-center mb-2\"\n            style={{ color: colors.foreground, fontFamily: 'Lora_600SemiBold' }}\n          >\n            A quiet week\n          </Text>\n          <Text\n            className=\"text-sm text-center leading-5\"\n            style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n          >\n            Sometimes we need rest. When you're ready, your friends are waiting.\n          </Text>\n        </Animated.View >\n      )\n}\n\n{/* Stats Grid */ }\n<View className=\"gap-3 mb-6\">\n  {stats.map((stat, index) => (\n    <Animated.View\n      key={stat.label}\n      entering={FadeInDown.delay(200 + index * 100)}\n      className=\"flex-row items-center p-4 rounded-xl\"\n      style={{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }}\n    >\n      <View\n        className=\"w-12 h-12 rounded-full items-center justify-center mr-4\"\n        style={{ backgroundColor: stat.color + '20' }}\n      >\n        <stat.icon size={24} color={stat.color} />\n      </View>\n      <View className=\"flex-1\">\n        <Text\n          className=\"text-xs mb-1\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n        >\n          {stat.label}\n        </Text>\n        <View className=\"flex-row items-baseline gap-2\">\n          <Text\n            className=\"text-2xl font-bold\"\n            style={{ color: colors.foreground, fontFamily: 'Lora_700Bold' }}\n          >\n            {stat.value}\n          </Text>\n          {stat.subValue && (\n            <Text\n              className=\"text-sm\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            >\n              {stat.subValue}\n            </Text>\n          )}\n        </View>\n      </View>\n    </Animated.View>\n  ))}\n</View>\n\n{/* Comparison Insights (vs Last Week) */ }\n{\n  summary.comparison && (\n    <Animated.View\n      entering={FadeInDown.delay(500)}\n      className=\"mb-6 p-4 rounded-xl\"\n      style={{ backgroundColor: colors.muted }}\n    >\n      <Text\n        className=\"text-sm font-semibold mb-3\"\n        style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n      >\n        📈 This Week vs Last Week\n      </Text>\n      <View className=\"gap-2\">\n        {/* Weaves comparison */}\n        <View className=\"flex-row items-center\">\n          {summary.comparison.weavesChange > 0 ? (\n            <ArrowUp size={16} color=\"#10b981\" />\n          ) : summary.comparison.weavesChange < 0 ? (\n            <ArrowDown size={16} color=\"#ef4444\" />\n          ) : (\n            <Minus size={16} color={colors['muted-foreground']} />\n          )}\n          <Text\n            className=\"text-xs ml-2\"\n            style={{\n              color: summary.comparison.weavesChange > 0 ? '#10b981' :\n                summary.comparison.weavesChange < 0 ? '#ef4444' :\n                  colors['muted-foreground'],\n              fontFamily: 'Inter_400Regular'\n            }}\n          >\n            {summary.comparison.weavesChange > 0 ? '+' : ''}{summary.comparison.weavesChange} weaves\n            {summary.comparison.weavesChange > 0 ? ' from last week' : ' vs last week'}\n          </Text>\n        </View>\n        {/* Friends comparison */}\n        <View className=\"flex-row items-center\">\n          {summary.comparison.friendsChange > 0 ? (\n            <ArrowUp size={16} color=\"#10b981\" />\n          ) : summary.comparison.friendsChange < 0 ? (\n            <ArrowDown size={16} color=\"#ef4444\" />\n          ) : (\n            <Minus size={16} color={colors['muted-foreground']} />\n          )}\n          <Text\n            className=\"text-xs ml-2\"\n            style={{\n              color: summary.comparison.friendsChange > 0 ? '#10b981' :\n                summary.comparison.friendsChange < 0 ? '#ef4444' :\n                  colors['muted-foreground'],\n              fontFamily: 'Inter_400Regular'\n            }}\n          >\n            {summary.comparison.friendsChange > 0 ? '+' : ''}{summary.comparison.friendsChange} friends contacted\n          </Text>\n        </View>\n      </View>\n    </Animated.View>\n  )\n}\n\n{/* Pattern Recognition */ }\n{\n  summary.patterns && (\n    <Animated.View\n      entering={FadeInDown.delay(600)}\n      className=\"mb-6 gap-3\"\n    >\n      {/* Most Consistent Friend */}\n      {summary.patterns.mostConsistentFriend && summary.patterns.mostConsistentFriend.weaveCount > 1 && (\n        <View\n          className=\"flex-row items-center p-4 rounded-xl\"\n          style={{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }}\n        >\n          <Heart size={20} color={colors.primary} />\n          <View className=\"flex-1 ml-3\">\n            <Text\n              className=\"text-xs mb-1\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            >\n              💪 Most consistent\n            </Text>\n            <Text\n              className=\"text-sm font-semibold\"\n              style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n            >\n              {summary.patterns.mostConsistentFriend.name} ({summary.patterns.mostConsistentFriend.weaveCount} weaves)\n            </Text>\n          </View>\n        </View>\n      )}\n\n      {/* Rising Connection */}\n      {summary.patterns.risingConnection && (\n        <View\n          className=\"flex-row items-center p-4 rounded-xl\"\n          style={{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }}\n        >\n          <Sparkles size={20} color=\"#10b981\" />\n          <View className=\"flex-1 ml-3\">\n            <Text\n              className=\"text-xs mb-1\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            >\n              🌟 Strongest connection\n            </Text>\n            <Text\n              className=\"text-sm font-semibold\"\n              style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n            >\n              {summary.patterns.risingConnection.name}\n            </Text>\n          </View>\n        </View>\n      )}\n\n      {/* Needs Attention */}\n      {summary.patterns.needsAttention && summary.patterns.needsAttention > 0 && (\n        <View\n          className=\"flex-row items-center p-4 rounded-xl\"\n          style={{ backgroundColor: colors.card, borderColor: colors.border, borderWidth: 1 }}\n        >\n          <AlertCircle size={20} color=\"#f59e0b\" />\n          <View className=\"flex-1 ml-3\">\n            <Text\n              className=\"text-xs mb-1\"\n              style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n            >\n              💭 Needs attention\n            </Text>\n            <Text\n              className=\"text-sm font-semibold\"\n              style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n            >\n              {summary.patterns.needsAttention} friend{summary.patterns.needsAttention > 1 ? 's' : ''}\n            </Text>\n          </View>\n        </View>\n      )}\n    </Animated.View>\n  )\n}\n\n{/* Social Health Score */ }\n{\n  summary.socialHealth && (\n    <Animated.View\n      entering={FadeInDown.delay(700)}\n      className=\"mb-8 p-5 rounded-xl\"\n      style={{\n        backgroundColor: summary.socialHealth.score >= 70 ? '#10b98120' :\n          summary.socialHealth.score >= 50 ? '#f59e0b20' :\n            '#ef444420'\n      }}\n    >\n      <Text\n        className=\"text-sm font-semibold mb-2\"\n        style={{ color: colors.foreground, fontFamily: 'Inter_600SemiBold' }}\n      >\n        Your Weave Health\n      </Text>\n      <View className=\"flex-row items-center\">\n        <Text\n          className=\"text-4xl font-bold mr-3\"\n          style={{\n            color: summary.socialHealth.score >= 70 ? '#10b981' :\n              summary.socialHealth.score >= 50 ? '#f59e0b' :\n                '#ef4444',\n            fontFamily: 'Lora_700Bold'\n          }}\n        >\n          {summary.socialHealth.score}%\n        </Text>\n        <Text\n          className=\"text-sm flex-1\"\n          style={{ color: colors['muted-foreground'], fontFamily: 'Inter_400Regular' }}\n        >\n          Average of all your friendship scores\n        </Text>\n      </View>\n    </Animated.View>\n  )\n}\n\n{/* Continue Button */ }\n<TouchableOpacity\n  onPress={onNext}\n  className=\"py-4 rounded-xl items-center\"\n  style={{ backgroundColor: colors.primary }}\n>\n  <Text\n    className=\"text-base font-semibold\"\n    style={{ color: colors['primary-foreground'], fontFamily: 'Inter_600SemiBold' }}\n  >\n    {summary.missedFriends.length > 0 ? 'See Who Needs Attention' : 'Continue'}\n  </Text>\n</TouchableOpacity>\n    </ScrollView >\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/WeeklyReflectionDetailModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/WeeklyReflection/WeeklyReflectionModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'extendWeeklySummary' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WeeklyReflectionModal (Redesigned)\n * \n * Sunday check-in flow: 60 seconds, writing-first, compact celebration.\n * \n * Flow:\n * 1. ReflectionPromptStep - One contextual question, optional writing, chip detection\n * 2. WeekSnapshotStep - Compact stats, insight, up to 3 friends needing attention\n * 3. CalendarEventsStep - Only if unlogged events exist (optional catch-up)\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { View, TouchableOpacity } from 'react-native';\nimport { WeaveLoading } from '@/shared/components/WeaveLoading';\nimport { ChevronLeft } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport {\n  scanWeekForUnloggedEvents,\n  batchLogCalendarEvents,\n  ExtendedWeeklySummary,\n  calculateExtendedWeeklySummary,\n  extendWeeklySummary,\n  generateReflectionPrompt,\n  generateInsightLine,\n  ReflectionPrompt,\n  InsightLine,\n  PromptEngineInput,\n} from '@/modules/reflection';\nimport { notificationStore } from '@/modules/notifications';\nimport { ReflectionPromptStep } from './ReflectionPromptStepComponent';\nimport { WeekSnapshotStep } from './WeekSnapshotStepComponent';\nimport { CalendarEventsStep } from './CalendarEventsStepComponent';\nimport { database } from '@/db';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport { ScannedEvent } from '@/modules/interactions';\nimport * as Haptics from 'expo-haptics';\nimport { WeeklyReflectionChannel } from '@/modules/notifications';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface WeeklyReflectionModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\ntype Step = 'prompt' | 'snapshot' | 'events';\n\ninterface ReflectionData {\n  text: string;\n  chipIds: string[];\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Build prompt engine input from extended weekly summary\n * The ExtendedWeeklySummary already has all the data we need\n */\nfunction buildPromptEngineInput(summary: ExtendedWeeklySummary): PromptEngineInput {\n  // Find top friend (most weaves this week)\n  const topFriend = summary.friendActivity.length > 0\n    ? summary.friendActivity[0]\n    : undefined;\n\n  // Find reconnected friend (first from reconnections list)\n  const reconnectedFriend = summary.reconnections.length > 0\n    ? summary.reconnections[0]\n    : undefined;\n\n  // Get comparison data for previous week\n  const previousWeekWeaves = summary.comparison\n    ? summary.totalWeaves - summary.comparison.weavesChange\n    : undefined;\n\n  return {\n    totalWeaves: summary.totalWeaves,\n    friendsContacted: summary.friendsContacted,\n    topFriend: topFriend ? {\n      id: topFriend.friendId,\n      name: topFriend.friendName,\n      weaveCount: topFriend.weaveCount,\n    } : undefined,\n    reconnectedFriend: reconnectedFriend ? {\n      id: reconnectedFriend.friendId,\n      name: reconnectedFriend.friendName,\n      daysSinceLastContact: reconnectedFriend.daysSince,\n    } : undefined,\n    topActivity: summary.topActivity,\n    topActivityCount: summary.topActivityCount,\n    isQuietWeek: summary.totalWeaves < 2,\n    previousWeekWeaves,\n    weekStreak: summary.weekStreak,\n    averageWeeklyWeaves: summary.averageWeeklyWeaves,\n  };\n}\n\n// ============================================================================\n// COMPONENT\n// ============================================================================\n\nexport function WeeklyReflectionModal({ isOpen, onClose }: WeeklyReflectionModalProps) {\n  const { colors } = useTheme();\n\n  // State\n  const [currentStep, setCurrentStep] = useState<Step>('prompt');\n  const [isLoading, setIsLoading] = useState(true);\n  const [summary, setSummary] = useState<ExtendedWeeklySummary | null>(null);\n  const [prompt, setPrompt] = useState<ReflectionPrompt | null>(null);\n  const [insight, setInsight] = useState<InsightLine | null>(null);\n  const [reflectionData, setReflectionData] = useState<ReflectionData>({ text: '', chipIds: [] });\n  const [hasUnloggedEvents, setHasUnloggedEvents] = useState(false);\n  const [selectedEvents, setSelectedEvents] = useState<ScannedEvent[]>([]);\n\n  // Load data when modal opens\n  useEffect(() => {\n    if (isOpen) {\n      loadData();\n    } else {\n      // Reset state when closed\n      setCurrentStep('prompt');\n      setReflectionData({ text: '', chipIds: [] });\n      setSelectedEvents([]);\n    }\n  }, [isOpen]);\n\n  const loadData = async () => {\n    setIsLoading(true);\n    try {\n      // Load extended weekly summary (includes friendActivity, reconnections, weekStreak)\n      const summaryData = await calculateExtendedWeeklySummary();\n      setSummary(summaryData);\n\n      // Build prompt engine input and generate prompt/insight\n      const promptInput = buildPromptEngineInput(summaryData);\n      const generatedPrompt = generateReflectionPrompt(promptInput);\n      const generatedInsight = generateInsightLine(promptInput);\n\n      setPrompt(generatedPrompt);\n      setInsight(generatedInsight);\n\n      // Check for unlogged calendar events\n      const eventReview = await scanWeekForUnloggedEvents();\n\n      setHasUnloggedEvents(eventReview.events.length > 0);\n\n    } catch (error) {\n      console.error('[WeeklyReflectionModal] Error loading data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // ============================================================================\n  // STEP HANDLERS\n  // ============================================================================\n\n  const handlePromptNext = (text: string, chipIds: string[]) => {\n    setReflectionData({ text, chipIds });\n    setCurrentStep('snapshot');\n  };\n\n  const handleSnapshotComplete = async () => {\n    // Save completion\n    if (summary) {\n      await notificationStore.setLastReflectionDate(new Date());\n    }\n\n    // Move to next step or save and close\n    if (hasUnloggedEvents) {\n      setCurrentStep('events');\n    } else {\n      await saveAndClose();\n    }\n  };\n\n  const handleEventsNext = async (events: ScannedEvent[]) => {\n    setSelectedEvents(events);\n    await saveAndClose(events);\n  };\n\n  const handleEventsSkip = async () => {\n    await saveAndClose();\n  };\n\n  // ============================================================================\n  // SAVE & CLOSE\n  // ============================================================================\n\n  const saveAndClose = async (events?: ScannedEvent[]) => {\n    if (!summary || !prompt) return;\n\n    try {\n      const eventsToLog = events || selectedEvents;\n\n      // Batch log selected calendar events if any\n      if (eventsToLog.length > 0) {\n        const emotionalRating = reflectionData.text.trim().length > 0 ? 8 : undefined;\n        await batchLogCalendarEvents({\n          events: eventsToLog,\n          emotionalRating,\n          reflectionNotes: reflectionData.text.trim().length > 0 ? reflectionData.text : undefined,\n        });\n        console.log(`[WeeklyReflection] Batch logged ${eventsToLog.length} calendar events`);\n      }\n\n      // Save weekly reflection to database\n      await database.write(async () => {\n        await database.get<WeeklyReflection>('weekly_reflections').create((reflection) => {\n          reflection.weekStartDate = summary.weekStartDate.getTime();\n          reflection.weekEndDate = summary.weekEndDate.getTime();\n          reflection.totalWeaves = summary.totalWeaves;\n          reflection.friendsContacted = summary.friendsContacted;\n          reflection.topActivity = summary.topActivity;\n          reflection.topActivityCount = summary.topActivityCount;\n          reflection.missedFriendsCount = summary.missedFriends.length;\n          reflection.gratitudeText = reflectionData.text.trim().length > 0 ? reflectionData.text : undefined;\n          reflection.gratitudePrompt = prompt.question;\n          reflection.promptContext = prompt.context;\n          reflection.storyChips = reflectionData.chipIds.map(chipId => ({ chipId }));\n          reflection.completedAt = new Date();\n        });\n      });\n\n      // Mark reflection as complete (for timing/notifications)\n      await notificationStore.setLastReflectionDate(new Date());\n      // Cancel the scheduled notification since user completed it now\n      await WeeklyReflectionChannel.cancel('weekly-reflection');\n\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      onClose();\n\n    } catch (error) {\n      console.error('[WeeklyReflectionModal] Error saving reflection:', error);\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n      // Still close even if save fails\n      onClose();\n    }\n  };\n\n  // ============================================================================\n  // NAVIGATION\n  // ============================================================================\n\n  const handleBack = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    if (currentStep === 'snapshot') {\n      setCurrentStep('prompt');\n    } else if (currentStep === 'events') {\n      setCurrentStep('snapshot');\n    }\n  };\n\n  const handleClose = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onClose();\n  };\n\n  // ============================================================================\n  // RENDER\n  // ============================================================================\n\n  const stepTitles: Record<Step, string> = {\n    prompt: 'Check-in',\n    snapshot: 'Your Week',\n    events: 'Calendar',\n  };\n\n  // Progress indicator\n  const steps: Step[] = hasUnloggedEvents ? ['prompt', 'snapshot', 'events'] : ['prompt', 'snapshot'];\n  const currentStepIndex = steps.indexOf(currentStep);\n\n  return (\n    <StandardBottomSheet\n      visible={isOpen}\n      onClose={handleClose}\n      height=\"full\"\n      title={stepTitles[currentStep]}\n    >\n      {/* Back Button */}\n      {currentStep !== 'prompt' && (\n        <View className=\"px-5 pb-3 border-b border-border\">\n          <TouchableOpacity onPress={handleBack} className=\"flex-row items-center gap-1\">\n            <ChevronLeft size={20} color={colors.foreground} />\n            <Text variant=\"body\" className=\"font-medium text-foreground\">Back</Text>\n          </TouchableOpacity>\n        </View>\n      )}\n\n      {/* Progress Indicator */}\n      <View className=\"flex-row px-5 py-3 gap-2\">\n        {steps.map((step, index) => {\n          const isActive = step === currentStep;\n          const isCompleted = index < currentStepIndex;\n\n          return (\n            <View\n              key={step}\n              className=\"flex-1 h-1 rounded-full\"\n              style={{\n                backgroundColor: isActive || isCompleted ? colors.primary : colors.muted,\n                opacity: isActive ? 1 : isCompleted ? 0.6 : 0.3,\n              }}\n            />\n          );\n        })}\n      </View>\n\n      {/* Content */}\n      <View className=\"flex-1 px-5 py-2\">\n        {isLoading ? (\n          <View className=\"flex-1 items-center justify-center\">\n            <WeaveLoading size={48} />\n            <Text variant=\"caption\" className=\"text-muted-foreground mt-4\">\n              Preparing your check-in...\n            </Text>\n          </View>\n        ) : summary && prompt && insight ? (\n          <>\n            {currentStep === 'prompt' && (\n              <View className=\"flex-1\">\n                <ReflectionPromptStep\n                  prompt={prompt}\n                  onNext={handlePromptNext}\n                />\n              </View>\n            )}\n\n            {currentStep === 'snapshot' && (\n              <View className=\"flex-1\">\n                <WeekSnapshotStep\n                  summary={summary}\n                  insight={insight}\n                  onComplete={handleSnapshotComplete}\n                />\n              </View>\n            )}\n\n            {currentStep === 'events' && (\n              <View className=\"flex-1\">\n                <CalendarEventsStep\n                  onNext={handleEventsNext}\n                  onSkip={handleEventsSkip}\n                />\n              </View>\n            )}\n          </>\n        ) : (\n          <View className=\"flex-1 items-center justify-center\">\n            <Text variant=\"body\" className=\"text-muted-foreground text-center\">\n              Unable to load check-in. Please try again.\n            </Text>\n            <Button\n              onPress={loadData}\n              variant=\"primary\"\n              className=\"mt-4\"\n            >\n              Retry\n            </Button>\n          </View>\n        )}\n      </View>\n    </StandardBottomSheet>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/YearInMoons/GraphsTabContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Rect' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SlideInRight' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getYearStats' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TrendingUp' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TrendingDown' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Minus' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":610,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":610,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":1041,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":1041,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":1105,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":1105,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * GraphsTabContent - Enhanced Edition\n * Beautiful visual charts with heat maps, gradients, and portfolio insights\n * Moon/cosmic theme with smooth animations and glassmorphism\n */\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { View, Text, ScrollView, Dimensions, TouchableOpacity, Modal, Pressable } from 'react-native';\nimport Svg, { Circle, Line, Text as SvgText, G, Path, Rect, Defs, LinearGradient as SvgLinearGradient, Stop } from 'react-native-svg';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport { BlurView } from 'expo-blur';\nimport Animated, { FadeIn, FadeInDown, SlideInRight } from 'react-native-reanimated';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport { getYearMoonData, getYearStats } from '@/modules/reflection';\nimport { usePortfolio } from '@/modules/insights';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { TrendingUp, TrendingDown, Minus, X } from 'lucide-react-native';\nimport * as Haptics from 'expo-haptics';\n\nconst { width: screenWidth } = Dimensions.get('window');\n\n// Theme-aware color palette for graphs\n// Theme-aware color palette for graphs\nconst getGraphTheme = (isDarkMode: boolean) => ({\n  // Card backgrounds\n  cardBackground: isDarkMode ? '#1E2030' : '#FFFFFF',\n  cardBackgroundAlt: isDarkMode ? '#151725' : '#F8F9FA',\n  cardBackgroundDeep: isDarkMode ? '#131522' : '#E8EAF0',\n  cardBorder: isDarkMode ? '#2D314D' : '#E0E3E9',\n\n  // Text colors\n  textPrimary: isDarkMode ? '#F0F2F5' : '#1A1D2D',\n  textSecondary: isDarkMode ? '#9CA3AF' : '#6B7280',\n  textTertiary: isDarkMode ? '#6B7280' : '#9CA3AF',\n\n  // Chart colors - primary palette (Cosmic/Gem)\n  chartPrimary: isDarkMode ? '#8B5CF6' : '#7C3AED', // Vivid Purple\n  chartSecondary: isDarkMode ? '#A78BFA' : '#8B5CF6', // Soft Purple\n  chartTertiary: isDarkMode ? '#6366F1' : '#4F46E5', // Indigo\n  chartAccent: isDarkMode ? '#F472B6' : '#EC4899', // Pink accent\n\n  // Energy/Battery colors\n  energyColor: isDarkMode ? '#FCD34D' : '#F59E0B', // Amber/Gold\n  energyGlow: isDarkMode ? 'rgba(252, 211, 77, 0.3)' : 'rgba(245, 158, 11, 0.2)',\n\n  // Weave/Connection colors\n  weaveColor: isDarkMode ? '#34D399' : '#10B981', // Emerald\n  weaveGlow: isDarkMode ? 'rgba(52, 211, 153, 0.3)' : 'rgba(16, 185, 129, 0.2)',\n\n  // Heatmap colors (Gemstones)\n  heatmapEmpty: isDarkMode ? '#2A2E3F' : '#F3F4F6',\n  heatmapLevel1: isDarkMode ? '#4C1D95' : '#E9D5FF', // Deep Purple / Light Lavender\n  heatmapLevel2: isDarkMode ? '#6D28D9' : '#C084FC',\n  heatmapLevel3: isDarkMode ? '#8B5CF6' : '#A855F7',\n  heatmapLevel4: isDarkMode ? '#A78BFA' : '#9333EA', // Brightest\n\n  // Grid and structure\n  gridLine: isDarkMode ? '#2D314D' : '#E5E7EB',\n  axisLine: isDarkMode ? '#4B5563' : '#D1D5DB',\n\n  // Interactive states\n  hoverBackground: isDarkMode ? '#2D314D' : '#F3F4F6',\n  activeBackground: isDarkMode ? '#4C1D95' : '#E0E7FF',\n\n  // Gradients\n  gradientStart: isDarkMode ? '#1E2030' : '#FFFFFF',\n  gradientEnd: isDarkMode ? '#131522' : '#F8F9FA',\n\n  // Health score colors (keep consistent)\n  healthHigh: '#10B981', // Emerald\n  healthGood: '#34D399',\n  healthMedium: '#FBBF24', // Amber\n  healthLow: '#EF4444', // Red\n\n  // Tier colors (Cosmic Tiers)\n  tierInner: isDarkMode ? '#F59E0B' : '#D97706', // Gold\n  tierClose: isDarkMode ? '#EC4899' : '#DB2777', // Pink\n  tierCommunity: isDarkMode ? '#6366F1' : '#4F46E5', // Indigo\n\n  // Special accent colors\n  accentGold: '#FFD700',\n  accentSilver: '#C0C0C0',\n  accentBronze: '#CD7F32',\n\n  // Shadow and depth\n  shadowColor: isDarkMode ? '#000' : '#6B7280',\n  shadowOpacity: isDarkMode ? 0.5 : 0.2,\n});\n\ninterface GraphsTabContentProps {\n  year?: number;\n}\n\ninterface TooltipData {\n  visible: boolean;\n  type: 'heatmap' | 'donut' | 'tier' | 'rhythm' | 'friend' | null;\n  data: any;\n  position?: { x: number; y: number };\n}\n\nexport function GraphsTabContent({ year = new Date().getFullYear() }: GraphsTabContentProps) {\n  const { isDarkMode } = useTheme();\n  const graphTheme = useMemo(() => getGraphTheme(isDarkMode), [isDarkMode]);\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [weeklyRhythm, setWeeklyRhythm] = useState<any[]>([]);\n  const [topFriends, setTopFriends] = useState<Array<{ name: string; count: number }>>([]);\n  const [archetypeDistribution, setArchetypeDistribution] = useState<Record<string, number>>({});\n  const [batteryWeaveData, setBatteryWeaveData] = useState<Array<{ date: Date; battery: number; weaves: number }>>([]);\n  const [heatmapData, setHeatmapData] = useState<Array<{ date: Date; count: number }>>([]);\n  const { portfolio } = usePortfolio();\n  const [tooltip, setTooltip] = useState<TooltipData>({ visible: false, type: null, data: null });\n\n  useEffect(() => {\n    loadGraphData();\n  }, [year]);\n\n  const loadGraphData = async () => {\n    setIsLoading(true);\n    try {\n      // 1. Get weekly rhythm from battery data\n      const yearData = await getYearMoonData(year);\n      const allDays = yearData.flatMap(month => month.days.filter(d => d.hasCheckin));\n\n      if (allDays.length > 0) {\n        // Calculate day-of-week averages\n        const dayData: Array<{ dayOfWeek: number; avgBattery: number; count: number }> =\n          Array.from({ length: 7 }, (_, i) => ({ dayOfWeek: i, avgBattery: 0, count: 0 }));\n\n        allDays.forEach((day) => {\n          const dayOfWeek = day.date.getDay(); // 0 = Sunday, 6 = Saturday\n          dayData[dayOfWeek].avgBattery += day.batteryLevel || 0;\n          dayData[dayOfWeek].count += 1;\n        });\n\n        // Calculate averages\n        dayData.forEach((day) => {\n          if (day.count > 0) {\n            day.avgBattery = day.avgBattery / day.count;\n          }\n        });\n\n        setWeeklyRhythm(dayData);\n      }\n\n      // 2. Get battery + weave correlation data (last 90 days)\n      const ninetyDaysAgo = Date.now() - (90 * 24 * 60 * 60 * 1000);\n      const recentDays = allDays.filter(d => d.date.getTime() > ninetyDaysAgo);\n\n      // Count weaves per day\n      const interactions = await database\n        .get<InteractionModel>('interactions')\n        .query(\n          Q.where('interaction_date', Q.gte(ninetyDaysAgo)),\n          Q.where('status', 'completed')\n        )\n        .fetch();\n\n      const weavesByDate = new Map<string, number>();\n      interactions.forEach(i => {\n        const dateKey = new Date(i.interactionDate).toDateString();\n        weavesByDate.set(dateKey, (weavesByDate.get(dateKey) || 0) + 1);\n      });\n\n      const correlationData = recentDays.map(d => ({\n        date: d.date,\n        battery: d.batteryLevel || 0,\n        weaves: weavesByDate.get(d.date.toDateString()) || 0,\n      }));\n      setBatteryWeaveData(correlationData);\n\n      // 3. Build year heatmap (all days with weave counts)\n      const yearStart = new Date(year, 0, 1).getTime();\n      const yearEnd = new Date(year, 11, 31, 23, 59, 59).getTime();\n\n      const yearInteractions = await database\n        .get<InteractionModel>('interactions')\n        .query(\n          Q.where('interaction_date', Q.gte(yearStart)),\n          Q.where('interaction_date', Q.lte(yearEnd)),\n          Q.where('status', 'completed')\n        )\n        .fetch();\n\n      const heatmap: Array<{ date: Date; count: number }> = [];\n      for (let d = new Date(yearStart); d <= new Date(yearEnd); d.setDate(d.getDate() + 1)) {\n        const dateKey = new Date(d).toDateString();\n        const count = weavesByDate.get(dateKey) || 0;\n        heatmap.push({ date: new Date(d), count });\n      }\n      setHeatmapData(heatmap);\n\n      // 4. Get top friends (by interaction count this year)\n      const friendInteractionCount = new Map<string, number>();\n      for (const interaction of yearInteractions) {\n        const interactionFriends = await database\n          .get('interaction_friends')\n          .query(Q.where('interaction_id', interaction.id))\n          .fetch();\n\n        for (const ifriend of interactionFriends) {\n          const friendId = (ifriend as any)._raw.friend_id;\n          friendInteractionCount.set(friendId, (friendInteractionCount.get(friendId) || 0) + 1);\n        }\n      }\n\n      // Get friend names and sort\n      const friendCounts = await Promise.all(\n        Array.from(friendInteractionCount.entries()).map(async ([friendId, count]) => {\n          try {\n            const friend = await database.get<FriendModel>('friends').find(friendId);\n            return { name: friend.name, count };\n          } catch {\n            return null;\n          }\n        })\n      );\n\n      const validFriendCounts = friendCounts.filter((f): f is { name: string; count: number } => f !== null);\n      setTopFriends(validFriendCounts.sort((a, b) => b.count - a.count).slice(0, 5));\n\n      // 5. Get archetype distribution\n      const allFriends = await database.get<FriendModel>('friends').query().fetch();\n      const archetypes: Record<string, number> = {};\n      allFriends.forEach(f => {\n        archetypes[f.archetype] = (archetypes[f.archetype] || 0) + 1;\n      });\n      setArchetypeDistribution(archetypes);\n\n    } catch (error) {\n      console.error('Error loading graph data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const showTooltip = (type: TooltipData['type'], data: any) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setTooltip({ visible: true, type, data });\n  };\n\n  const hideTooltip = () => {\n    setTooltip({ visible: false, type: null, data: null });\n  };\n\n  if (isLoading) {\n    return (\n      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', paddingTop: 40 }}>\n        <Text style={{ color: graphTheme.textSecondary, fontFamily: 'Inter_400Regular', fontSize: 14 }}>\n          Loading your data...\n        </Text>\n      </View>\n    );\n  }\n\n  return (\n    <>\n      <ScrollView\n        style={{ flex: 1, paddingHorizontal: 20, paddingTop: 16 }}\n        showsVerticalScrollIndicator={false}\n      >\n        {/* Portfolio Health Score */}\n        {portfolio && (\n          <Animated.View entering={FadeInDown.delay(0)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 16 }}>\n              Network Health\n            </Text>\n            <PortfolioHealthCard portfolio={portfolio} theme={graphTheme} />\n          </Animated.View>\n        )}\n\n        {/* Year Activity Heatmap */}\n        {heatmapData.length > 0 && (\n          <Animated.View entering={FadeInDown.delay(100)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 8 }}>\n              Activity Pattern\n            </Text>\n            <Text style={{ fontSize: 13, color: graphTheme.textSecondary, fontFamily: 'Inter_400Regular', marginBottom: 16 }}>\n              Your logged interactions over the last 16 weeks\n            </Text>\n            <ActivityHeatmap data={heatmapData} onCellPress={(day) => showTooltip('heatmap', day)} theme={graphTheme} />\n          </Animated.View>\n        )}\n\n        {/* Tier Health Visualization */}\n        {portfolio && (\n          <Animated.View entering={FadeInDown.delay(200)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 16 }}>\n              Tier Health\n            </Text>\n            <TierHealthRings portfolio={portfolio} onTierPress={(tier) => showTooltip('tier', tier)} theme={graphTheme} />\n          </Animated.View>\n        )}\n\n        {/* Weekly Energy Rhythm */}\n        {weeklyRhythm.length > 0 && (\n          <Animated.View entering={FadeInDown.delay(300)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 16 }}>\n              Weekly Energy Rhythm\n            </Text>\n            <WeeklyRhythmRadial data={weeklyRhythm} onDayPress={(day) => showTooltip('rhythm', day)} theme={graphTheme} />\n          </Animated.View>\n        )}\n\n        {/* Battery + Weaves Correlation */}\n        {batteryWeaveData.length > 0 && (\n          <Animated.View entering={FadeInDown.delay(400)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 16 }}>\n              Energy & Connection\n            </Text>\n            <BatteryWeaveChart data={batteryWeaveData} theme={graphTheme} />\n          </Animated.View>\n        )}\n\n        {/* Top Friends with Sparkles */}\n        {topFriends.length > 0 && (\n          <Animated.View entering={FadeInDown.delay(500)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 12 }}>\n              Most Connected\n            </Text>\n            {topFriends.map((friend, index) => {\n              const isTop3 = index < 3;\n              const rankColors = [graphTheme.accentGold, graphTheme.accentSilver, graphTheme.accentBronze];\n              const rankColor = isTop3 ? rankColors[index] : graphTheme.textSecondary;\n\n              return (\n                <TouchableOpacity\n                  key={friend.name}\n                  onPress={() => showTooltip('friend', friend)}\n                  style={{\n                    flexDirection: 'row',\n                    justifyContent: 'space-between',\n                    alignItems: 'center',\n                    backgroundColor: isTop3 ? `${rankColor}10` : graphTheme.cardBackground,\n                    padding: 14,\n                    borderRadius: 16,\n                    marginBottom: 8,\n                    borderWidth: 1,\n                    borderColor: isTop3 ? `${rankColor}40` : 'transparent',\n                  }}\n                  activeOpacity={0.7}\n                >\n                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>\n                    <View\n                      style={{\n                        width: 32,\n                        height: 32,\n                        borderRadius: 16,\n                        backgroundColor: isTop3 ? rankColor : graphTheme.hoverBackground,\n                        alignItems: 'center',\n                        justifyContent: 'center',\n                        shadowColor: isTop3 ? rankColor : 'transparent',\n                        shadowOffset: { width: 0, height: 2 },\n                        shadowOpacity: 0.3,\n                        shadowRadius: 4,\n                        elevation: isTop3 ? 4 : 0,\n                      }}\n                    >\n                      <Text style={{ fontSize: 14, color: isTop3 ? '#FFFFFF' : graphTheme.textSecondary, fontFamily: 'Inter_700Bold' }}>\n                        {index + 1}\n                      </Text>\n                    </View>\n                    <Text style={{ fontSize: 16, color: graphTheme.textPrimary, fontFamily: 'Inter_600SemiBold' }}>\n                      {friend.name}\n                    </Text>\n                    {index === 0 && <Text style={{ fontSize: 16 }}>👑</Text>}\n                  </View>\n                  <Text style={{ fontSize: 14, color: graphTheme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n                    {friend.count} weaves\n                  </Text>\n                </TouchableOpacity>\n              );\n            })}\n          </Animated.View>\n        )}\n\n        {/* Archetype Distribution */}\n        {Object.keys(archetypeDistribution).length > 0 && (\n          <Animated.View entering={FadeInDown.delay(600)} style={{ marginBottom: 32 }}>\n            <Text style={{ fontSize: 18, fontWeight: '600', color: graphTheme.textPrimary, fontFamily: 'Lora_600SemiBold', marginBottom: 12 }}>\n              Circle Archetypes\n            </Text>\n            <ArchetypeDonutChart archetypes={archetypeDistribution} onSegmentPress={(data) => showTooltip('donut', data)} theme={graphTheme} />\n          </Animated.View>\n        )}\n\n        {/* Spacer */}\n        <View style={{ height: 40 }} />\n      </ScrollView>\n\n      {/* Tooltip Modal */}\n      <TooltipModal tooltip={tooltip} onClose={hideTooltip} theme={graphTheme} />\n    </>\n  );\n}\n\n// ============================================\n// PORTFOLIO HEALTH CARD\n// ============================================\nfunction PortfolioHealthCard({ portfolio, theme }: { portfolio: any; theme: ReturnType<typeof getGraphTheme> }) {\n  const healthScore = Math.round(portfolio.overallHealthScore);\n  const getHealthColor = (score: number) => {\n    if (score >= 80) return theme.healthHigh;\n    if (score >= 60) return theme.healthGood;\n    if (score >= 40) return theme.healthMedium;\n    return theme.healthLow;\n  };\n\n  return (\n    <LinearGradient\n      colors={[theme.gradientStart, theme.gradientEnd]}\n      style={{\n        borderRadius: 20,\n        padding: 20,\n        borderWidth: 1,\n        borderColor: theme.cardBorder,\n      }}\n    >\n      <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 16 }}>\n        <View>\n          <Text style={{ fontSize: 48, fontWeight: '700', color: getHealthColor(healthScore), fontFamily: 'Lora_700Bold' }}>\n            {healthScore}\n          </Text>\n          <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n            Health Score\n          </Text>\n        </View>\n        <View style={{ alignItems: 'flex-end', gap: 8 }}>\n          <MetricPill label=\"Thriving\" value={portfolio.thrivingFriends} color={theme.healthHigh} theme={theme} />\n          <MetricPill label=\"Drifting\" value={portfolio.driftingFriends} color=\"#FF9800\" theme={theme} />\n          <MetricPill label=\"Total\" value={portfolio.totalFriends} color={theme.chartPrimary} theme={theme} />\n        </View>\n      </View>\n\n      <View style={{ height: 1, backgroundColor: theme.gridLine, marginVertical: 12 }} />\n\n      <View style={{ flexDirection: 'row', justifyContent: 'space-around' }}>\n        <View style={{ alignItems: 'center' }}>\n          <Text style={{ fontSize: 20, fontWeight: '600', color: theme.textPrimary, fontFamily: 'Inter_600SemiBold' }}>\n            {portfolio.recentActivityMetrics.totalInteractions}\n          </Text>\n          <Text style={{ fontSize: 11, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n            Last 30 Days\n          </Text>\n        </View>\n        <View style={{ width: 1, height: 40, backgroundColor: theme.gridLine }} />\n        <View style={{ alignItems: 'center' }}>\n          <Text style={{ fontSize: 20, fontWeight: '600', color: theme.textPrimary, fontFamily: 'Inter_600SemiBold' }}>\n            {Math.round(portfolio.recentActivityMetrics.diversityScore * 100)}%\n          </Text>\n          <Text style={{ fontSize: 11, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n            Diversity\n          </Text>\n        </View>\n      </View>\n    </LinearGradient>\n  );\n}\n\nfunction MetricPill({ label, value, color, theme }: { label: string; value: number; color: string; theme: ReturnType<typeof getGraphTheme> }) {\n  return (\n    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, backgroundColor: `${color}20`, paddingHorizontal: 10, paddingVertical: 4, borderRadius: 12 }}>\n      <View style={{ width: 6, height: 6, borderRadius: 3, backgroundColor: color }} />\n      <Text style={{ fontSize: 12, color: theme.textPrimary, fontFamily: 'Inter_500Medium' }}>\n        {label}: {value}\n      </Text>\n    </View>\n  );\n}\n\n// ============================================\n// ACTIVITY HEATMAP (GitHub-style)\n// ============================================\nfunction ActivityHeatmap({\n  data,\n  onCellPress,\n  theme\n}: {\n  data: Array<{ date: Date; count: number }>;\n  onCellPress: (day: any) => void;\n  theme: ReturnType<typeof getGraphTheme>;\n}) {\n  const weeksToShow = 16; // 4 months\n  const cellGap = 3;\n\n  // Calculate cell size to fill the width: (screenWidth - scrollViewPadding - cardPadding - gaps) / weeks\n  // screenWidth - 40 (scrollView padding) - 40 (card padding) - (16-1)*3 (gaps between weeks) = available width\n  // Then divide by 16 weeks\n  const availableWidth = screenWidth - 40 - 40 - (weeksToShow - 1) * cellGap;\n  const cellSize = Math.floor(availableWidth / weeksToShow);\n\n  const rawMaxCount = Math.max(...data.map(d => d.count), 1);\n  const maxCount = (isNaN(rawMaxCount) || rawMaxCount === -Infinity) ? 1 : rawMaxCount;\n\n  const getHeatColor = (count: number) => {\n    if (count === 0) return theme.heatmapEmpty;\n    const intensity = Math.min(count / maxCount, 1);\n    if (intensity > 0.75) return theme.heatmapLevel4;\n    if (intensity > 0.5) return theme.heatmapLevel3;\n    if (intensity > 0.25) return theme.heatmapLevel2;\n    return theme.heatmapLevel1;\n  };\n\n  // Get last 16 weeks\n  const recentData = data.slice(-weeksToShow * 7);\n\n  return (\n    <View style={{ backgroundColor: theme.cardBackground, borderRadius: 16, paddingVertical: 16, paddingHorizontal: 20 }}>\n      <View style={{ flexDirection: 'row', justifyContent: 'space-between' }}>\n        {Array.from({ length: weeksToShow }).map((_, weekIndex) => (\n          <View key={weekIndex}>\n            {Array.from({ length: 7 }).map((_, dayIndex) => {\n              const dataIndex = weekIndex * 7 + dayIndex;\n              const dayData = recentData[dataIndex];\n              if (!dayData) return <View key={dayIndex} style={{ width: cellSize, height: cellSize + cellGap }} />;\n\n              return (\n                <TouchableOpacity\n                  key={dayIndex}\n                  onPress={() => onCellPress(dayData)}\n                  style={{\n                    width: cellSize,\n                    height: cellSize,\n                    backgroundColor: getHeatColor(dayData.count),\n                    borderRadius: 6, // Rounded gems\n                    marginBottom: cellGap,\n                    shadowColor: dayData.count > 0 ? getHeatColor(dayData.count) : 'transparent',\n                    shadowOffset: { width: 0, height: 0 },\n                    shadowOpacity: dayData.count > 0 ? 0.4 : 0,\n                    shadowRadius: 4,\n                    elevation: dayData.count > 0 ? 2 : 0,\n                    borderWidth: dayData.count > 0 ? 1 : 0,\n                    borderColor: 'rgba(255,255,255,0.1)',\n                  }}\n                />\n              );\n            })}\n          </View>\n        ))}\n      </View>\n      {/* Legend */}\n      <View style={{ marginTop: 12 }}>\n        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>\n          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 4 }}>\n            <Text style={{ fontSize: 9, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>Less</Text>\n            {[0, 0.25, 0.5, 0.75, 1].map((intensity, i) => (\n              <View\n                key={i}\n                style={{\n                  width: 10,\n                  height: 10,\n                  backgroundColor: getHeatColor(intensity * maxCount),\n                  borderRadius: 2,\n                }}\n              />\n            ))}\n            <Text style={{ fontSize: 9, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>More</Text>\n          </View>\n          <Text style={{ fontSize: 9, color: theme.textTertiary, fontFamily: 'Inter_400Regular' }}>\n            Tap any day for details\n          </Text>\n        </View>\n      </View>\n    </View>\n  );\n}\n\n// ============================================\n// TIER HEALTH RINGS (Concentric Circles)\n// ============================================\nfunction TierHealthRings({\n  portfolio,\n  onTierPress,\n  theme\n}: {\n  portfolio: any;\n  onTierPress: (tier: any) => void;\n  theme: ReturnType<typeof getGraphTheme>;\n}) {\n  const size = Math.min(screenWidth - 80, 280);\n  const center = size / 2;\n  const maxRadius = size / 2 - 20;\n\n  const tierData = portfolio.tierDistribution || [];\n  const sortedTiers = [...tierData].sort((a: any, b: any) => {\n    const order: Record<string, number> = { InnerCircle: 0, CloseFriends: 1, Community: 2 };\n    return order[a.tier] - order[b.tier];\n  });\n\n  const tierColors: Record<string, string> = {\n    InnerCircle: theme.tierInner,\n    CloseFriends: theme.tierClose,\n    Community: theme.tierCommunity,\n  };\n\n  const tierLabels: Record<string, string> = {\n    InnerCircle: 'Inner Circle',\n    CloseFriends: 'Close Friends',\n    Community: 'Community',\n  };\n\n  return (\n    <View style={{ backgroundColor: theme.cardBackground, borderRadius: 20, padding: 20 }}>\n      <View style={{ alignItems: 'center', marginBottom: 20 }}>\n        <Svg width={size} height={size}>\n          <Defs>\n            {sortedTiers.map((tier: any, index: number) => (\n              <SvgLinearGradient key={tier.tier} id={`grad-${tier.tier}`} x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\n                <Stop offset=\"0\" stopColor={tierColors[tier.tier]} stopOpacity=\"0.8\" />\n                <Stop offset=\"1\" stopColor={tierColors[tier.tier]} stopOpacity=\"0.4\" />\n              </SvgLinearGradient>\n            ))}\n          </Defs>\n\n          {/* Background circles (Dashed Orbit Style) */}\n          {[1, 0.75, 0.5, 0.25].map((scale, i) => (\n            <Circle\n              key={i}\n              cx={center}\n              cy={center}\n              r={maxRadius * scale}\n              stroke={theme.gridLine}\n              strokeWidth=\"1\"\n              strokeDasharray={i % 2 === 0 ? \"4, 4\" : \"0\"} // Alternate dashed/solid\n              fill=\"none\"\n              opacity={0.2}\n            />\n          ))}\n\n          {/* Tier rings */}\n          {sortedTiers.map((tier: any, index: number) => {\n            const radius = maxRadius * (1 - index * 0.33);\n            const rawHealthPercent = tier.avgScore / 100;\n            const healthPercent = isNaN(rawHealthPercent) ? 0 : Math.max(0, Math.min(1, rawHealthPercent));\n            const strokeWidth = 20;\n\n            return (\n              <G key={tier.tier}>\n                {/* Background ring */}\n                <Circle\n                  cx={center}\n                  cy={center}\n                  r={radius}\n                  stroke={theme.cardBackgroundAlt}\n                  strokeWidth={strokeWidth}\n                  fill=\"none\"\n                />\n                {/* Health ring */}\n                <Circle\n                  cx={center}\n                  cy={center}\n                  r={radius}\n                  stroke={`url(#grad-${tier.tier})`}\n                  strokeWidth={strokeWidth}\n                  fill=\"none\"\n                  strokeDasharray={`${2 * Math.PI * radius * healthPercent} ${2 * Math.PI * radius}`}\n                  strokeLinecap=\"round\"\n                  rotation=\"-90\"\n                  origin={`${center}, ${center}`}\n                />\n              </G>\n            );\n          })}\n\n          {/* Center score */}\n          <SvgText\n            x={center}\n            y={center}\n            fontSize=\"32\"\n            fill={theme.textPrimary}\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n            fontFamily=\"Lora_700Bold\"\n          >\n            {Math.round(portfolio.overallHealthScore)}\n          </SvgText>\n        </Svg>\n      </View>\n\n      {/* Legend */}\n      <View style={{ gap: 8 }}>\n        {sortedTiers.map((tier: any) => {\n          const totalFriends = sortedTiers.reduce((sum: number, t: any) => sum + t.count, 0);\n          const percentage = totalFriends > 0 ? (tier.count / totalFriends) * 100 : 0;\n\n          return (\n            <TouchableOpacity\n              key={tier.tier}\n              onPress={() => onTierPress({ tier: tier.tier, avgScore: tier.avgScore, count: tier.count, percentage })}\n              style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}\n              activeOpacity={0.7}\n            >\n              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>\n                <View style={{ width: 12, height: 12, borderRadius: 6, backgroundColor: tierColors[tier.tier] }} />\n                <Text style={{ fontSize: 13, color: theme.textPrimary, fontFamily: 'Inter_500Medium' }}>\n                  {tierLabels[tier.tier]}\n                </Text>\n              </View>\n              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>\n                <Text style={{ fontSize: 13, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n                  {Math.round(tier.avgScore)}/100\n                </Text>\n                <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n                  ({tier.count})\n                </Text>\n              </View>\n            </TouchableOpacity>\n          );\n        })}\n      </View>\n    </View>\n  );\n}\n\n// ============================================\n// WEEKLY RHYTHM RADIAL (Enhanced)\n// ============================================\nfunction WeeklyRhythmRadial({\n  data,\n  onDayPress,\n  theme\n}: {\n  data: any[];\n  onDayPress: (day: any) => void;\n  theme: ReturnType<typeof getGraphTheme>;\n}) {\n  const size = Math.min(screenWidth - 80, 300);\n  const center = size / 2;\n  const radius = size / 2 - 40;\n\n  const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  const maxBattery = 5;\n\n  return (\n    <View style={{ alignItems: 'center', backgroundColor: theme.cardBackground, borderRadius: 20, padding: 20 }}>\n      <Svg width={size} height={size}>\n        <Defs>\n          <SvgLinearGradient id=\"radialGrad\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\n            <Stop offset=\"0\" stopColor={theme.energyColor} stopOpacity=\"0.5\" />\n            <Stop offset=\"1\" stopColor={theme.chartPrimary} stopOpacity=\"0.3\" />\n          </SvgLinearGradient>\n        </Defs>\n\n        {/* Background circles (Star Map Grid) */}\n        {[0.2, 0.4, 0.6, 0.8, 1.0].map((scale, i) => (\n          <Circle\n            key={i}\n            cx={center}\n            cy={center}\n            r={radius * scale}\n            stroke={theme.gridLine}\n            strokeWidth=\"1\"\n            strokeDasharray=\"2, 4\"\n            fill=\"none\"\n            opacity={0.2}\n          />\n        ))}\n\n        {/* Radial lines */}\n        {data.map((_, index) => {\n          const angle = (index / data.length) * 2 * Math.PI - Math.PI / 2;\n          const x2 = center + Math.cos(angle) * radius;\n          const y2 = center + Math.sin(angle) * radius;\n          return (\n            <Line\n              key={`line-${index}`}\n              x1={center}\n              y1={center}\n              x2={x2}\n              y2={y2}\n              stroke={theme.gridLine}\n              strokeWidth=\"1\"\n              opacity={0.3}\n            />\n          );\n        })}\n\n        {/* Data polygon with gradient fill */}\n        {data.length > 0 && (\n          <G>\n            <Path\n              d={data.map((day, index) => {\n                const angle = (index / data.length) * 2 * Math.PI - Math.PI / 2;\n                const value = day.avgBattery || 0;\n                const distance = (value / maxBattery) * radius;\n                const x = center + Math.cos(angle) * distance;\n                const y = center + Math.sin(angle) * distance;\n                return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;\n              }).join(' ') + ' Z'}\n              fill=\"url(#radialGrad)\"\n              stroke={theme.energyColor}\n              strokeWidth=\"2.5\"\n            />\n            {/* Data points with glow */}\n            {data.map((day, index) => {\n              const angle = (index / data.length) * 2 * Math.PI - Math.PI / 2;\n              const value = day.avgBattery || 0;\n              const distance = (value / maxBattery) * radius;\n              const x = center + Math.cos(angle) * distance;\n              const y = center + Math.sin(angle) * distance;\n              return (\n                <G key={`point-${index}`} onPress={() => onDayPress(day)}>\n                  <Circle cx={x} cy={y} r={8} fill={theme.energyColor} opacity={0.2} />\n                  <Circle cx={x} cy={y} r={4} fill=\"#FFFFFF\" stroke={theme.energyColor} strokeWidth={1.5} />\n                </G>\n              );\n            })}\n          </G>\n        )}\n\n        {/* Day labels */}\n        {data.map((day, index) => {\n          const angle = (index / data.length) * 2 * Math.PI - Math.PI / 2;\n          const labelDistance = radius + 25;\n          const x = center + Math.cos(angle) * labelDistance;\n          const y = center + Math.sin(angle) * labelDistance;\n          return (\n            <SvgText\n              key={`label-${index}`}\n              x={x}\n              y={y}\n              fontSize=\"12\"\n              fill={theme.textSecondary}\n              textAnchor=\"middle\"\n              alignmentBaseline=\"middle\"\n              fontFamily=\"Inter_600SemiBold\"\n            >\n              {dayNames[day.dayOfWeek]}\n            </SvgText>\n          );\n        })}\n      </Svg>\n      <Text style={{ marginTop: 12, fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular', textAlign: 'center' }}>\n        Average energy level by day of week\n      </Text>\n    </View>\n  );\n}\n\n// ============================================\n// BATTERY + WEAVES CHART (Enhanced)\n// ============================================\nfunction BatteryWeaveChart({\n  data,\n  theme\n}: {\n  data: Array<{ date: Date; battery: number; weaves: number }>;\n  theme: ReturnType<typeof getGraphTheme>;\n}) {\n  const chartWidth = screenWidth - 80;\n  const chartHeight = 220;\n  const padding = 40;\n\n  const maxWeaves = Math.max(...data.map(d => d.weaves), 1);\n  const maxBattery = 5;\n\n  // Calculate weekly averages to reduce noise\n  const weeklyData: Array<{ week: number; avgBattery: number; avgWeaves: number }> = [];\n  const weeks = Math.ceil(data.length / 7);\n\n  for (let i = 0; i < weeks; i++) {\n    const weekData = data.slice(i * 7, (i + 1) * 7);\n    if (weekData.length > 0) {\n      const avgBattery = weekData.reduce((sum, d) => sum + d.battery, 0) / weekData.length;\n      const avgWeaves = weekData.reduce((sum, d) => sum + d.weaves, 0) / weekData.length;\n      weeklyData.push({ week: i, avgBattery, avgWeaves });\n    }\n  }\n\n  return (\n    <View style={{ backgroundColor: theme.cardBackground, borderRadius: 20, padding: 20 }}>\n      <Svg width={chartWidth} height={chartHeight}>\n        <Defs>\n          <SvgLinearGradient id=\"batteryGrad\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n            <Stop offset=\"0\" stopColor={theme.energyColor} stopOpacity=\"0.4\" />\n            <Stop offset=\"1\" stopColor={theme.energyColor} stopOpacity=\"0.05\" />\n          </SvgLinearGradient>\n          <SvgLinearGradient id=\"weaveGrad\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n            <Stop offset=\"0\" stopColor={theme.weaveColor} stopOpacity=\"0.4\" />\n            <Stop offset=\"1\" stopColor={theme.weaveColor} stopOpacity=\"0.05\" />\n          </SvgLinearGradient>\n        </Defs>\n\n        {/* Grid lines */}\n        {[0.25, 0.5, 0.75].map((ratio, i) => (\n          <Line\n            key={i}\n            x1={padding}\n            y1={chartHeight - padding - (chartHeight - 2 * padding) * ratio}\n            x2={chartWidth - padding}\n            y2={chartHeight - padding - (chartHeight - 2 * padding) * ratio}\n            stroke={theme.gridLine}\n            strokeWidth=\"1\"\n            opacity={0.3}\n            strokeDasharray=\"4 4\"\n          />\n        ))}\n\n        {/* Axes */}\n        <Line\n          x1={padding}\n          y1={chartHeight - padding}\n          x2={chartWidth - padding}\n          y2={chartHeight - padding}\n          stroke={theme.axisLine}\n          strokeWidth=\"2\"\n        />\n        <Line\n          x1={padding}\n          y1={padding}\n          x2={padding}\n          y2={chartHeight - padding}\n          stroke={theme.axisLine}\n          strokeWidth=\"2\"\n        />\n\n        {/* Battery area fill */}\n        {weeklyData.length > 1 && (\n          <Path\n            d={\n              weeklyData.map((w, i) => {\n                const x = padding + (i / (weeklyData.length - 1)) * (chartWidth - 2 * padding);\n                const y = chartHeight - padding - (w.avgBattery / maxBattery) * (chartHeight - 2 * padding);\n                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;\n              }).join(' ') +\n              ` L ${chartWidth - padding} ${chartHeight - padding} L ${padding} ${chartHeight - padding} Z`\n            }\n            fill=\"url(#batteryGrad)\"\n          />\n        )}\n\n        {/* Battery line */}\n        {weeklyData.length > 1 && (\n          <Path\n            d={weeklyData.map((w, i) => {\n              const x = padding + (i / (weeklyData.length - 1)) * (chartWidth - 2 * padding);\n              const y = chartHeight - padding - (w.avgBattery / maxBattery) * (chartHeight - 2 * padding);\n              return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;\n            }).join(' ')}\n            stroke={theme.energyColor}\n            strokeWidth=\"3\"\n            fill=\"none\"\n          />\n        )}\n\n        {/* Weaves area fill */}\n        {weeklyData.length > 1 && (\n          <Path\n            d={\n              weeklyData.map((w, i) => {\n                const x = padding + (i / (weeklyData.length - 1)) * (chartWidth - 2 * padding);\n                const y = chartHeight - padding - (w.avgWeaves / maxWeaves) * (chartHeight - 2 * padding);\n                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;\n              }).join(' ') +\n              ` L ${chartWidth - padding} ${chartHeight - padding} L ${padding} ${chartHeight - padding} Z`\n            }\n            fill=\"url(#weaveGrad)\"\n          />\n        )}\n\n        {/* Weaves line */}\n        {weeklyData.length > 1 && (\n          <Path\n            d={weeklyData.map((w, i) => {\n              const x = padding + (i / (weeklyData.length - 1)) * (chartWidth - 2 * padding);\n              const y = chartHeight - padding - (w.avgWeaves / maxWeaves) * (chartHeight - 2 * padding);\n              return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;\n            }).join(' ')}\n            stroke={theme.weaveColor}\n            strokeWidth=\"3\"\n            fill=\"none\"\n          />\n        )}\n\n        {/* Axis labels */}\n        <SvgText x={padding} y={15} fontSize=\"10\" fill={theme.textSecondary} fontFamily=\"Inter_400Regular\">\n          Energy\n        </SvgText>\n        <SvgText x={chartWidth - 60} y={chartHeight - 10} fontSize=\"10\" fill={theme.textSecondary} fontFamily=\"Inter_400Regular\" textAnchor=\"end\">\n          Weeks\n        </SvgText>\n      </Svg>\n\n      {/* Legend */}\n      <View style={{ flexDirection: 'row', justifyContent: 'center', gap: 24, marginTop: 16 }}>\n        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>\n          <View style={{ width: 24, height: 4, backgroundColor: theme.energyColor, borderRadius: 2 }} />\n          <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>Energy</Text>\n        </View>\n        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>\n          <View style={{ width: 24, height: 4, backgroundColor: theme.weaveColor, borderRadius: 2 }} />\n          <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>Weaves</Text>\n        </View>\n      </View>\n    </View>\n  );\n}\n\n// ============================================\n// ARCHETYPE DONUT CHART\n// ============================================\n\n// Archetype-specific colors matching the selector cards\nconst ARCHETYPE_COLORS: Record<string, string> = {\n  Emperor: '#ef4444',       // Red\n  Empress: '#10b981',       // Green\n  HighPriestess: '#8b5cf6', // Purple\n  Fool: '#f59e0b',          // Orange\n  Sun: '#eab308',           // Yellow\n  Hermit: '#6366f1',        // Indigo\n  Magician: '#ec4899',      // Pink\n};\n\nfunction ArchetypeDonutChart({\n  archetypes,\n  onSegmentPress,\n  theme\n}: {\n  archetypes: Record<string, number>;\n  onSegmentPress: (data: any) => void;\n  theme: ReturnType<typeof getGraphTheme>;\n}) {\n  const size = Math.min(screenWidth - 80, 260);\n  const center = size / 2;\n  const outerRadius = size / 2 - 30;\n  const innerRadius = outerRadius * 0.6;\n\n  const total = Object.values(archetypes).reduce((sum, count) => sum + count, 0);\n  const entries = Object.entries(archetypes).sort((a, b) => b[1] - a[1]);\n\n  // Use archetype-specific colors, fallback to theme colors if archetype not found\n  const getArchetypeColor = (archetype: string) => {\n    return ARCHETYPE_COLORS[archetype] || theme.chartPrimary;\n  };\n\n  let currentAngle = -Math.PI / 2;\n\n  const paths = entries.map(([archetype, count], index) => {\n    const percentage = count / total;\n    const angle = percentage * 2 * Math.PI;\n    const endAngle = currentAngle + angle;\n\n    const x1 = center + Math.cos(currentAngle) * outerRadius;\n    const y1 = center + Math.sin(currentAngle) * outerRadius;\n    const x2 = center + Math.cos(endAngle) * outerRadius;\n    const y2 = center + Math.sin(endAngle) * outerRadius;\n    const x3 = center + Math.cos(endAngle) * innerRadius;\n    const y3 = center + Math.sin(endAngle) * innerRadius;\n    const x4 = center + Math.cos(currentAngle) * innerRadius;\n    const y4 = center + Math.sin(currentAngle) * innerRadius;\n\n    const largeArc = angle > Math.PI ? 1 : 0;\n\n    const path = `\n      M ${x1} ${y1}\n      A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${x2} ${y2}\n      L ${x3} ${y3}\n      A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x4} ${y4}\n      Z\n    `;\n\n    const result = { path, color: getArchetypeColor(archetype), archetype, count, percentage };\n    currentAngle = endAngle;\n    return result;\n  });\n\n  return (\n    <View style={{ backgroundColor: theme.cardBackground, borderRadius: 20, padding: 20 }}>\n      <View style={{ alignItems: 'center', marginBottom: 20 }}>\n        <Svg width={size} height={size}>\n          {paths.map((p, i) => (\n            <G key={i} onPress={() => onSegmentPress({ archetype: p.archetype, count: p.count, percentage: p.percentage, color: p.color })}>\n              <Path d={p.path} fill={p.color} />\n            </G>\n          ))}\n          <SvgText\n            x={center}\n            y={center}\n            fontSize=\"28\"\n            fill={theme.textPrimary}\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n            fontFamily=\"Lora_700Bold\"\n          >\n            {total}\n          </SvgText>\n          <SvgText\n            x={center}\n            y={center + 20}\n            fontSize=\"11\"\n            fill={theme.textSecondary}\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n            fontFamily=\"Inter_400Regular\"\n          >\n            friends\n          </SvgText>\n        </Svg>\n      </View>\n\n      <View style={{ gap: 8 }}>\n        {entries.map(([archetype, count], index) => {\n          const percentage = (count / total);\n          const color = getArchetypeColor(archetype);\n          return (\n            <TouchableOpacity\n              key={archetype}\n              onPress={() => onSegmentPress({ archetype, count, percentage, color })}\n              style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}\n              activeOpacity={0.7}\n            >\n              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>\n                <View style={{ width: 12, height: 12, borderRadius: 6, backgroundColor: color }} />\n                <Text style={{ fontSize: 14, color: theme.textPrimary, fontFamily: 'Inter_500Medium' }}>\n                  {archetype}\n                </Text>\n              </View>\n              <Text style={{ fontSize: 13, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n                {count} ({Math.round(percentage * 100)}%)\n              </Text>\n            </TouchableOpacity>\n          );\n        })}\n      </View>\n    </View>\n  );\n}\n\n// ============================================\n// TOOLTIP MODAL\n// ============================================\nfunction TooltipModal({ tooltip, onClose, theme }: { tooltip: TooltipData; onClose: () => void; theme: ReturnType<typeof getGraphTheme> }) {\n  if (!tooltip.visible || !tooltip.data) return null;\n\n  const renderContent = () => {\n    switch (tooltip.type) {\n      case 'heatmap':\n        return (\n          <>\n            <Text style={{ fontSize: 20, fontWeight: '700', color: theme.textPrimary, fontFamily: 'Lora_700Bold', marginBottom: 8 }}>\n              {tooltip.data.date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}\n            </Text>\n            <Text style={{ fontSize: 32, fontWeight: '700', color: theme.chartPrimary, fontFamily: 'Lora_700Bold', marginBottom: 4 }}>\n              {tooltip.data.count}\n            </Text>\n            <Text style={{ fontSize: 14, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n              {tooltip.data.count === 0 ? 'No weaves' : tooltip.data.count === 1 ? 'weave logged' : 'weaves logged'}\n            </Text>\n          </>\n        );\n\n      case 'rhythm':\n        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n        return (\n          <>\n            <Text style={{ fontSize: 20, fontWeight: '700', color: theme.textPrimary, fontFamily: 'Lora_700Bold', marginBottom: 8 }}>\n              {dayNames[tooltip.data.dayOfWeek]}\n            </Text>\n            <Text style={{ fontSize: 32, fontWeight: '700', color: theme.energyColor, fontFamily: 'Lora_700Bold', marginBottom: 4 }}>\n              {tooltip.data.avgBattery.toFixed(1)}/5\n            </Text>\n            <Text style={{ fontSize: 14, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n              Average energy level\n            </Text>\n            <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular', marginTop: 8 }}>\n              Based on {tooltip.data.count} check-ins\n            </Text>\n          </>\n        );\n\n      case 'tier':\n        const tierLabels: Record<string, string> = {\n          InnerCircle: 'Inner Circle',\n          CloseFriends: 'Close Friends',\n          Community: 'Community',\n        };\n        return (\n          <>\n            <Text style={{ fontSize: 20, fontWeight: '700', color: theme.textPrimary, fontFamily: 'Lora_700Bold', marginBottom: 8 }}>\n              {tierLabels[tooltip.data.tier]}\n            </Text>\n            <Text style={{ fontSize: 32, fontWeight: '700', color: theme.chartPrimary, fontFamily: 'Lora_700Bold', marginBottom: 4 }}>\n              {Math.round(tooltip.data.avgScore)}\n            </Text>\n            <Text style={{ fontSize: 14, color: theme.textSecondary, fontFamily: 'Inter_400Regular', marginBottom: 8 }}>\n              Average health score\n            </Text>\n            <View style={{ flexDirection: 'row', gap: 16, marginTop: 8 }}>\n              <View>\n                <Text style={{ fontSize: 18, fontWeight: '600', color: theme.textPrimary, fontFamily: 'Inter_600SemiBold' }}>\n                  {tooltip.data.count}\n                </Text>\n                <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n                  friends\n                </Text>\n              </View>\n              <View>\n                <Text style={{ fontSize: 18, fontWeight: '600', color: theme.textPrimary, fontFamily: 'Inter_600SemiBold' }}>\n                  {tooltip.data.percentage.toFixed(0)}%\n                </Text>\n                <Text style={{ fontSize: 12, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n                  of network\n                </Text>\n              </View>\n            </View>\n          </>\n        );\n\n      case 'friend':\n        return (\n          <>\n            <Text style={{ fontSize: 24, fontWeight: '700', color: theme.textPrimary, fontFamily: 'Lora_700Bold', marginBottom: 16 }}>\n              {tooltip.data.name}\n            </Text>\n            <Text style={{ fontSize: 48, fontWeight: '700', color: theme.chartPrimary, fontFamily: 'Lora_700Bold', marginBottom: 4 }}>\n              {tooltip.data.count}\n            </Text>\n            <Text style={{ fontSize: 16, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n              weaves this year\n            </Text>\n            <View style={{ marginTop: 16, padding: 12, backgroundColor: theme.cardBackgroundDeep, borderRadius: 12 }}>\n              <Text style={{ fontSize: 13, color: theme.textTertiary, fontFamily: 'Inter_400Regular', textAlign: 'center' }}>\n                Your most frequent connection this year!\n              </Text>\n            </View>\n          </>\n        );\n\n      case 'donut':\n        return (\n          <>\n            <Text style={{ fontSize: 24, fontWeight: '700', color: theme.textPrimary, fontFamily: 'Lora_700Bold', marginBottom: 8 }}>\n              {tooltip.data.archetype}\n            </Text>\n            <Text style={{ fontSize: 48, fontWeight: '700', color: tooltip.data.color, fontFamily: 'Lora_700Bold', marginBottom: 4 }}>\n              {tooltip.data.count}\n            </Text>\n            <Text style={{ fontSize: 16, color: theme.textSecondary, fontFamily: 'Inter_400Regular' }}>\n              {tooltip.data.count === 1 ? 'friend' : 'friends'} • {Math.round(tooltip.data.percentage * 100)}% of circle\n            </Text>\n          </>\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <Modal visible={tooltip.visible} transparent animationType=\"fade\" onRequestClose={onClose}>\n      <Pressable style={{ flex: 1 }} onPress={onClose}>\n        <BlurView intensity={20} style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 24 }}>\n          <Animated.View entering={FadeIn.duration(200)}>\n            <Pressable\n              onPress={(e) => e.stopPropagation()}\n              style={{\n                backgroundColor: theme.cardBackground,\n                borderRadius: 24,\n                padding: 32,\n                minWidth: 280,\n                maxWidth: 320,\n                borderWidth: 1,\n                borderColor: theme.cardBorder,\n                shadowColor: theme.shadowColor,\n                shadowOffset: { width: 0, height: 8 },\n                shadowOpacity: theme.shadowOpacity,\n                shadowRadius: 16,\n                elevation: 8,\n              }}\n            >\n              <TouchableOpacity\n                onPress={onClose}\n                style={{ position: 'absolute', top: 16, right: 16, padding: 8 }}\n                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}\n              >\n                <X size={20} color={theme.textSecondary} />\n              </TouchableOpacity>\n              <View style={{ alignItems: 'center' }}>\n                {renderContent()}\n              </View>\n            </Pressable>\n          </Animated.View>\n        </BlurView>\n      </Pressable>\n    </Modal>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/YearInMoons/GraphsTabContentV2.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Animated' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FadeInDown' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Divider' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TrendBadge' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'year' is assigned a value but never used. Allowed unused args must match /^_/u.","line":71,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":163,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":163,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * GraphsTabContent V2\n * \n * Redesigned with iOS-native patterns:\n * - Summary first (big number, then context)\n * - One visualization per card\n * - Week/Month toggle instead of Year\n * - Uses main design tokens (no separate graph theme)\n * - No decorative elements — data is the decoration\n */\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { View, Text, ScrollView, StyleSheet } from 'react-native';\nimport Animated, { FadeInDown } from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport SocialBatteryLog from '@/db/models/SocialBatteryLog';\nimport { usePortfolio } from '@/modules/insights';\nimport { Card } from '@/components/ui/Card';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport { ProgressBar } from '@/components/ui/ProgressBar';\nimport { Divider } from '@/components/ui/Divider';\nimport {\n  PeriodToggle,\n  Period,\n  TrendBadge,\n  TierProgressRow,\n  ActivityDots,\n  MetricCard,\n  InsightText,\n  SimpleBarChart,\n} from '@/components/charts';\n\ninterface GraphsTabContentProps {\n  year?: number;\n}\n\ninterface PeriodData {\n  // Network Health\n  healthScore: number;\n  previousHealthScore: number;\n  thrivingCount: number;\n  stableCount: number;\n  driftingCount: number;\n\n  // Activity\n  weaveCount: number;\n  previousWeaveCount: number;\n  activityByDay: Array<{ date: Date; count: number }>;\n\n  // Energy & Connection\n  avgEnergy: number;\n  avgWeavesPerDay: number;\n  energyByDay: Array<{ label: string; value: number }>;\n  peakDay: { day: string; energy: number; weaves: number } | null;\n\n  // Tier Health\n  tiers: Array<{\n    name: string;\n    key: string;\n    progress: number;\n    count: number;\n    color: string;\n  }>;\n  tierInsight: { text: string; type: 'positive' | 'warning' | 'neutral' } | null;\n}\n\nexport function GraphsTabContent({ year = new Date().getFullYear() }: GraphsTabContentProps) {\n  const { tokens, spacing, layout } = useTheme();\n  const { portfolio } = usePortfolio();\n\n  const [period, setPeriod] = useState<Period>('week');\n  const [isLoading, setIsLoading] = useState(true);\n  const [data, setData] = useState<PeriodData | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load data when period changes\n  useEffect(() => {\n    loadPeriodData();\n  }, [period, portfolio]);\n\n  const loadPeriodData = async () => {\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const now = new Date();\n\n      const periodDays = period === 'week' ? 7 : 30;\n      const periodStart = new Date(now.getTime() - periodDays * 24 * 60 * 60 * 1000);\n      const previousPeriodStart = new Date(periodStart.getTime() - periodDays * 24 * 60 * 60 * 1000);\n\n      // === ACTIVITY DATA ===\n\n      // Current period weaves\n      const currentWeaves = await database\n        .get<InteractionModel>('interactions')\n        .query(\n          Q.where('interaction_date', Q.gte(periodStart.getTime())),\n          Q.where('status', 'completed')\n        )\n        .fetch();\n\n\n      // Previous period weaves (for trend)\n      const previousWeaves = await database\n        .get<InteractionModel>('interactions')\n        .query(\n          Q.where('interaction_date', Q.gte(previousPeriodStart.getTime())),\n          Q.where('interaction_date', Q.lt(periodStart.getTime())),\n          Q.where('status', 'completed')\n        )\n        .fetch();\n\n      // Activity by day\n      const activityByDay: Array<{ date: Date; count: number }> = [];\n      for (let i = 0; i < periodDays; i++) {\n        const dayStart = new Date(periodStart.getTime() + i * 24 * 60 * 60 * 1000);\n        dayStart.setHours(0, 0, 0, 0);\n        const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);\n\n        const count = currentWeaves.filter(w => {\n          const wDate = new Date(w.interactionDate);\n          return wDate >= dayStart && wDate < dayEnd;\n        }).length;\n\n        activityByDay.push({ date: dayStart, count });\n      }\n\n      // === ENERGY DATA ===\n\n      const batteryLogs = await database\n        .get<SocialBatteryLog>('social_battery_logs')\n        .query(\n          Q.where('timestamp', Q.gte(periodStart.getTime())),\n          Q.sortBy('timestamp', Q.asc)\n        )\n        .fetch();\n\n      // Energy by day of week\n      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n      const energyByDayOfWeek: Record<number, { total: number; count: number }> = {};\n\n      batteryLogs.forEach(log => {\n        const day = new Date(log.timestamp).getDay();\n        if (!energyByDayOfWeek[day]) {\n          energyByDayOfWeek[day] = { total: 0, count: 0 };\n        }\n        energyByDayOfWeek[day].total += log.value;\n        energyByDayOfWeek[day].count += 1;\n      });\n\n      // For week view: show actual days M-S\n      // For month view: show day-of-week averages\n      let energyByDay: Array<{ label: string; value: number }>;\n\n      if (period === 'week') {\n        // Last 7 days\n        energyByDay = activityByDay.map((day, i) => {\n          const dayLogs = batteryLogs.filter(log => {\n            const logDate = new Date(log.timestamp);\n            logDate.setHours(0, 0, 0, 0);\n            return logDate.getTime() === day.date.getTime();\n          });\n          const avg = dayLogs.length > 0\n            ? dayLogs.reduce((sum, l) => sum + l.value, 0) / dayLogs.length\n            : 0;\n\n          // Convert to M T W T F S S labels\n          const jsDay = day.date.getDay();\n          const labelIndex = jsDay === 0 ? 6 : jsDay - 1;\n          return { label: ['M', 'T', 'W', 'T', 'F', 'S', 'S'][labelIndex], value: avg };\n        });\n      } else {\n        // Day of week averages for month\n        energyByDay = [1, 2, 3, 4, 5, 6, 0].map(day => {\n          const data = energyByDayOfWeek[day];\n          const avg = data && data.count > 0 ? data.total / data.count : 0;\n          return { label: dayNames[day].charAt(0), value: avg };\n        });\n      }\n\n      // Calculate averages\n      const avgEnergy = batteryLogs.length > 0\n        ? batteryLogs.reduce((sum, l) => sum + l.value, 0) / batteryLogs.length\n        : 0;\n\n      const avgWeavesPerDay = currentWeaves.length / periodDays;\n\n      // Find peak day\n      let peakDay: PeriodData['peakDay'] = null;\n      let maxEnergy = 0;\n\n      energyByDay.forEach((day, i) => {\n        if (day.value > maxEnergy) {\n          maxEnergy = day.value;\n          const dayIndex = period === 'week'\n            ? activityByDay[i]?.date.getDay() ?? 0\n            : [1, 2, 3, 4, 5, 6, 0][i];\n\n          // Count weaves for this day\n          const dayWeaves = period === 'week'\n            ? activityByDay[i]?.count ?? 0\n            : currentWeaves.filter(w => new Date(w.interactionDate).getDay() === dayIndex).length / 4; // Avg per week\n\n          peakDay = {\n            day: dayNames[dayIndex],\n            energy: day.value,\n            weaves: Math.round(dayWeaves * 10) / 10,\n          };\n        }\n      });\n\n      // === TIER HEALTH ===\n\n      const friends = await database.get<FriendModel>('friends').query().fetch();\n\n      const tierData: Record<string, { total: number; count: number }> = {\n        InnerCircle: { total: 0, count: 0 },\n        CloseFriends: { total: 0, count: 0 },\n        Community: { total: 0, count: 0 },\n      };\n\n      friends.forEach(friend => {\n        const tier = friend.dunbarTier || 'Community';\n        if (tierData[tier]) {\n          tierData[tier].total += friend.weaveScore || 0;\n          tierData[tier].count += 1;\n        }\n      });\n\n      const tiers = [\n        {\n          name: 'Inner Circle',\n          key: 'InnerCircle',\n          progress: tierData.InnerCircle.count > 0\n            ? tierData.InnerCircle.total / tierData.InnerCircle.count\n            : 0,\n          count: tierData.InnerCircle.count,\n          color: tokens.tier.inner,\n        },\n        {\n          name: 'Close Friends',\n          key: 'CloseFriends',\n          progress: tierData.CloseFriends.count > 0\n            ? tierData.CloseFriends.total / tierData.CloseFriends.count\n            : 0,\n          count: tierData.CloseFriends.count,\n          color: tokens.tier.close,\n        },\n        {\n          name: 'Community',\n          key: 'Community',\n          progress: tierData.Community.count > 0\n            ? tierData.Community.total / tierData.Community.count\n            : 0,\n          count: tierData.Community.count,\n          color: tokens.tier.community,\n        },\n      ];\n\n      // Generate tier insight\n      const bestTier = tiers.reduce((best, tier) =>\n        tier.progress > best.progress ? tier : best\n      );\n      const worstTier = tiers.reduce((worst, tier) =>\n        tier.progress < worst.progress && tier.count > 0 ? tier : worst\n      );\n\n      let tierInsight: PeriodData['tierInsight'] = null;\n      if (bestTier.progress >= 70) {\n        tierInsight = { text: `${bestTier.name} is thriving`, type: 'positive' };\n      } else if (worstTier.progress < 40 && worstTier.count > 0) {\n        tierInsight = { text: `${worstTier.name} needs attention`, type: 'warning' };\n      }\n\n      // === NETWORK HEALTH ===\n\n      const rawHealthScore = portfolio?.overallHealthScore;\n      const healthScore = typeof rawHealthScore === 'number' && Number.isFinite(rawHealthScore) ? rawHealthScore : 0;\n\n      // Get historical health score\n      const historyDate = period === 'week' ? 7 : 30;\n      const historyTimestamp = now.getTime() - historyDate * 24 * 60 * 60 * 1000;\n      // Find the log closest to the target date (within a 2-day window)\n      const windowSize = 2 * 24 * 60 * 60 * 1000;\n\n      const historyLogs = await database.get('network_health_logs')\n        .query(\n          Q.where('timestamp', Q.gte(historyTimestamp - windowSize)),\n          Q.where('timestamp', Q.lte(historyTimestamp + windowSize)),\n          Q.sortBy('timestamp', Q.desc), // Get the latest one in that window\n          Q.take(1)\n        )\n        .fetch();\n\n      let previousHealthScore = healthScore;\n      if (historyLogs.length > 0) {\n        previousHealthScore = (historyLogs[0] as any).score;\n      } else {\n        // If no exact match, try to find ANY log before the period start to establish a baseline\n        const olderLogs = await database.get('network_health_logs')\n          .query(\n            Q.where('timestamp', Q.lt(historyTimestamp)),\n            Q.sortBy('timestamp', Q.desc),\n            Q.take(1)\n          )\n          .fetch();\n\n        if (olderLogs.length > 0) {\n          previousHealthScore = (olderLogs[0] as any).score;\n        }\n      }\n\n      const thrivingCount = friends.filter(f => (f.weaveScore || 0) >= 70).length;\n      const driftingCount = friends.filter(f => (f.weaveScore || 0) < 40).length;\n      const stableCount = friends.length - thrivingCount - driftingCount;\n\n      const newData = {\n        healthScore: Math.round(healthScore),\n        previousHealthScore: Math.round(previousHealthScore),\n        thrivingCount,\n        stableCount,\n        driftingCount,\n        weaveCount: currentWeaves.length,\n        previousWeaveCount: previousWeaves.length,\n        activityByDay,\n        avgEnergy,\n        avgWeavesPerDay,\n        energyByDay,\n        peakDay,\n        tiers,\n        tierInsight,\n      };\n\n\n      setData(newData);\n\n    } catch (error) {\n      console.error('Error loading period data:', error);\n      setError(error instanceof Error ? error.message : 'Failed to load data');\n    } finally {\n\n      setIsLoading(false);\n    }\n  };\n\n  const periodLabel = period === 'week' ? 'this week' : 'this month';\n  const previousLabel = period === 'week' ? 'from last week' : 'from last month';\n\n\n\n  if (isLoading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <Text style={[styles.loadingText, { color: tokens.foregroundMuted }]}>\n          Loading...\n        </Text>\n      </View>\n    );\n  }\n\n  if (error) {\n    return (\n      <View style={styles.loadingContainer}>\n        <Text style={[styles.loadingText, { color: tokens.destructive }]}>\n          Error: {error}\n        </Text>\n        <Text style={{ color: tokens.foregroundMuted, marginTop: 8, textAlign: 'center' }}>\n          Check console for details.\n        </Text>\n      </View>\n    );\n  }\n\n  if (!data) {\n    return (\n      <View style={styles.loadingContainer}>\n        <Text style={{ color: tokens.foregroundMuted }}>No data available</Text>\n      </View>\n    );\n  }\n\n  return (\n    <View\n      style={[styles.container, { padding: 16 }]}\n    >\n      {/* Period Toggle */}\n      <View style={styles.toggleContainer}>\n        <PeriodToggle value={period} onChange={setPeriod} />\n      </View>\n\n      {/* Network Health Card */}\n      <View>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Network Health\" />\n\n          <MetricCard\n            value={data.healthScore}\n            label=\"Health Score\"\n            trend={data.healthScore - data.previousHealthScore}\n            trendLabel={previousLabel}\n          />\n\n          <View style={{ marginTop: spacing[4] }}>\n            <ProgressBar\n              progress={data.healthScore}\n              color={\n                data.healthScore >= 70 ? tokens.success :\n                  data.healthScore >= 40 ? tokens.warning :\n                    tokens.destructive\n              }\n              height={8}\n            />\n          </View>\n\n          <View style={[styles.statsRow, { marginTop: spacing[4] }]}>\n            <Text style={[styles.statText, { color: tokens.foregroundMuted }]}>\n              <Text style={{ color: tokens.success, fontFamily: 'Inter_600SemiBold' }}>\n                {data.thrivingCount}\n              </Text> thriving\n            </Text>\n            <Text style={[styles.statDivider, { color: tokens.borderSubtle }]}>·</Text>\n            <Text style={[styles.statText, { color: tokens.foregroundMuted }]}>\n              <Text style={{ color: tokens.foreground, fontFamily: 'Inter_600SemiBold' }}>\n                {data.stableCount}\n              </Text> stable\n            </Text>\n            <Text style={[styles.statDivider, { color: tokens.borderSubtle }]}>·</Text>\n            <Text style={[styles.statText, { color: tokens.foregroundMuted }]}>\n              <Text style={{ color: tokens.warning, fontFamily: 'Inter_600SemiBold' }}>\n                {data.driftingCount}\n              </Text> drifting\n            </Text>\n          </View>\n        </Card>\n      </View>\n\n      {/* Activity Card */}\n      <View>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Activity\" />\n\n          <MetricCard\n            value={data.weaveCount}\n            label={`weaves ${periodLabel}`}\n            trend={data.weaveCount - data.previousWeaveCount}\n            trendLabel={previousLabel}\n            size=\"medium\"\n          />\n\n          <View style={{ marginTop: spacing[4] }}>\n            <ActivityDots data={data.activityByDay} period={period} />\n          </View>\n        </Card>\n      </View>\n\n      {/* Energy & Connection Card */}\n      <View>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Energy & Connection\" />\n\n          {/* Insight sentence */}\n          {data.peakDay && data.avgEnergy > 0 && (\n            <Text style={[styles.insightSentence, { color: tokens.foreground }]}>\n              You connect more on high-energy days\n            </Text>\n          )}\n\n          {/* Simple stats */}\n          <View style={[styles.energyStats, { marginTop: spacing[3] }]}>\n            <View style={styles.energyStat}>\n              <Text style={[styles.energyStatValue, { color: tokens.primary }]}>\n                {data.avgEnergy.toFixed(1)}\n              </Text>\n              <Text style={[styles.energyStatLabel, { color: tokens.foregroundMuted }]}>\n                avg energy\n              </Text>\n            </View>\n            <View style={[styles.energyStatDivider, { backgroundColor: tokens.borderSubtle }]} />\n            <View style={styles.energyStat}>\n              <Text style={[styles.energyStatValue, { color: tokens.success }]}>\n                {data.avgWeavesPerDay.toFixed(1)}\n              </Text>\n              <Text style={[styles.energyStatLabel, { color: tokens.foregroundMuted }]}>\n                weaves/day\n              </Text>\n            </View>\n          </View>\n\n          {/* Energy by day bar chart */}\n          {data.energyByDay.some(d => d.value > 0) && (\n            <View style={{ marginTop: spacing[4] }}>\n              <SimpleBarChart\n                data={data.energyByDay}\n                color={tokens.primary}\n                height={60}\n                showValues={false}\n              />\n            </View>\n          )}\n\n          {/* Peak day callout */}\n          {data.peakDay && (\n            <View style={[styles.peakDay, { backgroundColor: tokens.backgroundSubtle, marginTop: spacing[4] }]}>\n              <Text style={[styles.peakDayText, { color: tokens.foregroundMuted }]}>\n                Peak: <Text style={{ color: tokens.foreground, fontFamily: 'Inter_600SemiBold' }}>\n                  {data.peakDay.day}\n                </Text> ({data.peakDay.energy.toFixed(1)} energy, {data.peakDay.weaves} weaves)\n              </Text>\n            </View>\n          )}\n        </Card>\n      </View>\n\n      {/* Circle Health Card */}\n      <View>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Circle Health\" />\n\n          <View style={{ gap: spacing[3] }}>\n            {data.tiers.map((tier) => (\n              <TierProgressRow\n                key={tier.key}\n                label={tier.name}\n                progress={tier.progress}\n                count={tier.count}\n                color={tier.color}\n              />\n            ))}\n          </View>\n\n          {/* Tier insight */}\n          {data.tierInsight && (\n            <View style={{ marginTop: spacing[4] }}>\n              <InsightText\n                text={data.tierInsight.text}\n                type={data.tierInsight.type}\n              />\n            </View>\n          )}\n        </Card>\n      </View>\n\n      {/* Bottom spacing */}\n      <View style={{ height: spacing[8] }} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    // Removed flex: 1 to allow parent ScrollView to handle scrolling\n  },\n  content: {},\n  loadingContainer: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingTop: 60,\n  },\n  loadingText: {\n    fontSize: 14,\n    fontFamily: 'Inter_400Regular',\n  },\n  toggleContainer: {\n    alignItems: 'center',\n    marginBottom: 20,\n  },\n  statsRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  statText: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n  },\n  statDivider: {\n    marginHorizontal: 8,\n    fontSize: 13,\n  },\n  insightSentence: {\n    fontSize: 15,\n    fontFamily: 'Inter_500Medium',\n    lineHeight: 22,\n  },\n  energyStats: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  energyStat: {\n    flex: 1,\n    alignItems: 'center',\n  },\n  energyStatValue: {\n    fontSize: 24,\n    fontFamily: 'Lora_700Bold',\n  },\n  energyStatLabel: {\n    fontSize: 12,\n    fontFamily: 'Inter_400Regular',\n    marginTop: 2,\n  },\n  energyStatDivider: {\n    width: 1,\n    height: 32,\n    marginHorizontal: 16,\n  },\n  peakDay: {\n    paddingVertical: 10,\n    paddingHorizontal: 12,\n    borderRadius: 8,\n  },\n  peakDayText: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n    textAlign: 'center',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/YearInMoons/MoonPhaseIllustration.tsx","messages":[{"ruleId":"no-restricted-imports","severity":2,"message":"'../../../assets/MoonIcons/Phase1.svg' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":3,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":3,"endColumn":59},{"ruleId":"no-restricted-imports","severity":2,"message":"'../../../assets/MoonIcons/Phase2.svg' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":4,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":4,"endColumn":59},{"ruleId":"no-restricted-imports","severity":2,"message":"'../../../assets/MoonIcons/Phase3.svg' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":5,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":5,"endColumn":59},{"ruleId":"no-restricted-imports","severity":2,"message":"'../../../assets/MoonIcons/Phase4.svg' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":6,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":6,"endColumn":59},{"ruleId":"no-restricted-imports","severity":2,"message":"'../../../assets/MoonIcons/Phase5.svg' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":7,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":7,"endColumn":59}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View } from 'react-native';\nimport Phase1 from '../../../assets/MoonIcons/Phase1.svg';\nimport Phase2 from '../../../assets/MoonIcons/Phase2.svg';\nimport Phase3 from '../../../assets/MoonIcons/Phase3.svg';\nimport Phase4 from '../../../assets/MoonIcons/Phase4.svg';\nimport Phase5 from '../../../assets/MoonIcons/Phase5.svg';\n\ninterface MoonPhaseIllustrationProps {\n  phase: number; // 0-1 (0 = new moon/dark, 1 = full moon/bright)\n  size?: number;\n  hasCheckin?: boolean;\n  batteryLevel?: number | null; // 1-5, if provided directly (avoids round-trip conversion)\n  color?: string;\n}\n\n// Battery level moon icons\nconst MOON_ICONS = {\n  1: Phase1, // New Moon - Depleted\n  2: Phase2, // Waning - Low\n  3: Phase3, // Half Moon - Balanced\n  4: Phase4, // Waxing - Good\n  5: Phase5, // Full Moon - High\n};\n\nexport function MoonPhaseIllustration({\n  phase,\n  size = 40,\n  hasCheckin = true,\n  batteryLevel: providedBatteryLevel,\n  color\n}: MoonPhaseIllustrationProps) {\n  // Use provided battery level if available, otherwise convert from phase\n  let level: 1 | 2 | 3 | 4 | 5;\n  if (providedBatteryLevel !== null && providedBatteryLevel !== undefined) {\n    level = Math.max(1, Math.min(5, Math.round(providedBatteryLevel))) as 1 | 2 | 3 | 4 | 5;\n  } else {\n    // Convert phase (0-1) to battery level (1-5)\n    level = Math.max(1, Math.min(5, Math.ceil(phase * 5) || 1)) as 1 | 2 | 3 | 4 | 5;\n  }\n\n  const MoonIcon = MOON_ICONS[level];\n\n  // If no check-in, show Phase 1 (New Moon) with low opacity\n  if (!hasCheckin) {\n    return (\n      <View style={{ width: size, height: size, alignItems: 'center', justifyContent: 'center', opacity: 0.2 }}>\n        <Phase1 width={size} height={size} fill={color} color={color} />\n      </View>\n    );\n  }\n\n  return (\n    <View style={{ width: size, height: size, alignItems: 'center', justifyContent: 'center' }}>\n      <MoonIcon width={size} height={size} fill={color} color={color} />\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/YearInMoons/PatternsTabContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tokens' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":29}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":14,"column":11,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":14,"endColumn":34,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[637,674],"text":"type PatternsTabContentProps = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[637,674],"text":"type PatternsTabContentProps = unknown"},"desc":"Replace empty interface with `unknown`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * PatternsTabContent\n * Displays algorithm-detected patterns from battery and weave data\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { View, Text, ActivityIndicator } from 'react-native';\nimport Animated, { FadeInDown } from 'react-native-reanimated';\nimport { AlertCircle, Calendar, Zap, Sparkles, Star, Scale, Activity, TrendingUp, TrendingDown, ArrowRight, Gem, Brain, Users } from 'lucide-react-native';\nimport { detectPatterns, getPatternDataStats, Pattern } from '@/modules/insights';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ninterface PatternsTabContentProps { }\n\nconst ICON_MAP: Record<string, React.ElementType> = {\n  'calendar': Calendar,\n  'zap': Zap,\n  'sparkles': Sparkles,\n  'star': Star,\n  'scale': Scale,\n  'activity': Activity,\n  'trending-up': TrendingUp,\n  'trending-down': TrendingDown,\n  'arrow-right': ArrowRight,\n  'gem': Gem,\n  'brain': Brain,\n  'users': Users,\n};\n\nexport function PatternsTabContent({ }: PatternsTabContentProps) {\n  const { isDarkMode, tokens } = useTheme();\n  const [patterns, setPatterns] = useState<Pattern[]>([]);\n  const [dataStats, setDataStats] = useState<{ batteryDays: number; weaveCount: number } | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // ... existing useEffect and helpers ...\n\n  useEffect(() => {\n    loadPatterns();\n  }, []);\n\n  const loadPatterns = async () => {\n    setIsLoading(true);\n    try {\n      const [detected, stats] = await Promise.all([\n        detectPatterns(),\n        getPatternDataStats()\n      ]);\n      setPatterns(detected);\n      setDataStats(stats);\n    } catch (error) {\n      console.error('Error detecting patterns:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const getConfidenceBadgeColor = (confidence: Pattern['confidence']) => {\n    switch (confidence) {\n      case 'high':\n        return { bg: '#10B98120', text: '#10B981' }; // Green\n      case 'medium':\n        return { bg: '#F59E0B20', text: '#F59E0B' }; // Orange\n      case 'low':\n        return { bg: '#8A8F9E20', text: '#8A8F9E' }; // Gray\n    }\n  };\n\n  const getPatternIcon = (iconKey: string) => {\n    const IconComponent = ICON_MAP[iconKey];\n    if (IconComponent) {\n      return <IconComponent size={32} color={isDarkMode ? '#F5F1E8' : '#2D3142'} />;\n    }\n    return <Text className=\"text-3xl\">{iconKey}</Text>;\n  };\n\n  const getTypeLabel = (type: Pattern['type']) => {\n    switch (type) {\n      case 'cyclical':\n        return 'Cyclical';\n      case 'correlation':\n        return 'Correlation';\n      case 'best_days':\n        return 'Best Days';\n      case 'consistency':\n        return 'Consistency';\n      case 'trend':\n        return 'Trend';\n      default:\n        // Handle newer types if needed or return capitalized\n        return type.charAt(0).toUpperCase() + type.slice(1).replace('_', ' ');\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <View className=\"flex-1 items-center justify-center px-8\">\n        <ActivityIndicator size=\"large\" color={isDarkMode ? '#F5F1E8' : '#6366F1'} />\n        <Text\n          className=\"text-sm mt-4 text-center\"\n          style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n        >\n          Analyzing your patterns...\n        </Text>\n      </View>\n    );\n  }\n\n  if (patterns.length === 0) {\n    const hasEnoughData = dataStats && dataStats.batteryDays >= 14;\n\n    return (\n      <View className=\"flex-1 items-center justify-center px-8\">\n        <Text className=\"text-6xl mb-4\">{hasEnoughData ? '✨' : '📊'}</Text>\n        <Text\n          className=\"text-lg font-semibold text-center mb-2\"\n          style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_600SemiBold' }}\n        >\n          {hasEnoughData ? 'No Strong Patterns Yet' : 'Not Enough Data Yet'}\n        </Text>\n        <Text\n          className=\"text-sm text-center leading-5\"\n          style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n        >\n          {hasEnoughData\n            ? \"Your rhythm is unique! We haven't detected any strong statistical patterns yet, but keep logging to help us find deeper insights.\"\n            : \"Keep checking in your battery levels! We need at least 2 weeks of data to detect meaningful patterns.\"\n          }\n        </Text>\n      </View>\n    );\n  }\n\n  return (\n    <View\n      className=\"flex-1 px-5 py-4\"\n    >\n      {/* Header */}\n      <View className=\"mb-6\">\n        <Text\n          className=\"text-xl font-bold mb-1\"\n          style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_700Bold' }}\n        >\n          Your Energy Patterns\n        </Text>\n        <Text\n          className=\"text-sm leading-5\"\n          style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n        >\n          Algorithm-detected insights from your battery and connection history\n        </Text>\n      </View>\n\n      {/* Pattern Cards */}\n      {patterns.map((pattern, index) => {\n        const confidenceColors = getConfidenceBadgeColor(pattern.confidence);\n\n        return (\n          <Animated.View\n            key={pattern.id}\n            entering={FadeInDown.delay(index * 100)}\n            className=\"mb-4 p-4 rounded-2xl\"\n            style={{ backgroundColor: isDarkMode ? '#2A2E3F' : '#FFFFFF' }}\n          >\n            {/* Header Row: Icon, Title, Type Badge */}\n            <View className=\"flex-row items-start justify-between mb-3\">\n              <View className=\"flex-row items-center gap-3 flex-1\">\n                {getPatternIcon(pattern.icon)}\n                <View className=\"flex-1\">\n                  <Text\n                    className=\"text-base font-bold mb-0.5\"\n                    style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_700Bold' }}\n                  >\n                    {pattern.title}\n                  </Text>\n                  <Text\n                    className=\"text-[10px] font-medium uppercase tracking-wider\"\n                    style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_500Medium' }}\n                  >\n                    {getTypeLabel(pattern.type)}\n                  </Text>\n                </View>\n              </View>\n\n              {/* Confidence Badge */}\n              <View\n                className=\"px-2 py-1 rounded-full\"\n                style={{ backgroundColor: confidenceColors.bg }}\n              >\n                <Text\n                  className=\"text-[10px] font-semibold uppercase\"\n                  style={{ color: confidenceColors.text, fontFamily: 'Inter_600SemiBold' }}\n                >\n                  {pattern.confidence}\n                </Text>\n              </View>\n            </View>\n\n            {/* Description */}\n            <View className=\"mb-3\">\n              <Text\n                className=\"text-sm leading-5\"\n                style={{ color: isDarkMode ? '#C5CAD3' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n              >\n                {pattern.description}\n              </Text>\n            </View>\n\n            {/* Insight Box */}\n            <View\n              className=\"p-3 rounded-xl flex-row items-start gap-2\"\n              style={{ backgroundColor: isDarkMode ? '#1a1d2e' : '#F8F9FA' }}\n            >\n              <AlertCircle size={16} color={isDarkMode ? '#8A8F9E' : '#6C7589'} style={{ marginTop: 2 }} />\n              <Text\n                className=\"text-xs leading-5 flex-1 italic\"\n                style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Inter_400Regular' }}\n              >\n                {pattern.insight}\n              </Text>\n            </View>\n          </Animated.View>\n        );\n      })}\n\n      {/* Footer Note */}\n      <View className=\"mt-4 p-4 rounded-xl\" style={{ backgroundColor: isDarkMode ? '#2A2E3F' : '#FFFFFF' }}>\n        <Text\n          className=\"text-xs leading-5 text-center\"\n          style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n        >\n          Patterns update as you check in your battery and log weaves. These insights are probabilistic, not prescriptive—use them as gentle guides, not rules.\n        </Text>\n      </View>\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/YearInMoons/YearInMoonsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LinearGradient' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * YearInMoonsModal\n * Beautiful year-view calendar with moon phases representing battery levels\n * Three tabs: Moons (calendar), Graphs (visualizations), Patterns (insights)\n */\n\nimport React, { useState, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  TouchableOpacity,\n  ScrollView,\n  ActivityIndicator,\n  Dimensions,\n  Modal,\n} from 'react-native';\nimport { useRouter } from 'expo-router';\nimport Animated, { FadeIn } from 'react-native-reanimated';\nimport { X, Calendar, BarChart3, Sparkles } from 'lucide-react-native';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport { useTheme } from '@/shared/hooks/useTheme';\n// import { StandardBottomSheet } from '@/shared/ui/Sheet';\n// import { BottomSheetScrollView } from '@gorhom/bottom-sheet';\nimport { useUserProfileStore } from '@/modules/auth';\nimport { MoonPhaseIllustration } from './MoonPhaseIllustration';\nimport { PatternsTabContent } from './PatternsTabContent';\n// import { ReflectionJourneyModal } from '../ReflectionJourney/ReflectionJourneyModal';\nimport { SocialBatterySheet } from '../home/SocialBatterySheet';\nimport {\n  getYearMoonData,\n  getYearStats,\n  getMonthName,\n  MonthMoonData,\n  DayMoonData,\n} from '@/modules/reflection';\nimport * as Haptics from 'expo-haptics';\n\ninterface YearInMoonsModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\ntype Tab = 'moons' | 'journal' | 'patterns';\n\nexport function YearInMoonsModal({ isOpen, onClose }: YearInMoonsModalProps) {\n  const { colors, isDarkMode, tokens } = useTheme();\n  const { submitBatteryCheckin } = useUserProfileStore();\n  const [currentTab, setCurrentTab] = useState<Tab>('moons');\n  const [yearData, setYearData] = useState<MonthMoonData[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [selectedDay, setSelectedDay] = useState<DayMoonData | null>(null);\n  const [batterySheetVisible, setBatterySheetVisible] = useState(false);\n  const [dayForBatteryCheckin, setDayForBatteryCheckin] = useState<Date | null>(null);\n  const [yearStats, setYearStats] = useState({\n    totalCheckins: 0,\n    avgBattery: 0,\n    mostCommonLevel: 0,\n    streakDays: 0,\n  });\n  const scrollViewRef = React.useRef<ScrollView>(null);\n  const hasScrolledRef = React.useRef(false);\n\n  const currentYear = new Date().getFullYear();\n  const currentMonth = new Date().getMonth(); // 0-11\n  const screenWidth = Dimensions.get('window').width;\n  const moonSize = Math.floor((screenWidth - 80) / 7); // 7 moons per row with padding\n\n  useEffect(() => {\n    if (isOpen) {\n      hasScrolledRef.current = false;\n      loadYearData();\n    }\n  }, [isOpen]);\n\n  const loadYearData = async () => {\n    setIsLoading(true);\n    try {\n      const [data, stats] = await Promise.all([\n        getYearMoonData(currentYear),\n        getYearStats(currentYear),\n      ]);\n      setYearData(data);\n      setYearStats(stats);\n    } catch (error) {\n      console.error('Error loading year moon data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleClose = () => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setSelectedDay(null);\n    onClose();\n  };\n\n  const router = useRouter();\n\n  const handleTabChange = (tab: Tab) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    if (tab === 'journal') {\n      onClose(); // Close the modal first\n      router.push('/journal'); // Navigate to the new Journal screen\n    } else {\n      setCurrentTab(tab);\n    }\n  };\n\n  const handleMoonPress = (day: DayMoonData) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setSelectedDay(day);\n  };\n\n  const handleMoonLongPress = (day: DayMoonData) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    setDayForBatteryCheckin(day.date);\n    setBatterySheetVisible(true);\n  };\n\n  const handleBatteryCheckinSubmit = async (value: number, note?: string) => {\n    if (dayForBatteryCheckin) {\n      // Set time to noon on the selected day to avoid timezone issues\n      const timestamp = new Date(dayForBatteryCheckin);\n      timestamp.setHours(12, 0, 0, 0);\n\n      await submitBatteryCheckin(value, note, timestamp.getTime(), true);\n\n      // Reload the year data to reflect the new check-in\n      loadYearData();\n    }\n\n    setBatterySheetVisible(false);\n    setDayForBatteryCheckin(null);\n  };\n\n  const handleBatterySheetDismiss = () => {\n    setBatterySheetVisible(false);\n    setDayForBatteryCheckin(null);\n  };\n\n  const tabs: { id: Tab; label: string; icon: any }[] = [\n    { id: 'moons', label: 'Moons', icon: Calendar },\n    { id: 'journal', label: 'Journal', icon: BarChart3 },\n    { id: 'patterns', label: 'Patterns', icon: Sparkles },\n  ];\n\n  return (\n    <Modal\n      visible={isOpen}\n      animationType=\"slide\"\n      presentationStyle=\"pageSheet\"\n      onRequestClose={handleClose}\n    >\n      <View style={{ flex: 1, backgroundColor: colors.background }}>\n\n        {/* Header */}\n        <View className=\"flex-row items-center justify-between px-5 pt-5 pb-3 border-b\"\n          style={{ borderBottomColor: isDarkMode ? '#2A2E3F' : '#E5E7EB', backgroundColor: colors.background }}>\n          <Text\n            className=\"text-lg font-bold\"\n            style={{ color: colors.foreground, fontFamily: 'Lora_700Bold' }}\n          >\n            Year in Moons · {currentYear}\n          </Text>\n          <TouchableOpacity\n            onPress={handleClose}\n            className=\"p-2 -mr-2\"\n          >\n            <X size={24} color={colors['muted-foreground']} />\n          </TouchableOpacity>\n        </View>\n\n        {/* Tab Navigation */}\n        <View className=\"flex-row px-5 py-3 gap-2\" style={{ backgroundColor: colors.background }}>\n          {tabs.map((tab) => {\n            const Icon = tab.icon;\n            const isActive = currentTab === tab.id;\n\n            return (\n              <TouchableOpacity\n                key={tab.id}\n                onPress={() => handleTabChange(tab.id)}\n                className=\"flex-1 py-2.5 rounded-xl flex-row items-center justify-center gap-1.5\"\n                style={{\n                  backgroundColor: isActive ? (isDarkMode ? '#2A2E3F' : '#FFF8ED') : 'transparent',\n                }}\n              >\n                <Icon size={16} color={isActive ? (isDarkMode ? '#F5F1E8' : '#2D3142') : (isDarkMode ? '#8A8F9E' : '#6C7589')} />\n                <Text\n                  className=\"text-sm font-medium\"\n                  style={{\n                    color: isActive ? (isDarkMode ? '#F5F1E8' : '#2D3142') : (isDarkMode ? '#8A8F9E' : '#6C7589'),\n                    fontFamily: 'Inter_500Medium',\n                  }}\n                >\n                  {tab.label}\n                </Text>\n              </TouchableOpacity>\n            );\n          })}\n        </View>\n\n        {/* Content */}\n        {isLoading ? (\n          <View className=\"flex-1 items-center justify-center\">\n            <ActivityIndicator size=\"large\" color={isDarkMode ? '#F5F1E8' : '#6366F1'} />\n            <Text\n              className=\"text-sm mt-4\"\n              style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n            >\n              Loading your moon journey...\n            </Text>\n          </View>\n        ) : (\n          <ScrollView\n            ref={scrollViewRef}\n            style={{ flex: 1 }}\n            contentContainerStyle={{ paddingBottom: 100 }} // Add bottom padding for safety\n          >\n            {currentTab === 'moons' && (\n              <View className=\"flex-1 px-5 py-4\">\n                {/* Stats Summary */}\n                <View className=\"flex-row gap-3 mb-6\">\n                  <View className=\"flex-1 p-3 rounded-xl\" style={{ backgroundColor: isDarkMode ? '#2A2E3F' : '#FFF8ED' }}>\n                    <Text\n                      className=\"text-2xl font-bold mb-0.5\"\n                      style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_700Bold' }}\n                    >\n                      {yearStats.totalCheckins}\n                    </Text>\n                    <Text\n                      className=\"text-[10px]\"\n                      style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n                    >\n                      Check-ins\n                    </Text>\n                  </View>\n\n                  <View className=\"flex-1 p-3 rounded-xl\" style={{ backgroundColor: isDarkMode ? '#2A2E3F' : '#FFF8ED' }}>\n                    <Text\n                      className=\"text-2xl font-bold mb-0.5\"\n                      style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_700Bold' }}\n                    >\n                      {yearStats.streakDays}\n                    </Text>\n                    <Text\n                      className=\"text-[10px]\"\n                      style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n                    >\n                      Day Streak\n                    </Text>\n                  </View>\n\n                  <View className=\"flex-1 p-3 rounded-xl\" style={{ backgroundColor: isDarkMode ? '#2A2E3F' : '#FFF8ED' }}>\n                    <Text\n                      className=\"text-2xl font-bold mb-0.5\"\n                      style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_700Bold' }}\n                    >\n                      {yearStats.avgBattery}/5\n                    </Text>\n                    <Text\n                      className=\"text-[10px]\"\n                      style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n                    >\n                      Avg Energy\n                    </Text>\n                  </View>\n                </View>\n\n                {/* Moon Calendar - Month by Month */}\n                {yearData.map((monthData, monthIndex) => (\n                  <Animated.View\n                    key={`${monthData.year}-${monthData.month}`}\n                    entering={FadeIn.delay(monthIndex * 50)}\n                    className=\"mb-6\"\n                    onLayout={(event) => {\n                      if (monthData.month === currentMonth && !hasScrolledRef.current && scrollViewRef.current) {\n                        const y = event.nativeEvent.layout.y;\n                        console.log(`[AutoScroll] Found current month at y=${y}, scrolling now...`);\n\n                        // Small delay to ensure ScrollView content size is updated\n                        setTimeout(() => {\n                          scrollViewRef.current?.scrollTo({ y: Math.max(0, y - 20), animated: true });\n                        }, 100);\n\n                        hasScrolledRef.current = true;\n                      }\n                    }}\n                    collapsable={false}\n                  >\n                    {/* Month Header */}\n                    <Text\n                      className=\"text-base font-semibold mb-3\"\n                      style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Inter_600SemiBold' }}\n                    >\n                      {getMonthName(monthData.month)}\n                    </Text>\n\n                    {/* Week Day Labels */}\n                    <View className=\"flex-row mb-2\">\n                      {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, i) => (\n                        <View\n                          key={i}\n                          style={{ width: moonSize }}\n                          className=\"items-center\"\n                        >\n                          <Text\n                            className=\"text-[10px]\"\n                            style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n                          >\n                            {day}\n                          </Text>\n                        </View>\n                      ))}\n                    </View>\n\n                    {/* Moon Grid */}\n                    <View className=\"flex-row flex-wrap\">\n                      {/* Padding for first day of month */}\n                      {Array.from({ length: monthData.days[0].date.getDay() }).map((_, i) => (\n                        <View key={`pad-${i}`} style={{ width: moonSize, height: moonSize }} />\n                      ))}\n\n                      {/* Moon days */}\n                      {monthData.days.map((day) => (\n                        <TouchableOpacity\n                          key={day.date.toISOString()}\n                          onPress={() => handleMoonPress(day)}\n                          onLongPress={() => handleMoonLongPress(day)}\n                          delayLongPress={200}\n                          className=\"items-center justify-center mb-2\"\n                          style={{ width: moonSize, height: moonSize }}\n                        >\n                          <MoonPhaseIllustration\n                            phase={day.moonPhase}\n                            size={moonSize - 8}\n                            hasCheckin={day.hasCheckin}\n                            batteryLevel={day.batteryLevel}\n                            color={tokens.primary}\n                          />\n                          {/* Day number */}\n                          <Text\n                            className=\"text-[9px] mt-0.5\"\n                            style={{\n                              color: day.hasCheckin\n                                ? (isDarkMode ? '#F5F1E8' : '#2D3142')\n                                : (isDarkMode ? '#5A5F6E' : '#9CA3AF'),\n                              fontFamily: 'Inter_400Regular',\n                            }}\n                          >\n                            {day.date.getDate()}\n                          </Text>\n                        </TouchableOpacity>\n                      ))}\n                    </View>\n                  </Animated.View>\n                ))}\n\n                {/* End of year spacer */}\n                <View className=\"h-8\" />\n              </View>\n            )}\n\n            {currentTab === 'patterns' && <PatternsTabContent />}\n          </ScrollView>\n        )}\n\n        {/* Day Detail Bottom Sheet (Inline) */}\n        {selectedDay && (\n          <View\n            className=\"absolute bottom-0 left-0 right-0 p-6 rounded-t-3xl shadow-xl border-t\"\n            style={{\n              backgroundColor: colors.card,\n              borderColor: colors.border,\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: -2 },\n              shadowOpacity: 0.1,\n              shadowRadius: 10,\n              paddingBottom: 40 // Extra padding for safety\n            }}\n          >\n            <View className=\"flex-row items-start justify-between mb-4\">\n              <View>\n                <Text\n                  className=\"text-lg font-bold mb-1\"\n                  style={{ color: isDarkMode ? '#F5F1E8' : '#2D3142', fontFamily: 'Lora_700Bold' }}\n                >\n                  {selectedDay.date.toLocaleDateString('en-US', {\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric',\n                  })}\n                </Text>\n                <Text\n                  className=\"text-sm\"\n                  style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n                >\n                  {selectedDay.hasCheckin\n                    ? `Energy Level: ${selectedDay.batteryLevel}/5`\n                    : 'No check-in recorded'}\n                </Text>\n              </View>\n\n              <TouchableOpacity\n                onPress={() => setSelectedDay(null)}\n                className=\"p-2 -mr-2\"\n              >\n                <X size={20} color={isDarkMode ? '#8A8F9E' : '#6C7589'} />\n              </TouchableOpacity>\n            </View>\n\n            <View className=\"items-center mb-4\">\n              <MoonPhaseIllustration\n                phase={selectedDay.moonPhase}\n                size={80}\n                hasCheckin={selectedDay.hasCheckin}\n                batteryLevel={selectedDay.batteryLevel}\n                color={tokens.primary}\n              />\n            </View>\n\n            {!selectedDay.hasCheckin && (\n              <Text\n                className=\"text-xs text-center mb-2\"\n                style={{ color: isDarkMode ? '#8A8F9E' : '#6C7589', fontFamily: 'Inter_400Regular' }}\n              >\n                Long-press to add a check-in for this day\n              </Text>\n            )}\n          </View>\n        )}\n\n        {/* Battery Check-in Sheet */}\n        <SocialBatterySheet\n          isVisible={batterySheetVisible}\n          onSubmit={handleBatteryCheckinSubmit}\n          onDismiss={handleBatterySheetDismiss}\n        />\n      </View>\n    </Modal>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/YourPatternsSection.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getChipType' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":58,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * YourPatternsSection\n * Shows user's most-used chips and suggests custom chip creation\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { View, ScrollView, ActivityIndicator, TouchableOpacity } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { getMostUsedChips, analyzeCustomNotesForPatterns } from '@/modules/reflection';\nimport { STORY_CHIPS, type ChipType } from '@/modules/reflection';\nimport { CustomChipModal } from './CustomChipModal';\nimport Animated, { FadeIn } from 'react-native-reanimated';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport { Icon } from '@/shared/ui/Icon';\nimport { Card } from '@/shared/ui/Card';\n\ninterface YourPatternsSectionProps {\n  onCustomChipCreated?: () => void;\n}\n\nexport function YourPatternsSection({ onCustomChipCreated }: YourPatternsSectionProps) {\n  const { colors } = useTheme();\n  const [topChips, setTopChips] = useState<Array<{ chipId: string; count: number; isCustom: boolean }>>([]);\n  const [suggestion, setSuggestion] = useState<{ text: string; occurrences: number } | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [showCustomChipModal, setShowCustomChipModal] = useState(false);\n  const [suggestedType, setSuggestedType] = useState<ChipType>('feeling');\n\n  useEffect(() => {\n    loadPatterns();\n  }, []);\n\n  const loadPatterns = async () => {\n    setIsLoading(true);\n    try {\n      const [chips, feelingSuggestion] = await Promise.all([\n        getMostUsedChips(6),\n        analyzeCustomNotesForPatterns('feeling', 3),\n      ]);\n      setTopChips(chips);\n      setSuggestion(feelingSuggestion ? { text: feelingSuggestion.suggestedText, occurrences: feelingSuggestion.occurrences } : null);\n    } catch (error) {\n      console.error('Error loading patterns:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const getChipDisplay = (chipId: string, isCustom: boolean) => {\n    if (isCustom) {\n      return chipId; // Custom chips store text as ID for now\n    }\n    const chip = STORY_CHIPS.find(c => c.id === chipId);\n    return chip?.plainText || chipId;\n  };\n\n  const getChipType = (chipId: string, isCustom: boolean): ChipType => {\n    if (isCustom) {\n      return 'feeling'; // Default for custom chips\n    }\n    const chip = STORY_CHIPS.find(c => c.id === chipId);\n    return chip?.type || 'feeling';\n  };\n\n  const handleCreateCustomChip = (text?: string, type?: ChipType) => {\n    if (text) {\n      setSuggestion({ text, occurrences: 3 });\n    }\n    if (type) {\n      setSuggestedType(type);\n    }\n    setShowCustomChipModal(true);\n  };\n\n  const handleChipCreated = () => {\n    loadPatterns();\n    onCustomChipCreated?.();\n  };\n\n  if (isLoading) {\n    return (\n      <View className=\"p-5 items-center\">\n        <ActivityIndicator size=\"small\" color={colors.primary} />\n      </View>\n    );\n  }\n\n  if (topChips.length === 0 && !suggestion) {\n    return null; // Don't show if no patterns yet\n  }\n\n  return (\n    <Animated.View entering={FadeIn.duration(400)} className=\"gap-4\">\n      <View className=\"flex-row items-center justify-between\">\n        <View className=\"flex-row items-center gap-2\">\n          <Icon name=\"TrendingUp\" size={20} color={colors.primary} />\n          <Text variant=\"h3\" weight=\"bold\">\n            Your Patterns\n          </Text>\n        </View>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onPress={() => handleCreateCustomChip()}\n          className=\"flex-row items-center gap-1.5 px-3 py-2 rounded-lg bg-card border-border\"\n        >\n          <Icon name=\"Plus\" size={16} color={colors.primary} />\n          <Text variant=\"button\" className=\"text-primary text-xs font-semibold\">\n            Custom Chip\n          </Text>\n        </Button>\n      </View>\n\n      {/* Most used chips */}\n      {topChips.length > 0 && (\n        <View className=\"gap-3\">\n          <Text className=\"text-muted-foreground text-xs font-semibold\">\n            Your most-used chips:\n          </Text>\n          <ScrollView\n            horizontal\n            showsHorizontalScrollIndicator={false}\n            contentContainerClassName=\"gap-2 pr-4\"\n          >\n            {topChips.map((item, index) => (\n              <Animated.View\n                key={item.chipId}\n                entering={FadeIn.duration(300).delay(index * 50)}\n              >\n                <View\n                  className=\"flex-row items-center gap-2 px-3.5 py-2.5 rounded-2xl border border-border bg-card\"\n                >\n                  <Text variant=\"body\" weight=\"medium\">\n                    {getChipDisplay(item.chipId, item.isCustom)}\n                  </Text>\n                  <View className=\"px-1.5 py-0.5 rounded-lg bg-primary\">\n                    <Text className=\"text-[11px] font-bold text-white\">{item.count}×</Text>\n                  </View>\n                </View>\n              </Animated.View>\n            ))}\n          </ScrollView>\n        </View>\n      )}\n\n      {/* Custom chip suggestion */}\n      {suggestion && (\n        <View className=\"gap-3\">\n          <Text className=\"text-muted-foreground text-xs font-semibold\">\n            Create a chip?\n          </Text>\n          <TouchableOpacity\n            onPress={() => handleCreateCustomChip(suggestion.text, 'feeling')}\n            activeOpacity={0.7}\n          >\n            <Card\n              variant=\"outlined\"\n              className=\"flex-row items-center justify-between p-4 border-primary/40 bg-card\"\n            >\n              <View className=\"flex-1 gap-1\">\n                <Text variant=\"body\" weight=\"semibold\">\n                  \"{suggestion.text}\"\n                </Text>\n                <Text variant=\"caption\" className=\"text-muted-foreground\">\n                  You've used this {suggestion.occurrences} times\n                </Text>\n              </View>\n              <Icon name=\"Plus\" size={20} color={colors.primary} />\n            </Card>\n          </TouchableOpacity>\n        </View>\n      )}\n\n      {/* Custom Chip Modal */}\n      <CustomChipModal\n        isOpen={showCustomChipModal}\n        onClose={() => setShowCustomChipModal(false)}\n        suggestedText={suggestion?.text}\n        suggestedType={suggestedType}\n        onChipCreated={handleChipCreated}\n      />\n    </Animated.View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/ActivityDots.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is defined but never used. Allowed unused args must match /^_/u.","line":42,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is defined but never used. Allowed unused args must match /^_/u.","line":82,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ActivityDots\n * Simple dot-based activity visualization\n * Week view: 7 dots (M-S)\n * Month view: Calendar grid (4-5 weeks)\n */\n\nimport React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\ninterface DayData {\n  date: Date;\n  count: number;\n}\n\ninterface ActivityDotsProps {\n  data: DayData[];\n  period: 'week' | 'month';\n}\n\nconst DAY_LABELS = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];\n\nexport const ActivityDots: React.FC<ActivityDotsProps> = ({\n  data,\n  period,\n}) => {\n  const { tokens, spacing } = useTheme();\n\n  if (period === 'week') {\n    return <WeekView data={data} tokens={tokens} spacing={spacing} />;\n  }\n\n  return <MonthView data={data} tokens={tokens} spacing={spacing} />;\n};\n\n// Week view: Single row of 7 dots\nconst WeekView: React.FC<{\n  data: DayData[];\n  tokens: any;\n  spacing: any;\n}> = ({ data, tokens, spacing }) => {\n  // Ensure we have 7 days, filling with zeros if needed\n  const weekData = React.useMemo(() => {\n    const result: number[] = new Array(7).fill(0);\n\n    data.forEach((day) => {\n      // Get day of week (0 = Sunday in JS, but we want Monday = 0)\n      const jsDay = day.date.getDay();\n      const dayIndex = jsDay === 0 ? 6 : jsDay - 1; // Convert to Monday = 0\n      result[dayIndex] = day.count;\n    });\n\n    return result;\n  }, [data]);\n\n  return (\n    <View style={styles.weekContainer}>\n      {weekData.map((count, index) => (\n        <View key={index} style={styles.dayColumn}>\n          <ActivityDot count={count} tokens={tokens} />\n          <Text style={[\n            styles.dayLabel,\n            {\n              color: tokens.foregroundMuted,\n              fontFamily: 'Inter_500Medium',\n            }\n          ]}>\n            {DAY_LABELS[index]}\n          </Text>\n        </View>\n      ))}\n    </View>\n  );\n};\n\n// Month view: Calendar grid\nconst MonthView: React.FC<{\n  data: DayData[];\n  tokens: any;\n  spacing: any;\n}> = ({ data, tokens, spacing }) => {\n  // Group data by weeks\n  const weeks = React.useMemo(() => {\n    if (data.length === 0) return [];\n\n    // Sort by date\n    const sorted = [...data].sort((a, b) => a.date.getTime() - b.date.getTime());\n\n    // Group into weeks (Monday-Sunday)\n    const result: number[][] = [];\n    let currentWeek: number[] = [];\n    let currentWeekStart: number | null = null;\n\n    sorted.forEach((day) => {\n      const jsDay = day.date.getDay();\n      const dayIndex = jsDay === 0 ? 6 : jsDay - 1; // Monday = 0\n\n      // Get week start (Monday) for this date\n      const weekStart = new Date(day.date);\n      weekStart.setDate(weekStart.getDate() - dayIndex);\n      weekStart.setHours(0, 0, 0, 0);\n      const weekStartTime = weekStart.getTime();\n\n      if (currentWeekStart !== weekStartTime) {\n        // New week\n        if (currentWeek.length > 0) {\n          // Pad previous week to 7 days\n          while (currentWeek.length < 7) {\n            currentWeek.push(0);\n          }\n          result.push(currentWeek);\n        }\n        currentWeek = new Array(dayIndex).fill(0); // Pad start of week\n        currentWeekStart = weekStartTime;\n      }\n\n      currentWeek.push(day.count);\n    });\n\n    // Add final week\n    if (currentWeek.length > 0) {\n      while (currentWeek.length < 7) {\n        currentWeek.push(0);\n      }\n      result.push(currentWeek);\n    }\n\n    return result;\n  }, [data]);\n\n  return (\n    <View style={styles.monthContainer}>\n      {/* Day labels header */}\n      <View style={styles.monthHeader}>\n        {DAY_LABELS.map((label, index) => (\n          <Text\n            key={index}\n            style={[\n              styles.monthDayLabel,\n              {\n                color: tokens.foregroundSubtle,\n                fontFamily: 'Inter_500Medium',\n              }\n            ]}\n          >\n            {label}\n          </Text>\n        ))}\n      </View>\n\n      {/* Week rows */}\n      {weeks.map((week, weekIndex) => (\n        <View key={weekIndex} style={styles.monthWeekRow}>\n          {week.map((count, dayIndex) => (\n            <View key={dayIndex} style={styles.monthDayCell}>\n              <ActivityDot count={count} tokens={tokens} size=\"small\" />\n            </View>\n          ))}\n        </View>\n      ))}\n    </View>\n  );\n};\n\n// Individual dot component\nconst ActivityDot: React.FC<{\n  count: number;\n  tokens: any;\n  size?: 'default' | 'small';\n}> = ({ count, tokens, size = 'default' }) => {\n  const dotSize = size === 'default' ? 16 : 12;\n\n  // No activity — empty dot\n  if (count === 0) {\n    return (\n      <View style={[\n        styles.dot,\n        {\n          width: dotSize,\n          height: dotSize,\n          borderRadius: dotSize / 2,\n          backgroundColor: tokens.borderSubtle,\n        }\n      ]} />\n    );\n  }\n\n  // Has activity — filled dot with intensity based on count\n  // 1 weave = 50% opacity, 2 = 70%, 3+ = 100%\n  const safeCount = Number.isFinite(count) ? count : 0;\n  const opacity = Math.min(0.4 + (safeCount * 0.2), 1);\n\n  return (\n    <View style={[\n      styles.dot,\n      {\n        width: dotSize,\n        height: dotSize,\n        borderRadius: dotSize / 2,\n        backgroundColor: tokens.primary,\n        opacity,\n      }\n    ]} />\n  );\n};\n\nconst styles = StyleSheet.create({\n  // Week view\n  weekContainer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    paddingVertical: 8,\n  },\n  dayColumn: {\n    alignItems: 'center',\n    gap: 6,\n  },\n  dayLabel: {\n    fontSize: 11,\n  },\n\n  // Month view\n  monthContainer: {\n    gap: 4,\n  },\n  monthHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    marginBottom: 4,\n  },\n  monthDayLabel: {\n    flex: 1,\n    textAlign: 'center',\n    fontSize: 10,\n  },\n  monthWeekRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n  },\n  monthDayCell: {\n    flex: 1,\n    alignItems: 'center',\n    paddingVertical: 3,\n  },\n\n  // Dot\n  dot: {},\n});\n\nexport default ActivityDots;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/GraphsTabContentV2.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Divider' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TrendBadge' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'year' is assigned a value but never used. Allowed unused args must match /^_/u.","line":71,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":158,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * GraphsTabContent V2\n * \n * Redesigned with iOS-native patterns:\n * - Summary first (big number, then context)\n * - One visualization per card\n * - Week/Month toggle instead of Year\n * - Uses main design tokens (no separate graph theme)\n * - No decorative elements — data is the decoration\n */\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { View, Text, ScrollView, StyleSheet } from 'react-native';\nimport Animated, { FadeInDown } from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport SocialBatteryLog from '@/db/models/SocialBatteryLog';\nimport { usePortfolio } from '@/modules/insights';\nimport { Card } from '@/components/ui/Card';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport { ProgressBar } from '@/components/ui/ProgressBar';\nimport { Divider } from '@/components/ui/Divider';\nimport {\n  PeriodToggle,\n  Period,\n  TrendBadge,\n  TierProgressRow,\n  ActivityDots,\n  MetricCard,\n  InsightText,\n  SimpleBarChart,\n} from '@/components/charts';\n\ninterface GraphsTabContentProps {\n  year?: number;\n}\n\ninterface PeriodData {\n  // Network Health\n  healthScore: number;\n  previousHealthScore: number;\n  thrivingCount: number;\n  stableCount: number;\n  driftingCount: number;\n  \n  // Activity\n  weaveCount: number;\n  previousWeaveCount: number;\n  activityByDay: Array<{ date: Date; count: number }>;\n  \n  // Energy & Connection\n  avgEnergy: number;\n  avgWeavesPerDay: number;\n  energyByDay: Array<{ label: string; value: number }>;\n  peakDay: { day: string; energy: number; weaves: number } | null;\n  \n  // Tier Health\n  tiers: Array<{\n    name: string;\n    key: string;\n    progress: number;\n    count: number;\n    color: string;\n  }>;\n  tierInsight: { text: string; type: 'positive' | 'warning' | 'neutral' } | null;\n}\n\nexport function GraphsTabContent({ year = new Date().getFullYear() }: GraphsTabContentProps) {\n  const { tokens, spacing, layout } = useTheme();\n  const { portfolio } = usePortfolio();\n  \n  const [period, setPeriod] = useState<Period>('week');\n  const [isLoading, setIsLoading] = useState(true);\n  const [data, setData] = useState<PeriodData | null>(null);\n  \n  // Load data when period changes\n  useEffect(() => {\n    loadPeriodData();\n  }, [period, portfolio]);\n  \n  const loadPeriodData = async () => {\n    setIsLoading(true);\n    \n    try {\n      const now = new Date();\n      const periodDays = period === 'week' ? 7 : 30;\n      const periodStart = new Date(now.getTime() - periodDays * 24 * 60 * 60 * 1000);\n      const previousPeriodStart = new Date(periodStart.getTime() - periodDays * 24 * 60 * 60 * 1000);\n      \n      // === ACTIVITY DATA ===\n      \n      // Current period weaves\n      const currentWeaves = await database\n        .get<InteractionModel>('interactions')\n        .query(\n          Q.where('interaction_date', Q.gte(periodStart.getTime())),\n          Q.where('status', 'completed')\n        )\n        .fetch();\n      \n      // Previous period weaves (for trend)\n      const previousWeaves = await database\n        .get<InteractionModel>('interactions')\n        .query(\n          Q.where('interaction_date', Q.gte(previousPeriodStart.getTime())),\n          Q.where('interaction_date', Q.lt(periodStart.getTime())),\n          Q.where('status', 'completed')\n        )\n        .fetch();\n      \n      // Activity by day\n      const activityByDay: Array<{ date: Date; count: number }> = [];\n      for (let i = 0; i < periodDays; i++) {\n        const dayStart = new Date(periodStart.getTime() + i * 24 * 60 * 60 * 1000);\n        dayStart.setHours(0, 0, 0, 0);\n        const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);\n        \n        const count = currentWeaves.filter(w => {\n          const wDate = new Date(w.interactionDate);\n          return wDate >= dayStart && wDate < dayEnd;\n        }).length;\n        \n        activityByDay.push({ date: dayStart, count });\n      }\n      \n      // === ENERGY DATA ===\n      \n      const batteryLogs = await database\n        .get<SocialBatteryLog>('social_battery_logs')\n        .query(\n          Q.where('timestamp', Q.gte(periodStart.getTime())),\n          Q.sortBy('timestamp', Q.asc)\n        )\n        .fetch();\n      \n      // Energy by day of week\n      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n      const energyByDayOfWeek: Record<number, { total: number; count: number }> = {};\n      \n      batteryLogs.forEach(log => {\n        const day = new Date(log.timestamp).getDay();\n        if (!energyByDayOfWeek[day]) {\n          energyByDayOfWeek[day] = { total: 0, count: 0 };\n        }\n        energyByDayOfWeek[day].total += log.value;\n        energyByDayOfWeek[day].count += 1;\n      });\n      \n      // For week view: show actual days M-S\n      // For month view: show day-of-week averages\n      let energyByDay: Array<{ label: string; value: number }>;\n      \n      if (period === 'week') {\n        // Last 7 days\n        energyByDay = activityByDay.map((day, i) => {\n          const dayLogs = batteryLogs.filter(log => {\n            const logDate = new Date(log.timestamp);\n            logDate.setHours(0, 0, 0, 0);\n            return logDate.getTime() === day.date.getTime();\n          });\n          const avg = dayLogs.length > 0\n            ? dayLogs.reduce((sum, l) => sum + l.value, 0) / dayLogs.length\n            : 0;\n          \n          // Convert to M T W T F S S labels\n          const jsDay = day.date.getDay();\n          const labelIndex = jsDay === 0 ? 6 : jsDay - 1;\n          return { label: ['M', 'T', 'W', 'T', 'F', 'S', 'S'][labelIndex], value: avg };\n        });\n      } else {\n        // Day of week averages for month\n        energyByDay = [1, 2, 3, 4, 5, 6, 0].map(day => {\n          const data = energyByDayOfWeek[day];\n          const avg = data && data.count > 0 ? data.total / data.count : 0;\n          return { label: dayNames[day].charAt(0), value: avg };\n        });\n      }\n      \n      // Calculate averages\n      const avgEnergy = batteryLogs.length > 0\n        ? batteryLogs.reduce((sum, l) => sum + l.value, 0) / batteryLogs.length\n        : 0;\n      \n      const avgWeavesPerDay = currentWeaves.length / periodDays;\n      \n      // Find peak day\n      let peakDay: PeriodData['peakDay'] = null;\n      let maxEnergy = 0;\n      \n      energyByDay.forEach((day, i) => {\n        if (day.value > maxEnergy) {\n          maxEnergy = day.value;\n          const dayIndex = period === 'week'\n            ? activityByDay[i]?.date.getDay() ?? 0\n            : [1, 2, 3, 4, 5, 6, 0][i];\n          \n          // Count weaves for this day\n          const dayWeaves = period === 'week'\n            ? activityByDay[i]?.count ?? 0\n            : currentWeaves.filter(w => new Date(w.interactionDate).getDay() === dayIndex).length / 4; // Avg per week\n          \n          peakDay = {\n            day: dayNames[dayIndex],\n            energy: day.value,\n            weaves: Math.round(dayWeaves * 10) / 10,\n          };\n        }\n      });\n      \n      // === TIER HEALTH ===\n      \n      const friends = await database.get<FriendModel>('friends').query().fetch();\n      \n      const tierData: Record<string, { total: number; count: number }> = {\n        InnerCircle: { total: 0, count: 0 },\n        CloseFriends: { total: 0, count: 0 },\n        Community: { total: 0, count: 0 },\n      };\n      \n      friends.forEach(friend => {\n        const tier = friend.dunbarTier || 'Community';\n        if (tierData[tier]) {\n          tierData[tier].total += friend.weaveScore || 0;\n          tierData[tier].count += 1;\n        }\n      });\n      \n      const tiers = [\n        {\n          name: 'Inner Circle',\n          key: 'InnerCircle',\n          progress: tierData.InnerCircle.count > 0\n            ? tierData.InnerCircle.total / tierData.InnerCircle.count\n            : 0,\n          count: tierData.InnerCircle.count,\n          color: tokens.tier.inner,\n        },\n        {\n          name: 'Close Friends',\n          key: 'CloseFriends',\n          progress: tierData.CloseFriends.count > 0\n            ? tierData.CloseFriends.total / tierData.CloseFriends.count\n            : 0,\n          count: tierData.CloseFriends.count,\n          color: tokens.tier.close,\n        },\n        {\n          name: 'Community',\n          key: 'Community',\n          progress: tierData.Community.count > 0\n            ? tierData.Community.total / tierData.Community.count\n            : 0,\n          count: tierData.Community.count,\n          color: tokens.tier.community,\n        },\n      ];\n      \n      // Generate tier insight\n      const bestTier = tiers.reduce((best, tier) =>\n        tier.progress > best.progress ? tier : best\n      );\n      const worstTier = tiers.reduce((worst, tier) =>\n        tier.progress < worst.progress && tier.count > 0 ? tier : worst\n      );\n      \n      let tierInsight: PeriodData['tierInsight'] = null;\n      if (bestTier.progress >= 70) {\n        tierInsight = { text: `${bestTier.name} is thriving`, type: 'positive' };\n      } else if (worstTier.progress < 40 && worstTier.count > 0) {\n        tierInsight = { text: `${worstTier.name} needs attention`, type: 'warning' };\n      }\n      \n      // === NETWORK HEALTH ===\n      \n      const healthScore = portfolio?.overallHealthScore ?? 0;\n      // For previous health, we'd need historical data — for now, simulate small change\n      const previousHealthScore = healthScore - (Math.random() * 10 - 5);\n      \n      const thrivingCount = friends.filter(f => (f.weaveScore || 0) >= 70).length;\n      const driftingCount = friends.filter(f => (f.weaveScore || 0) < 40).length;\n      const stableCount = friends.length - thrivingCount - driftingCount;\n      \n      setData({\n        healthScore: Math.round(healthScore),\n        previousHealthScore: Math.round(previousHealthScore),\n        thrivingCount,\n        stableCount,\n        driftingCount,\n        weaveCount: currentWeaves.length,\n        previousWeaveCount: previousWeaves.length,\n        activityByDay,\n        avgEnergy,\n        avgWeavesPerDay,\n        energyByDay,\n        peakDay,\n        tiers,\n        tierInsight,\n      });\n      \n    } catch (error) {\n      console.error('Error loading period data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  if (isLoading || !data) {\n    return (\n      <View style={styles.loadingContainer}>\n        <Text style={[styles.loadingText, { color: tokens.foregroundMuted }]}>\n          Loading...\n        </Text>\n      </View>\n    );\n  }\n  \n  const periodLabel = period === 'week' ? 'this week' : 'this month';\n  const previousLabel = period === 'week' ? 'from last week' : 'from last month';\n  \n  return (\n    <ScrollView\n      style={styles.container}\n      contentContainerStyle={[styles.content, { padding: layout.screenPadding }]}\n      showsVerticalScrollIndicator={false}\n    >\n      {/* Period Toggle */}\n      <View style={styles.toggleContainer}>\n        <PeriodToggle value={period} onChange={setPeriod} />\n      </View>\n      \n      {/* Network Health Card */}\n      <Animated.View entering={FadeInDown.delay(0).duration(300)}>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Network Health\" />\n          \n          <MetricCard\n            value={data.healthScore}\n            label=\"Health Score\"\n            trend={data.healthScore - data.previousHealthScore}\n            trendLabel={previousLabel}\n          />\n          \n          <View style={{ marginTop: spacing[4] }}>\n            <ProgressBar\n              progress={data.healthScore}\n              color={\n                data.healthScore >= 70 ? tokens.success :\n                data.healthScore >= 40 ? tokens.warning :\n                tokens.destructive\n              }\n              height={8}\n            />\n          </View>\n          \n          <View style={[styles.statsRow, { marginTop: spacing[4] }]}>\n            <Text style={[styles.statText, { color: tokens.foregroundMuted }]}>\n              <Text style={{ color: tokens.success, fontFamily: 'Inter_600SemiBold' }}>\n                {data.thrivingCount}\n              </Text> thriving\n            </Text>\n            <Text style={[styles.statDivider, { color: tokens.borderSubtle }]}>·</Text>\n            <Text style={[styles.statText, { color: tokens.foregroundMuted }]}>\n              <Text style={{ color: tokens.foreground, fontFamily: 'Inter_600SemiBold' }}>\n                {data.stableCount}\n              </Text> stable\n            </Text>\n            <Text style={[styles.statDivider, { color: tokens.borderSubtle }]}>·</Text>\n            <Text style={[styles.statText, { color: tokens.foregroundMuted }]}>\n              <Text style={{ color: tokens.warning, fontFamily: 'Inter_600SemiBold' }}>\n                {data.driftingCount}\n              </Text> drifting\n            </Text>\n          </View>\n        </Card>\n      </Animated.View>\n      \n      {/* Activity Card */}\n      <Animated.View entering={FadeInDown.delay(100).duration(300)}>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Activity\" />\n          \n          <MetricCard\n            value={data.weaveCount}\n            label={`weaves ${periodLabel}`}\n            trend={data.weaveCount - data.previousWeaveCount}\n            trendLabel={previousLabel}\n            size=\"medium\"\n          />\n          \n          <View style={{ marginTop: spacing[4] }}>\n            <ActivityDots data={data.activityByDay} period={period} />\n          </View>\n        </Card>\n      </Animated.View>\n      \n      {/* Energy & Connection Card */}\n      <Animated.View entering={FadeInDown.delay(200).duration(300)}>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Energy & Connection\" />\n          \n          {/* Insight sentence */}\n          {data.peakDay && data.avgEnergy > 0 && (\n            <Text style={[styles.insightSentence, { color: tokens.foreground }]}>\n              You connect more on high-energy days\n            </Text>\n          )}\n          \n          {/* Simple stats */}\n          <View style={[styles.energyStats, { marginTop: spacing[3] }]}>\n            <View style={styles.energyStat}>\n              <Text style={[styles.energyStatValue, { color: tokens.primary }]}>\n                {data.avgEnergy.toFixed(1)}\n              </Text>\n              <Text style={[styles.energyStatLabel, { color: tokens.foregroundMuted }]}>\n                avg energy\n              </Text>\n            </View>\n            <View style={[styles.energyStatDivider, { backgroundColor: tokens.borderSubtle }]} />\n            <View style={styles.energyStat}>\n              <Text style={[styles.energyStatValue, { color: tokens.success }]}>\n                {data.avgWeavesPerDay.toFixed(1)}\n              </Text>\n              <Text style={[styles.energyStatLabel, { color: tokens.foregroundMuted }]}>\n                weaves/day\n              </Text>\n            </View>\n          </View>\n          \n          {/* Energy by day bar chart */}\n          {data.energyByDay.some(d => d.value > 0) && (\n            <View style={{ marginTop: spacing[4] }}>\n              <SimpleBarChart\n                data={data.energyByDay}\n                color={tokens.primary}\n                height={60}\n                showValues={false}\n              />\n            </View>\n          )}\n          \n          {/* Peak day callout */}\n          {data.peakDay && (\n            <View style={[styles.peakDay, { backgroundColor: tokens.backgroundSubtle, marginTop: spacing[4] }]}>\n              <Text style={[styles.peakDayText, { color: tokens.foregroundMuted }]}>\n                Peak: <Text style={{ color: tokens.foreground, fontFamily: 'Inter_600SemiBold' }}>\n                  {data.peakDay.day}\n                </Text> ({data.peakDay.energy.toFixed(1)} energy, {data.peakDay.weaves} weaves)\n              </Text>\n            </View>\n          )}\n        </Card>\n      </Animated.View>\n      \n      {/* Circle Health Card */}\n      <Animated.View entering={FadeInDown.delay(300).duration(300)}>\n        <Card variant=\"default\" padding=\"large\" style={{ marginBottom: layout.cardGap }}>\n          <WidgetHeader title=\"Circle Health\" />\n          \n          <View style={{ gap: spacing[3] }}>\n            {data.tiers.map((tier) => (\n              <TierProgressRow\n                key={tier.key}\n                label={tier.name}\n                progress={tier.progress}\n                count={tier.count}\n                color={tier.color}\n              />\n            ))}\n          </View>\n          \n          {/* Tier insight */}\n          {data.tierInsight && (\n            <View style={{ marginTop: spacing[4] }}>\n              <InsightText\n                text={data.tierInsight.text}\n                type={data.tierInsight.type}\n              />\n            </View>\n          )}\n        </Card>\n      </Animated.View>\n      \n      {/* Bottom spacing */}\n      <View style={{ height: spacing[8] }} />\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {},\n  loadingContainer: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingTop: 60,\n  },\n  loadingText: {\n    fontSize: 14,\n    fontFamily: 'Inter_400Regular',\n  },\n  toggleContainer: {\n    alignItems: 'center',\n    marginBottom: 20,\n  },\n  statsRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  statText: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n  },\n  statDivider: {\n    marginHorizontal: 8,\n    fontSize: 13,\n  },\n  insightSentence: {\n    fontSize: 15,\n    fontFamily: 'Inter_500Medium',\n    lineHeight: 22,\n  },\n  energyStats: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  energyStat: {\n    flex: 1,\n    alignItems: 'center',\n  },\n  energyStatValue: {\n    fontSize: 24,\n    fontFamily: 'Lora_700Bold',\n  },\n  energyStatLabel: {\n    fontSize: 12,\n    fontFamily: 'Inter_400Regular',\n    marginTop: 2,\n  },\n  energyStatDivider: {\n    width: 1,\n    height: 32,\n    marginHorizontal: 16,\n  },\n  peakDay: {\n    paddingVertical: 10,\n    paddingHorizontal: 12,\n    borderRadius: 8,\n  },\n  peakDayText: {\n    fontSize: 13,\n    fontFamily: 'Inter_400Regular',\n    textAlign: 'center',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/InsightText.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/MetricCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/PeriodToggle.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":28,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * PeriodToggle\n * Segmented control for selecting time period (Week/Month)\n * iOS-native style with haptic feedback\n */\n\nimport React from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\nimport * as Haptics from 'expo-haptics';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n} from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\nexport type Period = 'week' | 'month';\n\ninterface PeriodToggleProps {\n  value: Period;\n  onChange: (period: Period) => void;\n}\n\nexport const PeriodToggle: React.FC<PeriodToggleProps> = ({\n  value,\n  onChange,\n}) => {\n  const { tokens, radius, spacing } = useTheme();\n\n  const slidePosition = useSharedValue(value === 'week' ? 0 : 1);\n\n  React.useEffect(() => {\n    slidePosition.value = withTiming(value === 'week' ? 0 : 1, { duration: 200 });\n  }, [value]);\n\n  const handlePress = (period: Period) => {\n    if (period !== value) {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n      onChange(period);\n    }\n  };\n\n  const indicatorStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: slidePosition.value * (containerWidth / 2) }],\n  }));\n\n  const containerWidth = 200; // Fixed width for predictable animation\n\n  return (\n    <View style={[\n      styles.container,\n      {\n        backgroundColor: tokens.secondary, // Darker background for visibility\n        borderRadius: radius.md, // Slightly rounder\n        width: containerWidth,\n        padding: 4, // More padding\n      }\n    ]}>\n      {/* Sliding indicator */}\n      <Animated.View\n        style={[\n          styles.indicator,\n          {\n            backgroundColor: tokens.card.background, // White/Dark card bg\n            borderRadius: radius.sm,\n            width: containerWidth / 2 - 4,\n            shadowColor: '#000',\n            shadowOffset: { width: 0, height: 1 },\n            shadowOpacity: 0.1,\n            shadowRadius: 2,\n            elevation: 2,\n          },\n          indicatorStyle,\n        ]}\n      />\n\n      {/* Week button */}\n      <TouchableOpacity\n        onPress={() => handlePress('week')}\n        style={styles.button}\n        activeOpacity={0.7}\n      >\n        <Text style={[\n          styles.buttonText,\n          {\n            color: value === 'week' ? tokens.foreground : tokens.foregroundMuted,\n            fontFamily: value === 'week' ? 'Inter_600SemiBold' : 'Inter_500Medium',\n          }\n        ]}>\n          Week\n        </Text>\n      </TouchableOpacity>\n\n      {/* Month button */}\n      <TouchableOpacity\n        onPress={() => handlePress('month')}\n        style={styles.button}\n        activeOpacity={0.7}\n      >\n        <Text style={[\n          styles.buttonText,\n          {\n            color: value === 'month' ? tokens.foreground : tokens.foregroundMuted,\n            fontFamily: value === 'month' ? 'Inter_600SemiBold' : 'Inter_500Medium',\n          }\n        ]}>\n          Month\n        </Text>\n      </TouchableOpacity>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    padding: 2,\n    position: 'relative',\n  },\n  indicator: {\n    position: 'absolute',\n    top: 2,\n    left: 2,\n    bottom: 2,\n  },\n  button: {\n    flex: 1,\n    paddingVertical: 8,\n    alignItems: 'center',\n    justifyContent: 'center',\n    zIndex: 1,\n  },\n  buttonText: {\n    fontSize: 14,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/SimpleBarChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SimpleBarChart\n * Minimal bar chart for energy/weave patterns\n * Shows labeled bars with values\n */\n\nimport React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\ninterface BarData {\n  label: string;\n  value: number;\n  maxValue?: number;\n}\n\ninterface SimpleBarChartProps {\n  data: BarData[];\n  color?: string;\n  height?: number;\n  showValues?: boolean;\n  formatValue?: (value: number) => string;\n}\n\nexport const SimpleBarChart: React.FC<SimpleBarChartProps> = ({\n  data,\n  color,\n  height = 80,\n  showValues = false,\n  formatValue = (v) => v.toFixed(1),\n}) => {\n  const { tokens, spacing } = useTheme();\n\n  const barColor = color || tokens.primary;\n  const maxValue = Math.max(...data.map(d => d.maxValue ?? d.value), 1);\n\n  return (\n    <View style={[styles.container, { height: height + 24 }]}>\n      <View style={styles.barsContainer}>\n        {data.map((item, index) => {\n          const val = Number.isFinite(item.value) ? item.value : 0;\n          const barHeight = Number.isFinite((val / maxValue) * height) ? (val / maxValue) * height : 0;\n\n          return (\n            <View key={index} style={styles.barColumn}>\n              {/* Value label (optional) */}\n              {showValues && (\n                <Text style={[\n                  styles.valueLabel,\n                  {\n                    color: tokens.foregroundMuted,\n                    fontFamily: 'Inter_500Medium',\n                  }\n                ]}>\n                  {formatValue(item.value)}\n                </Text>\n              )}\n\n              {/* Bar container */}\n              <View style={[styles.barWrapper, { height }]}>\n                <View style={[\n                  styles.barTrack,\n                  { backgroundColor: tokens.borderSubtle }\n                ]} />\n\n                <View style={[\n                  styles.bar,\n                  {\n                    height: barHeight,\n                    backgroundColor: barColor,\n                    borderRadius: 4,\n                  }\n                ]} />\n              </View>\n\n              {/* Label */}\n              <Text style={[\n                styles.label,\n                {\n                  color: tokens.foregroundMuted,\n                  fontFamily: 'Inter_500Medium',\n                }\n              ]}>\n                {String(item.label)}\n              </Text>\n            </View>\n          );\n        })}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {},\n  barsContainer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-end',\n    flex: 1,\n  },\n  barColumn: {\n    alignItems: 'center',\n    flex: 1,\n  },\n  valueLabel: {\n    fontSize: 10,\n    marginBottom: 4,\n  },\n  barWrapper: {\n    width: '60%',\n    justifyContent: 'flex-end',\n    position: 'relative',\n  },\n  barTrack: {\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    height: '100%',\n    borderRadius: 4,\n    opacity: 0.3,\n  },\n  bar: {\n    width: '100%',\n  },\n  label: {\n    fontSize: 11,\n    marginTop: 6,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/TierProgressRow.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":25,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TierProgressRow\n * Horizontal progress bar with label, percentage, and count\n * Used for showing tier health in Circle Health card\n */\n\nimport React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { ProgressBar } from '@/components/ui/ProgressBar';\n\ninterface TierProgressRowProps {\n  label: string;\n  progress: number; // 0-100\n  count: number;\n  color: string;\n}\n\nexport const TierProgressRow: React.FC<TierProgressRowProps> = ({\n  label,\n  progress,\n  count,\n  color,\n}) => {\n  const { tokens, spacing } = useTheme();\n  \n  return (\n    <View style={styles.container}>\n      {/* Label row */}\n      <View style={styles.labelRow}>\n        <View style={styles.labelLeft}>\n          <View style={[styles.dot, { backgroundColor: color }]} />\n          <Text style={[\n            styles.label,\n            {\n              color: tokens.foreground,\n              fontFamily: 'Inter_500Medium',\n            }\n          ]}>\n            {label}\n          </Text>\n        </View>\n        <View style={styles.labelRight}>\n          <Text style={[\n            styles.percentage,\n            {\n              color: tokens.foreground,\n              fontFamily: 'Inter_600SemiBold',\n            }\n          ]}>\n            {Math.round(progress)}%\n          </Text>\n          <Text style={[\n            styles.count,\n            {\n              color: tokens.foregroundMuted,\n              fontFamily: 'Inter_400Regular',\n            }\n          ]}>\n            ({count})\n          </Text>\n        </View>\n      </View>\n      \n      {/* Progress bar */}\n      <ProgressBar\n        progress={progress}\n        color={color}\n        height={6}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    gap: 6,\n  },\n  labelRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  labelLeft: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n  },\n  dot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n  label: {\n    fontSize: 14,\n  },\n  labelRight: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 4,\n  },\n  percentage: {\n    fontSize: 14,\n  },\n  count: {\n    fontSize: 13,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/TrendBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/charts/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/fab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/friend-profile/ActionButtons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/friend-profile/FriendProfileModals.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IntentionModel' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { isFuture } from 'date-fns';\nimport { Interaction, InteractionCategory, Friend } from '@/components/types';\nimport IntentionModel from '@/db/models/Intention';\nimport { StructuredReflection } from '@/modules/interactions';\nimport { InteractionDetailModal } from '@/components/interaction-detail-modal';\nimport { EditReflectionModal } from '@/components/EditReflectionModal';\nimport { EditInteractionModal } from '@/components/EditInteractionModal';\nimport { PlanChoiceModal } from '@/components/PlanChoiceModal';\nimport { PlanWizard, PlanService } from '@/modules/interactions';\nimport { IntentionFormModal } from '@/components/IntentionFormModal';\nimport { IntentionsDrawer } from '@/components/IntentionsDrawer';\nimport { IntentionActionSheet } from '@/components/IntentionActionSheet';\nimport { LifeEventModal } from '@/components/LifeEventModal';\nimport FriendBadgePopup from '@/components/FriendBadgePopup';\nimport { TierFitBottomSheetWrapper } from './TierFitBottomSheetWrapper';\nimport { useFriendProfileModals } from '@/modules/relationships';\n\nimport { Intention } from '@/components/types';\n\ninterface FriendProfileModalsProps {\n    friend: Friend;\n    modals: ReturnType<typeof useFriendProfileModals>;\n    friendIntentions: Intention[];\n    selectedInteraction: Interaction | null; // Reactive selected interaction\n    updateReflection: (id: string, reflection: StructuredReflection) => Promise<void>;\n    updateInteraction: (id: string, updates: any) => Promise<void>; // Using any to avoid Model vs DTO conflicts\n    createIntention: (friendIds: string[], description: string, category?: InteractionCategory) => Promise<void>;\n    dismissIntention: (id: string) => Promise<void>;\n    deleteWeave: (id: string) => Promise<void>;\n    refreshLifeEvents: () => Promise<void>;\n}\n\nexport function FriendProfileModals({\n    friend,\n    modals,\n    friendIntentions,\n    selectedInteraction, // Deconstruct explicit prop\n    updateReflection,\n    updateInteraction,\n    createIntention,\n    dismissIntention,\n    deleteWeave,\n    refreshLifeEvents,\n}: FriendProfileModalsProps) {\n    const {\n        setSelectedInteraction, // Still need setter trigger\n        editingReflection,\n        setEditingReflection,\n        editingInteraction,\n        setEditingInteraction,\n        showPlanChoice,\n        setShowPlanChoice,\n        showPlanWizard,\n        setShowPlanWizard,\n        showIntentionForm,\n        setShowIntentionForm,\n        showIntentionsDrawer,\n        setShowIntentionsDrawer,\n        selectedIntentionForAction,\n        setSelectedIntentionForAction,\n        showLifeEventModal,\n        setShowLifeEventModal,\n        editingLifeEvent,\n        setEditingLifeEvent,\n        showBadgePopup,\n        setShowBadgePopup,\n        showTierFitSheet,\n        setShowTierFitSheet,\n        handleEditInteraction,\n    } = modals;\n\n    return (\n        <>\n            <InteractionDetailModal\n                interaction={selectedInteraction as any}\n                isOpen={selectedInteraction !== null}\n                onClose={() => setSelectedInteraction(null)}\n                friendName={friend.name}\n                onEditReflection={(interaction) => {\n                    setSelectedInteraction(null);\n                    // Add delay to allow modal to close (iOS race condition)\n                    setTimeout(() => {\n                        setEditingReflection(interaction as any);\n                    }, 500);\n                }}\n                onEdit={(interaction) => {\n                    handleEditInteraction(interaction as any);\n                }}\n                onDelete={async (id) => {\n                    await deleteWeave(id);\n                    setSelectedInteraction(null);\n                }}\n            />\n\n            <EditReflectionModal\n                interaction={editingReflection as any}\n                isOpen={editingReflection !== null}\n                onClose={() => setEditingReflection(null)}\n                onSave={async (id, reflection, vibe) => {\n                    // Update reflection\n                    await updateReflection(id, reflection);\n\n                    // Update vibe if changed\n                    if (vibe !== undefined) {\n                        await updateInteraction(id, { vibe });\n                    }\n                }}\n                friendArchetype={friend?.archetype as any}\n            />\n\n            <EditInteractionModal\n                interaction={editingInteraction as any}\n                isOpen={editingInteraction !== null && !showPlanWizard}\n                onClose={() => setEditingInteraction(null)}\n                onSave={updateInteraction as any}\n            />\n\n            <PlanChoiceModal\n                isOpen={showPlanChoice}\n                onClose={() => setShowPlanChoice(false)}\n                onSetIntention={() => {\n                    setShowPlanChoice(false);\n                    setTimeout(() => {\n                        setShowIntentionForm(true);\n                    }, 500);\n                }}\n                onSchedulePlan={() => {\n                    setShowPlanChoice(false);\n                    setTimeout(() => {\n                        if (friend) {\n                            setShowPlanWizard(true);\n                        }\n                    }, 500);\n                }}\n            />\n\n            {friend && (\n                <PlanWizard\n                    visible={showPlanWizard}\n                    onClose={() => {\n                        setShowPlanWizard(false);\n                        setEditingInteraction(null);\n                    }}\n                    initialFriend={friend as any}\n                    prefillData={editingInteraction && isFuture(new Date(editingInteraction.interactionDate)) ? {\n                        date: new Date(editingInteraction.interactionDate),\n                        category: (editingInteraction.interactionCategory || editingInteraction.activity) as InteractionCategory,\n                        title: editingInteraction.title,\n                        location: editingInteraction.location,\n                    } : undefined}\n                    replaceInteractionId={editingInteraction && isFuture(new Date(editingInteraction.interactionDate)) ? editingInteraction.id : undefined}\n                    initialStep={editingInteraction && isFuture(new Date(editingInteraction.interactionDate)) ? 3 : 1}\n                />\n            )}\n\n            <IntentionFormModal\n                isOpen={showIntentionForm}\n                friendName={friend.name}\n                onClose={() => setShowIntentionForm(false)}\n                onSave={async (description, category) => {\n                    await createIntention(\n                        [friend.id],\n                        description || '',\n                        category,\n                    );\n                }}\n            />\n\n            <IntentionsDrawer\n                intentions={friendIntentions}\n                isOpen={showIntentionsDrawer}\n                onClose={() => setShowIntentionsDrawer(false)}\n                onIntentionPress={(intention) => {\n                    setSelectedIntentionForAction(intention as any);\n                }}\n            />\n\n            <IntentionActionSheet\n                intention={selectedIntentionForAction as any}\n                isOpen={selectedIntentionForAction !== null}\n                onClose={() => setSelectedIntentionForAction(null)}\n                onSchedule={async (intention) => {\n                    await PlanService.convertIntentionToPlan(intention.id);\n                    setSelectedIntentionForAction(null);\n                    setShowPlanWizard(true);\n                }}\n                onDismiss={async (intention) => {\n                    await dismissIntention(intention.id);\n                    setSelectedIntentionForAction(null);\n                }}\n            />\n\n            <LifeEventModal\n                visible={showLifeEventModal}\n                onClose={() => {\n                    setShowLifeEventModal(false);\n                    setEditingLifeEvent(null);\n                    refreshLifeEvents();\n                }}\n                friendId={friend.id}\n                existingEvent={editingLifeEvent as any}\n            />\n\n            {friend && (\n                <FriendBadgePopup\n                    visible={showBadgePopup}\n                    onClose={() => setShowBadgePopup(false)}\n                    friendId={friend.id}\n                    friendName={friend.name}\n                />\n            )}\n\n            {friend && showTierFitSheet && (\n                <TierFitBottomSheetWrapper\n                    friendId={friend.id}\n                    visible={showTierFitSheet}\n                    onDismiss={() => setShowTierFitSheet(false)}\n                />\n            )}\n        </>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/friend-profile/LifeEventsSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/friend-profile/ProfileHeader.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FriendListRow' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\nimport Animated, { SharedValue, useAnimatedStyle } from 'react-native-reanimated';\nimport { ArrowLeft, Edit, Trash2, Calendar } from 'lucide-react-native';\nimport { FriendListRow, FriendListRowContent } from '@/modules/relationships';\nimport { PatternBadge } from '@/components/PatternBadge';\nimport { TierFitCard } from '@/modules/insights';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport FriendModel from '@/db/models/Friend';\n\ninterface ProfileHeaderProps {\n    friend: FriendModel;\n    headerOpacity: SharedValue<number>;\n    onBack: () => void;\n    onEdit: () => void;\n    onDelete: () => void;\n    onGlobalCalendar: () => void;\n    onShowBadgePopup: () => void;\n    onShowTierFit: () => void;\n}\n\nexport function ProfileHeader({\n    friend,\n    headerOpacity,\n    onBack,\n    onEdit,\n    onDelete,\n    onGlobalCalendar,\n    onShowBadgePopup,\n    onShowTierFit,\n}: ProfileHeaderProps) {\n    const { colors } = useTheme();\n\n    const headerAnimatedStyle = useAnimatedStyle(() => ({\n        opacity: headerOpacity.value,\n    }));\n\n    return (\n        <View>\n            <View style={[styles.header, { borderColor: colors.border }]}>\n                <TouchableOpacity onPress={onBack} style={styles.backButton}>\n                    <ArrowLeft size={20} color={colors['muted-foreground']} />\n                    <Text style={{ color: colors.foreground }}>Back</Text>\n                </TouchableOpacity>\n                <View style={styles.headerActions}>\n                    <TouchableOpacity onPress={onGlobalCalendar} style={{ padding: 8 }}>\n                        <Calendar size={20} color={colors['muted-foreground']} />\n                    </TouchableOpacity>\n                    <TouchableOpacity onPress={onEdit} style={{ padding: 8 }}>\n                        <Edit size={20} color={colors['muted-foreground']} />\n                    </TouchableOpacity>\n                    <TouchableOpacity onPress={onDelete} style={{ padding: 8 }}>\n                        <Trash2 size={20} color={colors.destructive} />\n                    </TouchableOpacity>\n                </View>\n            </View>\n\n            <View style={styles.contentContainer}>\n                <Animated.View style={headerAnimatedStyle}>\n                    <TouchableOpacity\n                        activeOpacity={0.95}\n                        onLongPress={onShowBadgePopup}\n                    >\n                        <View style={{ flex: 1 }}>\n                            <FriendListRowContent friend={friend} variant=\"full\" />\n                        </View>\n                    </TouchableOpacity>\n                    <PatternBadge friend={friend as any} style={{ marginTop: 4, marginLeft: 4 }} />\n\n                    {/* Tier Fit Card */}\n                    <TierFitCard\n                        friendId={friend.id}\n                        onPress={onShowTierFit}\n                    />\n                </Animated.View>\n            </View>\n        </View>\n    );\n}\n\nconst styles = StyleSheet.create({\n    header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 20, paddingVertical: 12, borderBottomWidth: 1 },\n    backButton: { flexDirection: 'row', alignItems: 'center', gap: 8 },\n    headerActions: { flexDirection: 'row', alignItems: 'center', gap: 8 },\n    contentContainer: { paddingHorizontal: 20, paddingTop: 12, paddingBottom: 8, gap: 12 },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/friend-profile/TierFitBottomSheetWrapper.tsx","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":37,"column":39,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":37,"endColumn":66}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Alert } from 'react-native';\nimport { Tier } from '@/components/types';\nimport { TierFitBottomSheet, useTierFit, changeFriendTier, dismissTierSuggestion } from '@/modules/insights';\n\ninterface TierFitBottomSheetWrapperProps {\n    friendId: string;\n    visible: boolean;\n    onDismiss: () => void;\n}\n\n/**\n * Wrapper component to handle tier fit analysis and tier changes\n */\nexport function TierFitBottomSheetWrapper({\n    friendId,\n    visible,\n    onDismiss\n}: TierFitBottomSheetWrapperProps) {\n    const { analysis } = useTierFit(friendId);\n\n    if (!analysis || analysis.fitCategory === 'insufficient_data') {\n        return null;\n    }\n\n    const handleChangeTier = async (newTier: Tier) => {\n        try {\n            await changeFriendTier(friendId, newTier, true); // true = wasFromSuggestion\n            console.log(`[TierFit] Successfully changed ${friendId} to ${newTier}`);\n\n            // Dismiss the modal first\n            onDismiss();\n\n            // Show toast after a slight delay to allow modal to close (avoiding z-index layering issues)\n            // and provide feedback to the user\n            setTimeout(() => {\n                const { showToast } = require('@/stores/uiStore').useUIStore.getState();\n                showToast(`Moved to ${newTier}`, analysis.friendName);\n            }, 400);\n\n        } catch (error) {\n            console.error('[TierFit] Error changing tier:', error);\n            Alert.alert('Error', 'Failed to change tier. Please try again.');\n        }\n    };\n\n    const handleStayInTier = () => {\n        // User chose to keep current tier - just close\n        console.log(`[TierFit] User chose to stay in tier for ${friendId}`);\n        onDismiss();\n    };\n\n    const handleDismissSuggestion = async () => {\n        try {\n            await dismissTierSuggestion(friendId);\n            console.log(`[TierFit] Dismissed suggestion for ${friendId}`);\n            onDismiss();\n        } catch (error) {\n            console.error('[TierFit] Error dismissing suggestion:', error);\n            Alert.alert('Error', 'Failed to dismiss suggestion. Please try again.');\n        }\n    };\n\n    return (\n        <TierFitBottomSheet\n            visible={visible}\n            analysis={analysis}\n            onDismiss={onDismiss}\n            onChangeTier={handleChangeTier}\n            onStayInTier={handleStayInTier}\n            onDismissSuggestion={handleDismissSuggestion}\n        />\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/friend-profile/TimelineList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/groups/GroupListModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/groups/GroupManagerModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Users' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, TouchableOpacity, Alert, FlatList } from 'react-native';\nimport { Check, Trash2, Users } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\nimport { Text } from '@/shared/ui/Text';\nimport { Button } from '@/shared/ui/Button';\nimport { Input } from '@/shared/ui/Input';\nimport { Card } from '@/shared/ui/Card';\nimport FriendModel from '@/db/models/Friend';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport { groupService } from '@/modules/groups';\nimport Group from '@/db/models/Group';\n\ninterface GroupManagerModalProps {\n    visible: boolean;\n    onClose: () => void;\n    groupToEdit?: Group; // If provided, we are editing\n    initialData?: { name: string; memberIds: string[] }; // For pre-filling (e.g. from suggestions)\n    onGroupSaved: () => void;\n}\n\nexport function GroupManagerModal({\n    visible,\n    onClose,\n    groupToEdit,\n    initialData,\n    onGroupSaved,\n}: GroupManagerModalProps) {\n    const { colors } = useTheme();\n    const [allFriends, setAllFriends] = useState<FriendModel[]>([]);\n    const [name, setName] = useState('');\n    const [selectedFriendIds, setSelectedFriendIds] = useState<string[]>([]);\n    const [isSaving, setIsSaving] = useState(false);\n\n    useEffect(() => {\n        const subscription = database\n            .get<FriendModel>('friends')\n            .query(Q.sortBy('created_at', Q.desc))\n            .observe()\n            .subscribe(setAllFriends);\n\n        return () => subscription.unsubscribe();\n    }, []);\n\n    // Initialize form when groupToEdit or initialData changes\n    useEffect(() => {\n        if (groupToEdit) {\n            setName(groupToEdit.name);\n            // Fetch members\n            groupToEdit.members.fetch().then((members: any[]) => {\n                setSelectedFriendIds(members.map((m: any) => m.friendId));\n            });\n        } else if (initialData) {\n            setName(initialData.name);\n            setSelectedFriendIds(initialData.memberIds);\n        } else {\n            setName('');\n            setSelectedFriendIds([]);\n        }\n    }, [groupToEdit, initialData, visible]);\n\n    const toggleFriend = (friendId: string) => {\n        if (selectedFriendIds.includes(friendId)) {\n            setSelectedFriendIds(prev => prev.filter(id => id !== friendId));\n        } else {\n            setSelectedFriendIds(prev => [...prev, friendId]);\n        }\n    };\n\n    const handleSave = async () => {\n        if (!name.trim()) {\n            Alert.alert('Missing Name', 'Please enter a name for the group.');\n            return;\n        }\n        if (selectedFriendIds.length === 0) {\n            Alert.alert('No Friends', 'Please select at least one friend.');\n            return;\n        }\n\n        setIsSaving(true);\n        try {\n            if (groupToEdit) {\n                await groupService.updateGroup(groupToEdit.id, name, selectedFriendIds);\n            } else {\n                await groupService.createGroup(name, selectedFriendIds);\n            }\n            onGroupSaved();\n            onClose();\n        } catch (error) {\n            console.error('Error saving group:', error);\n            Alert.alert('Error', 'Failed to save group.');\n        } finally {\n            setIsSaving(false);\n        }\n    };\n\n    const handleDelete = async () => {\n        if (!groupToEdit) return;\n\n        Alert.alert(\n            'Delete Group',\n            `Are you sure you want to delete \"${groupToEdit.name}\"?`,\n            [\n                { text: 'Cancel', style: 'cancel' },\n                {\n                    text: 'Delete',\n                    style: 'destructive',\n                    onPress: async () => {\n                        try {\n                            await groupService.deleteGroup(groupToEdit.id);\n                            onGroupSaved();\n                            onClose();\n                        } catch (error) {\n                            console.error('Error deleting group:', error);\n                            Alert.alert('Error', 'Failed to delete group.');\n                        }\n                    }\n                }\n            ]\n        );\n    };\n\n    const renderFriendItem = ({ item }: { item: FriendModel }) => {\n        const isSelected = selectedFriendIds.includes(item.id);\n        return (\n            <TouchableOpacity\n                onPress={() => toggleFriend(item.id)}\n                activeOpacity={0.7}\n            >\n                <Card\n                    className={`flex-row items-center justify-between p-4 mb-2 border ${isSelected ? 'border-primary bg-primary/5' : 'border-transparent'}`}\n                >\n                    <Text variant=\"body\" className={`font-medium ${isSelected ? 'text-primary' : 'text-foreground'}`}>\n                        {item.name}\n                    </Text>\n                    {isSelected && <Check size={20} color={colors.primary} />}\n                </Card>\n            </TouchableOpacity>\n        );\n    };\n\n    return (\n        <StandardBottomSheet\n            visible={visible}\n            onClose={onClose}\n            title={groupToEdit ? 'Edit Group' : 'New Group'}\n            snapPoints={['90%']}\n            disableContentPanning\n        >\n            <View className=\"flex-1 px-4\">\n                {/* Form */}\n                <View className=\"mb-6\">\n                    <Input\n                        label=\"Group Name\"\n                        placeholder=\"e.g., Girl Group, Family\"\n                        value={name}\n                        onChangeText={setName}\n                        autoCapitalize=\"words\"\n                    />\n                </View>\n\n                <View className=\"flex-1 mb-2\">\n                    <Text variant=\"h4\" className=\"mb-2 text-muted-foreground font-medium\">\n                        Select Members ({selectedFriendIds.length})\n                    </Text>\n\n                    <FlatList\n                        data={allFriends}\n                        keyExtractor={item => item.id}\n                        renderItem={renderFriendItem}\n                        showsVerticalScrollIndicator={false}\n                        contentContainerStyle={{ paddingBottom: 120 }}\n                    />\n                </View>\n\n                {/* Footer Actions */}\n                <View className=\"absolute bottom-0 left-0 right-0 p-4 border-t border-border bg-background flex-row gap-3\">\n                    {groupToEdit && (\n                        <Button\n                            onPress={handleDelete}\n                            variant=\"destructive\"\n                            className=\"px-4\"\n                        >\n                            <Trash2 size={20} color={colors['destructive-foreground']} />\n                        </Button>\n                    )}\n\n                    <Button\n                        onPress={handleSave}\n                        variant=\"primary\"\n                        disabled={isSaving}\n                        className=\"flex-1\"\n                    >\n                        {isSaving ? 'Saving...' : 'Save Group'}\n                    </Button>\n                </View>\n            </View>\n        </StandardBottomSheet>\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/HomeWidgetBase.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/HomeWidgetGrid.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'refreshing' is assigned a value but never used. Allowed unused args must match /^_/u.","line":70,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet, ScrollView } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withDelay,\n  withTiming,\n} from 'react-native-reanimated';\nimport { HomeWidgetConfig, HomeWidgetProps } from './HomeWidgetBase';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\nexport interface WidgetGridItem {\n  id: string;\n  component: React.ComponentType<HomeWidgetProps>;\n  config: HomeWidgetConfig;\n  position: number;\n  visible: boolean;\n  props?: HomeWidgetProps; // Additional props to pass to widget\n}\n\ninterface HomeWidgetGridProps {\n  widgets: WidgetGridItem[];\n  refreshing?: boolean;\n}\n\n/**\n * Animated wrapper for individual widgets\n * Handles staggered fade-in animation on mount\n */\nconst AnimatedWidget: React.FC<{\n  item: WidgetGridItem;\n  index: number;\n}> = ({ item, index }) => {\n  const opacity = useSharedValue(0);\n  const translateY = useSharedValue(20);\n\n  React.useEffect(() => {\n    // Staggered animation: each widget delays by 80ms\n    opacity.value = withDelay(index * 80, withTiming(1, { duration: 400 }));\n    translateY.value = withDelay(index * 80, withTiming(0, { duration: 400 }));\n  }, [index]);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n    transform: [{ translateY: translateY.value }],\n  }));\n\n  const WidgetComponent = item.component;\n\n  return (\n    <Animated.View\n      style={[\n        animatedStyle,\n        item.config.fullWidth ? styles.fullWidthWidget : styles.halfWidthWidget,\n      ]}\n    >\n      <WidgetComponent {...(item.props || {})} />\n    </Animated.View>\n  );\n};\n\n/**\n * HomeWidgetGrid\n *\n * Manages layout and rendering of dashboard widgets\n * Supports responsive grid with full-width and half-width widgets\n */\nexport const HomeWidgetGrid: React.FC<HomeWidgetGridProps> = ({\n  widgets,\n  refreshing = false,\n}) => {\n  const { layout } = useTheme();\n\n  // Filter visible widgets and sort by position\n  const visibleWidgets = widgets\n    .filter(w => w.visible)\n    .sort((a, b) => a.position - b.position);\n\n  return (\n    <ScrollView\n      style={styles.scrollView}\n      contentContainerStyle={styles.container}\n      showsVerticalScrollIndicator={false}\n    >\n      {/* Render widgets in a flexible row layout */}\n      <View style={[styles.grid, { rowGap: layout.cardGap }]}>\n        {visibleWidgets.map((item, index) => (\n          <AnimatedWidget key={item.id} item={item} index={index} />\n        ))}\n      </View>\n    </ScrollView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  scrollView: {\n    flex: 1,\n  },\n  container: {\n    paddingHorizontal: 20,\n    paddingTop: 16,\n    paddingBottom: 32,\n  },\n  grid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    justifyContent: 'space-between',\n  },\n  fullWidthWidget: {\n    width: '100%',\n  },\n  halfWidthWidget: {\n    width: '48%', // Allows 2 columns with 4% gap\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/SocialBatterySheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/widgets/ReflectionReadyWidget.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":21,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Sparkles, ArrowRight } from 'lucide-react-native';\nimport * as Haptics from 'expo-haptics';\nimport { HomeWidgetBase, HomeWidgetConfig } from '../HomeWidgetBase';\nimport { Card } from '@/components/ui/Card';\n\nconst WIDGET_CONFIG: HomeWidgetConfig = {\n  id: 'reflection-ready',\n  type: 'reflection-ready',\n  title: 'Reflection Ready',\n  fullWidth: true,\n};\n\ninterface ReflectionReadyWidgetProps {\n  onPress?: () => void;\n}\n\nexport function ReflectionReadyWidget({ onPress }: ReflectionReadyWidgetProps) {\n  const { tokens, typography, spacing } = useTheme();\n\n  const handlePress = () => {\n    if (onPress) {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n      onPress();\n    }\n  };\n\n  return (\n    <HomeWidgetBase config={WIDGET_CONFIG} padding=\"none\">\n      <TouchableOpacity\n        onPress={handlePress}\n        activeOpacity={0.7}\n        style={{ padding: 16 }}\n      >\n        <View style={styles.container}>\n          <View style={[styles.iconContainer, { backgroundColor: tokens.primary + '20' }]}>\n            <Sparkles size={24} color={tokens.primary} />\n          </View>\n\n          <View style={styles.content}>\n            <Text style={[styles.title, {\n              color: tokens.foreground,\n              fontFamily: typography.fonts.serifBold,\n              fontSize: typography.scale.h3.fontSize,\n              lineHeight: typography.scale.h3.lineHeight\n            }]}>\n              Your weekly reflection is ready\n            </Text>\n            <Text style={[styles.subtitle, {\n              color: tokens.foregroundMuted,\n              fontFamily: typography.fonts.sans,\n              fontSize: typography.scale.body.fontSize,\n              lineHeight: typography.scale.body.lineHeight\n            }]}>\n              Tap to reflect on this week's connections\n            </Text>\n          </View>\n\n          <View style={[styles.arrowContainer, { backgroundColor: tokens.primary }]}>\n            <ArrowRight size={16} color={tokens.primaryForeground} />\n          </View>\n        </View>\n      </TouchableOpacity>\n    </HomeWidgetBase>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 16,\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  content: {\n    flex: 1,\n  },\n  title: {\n    marginBottom: 4,\n  },\n  subtitle: {},\n  arrowContainer: {\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/widgets/SocialSeasonWidgetV2.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":43,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity } from 'react-native';\nimport * as Haptics from 'expo-haptics';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { HomeWidgetBase, HomeWidgetConfig } from '../HomeWidgetBase';\nimport { useUserProfileStore } from '@/modules/auth';\nimport { useInteractions } from '@/modules/interactions';\nimport {\n    calculateSocialSeason,\n    calculateSeasonContext,\n    getSeasonGreeting,\n    getSeasonDisplayName,\n    calculateWeightedNetworkHealth,\n    calculateCurrentScore,\n    type SocialSeason,\n    type SeasonCalculationInput,\n    type SeasonExplanationData,\n    logNetworkHealth\n} from '@/modules/intelligence';\nimport { database } from '@/db';\nimport Interaction from '@/db/models/Interaction';\nimport FriendModel from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\nimport withObservables from '@nozbe/with-observables';\nimport { startOfDay, subDays, format } from 'date-fns';\nimport { SeasonIcon } from '@/components/SeasonIcon';\nimport { SocialSeasonDetailSheet } from '@/components/SocialSeasonDetailSheet';\nimport { SeasonOverrideModal } from '@/components/SeasonOverrideModal';\n\nconst WIDGET_CONFIG: HomeWidgetConfig = {\n    id: 'social-season',\n    type: 'social-season',\n    title: 'Your Season',\n    minHeight: 120,\n    fullWidth: true,\n};\n\ninterface SocialSeasonWidgetProps {\n    friends: FriendModel[];\n}\n\nconst SocialSeasonWidgetContent: React.FC<SocialSeasonWidgetProps> = ({ friends }) => {\n    const { tokens, typography, spacing } = useTheme();\n    const { profile, updateSocialSeason, batteryStats } = useUserProfileStore();\n    const { allInteractions } = useInteractions();\n\n    const [isCalculating, setIsCalculating] = useState(false);\n    const [season, setSeason] = useState<SocialSeason>('balanced');\n    const [seasonData, setSeasonData] = useState<SeasonExplanationData | null>(null);\n    const [showDetailSheet, setShowDetailSheet] = useState(false);\n    const [showOverrideModal, setShowOverrideModal] = useState(false);\n    const [weeklyWeaves, setWeeklyWeaves] = useState(0);\n    const [currentStreak, setCurrentStreak] = useState(0);\n    const [networkHealth, setNetworkHealth] = useState(0);\n\n    // Logic ported from V1\n    const calculateActivityStats = async () => {\n        try {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n            const currentDayOfWeek = today.getDay();\n            const daysFromMonday = currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1;\n            const monday = new Date(today);\n            monday.setDate(today.getDate() - daysFromMonday);\n            monday.setHours(0, 0, 0, 0);\n\n            let weaveCount = 0;\n            const knots: boolean[] = [];\n\n            for (let i = 0; i < 7; i++) {\n                const dayDate = new Date(monday);\n                dayDate.setDate(monday.getDate() + i);\n                const dayStart = dayDate.getTime();\n                const dayEnd = dayStart + 24 * 60 * 60 * 1000;\n\n                const completedWeaves = await database\n                    .get<Interaction>('interactions')\n                    .query(\n                        Q.where('status', 'completed'),\n                        Q.where('interaction_date', Q.gte(dayStart)),\n                        Q.where('interaction_date', Q.lt(dayEnd))\n                    )\n                    .fetchCount();\n                weaveCount += completedWeaves;\n                knots.push(completedWeaves > 0);\n            }\n            setWeeklyWeaves(weaveCount);\n\n            // Simple streak calculation (consecutive days with activity backwards from today)\n            let streak = 0;\n            const todayIndex = currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1;\n            for (let i = todayIndex; i >= 0; i--) {\n                if (knots[i]) streak++;\n                else break;\n            }\n            setCurrentStreak(streak);\n            setNetworkHealth(calculateWeightedNetworkHealth(friends));\n        } catch (error) {\n            console.error('Error calculating activity stats:', error);\n        }\n    };\n\n    const calculateAndUpdateSeason = async () => {\n        if (!profile || friends.length === 0) return;\n        setIsCalculating(true);\n        try {\n            const now = startOfDay(new Date()).getTime();\n            const sevenDaysAgo = subDays(now, 7).getTime();\n            const thirtyDaysAgo = subDays(now, 30).getTime();\n\n            const weavesLast7Days = await database.get<Interaction>('interactions').query(Q.where('status', 'completed'), Q.where('interaction_date', Q.gte(sevenDaysAgo))).fetchCount();\n            const weavesLast30Days = await database.get<Interaction>('interactions').query(Q.where('status', 'completed'), Q.where('interaction_date', Q.gte(thirtyDaysAgo))).fetchCount();\n            const avgScoreAllFriends = calculateWeightedNetworkHealth(friends);\n            const innerCircleFriends = friends.filter(f => f.dunbarTier === 'InnerCircle');\n            const innerCircleScores = innerCircleFriends.map(f => calculateCurrentScore(f));\n            const avgScoreInnerCircle = innerCircleScores.reduce((sum, score) => sum + score, 0) / innerCircleScores.length || 0;\n            const momentumCount = friends.filter(f => f.momentumScore > 10 && f.momentumLastUpdated.getTime() > Date.now() - 24 * 60 * 60 * 1000).length;\n            const averageBattery = batteryStats.average || 50;\n            const batteryTrend = batteryStats.trend || 'stable';\n\n            const input: SeasonCalculationInput = {\n                weavesLast7Days,\n                weavesLast30Days,\n                avgScoreAllFriends,\n                avgScoreInnerCircle,\n                momentumCount,\n                batteryLast7DaysAvg: averageBattery,\n                batteryTrend: batteryTrend,\n            };\n\n            let newSeason = calculateSocialSeason(input, profile.currentSocialSeason);\n\n            // CHECK OVERRIDE: If active, keep current season. If expired, allow calculation (which clears it).\n            let isOverridden = false;\n            if (profile.seasonOverrideUntil && profile.seasonOverrideUntil > Date.now()) {\n                newSeason = profile.currentSocialSeason as SocialSeason;\n                isOverridden = true;\n            }\n\n            setSeason(newSeason);\n            setSeasonData({\n                season: newSeason,\n                weavesLast7Days,\n                weavesLast30Days,\n                avgScoreAllFriends,\n                avgScoreInnerCircle,\n                momentumCount,\n                batteryLast7DaysAvg: averageBattery,\n                batteryTrend: batteryTrend,\n            });\n\n            const oneHourAgo = Date.now() - 60 * 60 * 1000;\n\n            // Only update DB if NOT overridden. \n            // If overridden, we skip auto-updates effectively pausing the engine.\n            // If expired (isOverridden=false), we proceed, which calls updateSocialSeason(newSeason), clearing the expired fields.\n            if (!isOverridden) {\n                if (newSeason !== profile.currentSocialSeason || !profile.seasonLastCalculated || profile.seasonLastCalculated < oneHourAgo) {\n                    await updateSocialSeason(newSeason);\n                }\n            }\n\n            // Log network health for historical tracking (throttled internally to once per 24h)\n            await logNetworkHealth(avgScoreAllFriends, database);\n        } catch (error) {\n            console.error('Error calculating season:', error);\n        } finally {\n            setIsCalculating(false);\n        }\n    };\n\n    useEffect(() => {\n        calculateActivityStats();\n        calculateAndUpdateSeason();\n    }, [allInteractions, friends, profile]);\n\n    const context = calculateSeasonContext({\n        weavesLast7Days: 0,\n        weavesLast30Days: 0,\n        avgScoreAllFriends: calculateWeightedNetworkHealth(friends) || 50,\n        avgScoreInnerCircle: friends.filter(f => f.dunbarTier === 'InnerCircle').reduce((sum, f) => sum + calculateCurrentScore(f), 0) / friends.filter(f => f.dunbarTier === 'InnerCircle').length || 50,\n        momentumCount: friends.filter(f => f.momentumScore > 10).length,\n        batteryLast7DaysAvg: batteryStats.average || 50,\n        batteryTrend: batteryStats.trend || 'stable',\n    });\n\n    const greeting = getSeasonGreeting(season, context);\n\n    const handleLongPress = () => {\n        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n        setShowOverrideModal(true);\n    };\n\n    const handleSeasonOverride = async (newSeason: SocialSeason, durationDays?: number) => {\n        setSeason(newSeason);\n        await updateSocialSeason(newSeason, durationDays);\n    };\n\n    return (\n        <>\n            <HomeWidgetBase config={WIDGET_CONFIG} isLoading={isCalculating}>\n                <TouchableOpacity\n                    onPress={() => setShowDetailSheet(true)}\n                    onLongPress={handleLongPress}\n                    delayLongPress={500}\n                    activeOpacity={0.7}\n                >\n                    <View>\n                        <View style={styles.container}>\n                            <View style={styles.iconContainer}>\n                                <SeasonIcon season={season} size={48} color={tokens.primary} />\n                            </View>\n                            <View style={styles.textContainer}>\n                                <Text style={[styles.headline, {\n                                    color: tokens.foreground,\n                                    fontFamily: typography.fonts.serifBold,\n                                    fontSize: typography.scale.h2.fontSize,\n                                    lineHeight: typography.scale.h2.lineHeight\n                                }]}>\n                                    {getSeasonDisplayName(season)}\n                                </Text>\n                                <Text style={[styles.subtext, {\n                                    color: tokens.foregroundMuted,\n                                    fontFamily: typography.fonts.sans,\n                                    fontSize: typography.scale.body.fontSize,\n                                    lineHeight: typography.scale.body.lineHeight\n                                }]}>\n                                    {greeting.subtext}\n                                </Text>\n                            </View>\n                        </View>\n\n                        {profile?.seasonOverrideUntil && profile.seasonOverrideUntil > Date.now() && (\n                            <View style={{\n                                marginTop: 12,\n                                backgroundColor: tokens.primary + '15',\n                                alignSelf: 'flex-start',\n                                paddingHorizontal: 10,\n                                paddingVertical: 4,\n                                borderRadius: 8,\n                                flexDirection: 'row',\n                                alignItems: 'center',\n                                gap: 6\n                            }}>\n                                <View style={{ width: 6, height: 6, borderRadius: 3, backgroundColor: tokens.primary }} />\n                                <Text style={{\n                                    color: tokens.primary,\n                                    fontFamily: typography.fonts.sansMedium,\n                                    fontSize: 12\n                                }}>\n                                    Override active until {format(profile.seasonOverrideUntil, 'MMM d')}\n                                </Text>\n                            </View>\n                        )}\n\n                        <View style={{\n                            marginTop: 12,\n                            paddingTop: 12,\n                            borderTopWidth: 1,\n                            borderTopColor: tokens.borderSubtle,\n                            alignItems: 'center'\n                        }}>\n                            <Text style={{\n                                color: tokens.primary,\n                                fontFamily: typography.fonts.sansMedium,\n                                fontSize: typography.scale.label.fontSize,\n                            }}>\n                                See insights\n                            </Text>\n                        </View>\n                    </View>\n                </TouchableOpacity >\n            </HomeWidgetBase >\n\n            <SocialSeasonDetailSheet\n                isVisible={showDetailSheet}\n                onClose={() => setShowDetailSheet(false)}\n                season={season}\n                seasonData={seasonData}\n                weeklyWeaves={weeklyWeaves}\n                currentStreak={currentStreak}\n                networkHealth={networkHealth}\n            />\n\n            <SeasonOverrideModal\n                visible={showOverrideModal}\n                onClose={() => setShowOverrideModal(false)}\n                currentSeason={season}\n                onSelectSeason={handleSeasonOverride}\n            />\n        </>\n    );\n};\n\nconst enhance = withObservables([], () => ({\n    friends: database.get<FriendModel>('friends').query().observe(),\n}));\n\nexport const SocialSeasonWidgetV2 = enhance(SocialSeasonWidgetContent);\n\nconst styles = StyleSheet.create({\n    container: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 16,\n    },\n    iconContainer: {\n        width: 64,\n        height: 64,\n        borderRadius: 32,\n        alignItems: 'center',\n        justifyContent: 'center',\n        backgroundColor: 'rgba(255, 215, 0, 0.1)', // Subtle gold tint\n    },\n    textContainer: {\n        flex: 1,\n    },\n    headline: {\n        marginBottom: 4,\n    },\n    subtext: {\n        // Font size handled by typography.scale.body in component\n    },\n});\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/widgets/TodaysFocusWidgetV2.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'format' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Check' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Clock' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCategoryLabel' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'spacing' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":47,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'completePlan' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":51,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'confirmingIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setConfirmingIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'visiblePendingPlans' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":90,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":139,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":139,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'planFriendIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":233,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":280,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":300,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":300,"endColumn":70}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useMemo } from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity } from 'react-native';\nimport { useRouter } from 'expo-router';\nimport { differenceInDays, format } from 'date-fns';\nimport { Check, Clock, ChevronRight, Sparkles, Calendar, CheckCircle2 } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { HomeWidgetBase, HomeWidgetConfig } from '../HomeWidgetBase';\nimport { useSuggestions, useInteractions, usePlans } from '@/modules/interactions';\nimport { useUIStore } from '@/stores/uiStore';\nimport { database } from '@/db';\nimport LifeEvent from '@/db/models/LifeEvent';\nimport { Q } from '@nozbe/watermelondb';\nimport withObservables from '@nozbe/with-observables';\nimport Interaction from '@/db/models/Interaction';\nimport { Card } from '@/components/ui/Card';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport { ListItem } from '@/components/ui/ListItem';\nimport { FocusDetailSheet } from '@/components/FocusDetailSheet';\nimport { FocusPlanItem } from './components/FocusPlanItem';\nimport FriendModel from '@/db/models/Friend';\nimport { Suggestion } from '@/shared/types/common';\nimport { PlanWizard } from '@/modules/interactions';\nimport { getCategoryLabel } from '@/modules/interactions';\nimport { SeasonAnalyticsService } from '@/modules/intelligence';\n\nconst WIDGET_CONFIG: HomeWidgetConfig = {\n    id: 'todays-focus',\n    type: 'todays-focus',\n    title: \"Today's Focus\",\n    minHeight: 160,\n    fullWidth: true,\n};\n\ninterface UpcomingDate {\n    friend: FriendModel;\n    type: 'birthday' | 'anniversary' | 'life_event';\n    daysUntil: number;\n    title?: string;\n    importance?: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface TodaysFocusWidgetProps {\n    friends: FriendModel[];\n}\n\nconst TodaysFocusWidgetContent: React.FC<TodaysFocusWidgetProps> = ({ friends }) => {\n    const { tokens, typography, spacing } = useTheme();\n    const router = useRouter();\n    const { suggestions } = useSuggestions();\n    const { allInteractions: interactions } = useInteractions();\n    const { completePlan } = usePlans();\n    const { openPostWeaveRating } = useUIStore();\n\n    const [showDetailSheet, setShowDetailSheet] = useState(false);\n    const [upcomingDates, setUpcomingDates] = useState<UpcomingDate[]>([]);\n    const [confirmingIds, setConfirmingIds] = useState<Set<string>>(new Set());\n\n    // Rescheduling state\n    const [isPlanWizardOpen, setIsPlanWizardOpen] = useState(false);\n    const [wizardFriend, setWizardFriend] = useState<FriendModel | null>(null);\n    const [wizardPrefill, setWizardPrefill] = useState<any>(null);\n    const [replaceInteractionId, setReplaceInteractionId] = useState<string | undefined>(undefined);\n\n    // Logic ported from V1\n    const pendingConfirmations = useMemo(() => {\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        const sevenDaysAgo = new Date(today);\n        sevenDaysAgo.setDate(today.getDate() - 7);\n\n        const tomorrow = new Date(today);\n        tomorrow.setDate(today.getDate() + 1);\n\n        return interactions\n            .filter((i: Interaction) => {\n                const iDate = new Date(i.interactionDate);\n                iDate.setHours(0, 0, 0, 0);\n\n                // Filter out plans further than tomorrow\n                if (iDate > tomorrow) return false;\n\n                const isToday = iDate.getTime() === today.getTime();\n                if (isToday && i.status !== 'cancelled') return true;\n                if (i.status === 'completed' || i.status === 'cancelled') return false;\n                return iDate >= sevenDaysAgo;\n            })\n            .sort((a, b) => new Date(a.interactionDate).getTime() - new Date(b.interactionDate).getTime());\n    }, [interactions]);\n\n    const visiblePendingPlans = useMemo(() => {\n        // We don't filter out confirmingIds anymore to prevent the visual glitch of disappearing/reappearing\n        return pendingConfirmations;\n    }, [pendingConfirmations]);\n\n    // Load upcoming dates (ported from V1)\n    useEffect(() => {\n        if (!friends || friends.length === 0) return;\n\n        const loadLifeEvents = async () => {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n            const thirtyDaysFromNow = new Date();\n            thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);\n            const events: UpcomingDate[] = [];\n\n            const lifeEvents = await database\n                .get<LifeEvent>('life_events')\n                .query(\n                    Q.where('event_date', Q.gte(today.getTime())),\n                    Q.where('event_date', Q.lte(thirtyDaysFromNow.getTime()))\n                )\n                .fetch();\n\n            lifeEvents.forEach(event => {\n                const friend = friends.find(f => f.id === event.friendId);\n                if (friend) {\n                    events.push({\n                        friend,\n                        type: 'life_event',\n                        daysUntil: differenceInDays(event.eventDate, today),\n                        title: event.title,\n                        importance: event.importance,\n                    });\n                }\n            });\n\n            friends.forEach(friend => {\n                try {\n                    if (friend.birthday) {\n                        const [month, day] = friend.birthday.split('-').map(n => parseInt(n, 10));\n                        const birthdayThisYear = new Date(today.getFullYear(), month - 1, day);\n                        birthdayThisYear.setHours(0, 0, 0, 0);\n                        if (birthdayThisYear < today) birthdayThisYear.setFullYear(today.getFullYear() + 1);\n                        const daysUntil = differenceInDays(birthdayThisYear, today);\n                        if (daysUntil >= 0 && daysUntil <= 7) {\n                            events.push({ friend, type: 'birthday', daysUntil });\n                        }\n                    }\n                } catch (e) {\n                    // ignore\n                }\n            });\n\n            events.sort((a, b) => a.daysUntil - b.daysUntil);\n            setUpcomingDates(events);\n        };\n\n        loadLifeEvents();\n    }, [friends]);\n\n    const { showMicroReflectionSheet } = useUIStore();\n\n    const handleConfirmPlan = async (interactionId: string) => {\n        // Just open the rating modal for this plan\n        openPostWeaveRating(interactionId);\n    };\n\n    const handleReschedulePlan = async (plan: Interaction) => {\n        try {\n            // Fetch the primary friend for this plan\n            const iFriends = await plan.interactionFriends.fetch();\n            if (iFriends.length === 0) return;\n            const friendId = iFriends[0].friendId;\n            const friend = friends.find(f => f.id === friendId);\n\n            if (friend) {\n                setWizardFriend(friend);\n                setWizardPrefill({\n                    date: new Date(plan.interactionDate),\n                    category: plan.interactionCategory,\n                    title: plan.title,\n                    location: plan.location,\n                    time: new Date(plan.interactionDate), // Ensure time is passed too if needed by wizard\n                    notes: plan.note,\n                });\n                setReplaceInteractionId(plan.id);\n                setIsPlanWizardOpen(true);\n                setShowDetailSheet(false); // Close sheet if open\n            }\n        } catch (e) {\n            console.error('Error preparing reschedule:', e);\n        }\n    };\n\n    const handleDeepenWeave = async (plan: Interaction) => {\n        const iFriends = await plan.interactionFriends.fetch();\n        const friendId = iFriends.length > 0 ? iFriends[0].friendId : '';\n        const friend = friends.find(f => f.id === friendId);\n\n        if (friend) {\n            showMicroReflectionSheet({\n                friendId: friend.id,\n                friendName: friend.name,\n                activityId: plan.interactionCategory || 'hangout',\n                activityLabel: plan.title || 'Interaction',\n                interactionId: plan.id,\n                friendArchetype: friend.archetype,\n            });\n        }\n    };\n\n    const handleReviewPlan = (id?: string) => {\n        openPostWeaveRating(id); // Pass ID if available, otherwise opens queue\n    };\n\n    const handleSuggestionAction = (suggestion: Suggestion) => {\n        const friend = friends.find(f => f.id === suggestion.friendId);\n        if (friend) {\n            router.push(`/friend-profile?friendId=${friend.id}`);\n\n            // ANALYTICS: Track acceptance\n            SeasonAnalyticsService.trackSuggestionAccepted().catch(console.error);\n        }\n        setShowDetailSheet(false);\n    };\n\n    const todaysUpcoming = useMemo(() =>\n        interactions.filter(i =>\n            differenceInDays(new Date(i.interactionDate), new Date()) === 0 &&\n            i.status === 'planned'\n        ).sort((a, b) => new Date(a.interactionDate).getTime() - new Date(b.interactionDate).getTime())\n        , [interactions]);\n\n    const todaysCompleted = useMemo(() =>\n        interactions.filter(i =>\n            differenceInDays(new Date(i.interactionDate), new Date()) === 0 &&\n            i.status === 'completed'\n        ).sort((a, b) => new Date(b.interactionDate).getTime() - new Date(a.interactionDate).getTime())\n        , [interactions]);\n\n    const pendingReviews = useMemo(() => interactions.filter((i: Interaction) => i.status === 'pending_confirm'), [interactions]);\n\n    const [planFriendIds, setPlanFriendIds] = useState<Record<string, string[]>>({});\n\n    useEffect(() => {\n        let isMounted = true;\n        const loadFriends = async () => {\n            const newMap: Record<string, string[]> = {};\n            const allItems = [...todaysUpcoming, ...todaysCompleted];\n            for (const plan of allItems) {\n                try {\n                    const iFriends = await plan.interactionFriends.fetch();\n                    newMap[plan.id] = iFriends.map((f: any) => f.friendId);\n                } catch (e) {\n                    console.error('Error loading plan friends:', e);\n                }\n            }\n            if (isMounted) setPlanFriendIds(newMap);\n        };\n        loadFriends();\n        return () => { isMounted = false; };\n    }, [todaysUpcoming, todaysCompleted]);\n\n    const hasUpcoming = todaysUpcoming.length > 0;\n    const hasCompleted = todaysCompleted.length > 0;\n    const hasReviews = pendingReviews.length > 0;\n    const hasSuggestions = suggestions.length > 0;\n    const hasUpcomingDates = upcomingDates.length > 0;\n    const isAllClear = !hasUpcoming && !hasCompleted && !hasReviews && !hasSuggestions && !hasUpcomingDates;\n\n    return (\n        <>\n            <HomeWidgetBase config={WIDGET_CONFIG} padding=\"none\">\n                <View style={{ padding: 16, paddingBottom: 0 }}>\n                    <WidgetHeader\n                        title=\"Today's Focus\"\n                        action={{ label: 'See all', onPress: () => setShowDetailSheet(true) }}\n                    />\n                </View>\n\n                {/* Upcoming Plans Section */}\n                {hasUpcoming && (\n                    <View>\n                        {/* Only show header if there are other sections to differentiate from */}\n                        {(hasCompleted || hasReviews) && (\n                            <View style={styles.sectionHeader}>\n                                <Text style={[styles.sectionTitle, { color: tokens.foregroundMuted }]}>Upcoming</Text>\n                            </View>\n                        )}\n                        {todaysUpcoming.map((plan, index) => {\n                            return (\n                                <FocusPlanItem\n                                    key={plan.id}\n                                    interaction={plan}\n                                    friends={friends}\n                                    onReschedule={handleReschedulePlan}\n                                    isCompletedSection={false}\n                                />\n                            );\n                        })}\n                    </View>\n                )}\n\n                {/* Completed Plans Section */}\n                {hasCompleted && (\n                    <View style={{ marginTop: hasUpcoming ? 8 : 0 }}>\n                        <View style={styles.sectionHeader}>\n                            <Text style={[styles.sectionTitle, { color: tokens.foregroundMuted }]}>Completed Today</Text>\n                        </View>\n                        {todaysCompleted.slice(0, 3).map((plan, index) => {\n                            return (\n                                <FocusPlanItem\n                                    key={plan.id}\n                                    interaction={plan}\n                                    friends={friends}\n                                    onDeepen={handleDeepenWeave}\n                                    isCompletedSection={true}\n                                />\n                            );\n                        })}\n                        {todaysCompleted.length > 3 && (\n                            <TouchableOpacity\n                                onPress={() => setShowDetailSheet(true)}\n                                style={{ paddingVertical: 8, paddingHorizontal: 16, flexDirection: 'row', alignItems: 'center' }}\n                            >\n                                <Text style={{\n                                    fontFamily: typography.fonts.sansMedium,\n                                    fontSize: 13,\n                                    color: tokens.primary\n                                }}>\n                                    + {todaysCompleted.length - 3} more completed\n                                </Text>\n                            </TouchableOpacity>\n                        )}\n                    </View>\n                )}\n\n                {isAllClear ? (\n                    <View style={styles.emptyState}>\n                        <CheckCircle2 size={32} color={tokens.success} />\n                        <Text style={[styles.emptyText, {\n                            color: tokens.foregroundMuted,\n                            fontFamily: typography.fonts.sans,\n                            fontSize: typography.scale.body.fontSize,\n                            lineHeight: typography.scale.body.lineHeight\n                        }]}>\n                            You're all caught up\n                        </Text>\n                    </View>\n                ) : null}\n\n                {hasReviews && (\n                    <View style={{ marginTop: (hasUpcoming || hasCompleted) ? 8 : 0 }}>\n                        <View style={styles.sectionHeader}>\n                            <Text style={[styles.sectionTitle, { color: tokens.foregroundMuted }]}>\n                                Pending Reviews\n                            </Text>\n                        </View>\n                        {pendingReviews.map((review, index) => (\n                            <View key={review.id} style={{ paddingHorizontal: 16 }}>\n                                <ListItem\n                                    title={`How was ${review.activity}?`}\n                                    subtitle=\"Rate this weave\"\n                                    showDivider={index < pendingReviews.length - 1}\n                                    trailing={\n                                        <View style={styles.actions}>\n                                            <TouchableOpacity\n                                                onPress={() => handleReviewPlan(review.id)}\n                                                style={[styles.iconBtn, { backgroundColor: tokens.primary + '20' }]}\n                                            >\n                                                <Sparkles size={18} color={tokens.primary} />\n                                            </TouchableOpacity>\n                                        </View>\n                                    }\n                                    onPress={() => handleReviewPlan(review.id)}\n                                />\n                            </View>\n                        ))}\n                    </View>\n                )}\n\n                {(hasUpcoming || hasCompleted || hasReviews) && <View style={{ height: 16 }} />}\n\n                {/* Visual Separator if needed, but spacing might be enough */}\n\n                {hasSuggestions && (\n                    <TouchableOpacity onPress={() => setShowDetailSheet(true)}>\n                        <View style={[styles.summaryRow, (hasUpcoming || hasCompleted || hasReviews || hasUpcomingDates) && { borderTopWidth: 1, borderTopColor: tokens.borderSubtle }]}>\n                            <View style={styles.summaryContent}>\n                                <Sparkles size={16} color={tokens.primaryMuted} style={{ marginRight: 8 }} />\n                                <Text style={[styles.summaryText, {\n                                    color: tokens.foreground,\n                                    fontFamily: typography.fonts.sans,\n                                    fontSize: typography.scale.body.fontSize,\n                                    lineHeight: typography.scale.body.lineHeight\n                                }]}>\n                                    {suggestions.length} suggestion{suggestions.length !== 1 ? 's' : ''}\n                                </Text>\n                            </View>\n                            <ChevronRight size={16} color={tokens.foregroundSubtle} />\n                        </View>\n                    </TouchableOpacity>\n                )}\n\n                {hasUpcomingDates && (\n                    <TouchableOpacity onPress={() => setShowDetailSheet(true)}>\n                        <View style={[styles.summaryRow, (hasUpcoming || hasCompleted || hasReviews || hasSuggestions) && { borderTopWidth: 1, borderTopColor: tokens.borderSubtle }]}>\n                            <View style={styles.summaryContent}>\n                                <Calendar size={16} color={tokens.primaryMuted} style={{ marginRight: 8 }} />\n                                <Text style={[styles.summaryText, {\n                                    color: tokens.foreground,\n                                    fontFamily: typography.fonts.sans,\n                                    fontSize: typography.scale.body.fontSize,\n                                    lineHeight: typography.scale.body.lineHeight\n                                }]}>\n                                    {upcomingDates[0].friend.name}'s {upcomingDates[0].type === 'birthday' ? 'birthday' : 'event'} {upcomingDates[0].daysUntil === 0 ? 'today' : upcomingDates[0].daysUntil === 1 ? 'tomorrow' : `in ${upcomingDates[0].daysUntil} days`}\n                                    {upcomingDates.length > 1 && ` +${upcomingDates.length - 1} more`}\n                                </Text>\n                            </View>\n                            <ChevronRight size={16} color={tokens.foregroundSubtle} />\n                        </View>\n                    </TouchableOpacity>\n                )}\n            </HomeWidgetBase>\n\n            <FocusDetailSheet\n                isVisible={showDetailSheet}\n                onClose={() => setShowDetailSheet(false)}\n                upcomingPlans={todaysUpcoming}\n                completedPlans={todaysCompleted}\n                suggestions={suggestions}\n                upcomingDates={upcomingDates}\n                friends={friends}\n                onConfirmPlan={handleConfirmPlan}\n                onReschedulePlan={handleReschedulePlan}\n                onSuggestionAction={handleSuggestionAction}\n            />\n\n            {wizardFriend && (\n                <PlanWizard\n                    visible={isPlanWizardOpen}\n                    onClose={() => {\n                        setIsPlanWizardOpen(false);\n                        setWizardFriend(null);\n                        setWizardPrefill(null);\n                        setReplaceInteractionId(undefined);\n                    }}\n                    initialFriend={wizardFriend}\n                    prefillData={wizardPrefill}\n                    replaceInteractionId={replaceInteractionId}\n                />\n            )}\n        </>\n    );\n};\n\nconst enhance = withObservables([], () => ({\n    friends: database.get<FriendModel>('friends').query().observe(),\n}));\n\nexport const TodaysFocusWidgetV2 = enhance(TodaysFocusWidgetContent);\n\nconst styles = StyleSheet.create({\n    actions: {\n        flexDirection: 'row',\n    },\n    iconBtn: {\n        width: 32,\n        height: 32,\n        borderRadius: 16,\n        alignItems: 'center',\n        justifyContent: 'center',\n    },\n    summaryRow: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        padding: 16,\n    },\n    summaryContent: {\n        flex: 1,\n        flexDirection: 'row',\n        alignItems: 'center',\n        marginRight: 8,\n    },\n    summaryText: {\n        flex: 1,\n        // Font size handled by typography.scale.body in component\n    },\n    emptyState: {\n        padding: 24,\n        alignItems: 'center',\n        justifyContent: 'center',\n        gap: 12,\n    },\n    emptyText: {\n        // Font size handled by typography.scale.body in component\n    },\n    sectionHeader: {\n        paddingHorizontal: 16,\n        paddingVertical: 8,\n        paddingTop: 16,\n    },\n    sectionTitle: {\n        fontSize: 12,\n        fontFamily: 'Inter_600SemiBold',\n        textTransform: 'uppercase',\n        letterSpacing: 0.5,\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/widgets/YourEnergyWidget.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Card' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":38,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentMonth' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":75,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":75,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo } from 'react';\nimport { View, Text, TouchableOpacity, Dimensions } from 'react-native';\nimport { Moon, BookOpen, Zap } from 'lucide-react-native';\nimport withObservables from '@nozbe/with-observables';\nimport { Q } from '@nozbe/watermelondb';\n\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport { HomeWidgetBase, HomeWidgetConfig } from '../HomeWidgetBase';\nimport { MoonPhaseIllustration } from '@/components/YearInMoons/MoonPhaseIllustration';\nimport { YearInMoonsModal } from '@/components/YearInMoons/YearInMoonsModal';\nimport { WidgetHeader } from '@/components/ui/WidgetHeader';\nimport { Card } from '@/components/ui/Card';\nimport {\n    getYearMoonData,\n    getYearStats,\n    getMonthName,\n    MonthMoonData,\n} from '@/modules/reflection';\nimport SocialBatteryLog from '@/db/models/SocialBatteryLog';\n\nconst WIDGET_CONFIG: HomeWidgetConfig = {\n    id: 'your-energy',\n    type: 'your-energy',\n    title: 'Your Energy',\n    fullWidth: true,\n};\n\ninterface YourEnergyWidgetContentProps {\n    logs: SocialBatteryLog[];\n}\n\nimport { useRouter } from 'expo-router';\n\n// ... imports\n\nconst YourEnergyWidgetContent: React.FC<YourEnergyWidgetContentProps> = ({ logs }) => {\n    const { tokens, typography, colors } = useTheme();\n    const router = useRouter();\n    const [showModal, setShowModal] = useState(false);\n\n    const screenWidth = Dimensions.get('window').width;\n    // Calculate column width to ensure 7 items fit perfectly in the row\n    const columnWidth = Math.floor((screenWidth - 100) / 7);\n    // Moon size is 67% of the column width (reduced size as requested)\n    const moonSize = Math.floor(columnWidth * 0.67);\n\n    // Process data synchronously when logs change\n    const { yearStats } = useMemo(() => {\n        const totalCheckins = logs.length;\n        const avgBattery = logs.length > 0\n            ? (logs.reduce((acc, log) => acc + log.value, 0) / logs.length).toFixed(1)\n            : '0.0';\n\n        return {\n            currentMonthData: null as MonthMoonData | null,\n            yearStats: {\n                totalCheckins,\n                avgBattery,\n                mostCommonLevel: 0,\n                streakDays: 0\n            }\n        };\n    }, [logs]);\n\n    const [asyncData, setAsyncData] = useState<{\n        yearData: MonthMoonData[] | null;\n        stats: any;\n    }>({ yearData: null, stats: null });\n\n    React.useEffect(() => {\n        let mounted = true;\n        const load = async () => {\n            const currentYear = new Date().getFullYear();\n            const currentMonth = new Date().getMonth();\n\n            const [yearData, stats] = await Promise.all([\n                getYearMoonData(currentYear),\n                getYearStats(currentYear),\n            ]);\n\n            if (mounted) {\n                setAsyncData({\n                    yearData: yearData,\n                    stats: stats\n                });\n            }\n        };\n        load();\n        return () => { mounted = false; };\n    }, [logs]);\n\n    if (!asyncData.yearData) {\n        return (\n            <HomeWidgetBase config={WIDGET_CONFIG} isLoading={true}>\n                <View />\n            </HomeWidgetBase>\n        );\n    }\n\n    const currentMonthIndex = new Date().getMonth();\n    const currentMonthData = asyncData.yearData[currentMonthIndex];\n    const currentStats = yearStats;\n    const currentMonthName = getMonthName(currentMonthData.month);\n\n    // BETTER APPROACH: Use the current date to determine the 2-week window\n    const today = new Date();\n    const currentDayOfWeek = today.getDay(); // 0 (Sun) - 6 (Sat)\n\n    // Calculate start date: Today - (Current Day of Week) - 7 days (Previous Sunday)\n    const startDate = new Date(today);\n    startDate.setDate(today.getDate() - currentDayOfWeek - 7);\n    startDate.setHours(0, 0, 0, 0);\n\n    // Generate the 14 days\n    const visibleDays = Array.from({ length: 14 }, (_, i) => {\n        const date = new Date(startDate);\n        date.setDate(startDate.getDate() + i);\n\n        // Find matching log/data if available\n        // We search in the correct month within yearData\n        const monthIndex = date.getMonth();\n        const targetMonthData = asyncData.yearData![monthIndex];\n\n        const existingDay = targetMonthData?.days.find(d =>\n            d.date.getDate() === date.getDate() &&\n            d.date.getFullYear() === date.getFullYear()\n        );\n\n        if (existingDay) return existingDay;\n\n        // Fallback for days not found (e.g. previous year or future)\n        return {\n            date: date,\n            moonPhase: 0,\n            hasCheckin: false,\n            batteryLevel: null,\n            journalEntry: null\n        } as any;\n    });\n\n    return (\n        <>\n            <HomeWidgetBase config={WIDGET_CONFIG} padding=\"none\">\n                <View style={{ padding: 16 }}>\n                    <WidgetHeader\n                        title=\"Your Energy\"\n                        icon={<Zap size={16} color={tokens.primaryMuted} />}\n                        action={{\n                            label: `${currentMonthName} ${currentMonthData.year}`,\n                            onPress: () => setShowModal(true)\n                        }}\n                    />\n\n                    <View style={{ flexDirection: 'row', marginBottom: 12, marginTop: 4 }}>\n                        {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, i) => (\n                            <View key={i} style={{ width: columnWidth, alignItems: 'center' }}>\n                                <Text style={{\n                                    fontSize: typography.scale.labelSmall.fontSize,\n                                    lineHeight: typography.scale.labelSmall.lineHeight,\n                                    color: tokens.foregroundMuted,\n                                    fontFamily: typography.fonts.sans\n                                }}>\n                                    {day}\n                                </Text>\n                            </View>\n                        ))}\n                    </View>\n\n                    <View style={{ flexDirection: 'row', flexWrap: 'wrap', marginBottom: 12 }}>\n                        {visibleDays.map((day) => (\n                            <View\n                                key={day.date.toISOString()}\n                                style={{ width: columnWidth, height: moonSize + 12, alignItems: 'center', justifyContent: 'center', marginBottom: 2 }}\n                            >\n                                <MoonPhaseIllustration\n                                    phase={day.moonPhase}\n                                    size={moonSize}\n                                    hasCheckin={day.hasCheckin}\n                                    color={tokens.primary}\n                                />\n                                <Text\n                                    style={{\n                                        fontSize: typography.scale.labelSmall.fontSize,\n                                        lineHeight: typography.scale.labelSmall.lineHeight,\n                                        marginTop: 1,\n                                        color: day.hasCheckin ? tokens.foreground : tokens.foregroundMuted,\n                                        fontFamily: typography.fonts.sans,\n                                        opacity: day.hasCheckin ? 1 : 0.5,\n                                    }}\n                                >\n                                    {day.date.getDate()}\n                                </Text>\n                            </View>\n                        ))}\n                    </View>\n\n                    {/* Stats & Actions Footer */}\n                    <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingTop: 12, borderTopWidth: 1, borderTopColor: tokens.borderSubtle }}>\n                        <View>\n                            <Text style={{\n                                fontSize: typography.scale.bodySmall.fontSize,\n                                lineHeight: typography.scale.bodySmall.lineHeight,\n                                fontFamily: typography.fonts.serifBold,\n                                color: tokens.foreground\n                            }}>\n                                Avg: {currentStats.avgBattery}/5\n                            </Text>\n                            <Text style={{\n                                fontSize: typography.scale.caption.fontSize,\n                                lineHeight: typography.scale.caption.lineHeight,\n                                fontFamily: typography.fonts.sans,\n                                color: tokens.foregroundMuted\n                            }}>\n                                {currentStats.totalCheckins} check-ins\n                            </Text>\n                        </View>\n\n                        <View style={{ flexDirection: 'row', gap: 6 }}>\n                            <TouchableOpacity\n                                onPress={() => router.push('/journal')}\n                                style={{ flexDirection: 'row', alignItems: 'center', gap: 4, backgroundColor: tokens.primary, paddingHorizontal: 10, paddingVertical: 5, borderRadius: 6 }}\n                            >\n                                <BookOpen size={12} color={tokens.background} />\n                                <Text style={{\n                                    fontSize: typography.scale.label.fontSize,\n                                    lineHeight: typography.scale.label.lineHeight,\n                                    fontFamily: typography.fonts.sansSemiBold,\n                                    color: tokens.background\n                                }}>\n                                    Journal\n                                </Text>\n                            </TouchableOpacity>\n\n                            <TouchableOpacity\n                                onPress={() => setShowModal(true)}\n                                style={{ flexDirection: 'row', alignItems: 'center', gap: 4, backgroundColor: tokens.secondary, paddingHorizontal: 10, paddingVertical: 5, borderRadius: 6 }}\n                            >\n                                <Moon size={12} color={tokens.foreground} />\n                                <Text style={{\n                                    fontSize: typography.scale.label.fontSize,\n                                    lineHeight: typography.scale.label.lineHeight,\n                                    fontFamily: typography.fonts.sansMedium,\n                                    color: tokens.foreground\n                                }}>\n                                    See patterns\n                                </Text>\n                            </TouchableOpacity>\n                        </View>\n                    </View>\n                </View>\n            </HomeWidgetBase>\n\n            <YearInMoonsModal\n                isOpen={showModal}\n                onClose={() => setShowModal(false)}\n            />\n        </>\n    );\n};\n\nconst enhance = withObservables([], () => {\n    const currentYear = new Date().getFullYear();\n    const startOfYear = new Date(currentYear, 0, 1).getTime();\n    const endOfYear = new Date(currentYear, 11, 31).getTime();\n\n    return {\n        logs: database.get<SocialBatteryLog>('social_battery_logs')\n            .query(\n                Q.where('timestamp', Q.gte(startOfYear)),\n                Q.where('timestamp', Q.lte(endOfYear))\n            )\n            .observe(),\n    };\n});\n\nexport const YourEnergyWidget = enhance(YourEnergyWidgetContent);\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/home/widgets/components/FocusPlanItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Text' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FocusPlanItemComponent' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":21,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tokens' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":28,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, TouchableOpacity, StyleSheet, Text } from 'react-native';\nimport { withObservables } from '@nozbe/watermelondb/react';\nimport { format } from 'date-fns';\nimport { Check, Sparkles, Clock } from 'lucide-react-native';\n\nimport Interaction from '@/db/models/Interaction';\nimport FriendModel from '@/db/models/Friend';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { ListItem } from '@/components/ui/ListItem';\nimport { getCategoryLabel } from '@/modules/interactions';\n\ninterface FocusPlanItemProps {\n    interaction: Interaction;\n    friends: FriendModel[];\n    onReschedule?: (plan: Interaction) => void;\n    onDeepen?: (plan: Interaction) => void;\n    isCompletedSection?: boolean;\n}\n\nconst FocusPlanItemComponent: React.FC<FocusPlanItemProps> = ({\n    interaction,\n    friends,\n    onReschedule,\n    onDeepen,\n    isCompletedSection = false,\n}) => {\n    const { tokens } = useTheme();\n\n    // We can't easily get the specific friends for this interaction without an async call or passing them in.\n    // The parent (TodaysFocusWidgetV2) was doing this via a map. \n    // Ideally, we observe interaction.interactionFriends, but that requires another HOC or logic.\n    // For now, let's rely on the parent passing the *relevant* friends, OR we just trust the parent passes the right friends list \n    // and we filter? No, that's inefficient. \n    // Let's assume the parent deals with finding the friend for the nickname for now, \n    // OR we can make this component responsible for fetching its friends?\n    // WatermelonDB 'Best Practice' is to observe the children.\n\n    // Let's stick to the current pattern where parent knows the friends, but wait, \n    // the parent `friends` prop is ALL friends.\n    // We need to know WHICH friends are in this interaction.\n    // We can observe `interaction.interactionFriends`.\n\n    // However, to keep it simple and fix the REACTIVITY of the interaction status/reflection first:\n    // We will assume the parent passes the ALL friends list and we might need to look up.\n    // Actually, `TodaysFocusWidgetV2` did a complex map lookup. \n    // To minimize refactor risk, let's accept `planFriends` as a prop?\n    // But `planFriends` changes if `interactionFriends` changes (rare).\n    // The main issue is `interaction` properties changing.\n\n    // Let's try to just use the props passed from parent for friends to avoid async complexity here,\n    // provided the parent handles that matching. \n    // BUT, the parent's matching was async `useEffect`.\n    // If we want this item to be self-contained, it should probably observe its friends.\n    // Let's Stick to checking `interaction` fields first.\n\n    // We'll filter `friends` (all friends) by finding who is in this interaction? \n    // Identifying friends solely by ID from `interaction_friends` table requires async lookup usually.\n    // Let's rely on parent passing `friendIds` or `planFriends` for now.\n\n    return (\n        <EnhancedPlanItem\n            interaction={interaction}\n            friends={friends}\n            onReschedule={onReschedule}\n            onDeepen={onDeepen}\n            isCompletedSection={isCompletedSection}\n        />\n    );\n};\n\n// Inner component to handle the rendering with observed props\nconst PlanItemView: React.FC<{\n    interaction: Interaction;\n    planFriends: FriendModel[];\n    onReschedule?: (plan: Interaction) => void;\n    onDeepen?: (plan: Interaction) => void;\n    isCompletedSection: boolean;\n}> = ({ interaction, planFriends, onReschedule, onDeepen, isCompletedSection }) => {\n    const { tokens } = useTheme();\n\n    const friendName = planFriends.length > 0 ? planFriends[0].name : '';\n    const subtitle = `${friendName ? `with ${friendName} • ` : ''}${format(new Date(interaction.interactionDate), 'h:mm a')}`;\n    const categoryLabel = getCategoryLabel(interaction.interactionCategory ?? undefined);\n\n    const isReflected = interaction.reflectionJSON || interaction.reflection;\n\n    return (\n        <View style={{ paddingHorizontal: 16 }}>\n            <ListItem\n                title={interaction.title || `${categoryLabel}${friendName ? ` with ${friendName}` : ''}`}\n                subtitle={subtitle}\n                // showDivider handled by parent usually? We'll leave it simple for now or pass index.\n                // Replicating parent behavior:\n                trailing={\n                    <View style={styles.actions}>\n                        {isCompletedSection ? (\n                            <TouchableOpacity\n                                onPress={() => onDeepen?.(interaction)}\n                                style={[styles.iconBtn, {\n                                    backgroundColor: isReflected\n                                        ? tokens.success + '15'\n                                        : tokens.primary + '15'\n                                }]}\n                            >\n                                {isReflected ? (\n                                    <Check size={18} color={tokens.success} />\n                                ) : (\n                                    <Sparkles size={18} color={tokens.primary} />\n                                )}\n                            </TouchableOpacity>\n                        ) : (\n                            <TouchableOpacity\n                                onPress={() => onReschedule?.(interaction)}\n                                style={[styles.iconBtn, { backgroundColor: tokens.primary + '20' }]}\n                            >\n                                <Clock size={18} color={tokens.primary} />\n                            </TouchableOpacity>\n                        )}\n                    </View>\n                }\n            />\n        </View>\n    );\n}\n\nconst styles = StyleSheet.create({\n    actions: {\n        flexDirection: 'row',\n    },\n    iconBtn: {\n        width: 32,\n        height: 32,\n        borderRadius: 16,\n        alignItems: 'center',\n        justifyContent: 'center',\n    },\n});\n\nimport { map } from 'rxjs/operators';\n\n// The magic: Observing the interaction\nconst enhance = withObservables(['interaction'], ({ interaction, friends }: FocusPlanItemProps) => ({\n    interaction: interaction.observe(),\n    planFriends: interaction.interactionFriends.observe().pipe(\n        map((iFriends: any[]) => {\n            return iFriends.map((iF: any) => friends.find(f => f.id === iF.friendId)).filter(Boolean);\n        })\n    ),\n}));\n\nconst EnhancedPlanItem = enhance(PlanItemView);\n\nexport const FocusPlanItem = EnhancedPlanItem;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/interaction-detail-modal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friendName' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":56,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useRef } from 'react';\nimport { View, Text, TouchableOpacity, ScrollView, StyleSheet } from 'react-native';\nimport { Calendar, MapPin, Heart, MessageCircle, Sparkles, Edit3, Trash2, Share2 } from 'lucide-react-native';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { AnimatedBottomSheet, AnimatedBottomSheetRef } from '@/shared/ui/Sheet';\nimport { type Interaction, type MoonPhase, type InteractionCategory } from './types';\nimport { modeIcons } from '@/shared/constants/constants';\nimport { getCategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { STORY_CHIPS } from '@/modules/reflection';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport { shareInteractionAsICS } from '@/modules/interactions';\n\nconst moonPhaseIcons: Record<MoonPhase, string> = {\n  'NewMoon': '🌑',\n  'WaxingCrescent': '🌒',\n  'FirstQuarter': '🌓',\n  'WaxingGibbous': '🌔',\n  'FullMoon': '🌕',\n  'WaningGibbous': '🌖',\n  'LastQuarter': '🌗',\n  'WaningCrescent': '🌘'\n};\n\nconst formatDateTime = (date: Date | string): { date: string; time: string } => {\n  const d = typeof date === 'string' ? new Date(date) : date;\n  return {\n    date: d.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }),\n    time: d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })\n  };\n};\n\ninterface InteractionDetailModalProps {\n  interaction: Interaction | null;\n  isOpen: boolean;\n  onClose: () => void;\n  friendName?: string;\n  onEditReflection?: (interaction: Interaction) => void;\n  onEdit?: (interaction: Interaction) => void;\n  onDelete?: (interactionId: string) => void;\n}\n\nexport function InteractionDetailModal({\n  interaction,\n  isOpen,\n  onClose,\n  friendName,\n  onEditReflection,\n  onEdit,\n  onDelete,\n}: InteractionDetailModalProps) {\n  const insets = useSafeAreaInsets();\n  const { colors, isDarkMode } = useTheme();\n\n  // Ref to control the sheet animation\n  const sheetRef = useRef<AnimatedBottomSheetRef>(null);\n\n  // Cache interaction to keep displaying it during close animation\n  const [cachedInteraction, setCachedInteraction] = useState<Interaction | null>(interaction);\n\n  useEffect(() => {\n    if (interaction) {\n      setCachedInteraction(interaction);\n    }\n  }, [interaction]);\n\n  // Use cached version if current is null (during closing)\n  const activeInteraction = interaction || cachedInteraction;\n\n  // Track pending actions for after close animation\n  const pendingActionRef = useRef<'edit' | 'delete' | 'editReflection' | null>(null);\n\n  const [participants, setParticipants] = useState<FriendModel[]>([]);\n\n  // Fetch all participants for this interaction\n  useEffect(() => {\n    if (!activeInteraction) {\n      setParticipants([]);\n      return;\n    }\n\n    const fetchParticipants = async () => {\n      try {\n        // Get join records for this interaction\n        const joinRecords = await database\n          .get('interaction_friends')\n          .query(Q.where('interaction_id', activeInteraction.id))\n          .fetch();\n\n        if (joinRecords.length === 0) {\n          setParticipants([]);\n          return;\n        }\n\n        // Get friend IDs from join records\n        const friendIds = joinRecords.map((jr: any) => jr.friendId);\n\n        // Fetch all friend models\n        const friends = await database\n          .get<FriendModel>('friends')\n          .query(Q.where('id', Q.oneOf(friendIds)))\n          .fetch();\n\n        setParticipants(friends);\n      } catch (error) {\n        console.error('Error fetching participants:', error);\n        setParticipants([]);\n      }\n    };\n\n    fetchParticipants();\n  }, [activeInteraction]);\n\n  if (!activeInteraction) return null;\n\n  const { date, time } = formatDateTime(activeInteraction.interactionDate);\n  const moonIcon = activeInteraction.vibe ? moonPhaseIcons[activeInteraction.vibe as MoonPhase] : null;\n  const isPast = new Date(activeInteraction.interactionDate) < new Date();\n  const isPlanned = activeInteraction.status === 'planned' || activeInteraction.status === 'pending_confirm';\n\n  // Handler for sharing the plan\n  const handleShare = async () => {\n    try {\n      // Fetch the full Interaction model from database to pass to share function\n      const interactionModel = await database.get<InteractionModel>('interactions').find(activeInteraction.id);\n      const success = await shareInteractionAsICS(interactionModel);\n      if (!success) {\n        console.warn('Share was cancelled or failed');\n      }\n    } catch (error) {\n      console.error('Error sharing interaction:', error);\n    }\n  };\n\n  // Handle close completion - execute pending action\n  const handleCloseComplete = () => {\n    if (!activeInteraction) return;\n\n    if (pendingActionRef.current === 'edit' && onEdit) {\n      onEdit(activeInteraction);\n    } else if (pendingActionRef.current === 'delete' && onDelete) {\n      onDelete(activeInteraction.id);\n    } else if (pendingActionRef.current === 'editReflection' && onEditReflection) {\n      onEditReflection(activeInteraction);\n    }\n    pendingActionRef.current = null;\n  };\n\n  // Action handlers that set pending action and close via ref to trigger animation\n  const handleEditPress = () => {\n    pendingActionRef.current = 'edit';\n    sheetRef.current?.close();\n  };\n\n  const handleDeletePress = () => {\n    pendingActionRef.current = 'delete';\n    sheetRef.current?.close();\n  };\n\n  const handleEditReflectionPress = () => {\n    pendingActionRef.current = 'editReflection';\n    sheetRef.current?.close();\n  };\n\n  // Get friendly label and icon for category (or fall back to activity)\n  // Check if activity looks like a category ID (has a dash)\n  const isCategory = activeInteraction.activity && activeInteraction.activity.includes('-');\n\n  let displayLabel: string;\n  let displayIcon: string;\n\n  if (isCategory) {\n    const categoryData = getCategoryMetadata(activeInteraction.activity as InteractionCategory);\n    if (categoryData) {\n      displayLabel = categoryData.label;\n      displayIcon = categoryData.icon;\n    } else {\n      // Fallback if category not found\n      displayLabel = activeInteraction.activity || 'Interaction';\n      displayIcon = modeIcons[activeInteraction.mode as keyof typeof modeIcons] || '📅';\n    }\n  } else {\n    // Old format - use mode icon and activity name\n    displayLabel = activeInteraction.activity || 'Interaction';\n    displayIcon = modeIcons[activeInteraction.mode as keyof typeof modeIcons] || '📅';\n  }\n\n  return (\n    <AnimatedBottomSheet\n      ref={sheetRef}\n      visible={isOpen}\n      onClose={onClose}\n      height=\"form\"\n      onCloseComplete={handleCloseComplete}\n    >\n      <View style={styles.header}>\n        <View style={styles.headerTitleContainer}>\n          <Text style={styles.headerIcon}>{displayIcon}</Text>\n          <View>\n            <Text style={[styles.headerTitle, { color: colors.foreground }]}>{displayLabel}</Text>\n            <Text style={[styles.headerSubtitle, { color: colors['muted-foreground'] }]}>\n              {activeInteraction.mode?.replace('-', ' ')} • {activeInteraction.interactionType}\n            </Text>\n          </View>\n        </View>\n\n        {/* Action buttons */}\n        <View style={styles.headerActions}>\n          {isPlanned && (\n            <TouchableOpacity\n              onPress={handleShare}\n              style={styles.actionButton}\n            >\n              <Share2 color={colors.primary} size={20} />\n            </TouchableOpacity>\n          )}\n          {onEdit && (\n            <TouchableOpacity\n              onPress={handleEditPress}\n              style={styles.actionButton}\n            >\n              <Edit3 color={colors.primary} size={20} />\n            </TouchableOpacity>\n          )}\n          {onDelete && (\n            <TouchableOpacity\n              onPress={handleDeletePress}\n              style={styles.actionButton}\n            >\n              <Trash2 color={colors.destructive} size={20} />\n            </TouchableOpacity>\n          )}\n        </View>\n      </View>\n\n      <ScrollView contentContainerStyle={styles.scrollViewContent}>\n        <View style={[styles.statusBadge, activeInteraction.status === 'completed' ? styles.statusCompleted : styles.statusPlanned]}>\n          <Text style={[styles.statusBadgeText, activeInteraction.status === 'completed' ? styles.statusCompletedText : styles.statusPlannedText]}>\n            {activeInteraction.status === 'completed' ? '✓ Completed' : '⏳ Planned'}\n          </Text>\n        </View>\n\n        <InfoRow icon={<Calendar color={colors['muted-foreground']} size={20} />} title={date} subtitle={time} colors={colors} />\n        {participants.length > 0 && (\n          <InfoRow\n            icon={<Heart color={colors['muted-foreground']} size={20} />}\n            title={participants.map(f => f.name).join(', ')}\n            subtitle={participants.length === 1 ? 'With' : `With ${participants.length} friends`}\n            colors={colors}\n          />\n        )}\n        {isPast && moonIcon && <InfoRow icon={<Text style={{ fontSize: 24 }}>{moonIcon}</Text>} title={(activeInteraction.vibe || '').replace(/([A-Z])/g, ' $1').trim()} subtitle=\"Moon phase\" colors={colors} />}\n        {activeInteraction.location && <InfoRow icon={<MapPin color={colors['muted-foreground']} size={20} />} title={activeInteraction.location} subtitle=\"Location\" colors={colors} />}\n\n        {/* Reflection chips display */}\n        {activeInteraction.reflection && (activeInteraction.reflection.chips?.length || activeInteraction.reflection.customNotes) && (\n          <View style={[styles.reflectionSection, { backgroundColor: colors.muted + '80' }]}>\n            <View style={styles.reflectionHeader}>\n              <Sparkles color={colors.primary} size={16} />\n              <Text style={[styles.reflectionHeaderText, { color: colors.foreground }]}>Reflection</Text>\n            </View>\n\n            {/* Story chips */}\n            {activeInteraction.reflection.chips && activeInteraction.reflection.chips.length > 0 && (\n              <View style={styles.reflectionChips}>\n                {activeInteraction.reflection.chips.map((chip, index) => {\n                  const storyChip = STORY_CHIPS.find(s => s.id === chip.chipId);\n                  if (!storyChip) return null;\n\n                  // Build the text with overrides\n                  let text = storyChip.template;\n                  if (storyChip.components) {\n                    Object.entries(storyChip.components).forEach(([componentId, component]) => {\n                      const value = chip.componentOverrides[componentId] || component.original;\n                      text = text.replace(`{${componentId}}`, value);\n                    });\n                  }\n\n                  return (\n                    <View key={index} style={[styles.reflectionChip, { backgroundColor: colors.primary + '20', borderColor: colors.primary + '40' }]}>\n                      <Text style={[styles.reflectionChipText, { color: colors.foreground }]}>{text}</Text>\n                    </View>\n                  );\n                })}\n              </View>\n            )}\n\n            {/* Custom notes */}\n            {activeInteraction.reflection.customNotes && (\n              <Text style={[styles.reflectionCustomNotes, { color: colors.foreground }]}>\n                {activeInteraction.reflection.customNotes}\n              </Text>\n            )}\n          </View>\n        )}\n\n        {activeInteraction.note && <InfoRow icon={<MessageCircle color={colors['muted-foreground']} size={20} />} title={activeInteraction.note} subtitle=\"Notes\" colors={colors} />}\n      </ScrollView>\n\n      {/* Deepen Weave / Edit Reflection Button - Only for past interactions */}\n      {onEditReflection && isPast && (\n        <View style={[styles.footer, { paddingBottom: insets.bottom + 16, borderTopColor: colors.border }]}>\n          <TouchableOpacity\n            style={[styles.deepenButton, { backgroundColor: colors.primary }]}\n            onPress={handleEditReflectionPress}\n          >\n            <Sparkles color={colors['primary-foreground']} size={20} />\n            <Text style={[styles.deepenButtonText, { color: colors['primary-foreground'] }]}>\n              {activeInteraction.reflection?.chips?.length ? 'Edit Reflection' : 'Deepen this weave'}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      )}\n    </AnimatedBottomSheet>\n  );\n}\n\nconst InfoRow = ({ icon, title, subtitle, colors }: { icon: React.ReactNode, title: string, subtitle: string, colors: any }) => (\n  <View style={[styles.infoRow, { backgroundColor: colors.muted + '80' }]}>\n    <View style={{ width: 24, alignItems: 'center' }}>{icon}</View>\n    <View style={{ flex: 1 }}>\n      <Text style={[styles.infoSubtitle, { color: colors['muted-foreground'] }]}>{subtitle}</Text>\n      <Text style={[styles.infoTitle, { color: colors.foreground }]}>{title}</Text>\n    </View>\n  </View>\n);\n\nconst styles = StyleSheet.create({\n  backdrop: {\n    flex: 1,\n    justifyContent: 'flex-end',\n  },\n  modalContainer: {\n    borderTopLeftRadius: 24,\n    borderTopRightRadius: 24,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: -10 },\n    shadowOpacity: 0.1,\n    shadowRadius: 10,\n    elevation: 20,\n    height: '75%',\n  },\n  handleBarContainer: {\n    padding: 16,\n    alignItems: 'center',\n  },\n  handleBar: {\n    width: 48,\n    height: 6,\n    borderRadius: 3,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-start',\n    paddingHorizontal: 24,\n    paddingTop: 8,\n  },\n  headerTitleContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 12,\n    marginBottom: 8,\n  },\n  headerActions: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 4,\n  },\n  actionButton: {\n    padding: 8,\n  },\n  headerIcon: {\n    fontSize: 32,\n  },\n  headerTitle: {\n    fontSize: 24,\n    fontWeight: '600',\n  },\n  headerSubtitle: {\n    fontSize: 14,\n    textTransform: 'capitalize',\n  },\n  scrollViewContent: {\n    padding: 24,\n    gap: 24,\n  },\n  statusBadge: {\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    borderRadius: 999,\n    alignSelf: 'flex-start',\n  },\n  statusCompleted: {\n    backgroundColor: '#dcfce7',\n  },\n  statusPlanned: {\n    backgroundColor: '#fef9c3',\n  },\n  statusBadgeText: {\n    fontSize: 12,\n    fontWeight: '500',\n  },\n  statusCompletedText: {\n    color: '#166534',\n  },\n  statusPlannedText: {\n    color: '#854d0e',\n  },\n  infoRow: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    gap: 12,\n    padding: 16,\n    borderRadius: 16,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.05,\n    shadowRadius: 8,\n    elevation: 4,\n  },\n  infoSubtitle: {\n    fontSize: 14,\n  },\n  infoTitle: {\n    fontWeight: '500',\n  },\n  reflectionSection: {\n    padding: 16,\n    borderRadius: 16,\n    gap: 12,\n  },\n  reflectionHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n    marginBottom: 4,\n  },\n  reflectionHeaderText: {\n    fontSize: 14,\n    fontWeight: '600',\n  },\n  reflectionChips: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: 8,\n  },\n  reflectionChip: {\n    borderWidth: 1,\n    borderRadius: 16,\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n  },\n  reflectionChipText: {\n    fontSize: 13,\n    fontWeight: '500',\n  },\n  reflectionCustomNotes: {\n    fontSize: 14,\n    lineHeight: 20,\n    fontStyle: 'italic',\n  },\n  footer: {\n    paddingHorizontal: 24,\n    paddingTop: 16,\n    borderTopWidth: 1,\n  },\n  deepenButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: 8,\n    padding: 16,\n    borderRadius: 12,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.1,\n    shadowRadius: 12,\n    elevation: 8,\n  },\n  deepenButtonText: {\n    fontSize: 16,\n    fontWeight: '600',\n  },\n});","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/onboarding/AnimatedThoughtBubbles.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/onboarding/ArchetypeImpactDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/onboarding/ContactPickerGrid.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityIndicator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":156,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":156,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { View, Text, TouchableOpacity, Image, TextInput, ActivityIndicator } from 'react-native';\nimport { WeaveLoading } from '@/shared/components/WeaveLoading';\nimport * as Contacts from 'expo-contacts';\nimport { CheckCircle2, Users, Plus, Search, X } from 'lucide-react-native';\nimport Animated, { FadeIn } from 'react-native-reanimated';\nimport { FlashList } from '@shopify/flash-list';\nimport { normalizeContactImageUri } from '@/modules/relationships';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\n// Consts for layout to prevent jumping\nconst NUM_COLUMNS = 3;\nconst ITEM_HEIGHT = 150; // Increased height to prevent clipping\n\ninterface ContactPickerGridProps {\n  maxSelection: number;\n  onSelectionChange: (selectedContacts: Contacts.Contact[]) => void;\n  onAddManually?: () => void;\n  title?: string;\n  subtitle?: string;\n  hideHeader?: boolean;\n  showAddManually?: boolean;\n  selectedIds?: string[]; // Allow parent to control selection if needed, though mostly internal\n  externalSearchQuery?: string;\n}\n\nconst ContactItem = React.memo(({\n  item,\n  isSelected,\n  onSelect,\n  colors\n}: {\n  item: Contacts.Contact;\n  isSelected: boolean;\n  onSelect: () => void;\n  colors: any;\n}) => {\n  const [imageError, setImageError] = useState(false);\n\n  // ... (ContactItem implementation remains the same)\n  const getInitials = (name: string) => {\n    if (!name) return '?';\n    const names = name.split(' ');\n    const firstName = names[0] || '';\n    const lastName = names.length > 1 ? names[names.length - 1] : '';\n    return `${firstName.charAt(0)}${lastName.charAt(0)}`.toUpperCase();\n  };\n\n  const getAvatarColor = (name: string) => {\n    const avatarColors = [\n      '#d1fae5', // emerald-100\n      '#fef3c7', // amber-100\n      '#ffe4e6', // rose-100\n      '#e0e7ff', // indigo-100\n      '#ccfbf1', // teal-100\n    ];\n    const textColors = [\n      '#047857', // emerald-700\n      '#b45309', // amber-700\n      '#be123c', // rose-700\n      '#4338ca', // indigo-700\n      '#0f766e', // teal-700\n    ];\n    const hash = name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    const index = hash % avatarColors.length;\n    return { bg: avatarColors[index], text: textColors[index] };\n  };\n\n  const colorStyle = getAvatarColor(item.name || '');\n  const shouldShowImage = item.imageAvailable && item.image && !imageError;\n\n  return (\n    <TouchableOpacity\n      onPress={onSelect}\n      className=\"items-center p-2 w-full\"\n      style={{ height: ITEM_HEIGHT }}\n      activeOpacity={0.7}\n    >\n      <View className=\"relative\">\n        <View\n          style={{\n            width: 80,\n            height: 80,\n            borderRadius: 40,\n            backgroundColor: isSelected ? colors.primary : colorStyle.bg,\n            borderWidth: isSelected ? 4 : 0,\n            borderColor: colors.primary,\n            justifyContent: 'center',\n            alignItems: 'center',\n            overflow: 'hidden'\n          }}\n        >\n          {/* Always render initials as the base layer */}\n          <View className=\"absolute inset-0 justify-center items-center w-full h-full\">\n            <Text\n              style={{\n                fontSize: 24,\n                fontWeight: '600',\n                color: isSelected ? 'white' : colorStyle.text\n              }}\n            >\n              {getInitials(item.name)}\n            </Text>\n          </View>\n\n          {/* Render image on top if available. It will cover initials when loaded. */}\n          {shouldShowImage && (\n            <Image\n              source={{ uri: normalizeContactImageUri(item.image?.uri || '') }}\n              className=\"w-full h-full\"\n              resizeMode=\"cover\"\n              onError={() => setImageError(true)}\n              fadeDuration={200}\n            />\n          )}\n        </View>\n\n        {isSelected && (\n          <Animated.View\n            entering={FadeIn.duration(200)}\n            className=\"absolute -top-1 -right-1 rounded-full p-1\"\n            style={{ backgroundColor: colors.primary }}\n          >\n            <CheckCircle2 color=\"white\" size={20} strokeWidth={3} />\n          </Animated.View>\n        )}\n      </View>\n\n      <Text\n        style={{\n          marginTop: 8,\n          textAlign: 'center',\n          fontSize: 14,\n          fontWeight: '500',\n          color: colors.foreground\n        }}\n        numberOfLines={2}\n      >\n        {item.name}\n      </Text>\n    </TouchableOpacity>\n  );\n});\n\nexport function ContactPickerGrid({\n  maxSelection,\n  onSelectionChange,\n  onAddManually,\n  title = \"Who's in your Inner Circle?\",\n  subtitle = \"Select up to 3 people you trust the most.\",\n  hideHeader = false,\n  showAddManually = true,\n  selectedIds: propSelectedIds,\n  externalSearchQuery,\n}: ContactPickerGridProps) {\n  const { colors, isDarkMode } = useTheme();\n  const [allContacts, setAllContacts] = useState<Contacts.Contact[]>([]);\n  const [internalSelectedIds, setInternalSelectedIds] = useState<string[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [permissionDenied, setPermissionDenied] = useState(false);\n  const [internalSearchQuery, setInternalSearchQuery] = useState('');\n\n  // Use effective search query (external has priority if passed, but usually intended for when header is hidden)\n  // If externalSearchQuery is strictly undefined, use internal. If it is a string (even empty), use it.\n  const searchQuery = externalSearchQuery !== undefined ? externalSearchQuery : internalSearchQuery;\n\n  // Use either controlled or internal state\n  const selectedContactIds = propSelectedIds || internalSelectedIds;\n\n  useEffect(() => {\n    (async () => {\n      let { status } = await Contacts.getPermissionsAsync();\n\n      if (status !== 'granted') {\n        const result = await Contacts.requestPermissionsAsync();\n        status = result.status;\n      }\n\n      if (status !== 'granted') {\n        setPermissionDenied(true);\n        setLoading(false);\n        return;\n      }\n\n      const { data } = await Contacts.getContactsAsync({\n        fields: [\n          Contacts.Fields.FirstName,\n          Contacts.Fields.LastName,\n          Contacts.Fields.Image\n        ],\n      });\n\n      if (data.length > 0) {\n        // Filter out contacts without names or \"Unknown\"\n        const validContacts = data.filter(c => {\n          const name = c.name?.trim();\n          return name && name.toLowerCase() !== 'unknown' && name.toLowerCase() !== 'null';\n        });\n\n        const sorted = validContacts.sort((a, b) =>\n          (a.name || '').localeCompare(b.name || '')\n        );\n        setAllContacts(sorted);\n      }\n\n      setLoading(false);\n    })();\n  }, []);\n\n  // Only call onSelectionChange when internal state changes (if not controlled)\n  useEffect(() => {\n    if (!propSelectedIds) {\n      const selected = allContacts.filter(c => c.id && internalSelectedIds.includes(c.id));\n      onSelectionChange(selected);\n    }\n  }, [internalSelectedIds, allContacts, onSelectionChange, propSelectedIds]);\n\n  // If controlled, we might need to notify parent when we *would* change selection\n  // But usually onSelectionChange is the callback for *actions*\n\n  const filteredContacts = useMemo(() => {\n    if (!searchQuery.trim()) return allContacts;\n    return allContacts.filter(c =>\n      (c.name || '').toLowerCase().includes(searchQuery.toLowerCase())\n    );\n  }, [allContacts, searchQuery]);\n\n  const handleSelectContact = useCallback((contactId: string) => {\n    // If controlled, we just calculate the new selection and call the callback\n    // If uncontrolled, we update local state\n\n    let newSelection: string[];\n    const currentSelection = propSelectedIds || internalSelectedIds;\n\n    if (currentSelection.includes(contactId)) {\n      newSelection = currentSelection.filter(id => id !== contactId);\n    } else {\n      if (maxSelection === 1) {\n        newSelection = [contactId];\n      } else if (currentSelection.length < maxSelection) {\n        newSelection = [...currentSelection, contactId];\n      } else {\n        newSelection = currentSelection; // Max reached\n      }\n    }\n\n    if (!propSelectedIds) {\n      setInternalSelectedIds(newSelection);\n    } else {\n      // If controlled, we find the contact objects and pass them up\n      // The parent is responsible for updating the `selectedIds` prop\n      const selectedContacts = allContacts.filter(c => c.id && newSelection.includes(c.id));\n      onSelectionChange(selectedContacts);\n    }\n  }, [propSelectedIds, internalSelectedIds, maxSelection, allContacts, onSelectionChange]);\n\n  const handleAddManually = () => {\n    onAddManually?.();\n  };\n\n  const renderItem = useCallback(({ item }: { item: Contacts.Contact }) => (\n    <ContactItem\n      item={item}\n      isSelected={!!item.id && selectedContactIds.includes(item.id)}\n      onSelect={() => item.id && handleSelectContact(item.id)}\n      colors={colors}\n    />\n  ), [selectedContactIds, handleSelectContact, colors]);\n\n  if (loading) {\n    return (\n      <View className=\"flex-1 justify-center items-center py-20\">\n        <WeaveLoading size={48} color={colors.primary} />\n        <Text style={{ color: colors['muted-foreground'], marginTop: 16 }}>Loading your contacts...</Text>\n      </View>\n    );\n  }\n\n  if (permissionDenied) {\n    return (\n      <View className=\"flex-1 justify-center items-center py-20 px-6\">\n        <Users size={48} color={colors['muted-foreground']} />\n        <Text style={{ fontSize: 20, fontWeight: '600', color: colors.foreground, marginTop: 16, textAlign: 'center' }}>\n          Contacts Access Needed\n        </Text>\n        <Text style={{ fontSize: 16, color: colors['muted-foreground'], marginTop: 8, textAlign: 'center' }}>\n          Weave needs access to your contacts to help you select your friends.\n          Please enable it in Settings.\n        </Text>\n      </View>\n    );\n  }\n\n  return (\n    <Animated.View className=\"flex-1\" entering={FadeIn.duration(300)}>\n      {!hideHeader && (\n        <View style={{ paddingTop: 16, paddingBottom: 16, paddingHorizontal: 24, backgroundColor: colors.background, zIndex: 10 }}>\n          <Text style={{ fontSize: 24, fontWeight: 'bold', textAlign: 'center', color: colors.foreground, marginBottom: 4 }}>{title}</Text>\n          <Text style={{ fontSize: 16, color: colors['muted-foreground'], textAlign: 'center', marginBottom: 16 }}>{subtitle}</Text>\n\n          {/* Search Bar */}\n          <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: colors.card, borderRadius: 12, paddingHorizontal: 16, paddingVertical: 10 }}>\n            <Search size={20} color={colors['muted-foreground']} />\n            <TextInput\n              style={{ flex: 1, marginLeft: 12, fontSize: 16, color: colors.foreground, paddingVertical: 4 }}\n              placeholder=\"Search contacts...\"\n              placeholderTextColor={colors['muted-foreground']}\n              value={searchQuery}\n              onChangeText={setInternalSearchQuery}\n              autoCorrect={false}\n            />\n            {searchQuery.length > 0 && (\n              <TouchableOpacity onPress={() => setInternalSearchQuery('')}>\n                <X size={18} color={colors['muted-foreground']} />\n              </TouchableOpacity>\n            )}\n          </View>\n\n          {showAddManually && (\n            <TouchableOpacity onPress={handleAddManually} style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center', padding: 12, marginTop: 12, borderRadius: 8, borderWidth: 1, borderColor: colors.border, backgroundColor: colors.muted }}>\n              <Plus size={16} color={colors.foreground} />\n              <Text style={{ color: colors.foreground, fontWeight: '500', marginLeft: 8 }}>Add Manually</Text>\n            </TouchableOpacity>\n          )}\n        </View>\n      )}\n\n      {/* Embedded Search (if header hidden but we still want search? Or assume parent handles it?)\n          For now, if header is hidden, we assume parent handles search or we don't have it?\n          Wait, ContactPickerGrid usually encapsulates search.\n          If I hide header, I might still want search.\n          Let's make search part of the list header if hideHeader is true?\n          Or just expose a prop to enforce search visibility.\n          Actually, for batch-add, we want the search to be sticky at top.\n          Let's assume if hideHeader is true, the parent creates the UI around it, including search.\n          BUT ContactPickerGrid manages the filtering.\n          So we need to expose `setSearchQuery` or accept `searchQuery` as prop if we want parent to control it.\n          Let's stick to the current plan: simple refactor.\n          If hideHeader is true, we probably still want the search bar?\n          The original batch-add had search bar.\n          Let's add a `searchable` prop?\n          Actually, let's keep it simple: If hideHeader is true, we ONLY render the list.\n          But then how do we search?\n          The `batch-add` screen has a search bar. It needs to pass the query down.\n          So let's add `searchQuery` prop (optional).\n      */}\n\n      {!hideHeader && (\n        <View style={{ paddingHorizontal: 16, paddingVertical: 8, backgroundColor: colors.primary + '10', borderTopWidth: 1, borderBottomWidth: 1, borderColor: colors.primary + '20' }}>\n          <Text style={{ fontSize: 14, color: colors.primary, textAlign: 'center', fontWeight: '500' }}>\n            {selectedContactIds.length} / {maxSelection > 100 ? '∞' : maxSelection} selected\n          </Text>\n        </View>\n      )}\n\n      {/* If header is hidden, we expect the parent might want to inject a search bar,\n          but passing query down is cleaner.\n          Let's just duplicate the search bar inside the list header if hideHeader is false.\n          Wait, I'll update the component to accept an optional `externalSearchQuery` prop.\n      */}\n\n      {filteredContacts.length === 0 ? (\n        <View className=\"flex-1 justify-center items-center py-20 px-6\">\n          <Users size={48} color={colors['muted-foreground']} />\n          <Text style={{ fontSize: 20, fontWeight: '600', color: colors.foreground, marginTop: 16, textAlign: 'center' }}>\n            {searchQuery ? 'No matching contacts' : 'No Contacts Found'}\n          </Text>\n          <Text style={{ fontSize: 16, color: colors['muted-foreground'], marginTop: 8, textAlign: 'center' }}>\n            {searchQuery ? 'Try a different search term.' : 'Add some contacts to your device first.'}\n          </Text>\n        </View>\n      ) : (\n        <FlashList\n          data={filteredContacts}\n          numColumns={NUM_COLUMNS}\n          keyExtractor={(item, index) => item.id || `contact-${index}-${item.name}`}\n          renderItem={renderItem}\n          contentContainerStyle={{ paddingBottom: 90, paddingTop: 10 }}\n          estimatedItemSize={ITEM_HEIGHT}\n        />\n      )}\n    </Animated.View>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings-modal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TouchableOpacity' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport { Battery, Trophy, BookOpen, Users } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { StandardBottomSheet } from '@/shared/ui/Sheet';\n\n// Components\nimport { SettingsItem } from './settings/SettingsItem';\nimport { AppearanceSettings } from './settings/AppearanceSettings';\nimport { GeneralSettings } from './settings/GeneralSettings';\nimport { CalendarSettings } from './settings/CalendarSettings';\nimport { TestingSettings } from './settings/TestingSettings';\nimport { DataSettings } from './settings/DataSettings';\nimport { NotificationSettings } from './settings/NotificationSettings';\n\n// Modals\nimport TrophyCabinetModal from './TrophyCabinetModal';\nimport { ArchetypeLibrary } from './ArchetypeLibrary';\nimport { FriendManagementModal } from './FriendManagementModal';\nimport { GroupListModal } from './groups/GroupListModal';\n\ninterface SettingsModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onOpenBatteryCheckIn?: () => void;\n}\n\nexport function SettingsModal({\n  isOpen,\n  onClose,\n  onOpenBatteryCheckIn,\n}: SettingsModalProps) {\n  const { colors } = useTheme();\n  const [showTrophyCabinet, setShowTrophyCabinet] = useState(false);\n  const [showArchetypeLibrary, setShowArchetypeLibrary] = useState(false);\n  const [showFriendManagement, setShowFriendManagement] = useState(false);\n  const [showGroupList, setShowGroupList] = useState(false);\n\n  if (!isOpen) return null;\n\n  return (\n    <StandardBottomSheet\n      visible={isOpen}\n      onClose={onClose}\n      height=\"full\"\n      scrollable\n      title=\"Settings\"\n    >\n      <View style={{ paddingBottom: 40 }}>\n        <View className=\"gap-4\">\n\n          {/* Appearance (Theme) */}\n          <AppearanceSettings />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          {/* Vital Features (Archetype, Friends, Trophy, Battery) */}\n          <SettingsItem\n            icon={BookOpen}\n            title=\"Archetype Library\"\n            subtitle=\"Explore connection archetypes\"\n            onPress={() => setShowArchetypeLibrary(true)}\n          />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          <SettingsItem\n            icon={Users}\n            title=\"Manage Friends\"\n            subtitle=\"Batch remove friends\"\n            onPress={() => setShowFriendManagement(true)}\n          />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          <SettingsItem\n            icon={Users}\n            title=\"Manage Groups\"\n            subtitle=\"Create and edit friend groups\"\n            onPress={() => setShowGroupList(true)}\n          />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          <SettingsItem\n            icon={Trophy}\n            title=\"Trophy Cabinet\"\n            subtitle=\"View your achievements\"\n            onPress={() => setShowTrophyCabinet(true)}\n          />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          {/* Social Battery Check-in */}\n          {onOpenBatteryCheckIn && (\n            <>\n              <SettingsItem\n                icon={Battery}\n                title=\"Social Battery Check-in\"\n                subtitle=\"Update your social energy\"\n                onPress={() => {\n                  onClose();\n                  setTimeout(() => onOpenBatteryCheckIn(), 300);\n                }}\n              />\n              <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n            </>\n          )}\n\n          {/* Testing / Debug Loop */}\n          <TestingSettings onClose={onClose} />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          {/* General (Groups, Feedback, Smart Defaults, Legal) */}\n          <GeneralSettings\n            onClose={onClose}\n          />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          {/* Calendar */}\n          <CalendarSettings />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          {/* Data (Backup, Restore, Export, Import) */}\n          <DataSettings onClose={onClose} />\n\n          <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n          {/* Notifications (Battery, Reflection, Digest, etc) */}\n          <NotificationSettings />\n\n        </View>\n      </View>\n\n      <View className=\"mt-6 pt-4 border-t pb-8\" style={{ borderColor: colors.border }}>\n        <Text className=\"text-center text-xs\" style={{ color: colors['muted-foreground'] }}>\n          Weave • Social Relationship Management\n        </Text>\n      </View>\n\n      {/* Modals */}\n      <TrophyCabinetModal\n        visible={showTrophyCabinet}\n        onClose={() => setShowTrophyCabinet(false)}\n      />\n\n      <ArchetypeLibrary\n        isVisible={showArchetypeLibrary}\n        onClose={() => setShowArchetypeLibrary(false)}\n      />\n\n      <FriendManagementModal\n        visible={showFriendManagement}\n        onClose={() => setShowFriendManagement(false)}\n      />\n\n      <GroupListModal\n        visible={showGroupList}\n        onClose={() => setShowGroupList(false)}\n      />\n\n    </StandardBottomSheet>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/AppearanceSettings.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":10,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { useUIStore } from '@/stores/uiStore';\nimport { Moon, Sun } from 'lucide-react-native';\nimport { ModernSwitch } from '@/components/ui/ModernSwitch';\nimport { SettingsItem } from './SettingsItem';\n\nexport const AppearanceSettings = () => {\n    const { colors } = useTheme();\n    const { isDarkMode, toggleDarkMode } = useUIStore();\n\n    return (\n        <SettingsItem\n            icon={isDarkMode ? Moon : Sun}\n            title={isDarkMode ? \"Dark Theme\" : \"Light Theme\"}\n            subtitle={isDarkMode ? \"Mystic arcane theme\" : \"Warm cream theme\"}\n            rightElement={\n                <ModernSwitch\n                    value={isDarkMode}\n                    onValueChange={toggleDarkMode}\n                />\n            }\n        />\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/CalendarSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/DataSettings.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SettingsItem' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity, Alert } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Database, Upload, Download, RefreshCw } from 'lucide-react-native';\nimport { ModernSwitch } from '@/components/ui/ModernSwitch';\nimport { SettingsItem } from './SettingsItem';\nimport { AutoBackupService } from '@/modules/backup';\nimport { DataWipeService } from '@/modules/data-management';\nimport {\n    exportAndShareData,\n    getExportStats,\n    getImportPreview,\n    importData,\n} from '@/modules/auth';\nimport * as DocumentPicker from 'expo-document-picker';\nimport * as FileSystem from 'expo-file-system';\n\ninterface DataSettingsProps {\n    onClose: () => void;\n}\n\nexport const DataSettings: React.FC<DataSettingsProps> = ({ onClose }) => {\n    const { colors } = useTheme();\n\n    const [autoBackupEnabled, setAutoBackupEnabled] = useState(false);\n    const [lastBackupTime, setLastBackupTime] = useState<string | null>(null);\n\n    useEffect(() => {\n        loadAutoBackupSettings();\n    }, []);\n\n    const loadAutoBackupSettings = async () => {\n        const enabled = await AutoBackupService.isEnabled();\n        const lastTime = await AutoBackupService.getLastBackupTime();\n        setAutoBackupEnabled(enabled);\n        setLastBackupTime(lastTime);\n    };\n\n    const handleToggleAutoBackup = async (enabled: boolean) => {\n        if (enabled) {\n            // Verify iCloud access before enabling\n            const initialized = await AutoBackupService.init();\n            if (!initialized) {\n                Alert.alert(\n                    'iCloud Access Failed',\n                    'Could not access iCloud Drive. Please ensure you are signed in to iCloud and have iCloud Drive enabled.',\n                    [{ text: 'OK' }]\n                );\n                return;\n            }\n        }\n\n        setAutoBackupEnabled(enabled);\n        await AutoBackupService.setEnabled(enabled);\n        if (enabled) {\n            // Try to backup immediately if enabling\n            AutoBackupService.checkAndBackup().then(() => {\n                loadAutoBackupSettings();\n            });\n        }\n    };\n\n    const handleExportData = async () => {\n        try {\n            const stats = await getExportStats();\n            Alert.alert(\n                'Backup Data',\n                `Create a backup of your data to save to iCloud Drive or another safe location.\\n\\nFriends: ${stats.totalFriends}\\nInteractions: ${stats.totalInteractions}\\nEstimated size: ${stats.estimatedSizeKB}KB`,\n                [\n                    { text: 'Cancel', style: 'cancel' },\n                    {\n                        text: 'Create Backup',\n                        onPress: async () => {\n                            try {\n                                await exportAndShareData();\n                            } catch (error) {\n                                console.error('Export failed:', error);\n                            }\n                        },\n                    },\n                ]\n            );\n        } catch (error) {\n            console.error('Failed to prepare export:', error);\n            Alert.alert('Error', 'Failed to prepare data export.');\n        }\n    };\n\n    const handleImportData = async () => {\n        try {\n            // Pick a document\n            const result = await DocumentPicker.getDocumentAsync({\n                type: 'application/json',\n                copyToCacheDirectory: true,\n            });\n\n            if (result.canceled) {\n                return;\n            }\n\n            const fileUri = result.assets[0].uri;\n\n            // Read the file\n            const fileContent = await FileSystem.readAsStringAsync(fileUri);\n\n            // Get preview\n            const preview = getImportPreview(fileContent);\n\n            if (!preview.valid) {\n                Alert.alert('Invalid File', preview.error || 'The selected file is not a valid Weave export.');\n                return;\n            }\n\n            // Show confirmation with preview\n            Alert.alert(\n                'Restore Data',\n                `This will restore your data from a backup file:\\n\\n` +\n                `Backup Date: ${new Date(preview.preview!.exportDate).toLocaleDateString()}\\n` +\n                `Friends: ${preview.preview!.totalFriends}\\n` +\n                `Interactions: ${preview.preview!.totalInteractions}\\n\\n` +\n                `⚠️ WARNING: This will DELETE all your current data and replace it with the backup.`,\n                [\n                    { text: 'Cancel', style: 'cancel' },\n                    {\n                        text: 'Restore',\n                        style: 'destructive',\n                        onPress: async () => {\n                            try {\n                                Alert.alert('Importing...', 'Please wait while we restore your data.');\n\n                                const result = await importData(fileContent, true);\n\n                                if (result.success) {\n                                    Alert.alert(\n                                        'Import Successful!',\n                                        `Your data has been restored:\\n\\n` +\n                                        `${result.friendsImported} friends imported\\n` +\n                                        `${result.interactionsImported} interactions imported\\n\\n` +\n                                        `Please restart the app to see your restored data.`,\n                                        [\n                                            {\n                                                text: 'OK',\n                                                onPress: () => {\n                                                    onClose();\n                                                },\n                                            },\n                                        ]\n                                    );\n                                } else {\n                                    Alert.alert(\n                                        'Import Failed',\n                                        `Failed to import data:\\n\\n${result.errors.join('\\n')}`,\n                                        [{ text: 'OK' }]\n                                    );\n                                }\n                            } catch (error) {\n                                console.error('Import failed:', error);\n                                Alert.alert('Import Failed', 'An error occurred while importing data.');\n                            }\n                        },\n                    },\n                ]\n            );\n        } catch (error) {\n            console.error('Failed to import data:', error);\n            Alert.alert('Error', 'Failed to read the selected file.');\n        }\n    };\n\n    const handleResetDatabase = () => {\n        Alert.alert(\n            \"Erase All Data\",\n            \"Are you sure? This will delete EVERYTHING:\\n\\n• All friends and interactions\\n• All settings and preferences\\n• All cloud backups\\n• Your account session\\n\\nThis action cannot be undone.\",\n            [\n                { text: \"Cancel\", style: \"cancel\" },\n                {\n                    text: \"Erase Everything\",\n                    style: \"destructive\",\n                    onPress: async () => {\n                        try {\n                            onClose();\n                            setTimeout(async () => {\n                                await DataWipeService.wipeAllData();\n                            }, 500);\n                        } catch (error) {\n                            console.error('Failed to erase data:', error);\n                            Alert.alert('Error', 'Failed to erase data.');\n                        }\n                    },\n                },\n            ]\n        );\n    };\n\n    return (\n        <View className=\"gap-4\">\n            <View className=\"flex-row items-center justify-between\">\n                <View className=\"flex-row items-center gap-3\">\n                    <View className=\"w-10 h-10 rounded-lg items-center justify-center\" style={{ backgroundColor: colors.muted }}>\n                        <Database color={colors.foreground} size={20} />\n                    </View>\n                    <View>\n                        <Text className=\"text-base font-inter-medium\" style={{ color: colors.foreground }}>Backup & Restore</Text>\n                        <Text className=\"text-sm font-inter-regular\" style={{ color: colors['muted-foreground'] }}>Save data to iCloud Drive</Text>\n                    </View>\n                </View>\n                <View className=\"flex-row gap-2\">\n                    <TouchableOpacity\n                        onPress={handleExportData}\n                        className=\"px-3 py-2 rounded-md\"\n                        style={{ backgroundColor: colors.muted }}\n                    >\n                        <Upload size={18} color={colors.foreground} />\n                    </TouchableOpacity>\n                    <TouchableOpacity\n                        onPress={handleImportData}\n                        className=\"px-3 py-2 rounded-md\"\n                        style={{ backgroundColor: colors.muted }}\n                    >\n                        <Download size={18} color={colors.foreground} />\n                    </TouchableOpacity>\n                </View>\n            </View>\n\n            <View className=\"flex-row items-center justify-between pl-13 mt-3\">\n                <View className=\"flex-1\">\n                    <Text className=\"text-sm font-inter-medium\" style={{ color: colors.foreground }}>Auto-Backup to iCloud</Text>\n                    <Text className=\"text-xs font-inter-regular\" style={{ color: colors['muted-foreground'] }}>\n                        Automatically backup to \"Weave/Backups\" daily\n                        {lastBackupTime && `\\nLast: ${new Date(lastBackupTime).toLocaleDateString()} ${new Date(lastBackupTime).toLocaleTimeString()}`}\n                    </Text>\n                </View>\n                <ModernSwitch\n                    value={autoBackupEnabled}\n                    onValueChange={handleToggleAutoBackup}\n                />\n            </View>\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <View className=\"flex-row items-center justify-between\">\n                <View className=\"flex-row items-center gap-3\">\n                    <View className=\"w-10 h-10 rounded-lg items-center justify-center\" style={{ backgroundColor: colors.destructive + '1A' }}>\n                        <RefreshCw color={colors.destructive} size={20} />\n                    </View>\n                    <View>\n                        <Text className=\"text-base font-inter-medium\" style={{ color: colors.foreground }}>Reset Database</Text>\n                        <Text className=\"text-sm font-inter-regular\" style={{ color: colors['muted-foreground'] }}>Clear all data and start fresh</Text>\n                    </View>\n                </View>\n                <TouchableOpacity onPress={handleResetDatabase} className=\"py-2 px-4 rounded-lg border\" style={{ borderColor: colors.destructive + '33' }}>\n                    <Text className=\"font-inter-medium\" style={{ color: colors.destructive }}>Reset</Text>\n                </TouchableOpacity>\n            </View>\n        </View>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/GeneralSettings.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TouchableOpacity' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Users' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport { router } from 'expo-router';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { SettingsItem } from './SettingsItem';\nimport { ModernSwitch } from '@/components/ui/ModernSwitch';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport {\n    Users,\n    MessageSquare,\n    Shield,\n    FileText,\n    Sparkles\n} from 'lucide-react-native';\n\n// Modals\nimport { FeedbackModal } from '../FeedbackModal';\n\ninterface GeneralSettingsProps {\n    onClose: () => void;\n}\n\nexport const GeneralSettings: React.FC<GeneralSettingsProps> = ({ onClose }) => {\n    const { colors } = useTheme();\n\n    const [showFeedbackModal, setShowFeedbackModal] = useState(false);\n    const [smartDefaultsEnabled, setSmartDefaultsEnabled] = useState(true);\n\n    useEffect(() => {\n        loadSettings();\n    }, []);\n\n    const loadSettings = async () => {\n        const smartDefaultsStr = await AsyncStorage.getItem('@weave:smart_defaults_enabled');\n        setSmartDefaultsEnabled(smartDefaultsStr ? JSON.parse(smartDefaultsStr) : true);\n    };\n\n    const handleToggleSmartDefaults = async (enabled: boolean) => {\n        setSmartDefaultsEnabled(enabled);\n        await AsyncStorage.setItem('@weave:smart_defaults_enabled', JSON.stringify(enabled));\n    };\n\n    return (\n        <View className=\"gap-4\">\n            {/* Community / Management */}\n            <SettingsItem\n                icon={Sparkles}\n                title=\"Smart Activity Ordering\"\n                subtitle=\"Reorder activities by time of day & context\"\n                rightElement={\n                    <ModernSwitch\n                        value={smartDefaultsEnabled}\n                        onValueChange={handleToggleSmartDefaults}\n                    />\n                }\n            />\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <SettingsItem\n                icon={MessageSquare}\n                title=\"Send Feedback\"\n                subtitle=\"Report bugs or share ideas\"\n                onPress={() => setShowFeedbackModal(true)}\n            />\n\n\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            {/* Legal Section */}\n            <Text className=\"text-xs font-inter-semibold uppercase tracking-wide mb-2\" style={{ color: colors['muted-foreground'] }}>\n                Legal\n            </Text>\n\n            <SettingsItem\n                icon={Shield}\n                title=\"Privacy Policy\"\n                subtitle=\"How we handle your data\"\n                onPress={() => {\n                    onClose();\n                    router.push('/privacy-policy');\n                }}\n            />\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <SettingsItem\n                icon={FileText}\n                title=\"Terms of Service\"\n                subtitle=\"Usage agreement\"\n                onPress={() => {\n                    onClose();\n                    router.push('/terms-of-service');\n                }}\n            />\n\n            {/* Modals */}\n            <FeedbackModal\n                visible={showFeedbackModal}\n                onClose={() => setShowFeedbackModal(false)}\n            />\n        </View>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/NotificationSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/SettingsItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/settings/TestingSettings.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ChevronRight' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'openReflectionPrompt' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":27,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, Text, TouchableOpacity, Alert } from 'react-native';\nimport { router } from 'expo-router';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport {\n    Sparkles,\n    Trophy,\n    Database,\n    Trash2,\n    Shield,\n    RefreshCw,\n    Moon,\n    ChevronRight\n} from 'lucide-react-native';\nimport { SettingsItem } from './SettingsItem';\nimport { useUIStore } from '@/stores/uiStore';\nimport { DiagnosticService } from '@/services/diagnostic.service';\nimport { EveningDigestChannel } from '@/modules/notifications';\nimport { generateStressTestData, clearStressTestData, getDataStats } from '@/db/seeds/stress-test-seed-data';\n\ninterface TestingSettingsProps {\n    onClose: () => void;\n}\n\nexport const TestingSettings: React.FC<TestingSettingsProps> = ({ onClose }) => {\n    const { colors } = useTheme();\n    const { openWeeklyReflection, openReflectionPrompt } = useUIStore();\n    const [isScanning, setIsScanning] = useState(false);\n\n    const handleGenerateStressTest = () => {\n        Alert.alert(\n            'Generate Stress Test Data',\n            'This will create realistic test data including friends, interactions, journal entries, and groups. Continue?',\n            [\n                { text: 'Cancel', style: 'cancel' },\n                {\n                    text: 'Generate',\n                    onPress: async () => {\n                        try {\n                            await generateStressTestData(100, 10);\n                            const stats = await getDataStats();\n                            Alert.alert(\n                                'Stress Test Data Generated',\n                                `Created ${stats.stressTestFriends} test friends!\\n\\n` +\n                                `Total friends: ${stats.totalFriends}\\n` +\n                                `Total interactions: ${stats.totalInteractions}\\n` +\n                                `Total journal entries: ${stats.totalJournalEntries}\\n` +\n                                `Total groups: ${stats.totalGroups}`,\n                                [{ text: 'OK' }]\n                            );\n                        } catch (error) {\n                            console.error('Failed to generate stress test data:', error);\n                            Alert.alert('Error', 'Failed to generate stress test data.');\n                        }\n                    },\n                },\n            ]\n        );\n    };\n\n    const handleClearStressTest = async () => {\n        try {\n            const stats = await getDataStats();\n            if (stats.stressTestFriends === 0) {\n                Alert.alert('No Stress Test Data', 'There is no stress test data to clear.');\n                return;\n            }\n\n            Alert.alert(\n                'Clear Stress Test Data',\n                `This will remove ${stats.stressTestFriends} test friends and their interactions. Continue?`,\n                [\n                    { text: 'Cancel', style: 'cancel' },\n                    {\n                        text: 'Clear',\n                        style: 'destructive',\n                        onPress: async () => {\n                            try {\n                                await clearStressTestData();\n                                Alert.alert('Cleared', 'Stress test data has been removed.', [{ text: 'OK' }]);\n                            } catch (error) {\n                                console.error('Failed to clear stress test data:', error);\n                                Alert.alert('Error', 'Failed to clear stress test data.');\n                            }\n                        },\n                    },\n                ]\n            );\n        } catch (error) {\n            console.error('Failed to check stress test data:', error);\n            Alert.alert('Error', 'Failed to check stress test data.');\n        }\n    };\n\n    const handleRunDiagnostics = async () => {\n        setIsScanning(true);\n        // Tiny delay to allow UI to update and user to perceive action\n        await new Promise(resolve => setTimeout(resolve, 800));\n\n        try {\n            const report = await DiagnosticService.runScan();\n            setIsScanning(false);\n\n            const issueSummary = report.issues.length > 0\n                ? report.issues.map(i => `• [${i.severity.toUpperCase()}] ${i.description}`).join('\\n')\n                : 'No issues found.';\n\n            Alert.alert(\n                'Diagnostic Report',\n                `Scan complete in ${report.scanDurationMs}ms.\\n\\nIssues Found: ${report.totalIssues}\\n\\n${issueSummary}`,\n                [\n                    { text: 'OK' },\n                    report.totalIssues > 0 ? {\n                        text: 'Attempt Fix',\n                        onPress: () => {\n                            Alert.alert('Fix Orphans', 'Attempting to remove orphaned links...', [\n                                {\n                                    text: 'Proceed',\n                                    style: 'destructive',\n                                    onPress: async () => {\n                                        const fixed = await DiagnosticService.fixOrphans(report.issues);\n                                        Alert.alert('Fix Complete', `Removed ${fixed} orphaned records.`);\n                                    }\n                                },\n                                { text: 'Cancel', style: 'cancel' }\n                            ]);\n                        }\n                    } : { text: '' } // no-op if no issues\n                ].filter(b => b.text)\n            );\n        } catch (error) {\n            setIsScanning(false);\n            console.error('Diagnostic run failed:', error);\n            Alert.alert('Error', 'Diagnostic scan failed.');\n        }\n    };\n\n    const handleTestEveningDigest = async () => {\n        try {\n            await EveningDigestChannel.handleTap({ isTest: true }, router);\n            onClose();\n        } catch (error) {\n            console.error('Failed to open digest:', error);\n            Alert.alert('Error', 'Failed to open digest sheet');\n        }\n    };\n\n    return (\n        <View className=\"gap-4\">\n            {/* Debug Section Title */}\n            <Text className=\"text-xs font-inter-semibold uppercase tracking-wide mb-2\" style={{ color: colors['muted-foreground'] }}>\n                Debug Tools\n            </Text>\n\n            {/* Test Actions */}\n            <SettingsItem\n                icon={Sparkles}\n                title=\"Test Weekly Reflection\"\n                subtitle=\"Trigger the weekly check-in flow\"\n                onPress={() => {\n                    onClose();\n                    setTimeout(() => openWeeklyReflection(), 300);\n                }}\n            />\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <SettingsItem\n                icon={Trophy}\n                title=\"Test Badge Popup\"\n                subtitle=\"Trigger a fake badge unlock\"\n                onPress={() => {\n                    useUIStore.getState().queueBadgeUnlocks([{\n                        badge: {\n                            id: 'test_badge',\n                            name: 'Test Badge',\n                            icon: '🧪',\n                            description: 'This is a test badge to verify the popup animation.',\n                            threshold: 1,\n                            tier: 1,\n                            rarity: 'epic',\n                            flavorText: 'Science requires experimentation!',\n                        },\n                        friendId: 'test_friend',\n                        friendName: 'Test Friend',\n                        categoryType: 'special',\n                    }]);\n                    onClose();\n                }}\n            />\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <SettingsItem\n                icon={Database}\n                title=\"Generate Test Data\"\n                subtitle=\"Create 100 test friends\"\n                onPress={handleGenerateStressTest}\n            />\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <SettingsItem\n                icon={Trash2}\n                title=\"Clear Test Data\"\n                subtitle=\"Remove stress test friends\"\n                onPress={handleClearStressTest}\n            />\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            {/* Diagnostic Scan */}\n            <TouchableOpacity\n                className=\"flex-row items-center justify-between\"\n                onPress={handleRunDiagnostics}\n                disabled={isScanning}\n            >\n                <View className=\"flex-row items-center gap-3\">\n                    <View className=\"w-10 h-10 rounded-lg items-center justify-center\" style={{ backgroundColor: isScanning ? colors.muted : colors.muted }}>\n                        {isScanning ? (\n                            <RefreshCw color={colors.foreground} size={20} className=\"animate-spin\" />\n                        ) : (\n                            <Shield color={colors.foreground} size={20} />\n                        )}\n                    </View>\n                    <View>\n                        <Text className=\"text-base font-inter-medium\" style={{ color: isScanning ? colors['muted-foreground'] : colors.foreground }}>\n                            {isScanning ? 'Scanning Database...' : 'Scan Database'}\n                        </Text>\n                        <Text className=\"text-sm font-inter-regular\" style={{ color: colors['muted-foreground'] }}>Check for data anomalies</Text>\n                    </View>\n                </View>\n            </TouchableOpacity>\n\n            <View className=\"border-t border-border\" style={{ borderColor: colors.border }} />\n\n            <SettingsItem\n                icon={Moon}\n                title=\"Test Evening Digest\"\n                subtitle=\"Trigger digest sheet immediately\"\n                onPress={handleTestEveningDigest}\n            />\n        </View>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/toast_notification.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withDelay' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'runOnJS' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Check' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withSpring,\n  withDelay,\n  withTiming,\n  runOnJS,\n} from 'react-native-reanimated';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { Check } from 'lucide-react-native';\nimport { theme } from '@/shared/theme/theme';\n\ninterface ToastNotificationProps {\n  message: string;\n  friendName: string;\n  onDismiss: () => void;\n}\n\nexport function ToastNotification({ message, friendName, onDismiss }: ToastNotificationProps) {\n  const insets = useSafeAreaInsets();\n  const translateY = useSharedValue(-100);\n  const opacity = useSharedValue(0);\n\n  useEffect(() => {\n    // Slide in\n    translateY.value = withSpring(0, {\n      damping: 15,\n      stiffness: 150,\n    });\n    opacity.value = withTiming(1, { duration: 200 });\n\n    // Auto dismiss after 2.5 seconds\n    const timer = setTimeout(() => {\n      translateY.value = withTiming(-100, { duration: 250 });\n      opacity.value = withTiming(0, { duration: 250 });\n      setTimeout(onDismiss, 250);\n    }, 2500);\n\n    return () => clearTimeout(timer);\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n    opacity: opacity.value,\n  }));\n\n  return (\n    <Animated.View \n      style={[\n        styles.container, \n        { top: insets.top + 12 },\n        animatedStyle\n      ]}\n    >\n      <View style={styles.content}>\n        <Text style={styles.icon}>✓</Text>\n        <View style={styles.textContainer}>\n          <Text style={styles.message}>\n            <Text style={styles.activityText}>{message}</Text>\n            <Text style={styles.withText}> logged with </Text>\n            <Text style={styles.friendNameText}>{friendName}</Text>\n          </Text>\n        </View>\n      </View>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    left: 20,\n    right: 20,\n    zIndex: 9999,\n  },\n  content: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: 'rgba(255, 255, 255, 0.95)',\n    borderRadius: 16,\n    padding: 16,\n    paddingVertical: 14,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.15,\n    shadowRadius: 12,\n    elevation: 8,\n    borderWidth: 1.5,\n    borderColor: 'rgba(181, 138, 108, 0.3)',\n  },\n  icon: {\n    fontSize: 24,\n    marginRight: 12,\n  },\n  textContainer: {\n    flex: 1,\n  },\n  message: {\n    fontSize: 15,\n    lineHeight: 20,\n  },\n  activityText: {\n    fontWeight: '700',\n    color: theme.colors.foreground,\n  },\n  withText: {\n    fontWeight: '400',\n    color: theme.colors['muted-foreground'],\n  },\n  friendNameText: {\n    fontWeight: '700',\n    color: theme.colors.primary,\n    fontFamily: 'Lora_700Bold',\n  },\n});","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/toast_provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/types.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityType' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":86,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":98}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/types.tsx\n// Re-export from shared/types/common for backward compatibility\nexport * from '@/shared/types/common';\n\n// Re-exporting types that were defined here but not yet moved to common if any unique ones exist\n// In this case, we moved everything to common.ts, so we just re-export.\nimport { InteractionCategory, InteractionType, Duration, Vibe, StructuredReflection, ActivityType, Archetype, Tier, RelationshipType, LifeEventType, LifeEventImportance, LifeEventSource } from '@/shared/types/common';\nexport type MoonPhase = Vibe;\n\n// Re-declaring types that might be used as values or need specific augmentation if any (none for now)\nexport type MockContact = {\n  id: string;\n  name: string;\n  imageAvailable?: boolean;\n  image?: { uri: string };\n};\n\nexport type Friend = {\n  id: string;\n  name: string;\n  createdAt: Date;\n  dunbarTier: Tier;\n  archetype: Archetype;\n  weaveScore: number;\n  lastUpdated: Date;\n  photoUrl?: string;\n  notes?: string;\n  isDormant?: boolean;\n  birthday?: string;\n  anniversary?: string;\n  relationshipType?: RelationshipType;\n  toleranceWindowDays?: number;\n  resilience: number;\n  typicalIntervalDays?: number;\n};\n\nexport type Interaction = {\n  id: string;\n  friendIds?: string[];\n  createdAt: Date;\n  interactionDate: Date;\n  category?: InteractionCategory; // NEW: Simplified interaction category\n  interactionType: InteractionType; // DEPRECATED: Old activity (kept for migration)\n  duration: Duration | null;\n  vibe: Vibe | null;\n  note: string | null;\n  source?: 'quick-weave' | 'full-form' | 'import'; // Track entry method for node sizing\n  photos?: string[]; // Photo URIs for rich content detection\n  reflection?: StructuredReflection; // NEW: Structured reflection data\n\n  // Missing properties added to fix build errors\n  activity: string;\n  status: string;\n  mode: string;\n  title?: string;\n  location?: string;\n  eventImportance?: string;\n  initiator?: string;\n  updatedAt: Date;\n  interactionCategory?: InteractionCategory;\n};\n\nexport type FriendFormData = {\n  name: string;\n  tier: string; // 'inner', 'close', or 'community'\n  archetype: Archetype;\n  notes: string;\n  photoUrl: string;\n  // Life events and relationship context\n  birthday?: string; // Format: \"MM-DD\"\n  anniversary?: string; // Format: \"MM-DD\"\n  relationshipType?: RelationshipType;\n};\n\nexport interface LifeEvent {\n  id: string;\n  friendId: string;\n  title: string;\n  date: Date; // mapped from eventDate\n  eventType: LifeEventType;\n  description?: string;\n  importance: LifeEventImportance;\n  isRecurring: boolean;\n  source: LifeEventSource;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Intention {\n  id: string;\n  description?: string;\n  interactionCategory?: string;\n  status: 'active' | 'converted' | 'dismissed' | 'fulfilled';\n  createdAt: Date;\n  updatedAt: Date;\n  lastRemindedAt?: Date;\n  linkedInteractionId?: string;\n  fulfilledAt?: Date;\n  daysToFulfillment?: number;\n  friendIds: string[];\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/Divider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/ListItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/ModernSwitch.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withTiming' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { Pressable, StyleSheet, ViewStyle } from 'react-native';\nimport Animated, {\n    interpolate,\n    interpolateColor,\n    useAnimatedStyle,\n    useSharedValue,\n    withSpring,\n    withTiming,\n} from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\ninterface ModernSwitchProps {\n    value: boolean;\n    onValueChange: (value: boolean) => void;\n    disabled?: boolean;\n    style?: ViewStyle;\n}\n\nconst SWITCH_WIDTH = 50;\nconst SWITCH_HEIGHT = 30;\nconst KNOB_SIZE = 26;\nconst PADDING = 2;\n\nexport function ModernSwitch({\n    value,\n    onValueChange,\n    disabled = false,\n    style,\n}: ModernSwitchProps) {\n    const { tokens, isDarkMode } = useTheme();\n\n    // Animation values\n    const progress = useSharedValue(value ? 1 : 0);\n    const pressed = useSharedValue(0);\n\n    // Sync external value changes\n    useEffect(() => {\n        progress.value = withSpring(value ? 1 : 0, {\n            mass: 0.8,\n            damping: 12,\n            stiffness: 120,\n        });\n    }, [value]);\n\n    const handlePress = async () => {\n        if (disabled) return;\n\n        // Haptic feedback\n        if (process.env.EXPO_OS === 'ios') {\n            await Haptics.selectionAsync();\n        }\n\n        onValueChange(!value);\n    };\n\n    const handlePressIn = () => {\n        pressed.value = withSpring(1, { mass: 0.5 });\n    };\n\n    const handlePressOut = () => {\n        pressed.value = withSpring(0, { mass: 0.5 });\n    };\n\n    // Colors\n    const activeColor = tokens.success; // Green for ON\n    const inactiveColor = tokens.border; // Muted for OFF\n    const knobColor = '#FFFFFF';\n\n    const containerAnimatedStyle = useAnimatedStyle(() => {\n        const backgroundColor = interpolateColor(\n            progress.value,\n            [0, 1],\n            [inactiveColor, activeColor]\n        );\n\n        return {\n            backgroundColor,\n        };\n    });\n\n    const knobAnimatedStyle = useAnimatedStyle(() => {\n        const translateX = interpolate(\n            progress.value,\n            [0, 1],\n            [PADDING, SWITCH_WIDTH - KNOB_SIZE - PADDING]\n        );\n\n        // Scale effect on press\n        const scale = interpolate(pressed.value, [0, 1], [1, 0.9]);\n\n        // Stretch effect when moving (optional, keep simple for now)\n        const width = interpolate(pressed.value, [0, 1], [KNOB_SIZE, KNOB_SIZE + 4]);\n\n        return {\n            transform: [\n                { translateX },\n                { scale },\n            ],\n            width,\n        };\n    });\n\n    return (\n        <Pressable\n            onPress={handlePress}\n            onPressIn={handlePressIn}\n            onPressOut={handlePressOut}\n            disabled={disabled}\n            style={[styles.container, style]}\n        >\n            <Animated.View style={[styles.track, containerAnimatedStyle]}>\n                <Animated.View style={[styles.knob, { backgroundColor: knobColor }, knobAnimatedStyle]} />\n            </Animated.View>\n        </Pressable>\n    );\n}\n\nconst styles = StyleSheet.create({\n    container: {\n        width: SWITCH_WIDTH,\n        height: SWITCH_HEIGHT,\n        justifyContent: 'center',\n    },\n    track: {\n        width: '100%',\n        height: '100%',\n        borderRadius: SWITCH_HEIGHT / 2,\n        justifyContent: 'center',\n    },\n    knob: {\n        width: KNOB_SIZE,\n        height: KNOB_SIZE,\n        borderRadius: KNOB_SIZE / 2,\n        position: 'absolute',\n        left: 0,\n        shadowColor: \"#000\",\n        shadowOffset: {\n            width: 0,\n            height: 2,\n        },\n        shadowOpacity: 0.2,\n        shadowRadius: 2.5,\n        elevation: 4,\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/ProgressBar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'radius' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":16,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\ninterface ProgressBarProps {\n    progress: number; // 0-100\n    color?: string;\n    height?: number;\n}\n\nexport const ProgressBar: React.FC<ProgressBarProps> = ({\n    progress,\n    color,\n    height = 6,\n}) => {\n    const { tokens, radius } = useTheme();\n\n    const clampedProgress = Math.min(100, Math.max(0, Number.isFinite(progress) ? progress : 0));\n    const fillColor = color || tokens.primary;\n\n    return (\n        <View style={[\n            styles.track,\n            {\n                height,\n                borderRadius: height / 2,\n                backgroundColor: tokens.borderSubtle,\n            }\n        ]}>\n            <View style={[\n                styles.fill,\n                {\n                    width: `${clampedProgress}%`,\n                    height,\n                    borderRadius: height / 2,\n                    backgroundColor: fillColor,\n                }\n            ]} />\n        </View>\n    );\n};\n\nconst styles = StyleSheet.create({\n    track: {\n        width: '100%',\n        overflow: 'hidden',\n    },\n    fill: {},\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/Stat.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/WidgetHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/context/CardGestureContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":169,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":206,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'success' is defined but never used. Allowed unused args must match /^_/u.","line":206,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useMemo, useRef } from 'react';\nimport { View } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedScrollHandler, runOnJS, measure } from 'react-native-reanimated';\nimport { Gesture } from 'react-native-gesture-handler';\nimport * as Haptics from 'expo-haptics';\n\nimport { useQuickWeave } from '@/modules/interactions';\nimport { itemPositions, HIGHLIGHT_THRESHOLD, SELECTION_THRESHOLD } from '@/modules/interactions';\n\ninterface CardGestureContextType {\n  gesture: any; // Using any to avoid complex Gesture type issues\n  animatedScrollHandler: any;\n  activeCardId: Animated.SharedValue<string | null>;\n  pendingCardId: Animated.SharedValue<string | null>; // Card being held (before long-press activates)\n  registerRef: (id: string, ref: React.RefObject<Animated.View>) => void;\n  unregisterRef: (id: string) => void;\n  dragX: Animated.SharedValue<number>;\n  dragY: Animated.SharedValue<number>;\n  highlightedIndex: Animated.SharedValue<number>;\n}\n\nconst CardGestureContext = createContext<CardGestureContextType | null>(null);\n\nexport function CardGestureProvider({ children }: { children: React.ReactNode }) {\n  const gestureCoordinator = useCardGestureCoordinator();\n  return <CardGestureContext.Provider value={gestureCoordinator}>{children}</CardGestureContext.Provider>;\n}\n\nexport function useCardGesture() {\n  const context = useContext(CardGestureContext);\n  if (!context) throw new Error('useCardGesture must be used within a CardGestureProvider');\n  return context;\n}\n\nfunction useCardGestureCoordinator(): CardGestureContextType {\n  const { handleInteractionSelection, handleOpenQuickWeave, handleTap, closeQuickWeave } = useQuickWeave();\n\n  // Create refs to hold the latest version of the handlers\n  // This prevents the stale closure issue where the gesture (which is memoized once)\n  // holds onto the *initial* version of these functions (and thus the initial activities list/state).\n  const interactionSelectionRef = useRef(handleInteractionSelection);\n  const openQuickWeaveRef = useRef(handleOpenQuickWeave);\n  const tapRef = useRef(handleTap);\n  const closeQuickWeaveRef = useRef(closeQuickWeave);\n\n  // Always keep refs up to date\n  interactionSelectionRef.current = handleInteractionSelection;\n  openQuickWeaveRef.current = handleOpenQuickWeave;\n  tapRef.current = handleTap;\n  closeQuickWeaveRef.current = closeQuickWeave;\n\n  // Stable wrappers that use the refs\n  const handleInteractionSelectionStable = (index: number, fId: string) => interactionSelectionRef.current(index, fId);\n  const handleOpenQuickWeaveStable = (fId: string, point: { x: number; y: number }) => openQuickWeaveRef.current(fId, point);\n  const handleTapStable = (fId: string) => tapRef.current(fId);\n  const closeQuickWeaveStable = () => closeQuickWeaveRef.current();\n\n  const cardRefs = useSharedValue<Record<string, React.RefObject<Animated.View>>>({});\n  const scrollOffset = useSharedValue(0);\n  const activeCardId = useSharedValue<string | null>(null);\n  const pendingCardId = useSharedValue<string | null>(null); // Track which card is being held before activation\n  const isLongPressActive = useSharedValue(false);\n  const dragX = useSharedValue(0);\n  const dragY = useSharedValue(0);\n  const highlightedIndex = useSharedValue(-1);\n  const startCoordinates = useSharedValue<{ x: number, y: number }>({ x: 0, y: 0 });\n\n  // Timeout for delayed pending feedback (so quick taps don't trigger it)\n  const pendingFeedbackTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const startPendingFeedback = (targetId: string) => {\n    // Clear any existing timeout\n    if (pendingFeedbackTimeout.current) {\n      clearTimeout(pendingFeedbackTimeout.current);\n    }\n    // Delay the visual feedback by 120ms so quick taps bypass it\n    pendingFeedbackTimeout.current = setTimeout(() => {\n      pendingCardId.value = targetId;\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    }, 120);\n  };\n\n  const clearPendingFeedback = () => {\n    if (pendingFeedbackTimeout.current) {\n      clearTimeout(pendingFeedbackTimeout.current);\n      pendingFeedbackTimeout.current = null;\n    }\n  };\n\n  const registerRef = (id: string, ref: React.RefObject<Animated.View>) => {\n    'worklet';\n    cardRefs.value[id] = ref;\n  };\n\n  const unregisterRef = (id: string) => {\n    'worklet';\n    delete cardRefs.value[id];\n  };\n\n  const animatedScrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => { 'worklet'; scrollOffset.value = event.contentOffset.y; },\n  });\n\n  const findTargetCardId = (absoluteX: number, absoluteY: number) => {\n    'worklet';\n    const cardIds = Object.keys(cardRefs.value);\n    for (const id of cardIds) {\n      const ref = cardRefs.value[id];\n      // Cast to any to satisfy Reanimated's measure type requirement, assuming ref is valid\n      const measurement = measure(ref as any);\n      if (measurement === null) continue;\n      const { pageX: x, pageY: y, width, height } = measurement;\n      if (absoluteX >= x && absoluteX <= x + width && absoluteY >= y && absoluteY <= y + height) {\n        return id;\n      }\n    }\n    return null;\n  };\n\n  // THE FIX: Wrap the entire gesture definition in useMemo to prevent re-creation on re-renders.\n  const gesture = useMemo(() => {\n    const tap = Gesture.Tap()\n      .maxDuration(260) // Increased for more forgiving quick taps\n      .onEnd((event, success) => {\n        'worklet';\n        // Clear any pending feedback timeout so quick taps don't trigger it\n        runOnJS(clearPendingFeedback)();\n        if (success && !isLongPressActive.value) {\n          const targetId = findTargetCardId(event.absoluteX, event.absoluteY);\n          if (targetId) {\n            runOnJS(handleTapStable)(targetId);\n          }\n        }\n      });\n\n    const longPressAndDrag = Gesture.LongPress()\n      .minDuration(260) // Aligned with tap maxDuration\n      .maxDistance(999999)\n      .shouldCancelWhenOutside(false)\n      .onBegin((event) => {\n        'worklet';\n        // Store coordinates immediately, but delay the visual feedback\n        // so quick taps don't trigger the \"charging\" animation/haptic\n        const targetId = findTargetCardId(event.absoluteX, event.absoluteY);\n        if (targetId) {\n          startCoordinates.value = { x: event.x, y: event.y };\n          // Delay pending feedback - only shows if user holds for 120ms+\n          runOnJS(startPendingFeedback)(targetId);\n        }\n      })\n      .onStart((event) => {\n        'worklet';\n        // Clear the delayed pending feedback since we're now activating\n        runOnJS(clearPendingFeedback)();\n        // Now set activeCardId when long press actually activates\n        const targetId = findTargetCardId(event.absoluteX, event.absoluteY);\n        if (targetId) {\n          pendingCardId.value = null; // Clear pending state\n          activeCardId.value = targetId;\n          isLongPressActive.value = true;\n          runOnJS(Haptics.impactAsync)(Haptics.ImpactFeedbackStyle.Medium);\n          const centerPoint = {\n            x: event.absoluteX,\n            y: event.absoluteY, // Use absolute position since overlay is screen-positioned\n          };\n          runOnJS(handleOpenQuickWeaveStable)(targetId, centerPoint);\n        }\n      })\n      .onTouchesMove((event, state) => {\n        'worklet';\n        if (!isLongPressActive.value) return;\n\n        const touch = event.changedTouches[0];\n        const currentDragX = touch.x - startCoordinates.value.x;\n        const currentDragY = touch.y - startCoordinates.value.y;\n\n        dragX.value = currentDragX;\n        dragY.value = currentDragY;\n\n        const distance = Math.sqrt(currentDragX ** 2 + currentDragY ** 2);\n\n        if (distance < HIGHLIGHT_THRESHOLD) {\n          highlightedIndex.value = -1;\n          return;\n        }\n\n        const angle = Math.atan2(currentDragY, currentDragX);\n        let closestIndex = -1;\n        let minAngleDiff = Infinity;\n\n        for (let i = 0; i < itemPositions.length; i++) {\n          const itemAngle = itemPositions[i].angle;\n          const diff = Math.abs(angle - itemAngle);\n          const normalizedDiff = Math.min(diff, 2 * Math.PI - diff);\n          if (normalizedDiff < minAngleDiff) {\n            minAngleDiff = normalizedDiff;\n            closestIndex = i;\n          }\n        }\n\n        if (highlightedIndex.value !== closestIndex) {\n          highlightedIndex.value = closestIndex;\n          runOnJS(Haptics.impactAsync)(Haptics.ImpactFeedbackStyle.Light);\n        }\n      })\n      .onEnd((event, success) => {\n        'worklet';\n        if (isLongPressActive.value) {\n          // Close the overlay first\n          runOnJS(closeQuickWeaveStable)();\n\n          const distance = Math.sqrt(dragX.value ** 2 + dragY.value ** 2);\n          if (distance >= SELECTION_THRESHOLD && highlightedIndex.value !== -1 && activeCardId.value) {\n            // Process interaction selection after overlay closes\n            const selectedIndex = highlightedIndex.value;\n            const friendId = activeCardId.value;\n            runOnJS(handleInteractionSelectionStable)(selectedIndex, friendId);\n          }\n        }\n\n        // Reset all state immediately - always, regardless of gesture state\n        isLongPressActive.value = false;\n        activeCardId.value = null;\n        pendingCardId.value = null;\n        dragX.value = 0;\n        dragY.value = 0;\n        highlightedIndex.value = -1;\n      })\n      .onFinalize(() => {\n        'worklet';\n        // Final cleanup to ensure card scale resets - extra safety\n        activeCardId.value = null;\n        pendingCardId.value = null;\n        isLongPressActive.value = false;\n        dragX.value = 0;\n        dragY.value = 0;\n        highlightedIndex.value = -1;\n      });\n\n    return Gesture.Exclusive(tap, longPressAndDrag);\n  }, []); // Empty dependency array means this runs only once.\n\n  return { gesture, animatedScrollHandler, activeCardId, pendingCardId, registerRef, unregisterRef, dragX, dragY, highlightedIndex };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/data-migration.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":186,"column":5,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":186,"endColumn":52,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5747,5794],"text":"// @ts-expect-error - _raw is internal but accessible"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":204,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":204,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":215,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":215,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":225,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":225,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":235,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":235,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Database, Q } from '@nozbe/watermelondb';\nimport { InteractionCategory, ActivityType } from '@/components/types';\n// import { migrateActivityToCategory } from '@/shared/constants/interaction-categories';\n\n\n// Helper to migrate old activity types to new categories\nfunction migrateActivityToCategory(activity: string): InteractionCategory {\n  const map: Record<string, InteractionCategory> = {\n    'catch_up': 'text-call',\n    'deep_talk': 'deep-talk',\n    'hangout': 'hangout',\n    'party': 'event-party',\n    'activity': 'activity-hobby',\n    'travel': 'activity-hobby',\n    'work': 'activity-hobby',\n    'other': 'text-call',\n  };\n  return map[activity] || 'text-call';\n}\n\n/**\n * Migrate existing interactions to use the new category system\n *\n * This function:\n * 1. Queries all interactions without a category\n * 2. Maps their old activity → new category\n * 3. Updates the interaction_category field\n *\n * Called once after schema migration from v8 to v9\n */\nexport async function migrateInteractionsToCategories(database: Database): Promise<void> {\n  const interactionsCollection = database.get('interactions');\n  const CHUNK_SIZE = 100;\n\n  try {\n    let migratedCount = 0;\n    let errorCount = 0;\n    let offset = 0;\n    let hasMore = true;\n\n    console.log('[Data Migration] Starting chunked interaction category migration...');\n\n    while (hasMore) {\n      // Fetch chunk of interactions\n      const chunk = await interactionsCollection\n        .query(\n          Q.take(CHUNK_SIZE),\n          Q.skip(offset)\n        )\n        .fetch();\n\n      if (chunk.length === 0) {\n        hasMore = false;\n        break;\n      }\n\n      // Process chunk in single batch operation\n      await database.write(async () => {\n        const batchOps: any[] = [];\n\n        for (const interaction of chunk) {\n          try {\n            // Skip if already has a category\n            if ((interaction._raw as any).interaction_category) {\n              continue;\n            }\n\n            // Get the old activity field\n            const oldActivity = (interaction._raw as any).activity as ActivityType;\n\n            if (!oldActivity) {\n              console.warn(`[Data Migration] Interaction ${interaction.id} has no activity field, skipping`);\n              continue;\n            }\n\n            // Migrate to new category\n            const newCategory = migrateActivityToCategory(oldActivity);\n\n            // Prepare update operation\n            const preparedUpdate = interaction.prepareUpdate((record: any) => {\n              (record._raw as any).interaction_category = newCategory;\n            });\n\n            batchOps.push(preparedUpdate);\n          } catch (error) {\n            console.error(`[Data Migration] Error preparing migration for interaction ${interaction.id}:`, error);\n            errorCount++;\n          }\n        }\n\n        // Execute all updates in a single batch\n        if (batchOps.length > 0) {\n          await database.batch(...batchOps);\n          migratedCount += batchOps.length;\n        }\n      });\n\n      console.log(`[Data Migration] Processed ${offset + chunk.length} interactions (migrated: ${migratedCount}, errors: ${errorCount})...`);\n      offset += chunk.length;\n    }\n\n    console.log(`[Data Migration] ✅ Migration complete. Migrated ${migratedCount} interactions with ${errorCount} errors.`);\n  } catch (error) {\n    console.error('[Data Migration] ❌ Fatal error during migration:', error);\n    throw error;\n  }\n}\n\n/**\n * Check if data migration has been completed\n * Returns true if all interactions have a category field\n * Uses chunking to avoid loading all interactions into memory\n */\nexport async function isDataMigrationComplete(database: Database): Promise<boolean> {\n  try {\n    const interactionsCollection = database.get('interactions');\n    const CHUNK_SIZE = 100;\n    let offset = 0;\n    let hasMore = true;\n    let totalUnmigrated = 0;\n\n    while (hasMore) {\n      const chunk = await interactionsCollection\n        .query(\n          Q.take(CHUNK_SIZE),\n          Q.skip(offset)\n        )\n        .fetch();\n\n      if (chunk.length === 0) {\n        // No more interactions\n        hasMore = false;\n        break;\n      }\n\n      // Check chunk for unmigrated interactions\n      const unmigratedInChunk = chunk.filter(\n        (interaction) => !(interaction._raw as any).interaction_category\n      );\n\n      totalUnmigrated += unmigratedInChunk.length;\n\n      // Early return if we find any unmigrated interactions\n      if (totalUnmigrated > 0) {\n        console.log(\n          `[Data Migration] Found ${totalUnmigrated} unmigrated interactions (checked ${offset + chunk.length} so far)`\n        );\n        return false;\n      }\n\n      offset += chunk.length;\n    }\n\n    if (offset === 0) {\n      // No interactions yet, migration not needed\n      return true;\n    }\n\n    return totalUnmigrated === 0;\n  } catch (error) {\n    console.error('[Data Migration] Error checking migration status:', error);\n    return false;\n  }\n}\n\n/**\n * Ensure user_progress table has v30 streak forgiveness columns\n * This handles cases where schema migration didn't run properly\n */\nexport async function ensureUserProgressColumns(database: Database): Promise<void> {\n  try {\n\n\n    const progressCollection = database.get('user_progress');\n    const progress = await progressCollection.query().fetch();\n\n    if (progress.length === 0) {\n      // No progress record yet, so we can't check columns easily.\n      // But typically user_progress is created immediately.\n      // If it's effectively empty, we might not need to migrate yet or it's a fresh install where schema is correct.\n      return;\n    }\n\n    // Check if columns already exist by inspecting the first record\n    const firstRecord = progress[0];\n    // @ts-ignore - _raw is internal but accessible\n    if ('last_streak_count' in firstRecord._raw) {\n      // Columns already exist, skip migration to avoid \"duplicate column\" errors\n      return;\n    }\n\n    // We'll try to add columns regardless of whether we think they exist, \n    // catching errors for duplicates. This is more robust than checking _raw.\n    const adapter = database.adapter;\n\n    await database.write(async () => {\n      // 1. last_streak_count\n      try {\n        await adapter.unsafeExecute({\n          sqls: [\n            ['ALTER TABLE user_progress ADD COLUMN last_streak_count INTEGER DEFAULT 0', []],\n          ],\n        });\n      } catch (e) {\n        // Ignore \"duplicate column name\" error\n      }\n\n      // 2. longest_streak_ever\n      try {\n        await adapter.unsafeExecute({\n          sqls: [\n            ['ALTER TABLE user_progress ADD COLUMN longest_streak_ever INTEGER DEFAULT 0', []],\n          ],\n        });\n      } catch (e) {\n      }\n\n      // 3. streak_released_date\n      try {\n        await adapter.unsafeExecute({\n          sqls: [\n            ['ALTER TABLE user_progress ADD COLUMN streak_released_date INTEGER', []],\n          ],\n        });\n      } catch (e) {\n      }\n\n      // Initialize longest_streak_ever to current best_streak if needed\n      try {\n        await adapter.unsafeExecute({\n          sqls: [\n            ['UPDATE user_progress SET longest_streak_ever = best_streak WHERE longest_streak_ever = 0', []],\n          ],\n        });\n      } catch (e) {\n\n      }\n    });\n\n\n  } catch (error) {\n    console.error('[Data Migration] Error checking user_progress columns:', error);\n  }\n}\n\n/**\n * Run data migration if needed\n * Safe to call multiple times - will only run once\n */\nexport async function runDataMigrationIfNeeded(database: Database): Promise<void> {\n  // Run interaction category migration\n  const isComplete = await isDataMigrationComplete(database);\n\n  if (!isComplete) {\n\n    await migrateInteractionsToCategories(database);\n  } else {\n\n  }\n\n  // Ensure user_progress has v30 columns\n  await ensureUserProgressColumns(database);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/migrations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/AchievementUnlock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/ChipUsage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/CustomChip.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/EventSuggestionFeedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/Friend.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'writer' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Model, Query } from '@nozbe/watermelondb'\nimport { field, date, children, text, writer, readonly } from '@nozbe/watermelondb/decorators'\nimport { Associations } from '@nozbe/watermelondb/Model'\nimport { Archetype, Tier } from '@/shared/types/common'\nimport InteractionFriend from './InteractionFriend'\n\nexport default class Friend extends Model {\n  static table = 'friends'\n\n  static associations: Associations = {\n    interaction_friends: { type: 'has_many', foreignKey: 'friend_id' }\n  }\n\n  @children('interaction_friends') interactionFriends!: Query<InteractionFriend>\n\n  @text('name') name!: string\n  @field('dunbar_tier') dunbarTier!: string\n\n  get tier(): Tier {\n    return (this.dunbarTier as Tier) || 'Community'\n  }\n\n  @text('archetype') archetype!: Archetype\n  @field('weave_score') weaveScore!: number\n  @date('last_updated') lastUpdated!: Date\n  @readonly @date('created_at') createdAt!: Date\n\n  // Cloud sync fields (v31)\n  @field('user_id') userId?: string\n  @field('synced_at') syncedAt?: number\n  @text('sync_status') customSyncStatus?: 'synced' | 'pending'\n  @field('server_updated_at') serverUpdatedAt?: number\n\n  @text('photo_url') photoUrl?: string\n  @text('notes') notes?: string\n\n  @field('resilience') resilience!: number\n  @field('rated_weaves_count') ratedWeavesCount!: number\n  @field('momentum_score') momentumScore!: number\n  @date('momentum_last_updated') momentumLastUpdated!: Date\n  @field('is_dormant') isDormant!: boolean\n  @date('dormant_since') dormantSince?: Date\n\n  // Life events and relationship context\n  @text('birthday') birthday?: string // Format: \"MM-DD\"\n  @text('anniversary') anniversary?: string // Format: \"MM-DD\"\n  @text('relationship_type') relationshipType?: string\n\n  // Adaptive decay pattern learning (v21)\n  @field('typical_interval_days') typicalIntervalDays?: number\n  @field('tolerance_window_days') toleranceWindowDays?: number\n\n  // Learned effectiveness from feedback (v23)\n  @text('category_effectiveness') categoryEffectiveness?: string // JSON\n  @field('outcome_count') outcomeCount!: number\n\n  // Reciprocity tracking (v25)\n  @field('initiation_ratio') initiationRatio!: number // 0 = always friend, 1.0 = always user, 0.5 = balanced\n  @text('last_initiated_by') lastInitiatedBy?: string // 'user' | 'friend' | 'mutual'\n  @field('consecutive_user_initiations') consecutiveUserInitiations!: number\n  @field('total_user_initiations') totalUserInitiations!: number\n  @field('total_friend_initiations') totalFriendInitiations!: number\n\n  // Tier intelligence (v36)\n  @field('tier_fit_score') tierFitScore?: number // 0-1 score of how well patterns match tier\n  @field('tier_fit_last_calculated') tierFitLastCalculated?: number // When tier fit was last calculated\n  @text('suggested_tier') suggestedTier?: string // AI-suggested tier based on patterns\n  @field('tier_suggestion_dismissed_at') tierSuggestionDismissedAt?: number // When user dismissed suggestion\n\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/FriendBadge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/Group.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/GroupMember.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/Intention.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'writer' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Model, Query } from '@nozbe/watermelondb';\nimport { Associations } from '@nozbe/watermelondb/Model';\nimport { field, date, text, writer, readonly, children } from '@nozbe/watermelondb/decorators'\nimport IntentionFriend from './IntentionFriend';\n\nexport default class Intention extends Model {\n  static table = 'intentions';\n\n  static associations: Associations = {\n    intention_friends: { type: 'has_many', foreignKey: 'intention_id' },\n  };\n\n  @children('intention_friends') intentionFriends!: Query<IntentionFriend>;\n\n\n  // Flexible description - can be vague or specific\n  @text('description') description?: string;\n\n  // Optional category if they have specific activity in mind\n  @field('interaction_category') interactionCategory?: string;\n\n  // Status tracking\n  @field('status') status!: 'active' | 'converted' | 'dismissed' | 'fulfilled';\n\n  @readonly @date('created_at') createdAt!: Date;\n  @date('updated_at') updatedAt!: Date;\n\n  // Cloud sync fields (v31)\n  @field('user_id') userId?: string;\n  @field('synced_at') syncedAt?: number;\n  @text('sync_status') customSyncStatus?: string;\n  @field('server_updated_at') serverUpdatedAt?: number;\n\n  async prepareDestroyWithChildren() {\n    // Delete all associated intention friends\n    const friends = await this.intentionFriends.fetch();\n    const friendsToDelete = friends.map(friend => friend.prepareDestroyPermanently());\n    await this.batch(...friendsToDelete);\n\n    return this.prepareDestroyPermanently();\n  }\n\n  // Track when last reminded (for suggestion engine)\n  @date('last_reminded_at') lastRemindedAt?: Date;\n\n  // v29: Fulfillment tracking for pattern analysis and celebration\n  @text('linked_interaction_id') linkedInteractionId?: string; // The interaction that fulfilled this intention\n  @date('fulfilled_at') fulfilledAt?: Date; // When it was fulfilled\n  @field('days_to_fulfillment') daysToFulfillment?: number; // Time from creation to fulfillment\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/IntentionFriend.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/Interaction.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'writer' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Model } from '@nozbe/watermelondb'\nimport { field, date, children, text, writer, readonly } from '@nozbe/watermelondb/decorators'\nimport { Associations } from '@nozbe/watermelondb/Model'\nimport { type StructuredReflection } from '@/components/types'\n\nexport default class Interaction extends Model {\n  static table = 'interactions'\n\n  static associations: Associations = {\n    interaction_friends: { type: 'has_many', foreignKey: 'interaction_id' }\n  }\n\n  @children('interaction_friends') interactionFriends!: any\n\n  @date('interaction_date') interactionDate!: Date\n  @field('interaction_type') interactionType!: string\n  @field('duration') duration?: string\n  @field('vibe') vibe?: string\n  @text('note') note?: string\n\n  get notes(): string | undefined {\n    return this.note\n  }\n\n  set notes(value: string | undefined) {\n    this.note = value\n  }\n  @readonly @date('created_at') createdAt!: Date\n  @date('updated_at') updatedAt!: Date\n\n  // Cloud sync fields (v31)\n  @field('user_id') userId?: string\n  @field('synced_at') syncedAt?: number\n  @text('sync_status') customSyncStatus?: string\n  @field('server_updated_at') serverUpdatedAt?: number\n\n  @text('activity') activity!: string\n  @text('status') status!: string // 'planned' | 'pending_confirm' | 'completed' | 'cancelled' | 'missed'\n  @text('mode') mode!: string\n\n  // NEW: Simplified interaction category system\n  @field('interaction_category') interactionCategory?: string\n\n  // NEW: Structured reflection data (stored as JSON)\n  @text('reflection') reflectionJSON?: string\n\n  // v17: Custom title for weaves\n  @text('title') title?: string\n\n  // v17: Location (Phase 1 - text only, no coordinates yet)\n  @text('location') location?: string\n\n  // v17: Plan lifecycle tracking\n  @field('completion_prompted_at') completionPromptedAt?: number\n\n  // v18: Calendar integration\n  @text('calendar_event_id') calendarEventId?: string\n\n  // v24: Event importance for special occasions\n  @field('event_importance') eventImportance?: string // 'low' | 'medium' | 'high' | 'critical'\n\n  // v25: Reciprocity tracking\n  @field('initiator') initiator?: string // 'user' | 'friend' | 'mutual'\n\n  // Getter for parsed reflection\n  get reflection(): StructuredReflection | undefined {\n    if (!this.reflectionJSON) return undefined\n    try {\n      return JSON.parse(this.reflectionJSON)\n    } catch {\n      return undefined\n    }\n  }\n\n  async prepareDestroyWithChildren() {\n    const friends = await this.interactionFriends.fetch();\n    const friendsToDelete = friends.map((friend: any) => friend.prepareDestroyPermanently());\n    await this.batch(...friendsToDelete);\n    return this.prepareDestroyPermanently()\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/InteractionFriend.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/InteractionOutcome.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/JournalEntry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/JournalEntryFriend.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'text' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Model, Relation } from '@nozbe/watermelondb';\nimport { field, text, relation } from '@nozbe/watermelondb/decorators';\nimport JournalEntry from './JournalEntry';\nimport Friend from './Friend';\n\nexport default class JournalEntryFriend extends Model {\n  static table = 'journal_entry_friends';\n\n  @field('journal_entry_id') journalEntryId!: string;\n  @field('friend_id') friendId!: string;\n\n  @relation('journal_entries', 'journal_entry_id') journalEntry!: Relation<JournalEntry>;\n  @relation('friends', 'friend_id') friend!: Relation<Friend>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/LifeEvent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/NetworkHealthLog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/OracleInsight.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/OracleUsage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/PortfolioSnapshot.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/PracticeLog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/SocialBatteryLog.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'date' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readonly' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Model } from '@nozbe/watermelondb';\nimport { field, text, date, readonly } from '@nozbe/watermelondb/decorators';\n\nexport default class SocialBatteryLog extends Model {\n  static table = 'social_battery_logs';\n\n  @text('user_id') userId!: string;\n  @field('value') value!: number;\n  @field('timestamp') timestamp!: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/SocialSeasonLog.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'date' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readonly' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Model } from '@nozbe/watermelondb';\nimport { field, text, date, readonly } from '@nozbe/watermelondb/decorators';\n\nexport default class SocialSeasonLog extends Model {\n  static table = 'social_season_logs';\n\n  @text('user_id') userId!: string;\n  @text('season') season!: string; // 'resting' | 'flowing' | 'blooming'\n  @field('start_date') startDate!: number;\n  @field('end_date') endDate?: number;\n\n  // Analytics Fields\n  @field('manual_override') manualOverride!: boolean;\n  @field('battery_start') batteryStart!: number;\n  @field('battery_end') batteryEnd?: number;\n  @field('suggestions_shown') suggestionsShown!: number;\n  @field('suggestions_accepted') suggestionsAccepted!: number;\n  @field('avg_interaction_rating') avgInteractionRating!: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/SuggestionEvent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/UserProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/UserProgress.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/models/WeeklyReflection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/db/seeds/stress-test-seed-data.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TIERS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":23,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friendIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":229,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":229,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport JournalEntryFriend from '@/db/models/JournalEntryFriend';\nimport LifeEvent from '@/db/models/LifeEvent';\nimport Group from '@/db/models/Group';\nimport GroupMember from '@/db/models/GroupMember';\nimport { Archetype, Tier } from '@/components/types';\nimport { Q } from '@nozbe/watermelondb';\n\nconst ARCHETYPES: Archetype[] = [\n  'Emperor',\n  'Empress',\n  'HighPriestess',\n  'Fool',\n  'Sun',\n  'Hermit',\n  'Magician',\n];\n\nconst TIERS: Tier[] = ['InnerCircle', 'CloseFriends', 'Community'];\n\nconst ACTIVITY_TYPES = [\n  'Call',\n  'Text',\n  'Chat',\n  'Video Call',\n  'Dinner',\n  'Lunch',\n  'Coffee',\n  'Walk',\n  'Event',\n  'Party',\n  'Game Night',\n  'Movie',\n  'Concert',\n  'Adventure',\n  'Tea Time',\n];\n\nconst DURATIONS = ['Quick', 'Standard', 'Extended'];\nconst VIBES = ['NewMoon', 'WaxingCrescent', 'FirstQuarter', 'WaxingGibbous', 'FullMoon', 'WaningGibbous', 'LastQuarter', 'WaningCrescent'];\nconst MODES = ['solo', 'group'];\n\nconst REAL_NAMES = [\n  \"Emma\", \"Liam\", \"Olivia\", \"Noah\", \"Ava\", \"Oliver\", \"Isabella\", \"Elijah\", \"Sophia\", \"James\",\n  \"Charlotte\", \"William\", \"Amelia\", \"Benjamin\", \"Mia\", \"Lucas\", \"Harper\", \"Henry\", \"Evelyn\", \"Theodore\",\n  \"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eva\", \"Frank\", \"Grace\", \"Hannah\", \"Ivy\", \"Jack\",\n  \"Kara\", \"Leo\", \"Mona\", \"Nina\", \"Oscar\", \"Paul\", \"Quinn\", \"Rose\", \"Sam\", \"Tara\",\n  \"Uma\", \"Victor\", \"Wendy\", \"Xander\", \"Yara\", \"Zane\", \"Arthur\", \"Beatrice\", \"Caleb\", \"Diana\",\n  \"Edward\", \"Fiona\", \"George\", \"Hazel\", \"Isaac\", \"Julia\", \"Kevin\", \"Luna\", \"Max\", \"Nora\",\n  \"Owen\", \"Penelope\", \"Quentin\", \"Rachel\", \"Simon\", \"Tessa\", \"Ulysses\", \"Violet\", \"Walter\", \"Xena\",\n  \"Yusuf\", \"Zara\", \"Adam\", \"Bella\", \"Connor\", \"Daisy\", \"Ethan\", \"Flora\", \"Gavin\", \"Holly\",\n  \"Ian\", \"Jenny\", \"Kyle\", \"Lily\", \"Mason\", \"Natalie\", \"Peter\", \"Queen\", \"Ryan\", \"Sarah\",\n  \"Thomas\", \"Ursula\", \"Vincent\", \"Willow\", \"Xavier\", \"Yasmine\", \"Zachary\", \"Abigail\", \"Brian\", \"Chloe\"\n];\n\nconst GROUP_NAMES = [\"College Friends\", \"Work Colleagues\", \"Family\", \"Book Club\", \"Gym Buddies\", \"High School Crew\"];\n\n/**\n * Generate stress test seed data for testing app performance\n */\nexport async function generateStressTestData(\n  friendsCount: number = 100, // This parameter is kept for signature compatibility but we'll use REAL_NAMES.length\n  interactionsPerFriend: number = 10\n): Promise<void> {\n  const count = Math.min(friendsCount, REAL_NAMES.length);\n  console.log(`[StressTest] Generating ${count} friends with ${interactionsPerFriend} interactions each...`);\n\n  try {\n    await database.write(async () => {\n      const friends: FriendModel[] = [];\n      const createdGroups: Group[] = [];\n\n      // Create Groups\n      for (const groupName of GROUP_NAMES) {\n        const group = await database.get<Group>('groups').create((g) => {\n          g.name = groupName;\n          g.type = 'manual';\n        });\n        createdGroups.push(group);\n      }\n\n      // Create friends\n      for (let i = 0; i < count; i++) {\n        // Distribute tiers: 5 Inner Circle, 15 Close Friends, Rest Community\n        let tier: Tier = 'Community';\n        if (i < 5) tier = 'InnerCircle';\n        else if (i < 20) tier = 'CloseFriends';\n\n        const archetype = ARCHETYPES[Math.floor(Math.random() * ARCHETYPES.length)];\n        const weaveScore = Math.floor(Math.random() * 100);\n\n        const friend = await database.get<FriendModel>('friends').create((f) => {\n          f.name = REAL_NAMES[i];\n          f.dunbarTier = tier;\n          f.archetype = archetype;\n          f.photoUrl = ''; // Could add placeholder URLs if needed\n          f.notes = `Generated friend from stress test. Tier: ${tier}, Archetype: ${archetype}.`;\n          f.weaveScore = weaveScore;\n          f.lastUpdated = new Date();\n          f.resilience = 0.8 + (Math.random() * 0.7); // 0.8 to 1.5\n          f.ratedWeavesCount = Math.floor(Math.random() * 50);\n          f.momentumScore = Math.random() > 0.6 ? Math.floor(Math.random() * 30) : 0;\n          f.momentumLastUpdated = new Date();\n          f.isDormant = Math.random() > 0.9;\n          f.dormantSince = f.isDormant ? new Date(Date.now() - 60 * 24 * 60 * 60 * 1000) : undefined;\n\n          // Random birthday\n          const month = Math.floor(Math.random() * 12) + 1; // 1-12\n          const day = Math.floor(Math.random() * 28) + 1; // 1-28 safe\n          const monthStr = month.toString().padStart(2, '0');\n          const dayStr = day.toString().padStart(2, '0');\n          f.birthday = `${monthStr}-${dayStr}`;\n\n          f.anniversary = Math.random() > 0.8 ? `${monthStr}-${dayStr}` : undefined;\n          f.relationshipType = undefined;\n        });\n\n        friends.push(friend);\n\n        // Add to a random group (50% chance)\n        if (Math.random() > 0.5) {\n          const randomGroup = createdGroups[Math.floor(Math.random() * createdGroups.length)];\n          await database.get<GroupMember>('group_members').create((gm) => {\n            gm.groupId = randomGroup.id;\n            gm.friendId = friend.id;\n          });\n        }\n\n        // Create Life Events\n        if (Math.random() > 0.3) {\n          await database.get<LifeEvent>('life_events').create((le) => {\n            le.friendId = friend.id;\n            le.eventType = 'other';\n            le.title = 'Met at coffee shop';\n            le.eventDate = new Date(Date.now() - Math.floor(Math.random() * 365 * 2) * 24 * 60 * 60 * 1000);\n            le.importance = 'medium';\n            le.source = 'manual';\n            le.isRecurring = false;\n            le.reminded = false;\n          });\n        }\n      }\n\n      console.log(`[StressTest] Created ${friends.length} friends`);\n\n      // Create interactions and journal entries\n      let totalInteractions = 0;\n      for (const friend of friends) {\n        for (let j = 0; j < interactionsPerFriend; j++) {\n          const activity = ACTIVITY_TYPES[Math.floor(Math.random() * ACTIVITY_TYPES.length)];\n          const duration = DURATIONS[Math.floor(Math.random() * DURATIONS.length)];\n          const vibe = VIBES[Math.floor(Math.random() * VIBES.length)];\n          const mode = MODES[Math.floor(Math.random() * MODES.length)];\n          const status = Math.random() > 0.1 ? 'completed' : 'planned'; // Mostly completed\n\n          // Random date within the last year\n          const randomDaysAgo = Math.floor(Math.random() * 365);\n          const interactionDate = new Date(Date.now() - randomDaysAgo * 24 * 60 * 60 * 1000);\n\n          const interaction = await database.get<InteractionModel>('interactions').create((i) => {\n            i.interactionDate = interactionDate;\n            i.interactionType = status === 'completed' ? 'log' : 'plan';\n            i.activity = activity;\n            i.status = status;\n            i.mode = mode;\n            i.note = `Interaction ${j + 1} with ${friend.name}. It was ${vibe}.`;\n            i.vibe = vibe;\n            i.duration = duration;\n            i.title = `${activity} with ${friend.name}`;\n            i.location = Math.random() > 0.5 ? 'Local Cafe' : 'Park';\n            i.eventImportance = undefined;\n            i.initiator = Math.random() > 0.5 ? 'me' : 'them';\n          });\n\n          // Create join table entry\n          await database.get<InteractionFriend>('interaction_friends').create((ifriend) => {\n            ifriend.interactionId = interaction.id;\n            ifriend.friendId = friend.id;\n          });\n\n          // 20% chance to create a journal entry for this interaction\n          if (Math.random() < 0.2) {\n            const entry = await database.get<JournalEntry>('journal_entries').create((je) => {\n              je.entryDate = interactionDate.getTime();\n              je.title = `Reflecting on ${activity}`;\n              je.content = `Had a great time with ${friend.name} doing ${activity}. We talked about life and the future.`;\n              je.isDraft = false;\n              je.storyChipsRaw = JSON.stringify([{ chipId: 'joy', customText: 'Fun' }, { chipId: 'connection', customText: 'Deep' }]);\n            });\n\n            await database.get<JournalEntryFriend>('journal_entry_friends').create((jef) => {\n              jef.journalEntryId = entry.id;\n              jef.friendId = friend.id;\n            });\n          }\n\n          totalInteractions++;\n        }\n      }\n\n      console.log(`[StressTest] Created ${totalInteractions} interactions`);\n    });\n\n    console.log(`[StressTest] Stress test data generation complete!`);\n  } catch (error) {\n    console.error('[StressTest] Failed to generate stress test data:', error);\n    throw error;\n  }\n}\n\n/**\n * Clear all stress test data (useful for cleanup)\n */\nexport async function clearStressTestData(): Promise<void> {\n  console.log('[StressTest] Clearing stress test data...');\n\n  try {\n    await database.write(async () => {\n      // 1. Find all friends created by stress test\n      const allFriends = await database.get<FriendModel>('friends').query().fetch();\n      const stressTestFriends = allFriends.filter(f => f.notes && f.notes.includes('Generated friend from stress test'));\n\n      console.log(`[StressTest] Found ${stressTestFriends.length} stress test friends to delete.`);\n\n      const friendIds = stressTestFriends.map(f => f.id);\n\n      // Delete Friends and related data\n      for (const friend of stressTestFriends) {\n        // Delete Interaction Links\n        const interactionFriends = await database.get<InteractionFriend>('interaction_friends').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const if_ of interactionFriends) {\n          await if_.destroyPermanently();\n        }\n\n        // Delete Group Memberships\n        const groupMembers = await database.get<GroupMember>('group_members').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const gm of groupMembers) {\n          await gm.destroyPermanently();\n        }\n\n        // Delete Journal Entry Links\n        const journalEntryFriends = await database.get<JournalEntryFriend>('journal_entry_friends').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const jef of journalEntryFriends) {\n          await jef.destroyPermanently();\n        }\n\n        // Delete Life Events\n        const lifeEvents = await database.get<LifeEvent>('life_events').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const le of lifeEvents) {\n          await le.destroyPermanently();\n        }\n\n        // Delete Suggestion Events\n        const suggestionEvents = await database.get('suggestion_events').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const se of suggestionEvents) {\n          await se.destroyPermanently();\n        }\n\n        // Delete Intention Friends\n        const intentionFriends = await database.get('intention_friends').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const if_ of intentionFriends) {\n          await if_.destroyPermanently();\n        }\n\n        // Delete Friend Badges\n        const friendBadges = await database.get('friend_badges').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const fb of friendBadges) {\n          await fb.destroyPermanently();\n        }\n\n        // Delete Achievement Unlocks (related to friend)\n        const achievementUnlocks = await database.get('achievement_unlocks').query(\n          Q.where('related_friend_id', friend.id)\n        ).fetch();\n        for (const au of achievementUnlocks) {\n          await au.destroyPermanently();\n        }\n\n        // Delete Chip Usage (related to friend)\n        const chipUsage = await database.get('chip_usage').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const cu of chipUsage) {\n          await cu.destroyPermanently();\n        }\n\n        // Delete Interaction Outcomes\n        const interactionOutcomes = await database.get('interaction_outcomes').query(\n          Q.where('friend_id', friend.id)\n        ).fetch();\n        for (const io of interactionOutcomes) {\n          await io.destroyPermanently();\n        }\n\n        await friend.destroyPermanently();\n      }\n\n      // Cleanup orphaned interactions\n      const allInteractions = await database.get<InteractionModel>('interactions').query().fetch();\n      const allInteractionFriends = await database.get<InteractionFriend>('interaction_friends').query().fetch();\n      const linkedInteractionIds = new Set(allInteractionFriends.map(if_ => if_.interactionId));\n\n      let deletedInteractions = 0;\n      for (const interaction of allInteractions) {\n        if (!linkedInteractionIds.has(interaction.id)) {\n          // Also delete chip usage for this interaction\n          const interactionChipUsage = await database.get('chip_usage').query(\n            Q.where('interaction_id', interaction.id)\n          ).fetch();\n          for (const cu of interactionChipUsage) {\n            await cu.destroyPermanently();\n          }\n\n          // Also delete interaction outcomes for this interaction\n          const interactionOutcomes = await database.get('interaction_outcomes').query(\n            Q.where('interaction_id', interaction.id)\n          ).fetch();\n          for (const io of interactionOutcomes) {\n            await io.destroyPermanently();\n          }\n\n          await interaction.destroyPermanently();\n          deletedInteractions++;\n        }\n      }\n      console.log(`[StressTest] Deleted ${deletedInteractions} orphaned interactions.`);\n\n      // Cleanup orphaned Journal Entries\n      const allJournalEntries = await database.get<JournalEntry>('journal_entries').query().fetch();\n      const allJournalEntryFriends = await database.get<JournalEntryFriend>('journal_entry_friends').query().fetch();\n      const linkedJournalEntryIds = new Set(allJournalEntryFriends.map(jef => jef.journalEntryId));\n\n      let deletedJournalEntries = 0;\n      for (const entry of allJournalEntries) {\n        if (!linkedJournalEntryIds.has(entry.id)) {\n          await entry.destroyPermanently();\n          deletedJournalEntries++;\n        }\n      }\n      console.log(`[StressTest] Deleted ${deletedJournalEntries} orphaned journal entries.`);\n\n      // Cleanup Groups created by stress test\n      const groups = await database.get<Group>('groups').query(\n        Q.where('name', Q.oneOf(GROUP_NAMES))\n      ).fetch();\n\n      for (const group of groups) {\n        // Only delete if empty\n        const members = await database.get<GroupMember>('group_members').query(\n          Q.where('group_id', group.id)\n        ).fetch();\n        if (members.length === 0) {\n          await group.destroyPermanently();\n        }\n      }\n\n    });\n\n    console.log('[StressTest] Stress test data cleared!');\n  } catch (error) {\n    console.error('[StressTest] Failed to clear stress test data:', error);\n    throw error;\n  }\n}\n\n/**\n * Get stats about current data\n */\nexport async function getDataStats(): Promise<{\n  totalFriends: number;\n  totalInteractions: number;\n  stressTestFriends: number;\n  averageInteractionsPerFriend: number;\n  totalJournalEntries: number;\n  totalGroups: number;\n}> {\n  const allFriends = await database.get<FriendModel>('friends').query().fetch();\n  const allInteractions = await database.get<InteractionModel>('interactions').query().fetch();\n  const allJournalEntries = await database.get<JournalEntry>('journal_entries').query().fetch();\n  const allGroups = await database.get<Group>('groups').query().fetch();\n\n  const stressTestFriends = allFriends.filter((f) => f.notes && f.notes.includes('Generated friend from stress test'));\n\n  return {\n    totalFriends: allFriends.length,\n    totalInteractions: allInteractions.length,\n    stressTestFriends: stressTestFriends.length,\n    averageInteractionsPerFriend:\n      allFriends.length > 0 ? allInteractions.length / allFriends.length : 0,\n    totalJournalEntries: allJournalEntries.length,\n    totalGroups: allGroups.length\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/_template/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/_template/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/components/SyncConflictModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/hooks/useFeatureGate.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usage' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":40,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tier' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":140,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":140,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Feature Gating Hook\n * Easy-to-use React hook for checking feature access and limits\n */\n\nimport { useAuthStore } from '../store/auth.store';\nimport {\n  hasFeatureAccess,\n  isAtLimit,\n  getRemainingQuota,\n  getUpgradeMessage,\n  TIER_LIMITS,\n  type SubscriptionTier,\n} from '../services/subscription-tiers';\nimport { Alert } from 'react-native';\nimport { router } from 'expo-router';\n\ninterface FeatureGateResult {\n  // Access checks\n  hasAccess: boolean;\n  tier: SubscriptionTier;\n\n  // Quota checks\n  isAtLimit: boolean;\n  remaining: number;\n  limit: number;\n\n  // Actions\n  showUpgradePrompt: (customMessage?: string) => void;\n  navigateToUpgrade: () => void;\n}\n\n/**\n * Hook to check feature access for boolean features\n */\nexport function useFeatureGate(\n  feature: keyof typeof TIER_LIMITS.free\n): FeatureGateResult {\n  const tier = useAuthStore(state => state.getTier());\n  const usage = useAuthStore(state => state.usage);\n\n  const access = hasFeatureAccess(tier, feature);\n\n  const showUpgradePrompt = (customMessage?: string) => {\n    const message = customMessage || getUpgradeMessage(tier, feature as any);\n\n    Alert.alert(\n      'Upgrade Required',\n      message,\n      [\n        { text: 'Not Now', style: 'cancel' },\n        {\n          text: 'Upgrade',\n          onPress: () => router.push('/(tabs)/settings?showUpgrade=true'),\n        },\n      ]\n    );\n  };\n\n  const navigateToUpgrade = () => {\n    router.push('/(tabs)/settings?showUpgrade=true');\n  };\n\n  return {\n    hasAccess: access,\n    tier,\n    isAtLimit: false,\n    remaining: Infinity,\n    limit: Infinity,\n    showUpgradePrompt,\n    navigateToUpgrade,\n  };\n}\n\n/**\n * Hook to check quota-based features (friends, weaves, etc.)\n */\nexport function useQuotaGate(\n  feature: 'maxFriends' | 'maxWeavesPerMonth' | 'maxPhotosPerFriend' | 'maxDevices'\n): FeatureGateResult {\n  const tier = useAuthStore(state => state.getTier());\n  const usage = useAuthStore(state => state.usage);\n\n  const limit = TIER_LIMITS[tier][feature];\n  let currentUsage = 0;\n\n  // Map feature to usage stat\n  if (feature === 'maxFriends') {\n    currentUsage = usage?.friendsCount ?? 0;\n  } else if (feature === 'maxWeavesPerMonth') {\n    currentUsage = usage?.weavesThisMonth ?? 0;\n  }\n\n  const atLimit = isAtLimit(tier, feature, currentUsage);\n  const remaining = getRemainingQuota(tier, feature, currentUsage);\n\n  const showUpgradePrompt = (customMessage?: string) => {\n    const defaultMessage = `You've reached your ${feature} limit (${limit}). Upgrade to increase your limit!`;\n    const message = customMessage || defaultMessage;\n\n    Alert.alert(\n      'Limit Reached',\n      message,\n      [\n        { text: 'Not Now', style: 'cancel' },\n        {\n          text: 'Upgrade',\n          onPress: () => router.push('/(tabs)/settings?showUpgrade=true'),\n        },\n      ]\n    );\n  };\n\n  const navigateToUpgrade = () => {\n    router.push('/(tabs)/settings?showUpgrade=true');\n  };\n\n  return {\n    hasAccess: !atLimit,\n    tier,\n    isAtLimit: atLimit,\n    remaining,\n    limit: limit === Infinity ? Infinity : limit,\n    showUpgradePrompt,\n    navigateToUpgrade,\n  };\n}\n\n/**\n * Hook to check if user can perform an action\n * Combines access check + quota check\n */\nexport function useCanPerformAction(\n  action: 'addFriend' | 'logWeave' | 'accessJournal' | 'exportData' | 'useAI'\n): {\n  canPerform: boolean;\n  reason?: string;\n  showBlocker: () => void;\n} {\n  const tier = useAuthStore(state => state.getTier());\n  const friendsGate = useQuotaGate('maxFriends');\n  const weavesGate = useQuotaGate('maxWeavesPerMonth');\n  const journalAccess = useFeatureGate('canAccessJournal');\n  const exportAccess = useFeatureGate('canExportData');\n  const aiAccess = useFeatureGate('canUseAIInsights');\n\n  switch (action) {\n    case 'addFriend':\n      return {\n        canPerform: !friendsGate.isAtLimit,\n        reason: friendsGate.isAtLimit\n          ? `Friend limit reached (${friendsGate.limit})`\n          : undefined,\n        showBlocker: () => friendsGate.showUpgradePrompt(),\n      };\n\n    case 'logWeave':\n      return {\n        canPerform: !weavesGate.isAtLimit,\n        reason: weavesGate.isAtLimit\n          ? `Monthly weave limit reached (${weavesGate.limit})`\n          : undefined,\n        showBlocker: () => weavesGate.showUpgradePrompt(),\n      };\n\n    case 'accessJournal':\n      return {\n        canPerform: journalAccess.hasAccess,\n        reason: !journalAccess.hasAccess\n          ? 'Journal is only available for Plus and Premium tiers'\n          : undefined,\n        showBlocker: () => journalAccess.showUpgradePrompt(),\n      };\n\n    case 'exportData':\n      return {\n        canPerform: exportAccess.hasAccess,\n        reason: !exportAccess.hasAccess\n          ? 'Data export is only available for Plus and Premium tiers'\n          : undefined,\n        showBlocker: () => exportAccess.showUpgradePrompt(),\n      };\n\n    case 'useAI':\n      return {\n        canPerform: aiAccess.hasAccess,\n        reason: !aiAccess.hasAccess\n          ? 'AI Insights are only available for Premium tier'\n          : undefined,\n        showBlocker: () => aiAccess.showUpgradePrompt(),\n      };\n\n    default:\n      return {\n        canPerform: true,\n        showBlocker: () => { },\n      };\n  }\n}\n\n/**\n * Hook to get current tier display info\n */\nexport function useTierInfo() {\n  const tier = useAuthStore(state => state.getTier());\n  const subscription = useAuthStore(state => state.subscription);\n\n  const tierDisplay = {\n    free: { name: 'Free', color: '#6B7280', icon: '🌱' },\n    plus: { name: 'Plus', color: '#8B5CF6', icon: '⭐' },\n    premium: { name: 'Premium', color: '#F59E0B', icon: '👑' },\n  };\n\n  return {\n    tier,\n    display: tierDisplay[tier],\n    isActive: subscription?.status === 'active' || subscription?.status === 'trialing',\n    isTrial: subscription?.status === 'trialing',\n    trialEndsAt: subscription?.trialEndsAt,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/__tests__/sync-engine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/background-event-sync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/data-export.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'shareError' is defined but never used.","line":215,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":215,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport UserProgress from '@/db/models/UserProgress';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { Platform, Alert, Share } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\nimport * as Application from 'expo-application';\n\ninterface ExportData {\n  exportDate: string;\n  appVersion: string;\n  platform: string;\n  friends: Array<{\n    id: string;\n    name: string;\n    dunbarTier: string;\n    archetype: string;\n    photoUrl: string | null;\n    notes: string | null;\n    weaveScore: number;\n    lastUpdated: string;\n    resilience: number;\n    ratedWeavesCount: number;\n    momentumScore: number;\n    momentumLastUpdated: string;\n    isDormant: boolean;\n    dormantSince: string | null;\n    birthday: string | null;\n    anniversary: string | null;\n    relationshipType: string | null;\n  }>;\n  interactions: Array<{\n    id: string;\n    interactionDate: string;\n    interactionType: string;\n    activity: string;\n    status: string;\n    mode: string;\n    note: string | null;\n    vibe: string | null;\n    duration: string | null;\n    title: string | null;\n    location: string | null;\n    eventImportance: string | null;\n    initiator: string | null;\n    friendIds: string[];\n  }>;\n  userProgress: {\n    totalWeaves: number;\n    curatorProgress: number;\n  } | null;\n  stats: {\n    totalFriends: number;\n    totalInteractions: number;\n    completedInteractions: number;\n    plannedInteractions: number;\n    averageWeaveScore: number;\n  };\n}\n\n/**\n * Export all user data to JSON\n */\nexport async function exportAllData(): Promise<string> {\n  try {\n\n\n    // Fetch all data\n    const friends = await database.get<FriendModel>('friends').query().fetch();\n    const interactions = await database.get<InteractionModel>('interactions').query().fetch();\n    const interactionFriends = await database\n      .get<InteractionFriend>('interaction_friends')\n      .query()\n      .fetch();\n    const userProgressRecords = await database.get<UserProgress>('user_progress').query().fetch();\n\n    // Format friends data\n    const friendsData = friends.map((f) => ({\n      id: f.id,\n      name: f.name,\n      dunbarTier: f.dunbarTier,\n      archetype: f.archetype,\n      photoUrl: f.photoUrl || null,\n      notes: f.notes || null,\n      weaveScore: f.weaveScore,\n      lastUpdated: f.lastUpdated.toISOString(),\n      resilience: f.resilience,\n      ratedWeavesCount: f.ratedWeavesCount,\n      momentumScore: f.momentumScore,\n      momentumLastUpdated: f.momentumLastUpdated.toISOString(),\n      isDormant: f.isDormant,\n      dormantSince: f.dormantSince?.toISOString() || null,\n      birthday: f.birthday || null,\n      anniversary: f.anniversary || null,\n      relationshipType: f.relationshipType || null,\n    }));\n\n    // Create a map of interactionId -> friendIds for O(1) lookup\n    const interactionFriendMap = new Map<string, string[]>();\n    for (const if_ of interactionFriends) {\n      if (!interactionFriendMap.has(if_.interactionId)) {\n        interactionFriendMap.set(if_.interactionId, []);\n      }\n      interactionFriendMap.get(if_.interactionId)?.push(if_.friendId);\n    }\n\n    // Format interactions data with linked friends\n    const interactionsData = interactions.map((i) => {\n      const linkedFriends = interactionFriendMap.get(i.id) || [];\n\n      return {\n        id: i.id,\n        interactionDate: i.interactionDate.toISOString(),\n        interactionType: i.interactionType,\n        activity: i.activity,\n        status: i.status,\n        mode: i.mode,\n        note: i.note || null,\n        vibe: i.vibe || null,\n        duration: i.duration || null,\n        title: i.title || null,\n        location: i.location || null,\n        eventImportance: i.eventImportance || null,\n        initiator: i.initiator || null,\n        friendIds: linkedFriends,\n      };\n    });\n\n    // Calculate stats\n    const completedInteractions = interactions.filter((i) => i.status === 'completed').length;\n    const plannedInteractions = interactions.filter((i) => i.status === 'planned').length;\n    const averageWeaveScore =\n      friends.length > 0\n        ? friends.reduce((sum, f) => sum + f.weaveScore, 0) / friends.length\n        : 0;\n\n    const exportData: ExportData = {\n      exportDate: new Date().toISOString(),\n      appVersion: Application.nativeApplicationVersion || '1.0.0',\n      platform: Platform.OS,\n      friends: friendsData,\n      interactions: interactionsData,\n      userProgress: userProgressRecords[0]\n        ? {\n          totalWeaves: userProgressRecords[0].totalWeaves,\n          curatorProgress: userProgressRecords[0].curatorProgress,\n        }\n        : null,\n      stats: {\n        totalFriends: friends.length,\n        totalInteractions: interactions.length,\n        completedInteractions,\n        plannedInteractions,\n        averageWeaveScore: Math.round(averageWeaveScore * 100) / 100,\n      },\n    };\n\n    const jsonString = JSON.stringify(exportData, null, 2);\n\n\n    return jsonString;\n  } catch (error) {\n    console.error('[DataExport] Failed to export data:', error);\n    throw error;\n  }\n}\n\n/**\n * Export data and save as file, then share\n */\nexport async function exportAndShareData(): Promise<void> {\n  try {\n    const jsonString = await exportAllData();\n\n    // Save to AsyncStorage as backup\n    const exportKey = `@weave:export_${Date.now()}`;\n    await AsyncStorage.setItem(exportKey, jsonString);\n\n\n    // Save to file system\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n    const fileName = `weave-export-${timestamp}.json`;\n    const fileUri = FileSystem.documentDirectory + fileName;\n\n    await FileSystem.writeAsStringAsync(fileUri, jsonString);\n\n\n\n    // Share the file\n    const stats = await getExportStats();\n    const shareMessage = `Weave Data Export\\n\\nFriends: ${stats.totalFriends}\\nInteractions: ${stats.totalInteractions}\\nExport Date: ${new Date().toLocaleDateString()}\\n\\nThis file contains all your Weave data and can be used to restore your profile.`;\n\n    try {\n      const result = await Share.share({\n        message: shareMessage,\n        url: fileUri,\n        title: 'Export Weave Data',\n      });\n\n      if (result.action === Share.sharedAction) {\n        Alert.alert(\n          'Export Successful',\n          `Your data has been exported successfully!\\n\\n${stats.totalFriends} friends\\n${stats.totalInteractions} interactions\\n\\nFile saved to: ${fileName}`,\n          [{ text: 'OK' }]\n        );\n      } else if (result.action === Share.dismissedAction) {\n        Alert.alert(\n          'Export Saved',\n          `Your data has been saved to:\\n${fileName}\\n\\nYou can find it in your app's documents folder.`,\n          [{ text: 'OK' }]\n        );\n      }\n    } catch (shareError) {\n      // If sharing fails, at least the file is saved\n      Alert.alert(\n        'Export Saved',\n        `Your data has been saved to:\\n${fileName}\\n\\nLocation: ${fileUri}\\n\\nYou can access this file through your device's file manager.`,\n        [{ text: 'OK' }]\n      );\n    }\n\n\n  } catch (error) {\n    console.error('[DataExport] Failed to export and share data:', error);\n    Alert.alert('Export Failed', 'Failed to export data. Please try again.');\n    throw error;\n  }\n}\n\n/**\n * Get export stats without exporting the full data\n */\nexport async function getExportStats(): Promise<{\n  totalFriends: number;\n  totalInteractions: number;\n  estimatedSizeKB: number;\n}> {\n  try {\n    const friends = await database.get<FriendModel>('friends').query().fetch();\n    const interactions = await database.get<InteractionModel>('interactions').query().fetch();\n\n    // Rough estimate: each friend ~500 bytes, each interaction ~300 bytes\n    const estimatedSize = friends.length * 500 + interactions.length * 300;\n\n    return {\n      totalFriends: friends.length,\n      totalInteractions: interactions.length,\n      estimatedSizeKB: Math.round(estimatedSize / 1024),\n    };\n  } catch (error) {\n    console.error('[DataExport] Failed to get export stats:', error);\n    return {\n      totalFriends: 0,\n      totalInteractions: 0,\n      estimatedSizeKB: 0,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/data-import.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport UserProgress from '@/db/models/UserProgress';\nimport { Q } from '@nozbe/watermelondb';\n\ninterface ExportData {\n  exportDate: string;\n  appVersion: string;\n  platform: string;\n  friends: Array<{\n    id: string;\n    name: string;\n    dunbarTier: string;\n    archetype: string;\n    photoUrl: string | null;\n    notes: string | null;\n    weaveScore: number;\n    lastUpdated: string;\n    resilience: number;\n    ratedWeavesCount: number;\n    momentumScore: number;\n    momentumLastUpdated: string;\n    isDormant: boolean;\n    dormantSince: string | null;\n    birthday: string | null;\n    anniversary: string | null;\n    relationshipType: string | null;\n  }>;\n  interactions: Array<{\n    id: string;\n    interactionDate: string;\n    interactionType: string;\n    activity: string;\n    status: string;\n    mode: string;\n    note: string | null;\n    vibe: string | null;\n    duration: string | null;\n    title: string | null;\n    location: string | null;\n    eventImportance: string | null;\n    initiator: string | null;\n    friendIds: string[];\n  }>;\n  userProgress: {\n    totalWeaves: number;\n    curatorProgress: number;\n  } | null;\n  stats: {\n    totalFriends: number;\n    totalInteractions: number;\n    completedInteractions: number;\n    plannedInteractions: number;\n    averageWeaveScore: number;\n  };\n}\n\nexport interface ImportResult {\n  success: boolean;\n  friendsImported: number;\n  interactionsImported: number;\n  userProgressImported: boolean;\n  errors: string[];\n}\n\n/**\n * Validate imported JSON data\n */\nexport function validateImportData(jsonString: string): {\n  valid: boolean;\n  data?: ExportData;\n  error?: string;\n} {\n  try {\n    const data = JSON.parse(jsonString) as ExportData;\n\n    // Check required fields\n    if (!data.exportDate || !data.friends || !data.interactions) {\n      return {\n        valid: false,\n        error: 'Invalid export format: missing required fields',\n      };\n    }\n\n    // Validate friends array\n    if (!Array.isArray(data.friends)) {\n      return {\n        valid: false,\n        error: 'Invalid export format: friends must be an array',\n      };\n    }\n\n    // Validate interactions array\n    if (!Array.isArray(data.interactions)) {\n      return {\n        valid: false,\n        error: 'Invalid export format: interactions must be an array',\n      };\n    }\n\n    // Check each friend has required fields\n    for (const friend of data.friends) {\n      if (!friend.id || !friend.name || !friend.dunbarTier || !friend.archetype) {\n        return {\n          valid: false,\n          error: 'Invalid friend data: missing required fields',\n        };\n      }\n    }\n\n    // Check each interaction has required fields\n    for (const interaction of data.interactions) {\n      if (\n        !interaction.id ||\n        !interaction.interactionDate ||\n        !interaction.interactionType ||\n        !interaction.status\n      ) {\n        return {\n          valid: false,\n          error: 'Invalid interaction data: missing required fields',\n        };\n      }\n    }\n\n    return { valid: true, data };\n  } catch (error) {\n    return {\n      valid: false,\n      error: `Failed to parse JSON: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    };\n  }\n}\n\n/**\n * Clear all existing data from the database\n */\nexport async function clearAllData(): Promise<void> {\n\n\n  await database.write(async () => {\n    // Delete all interaction_friends first (foreign key constraint)\n    const interactionFriends = await database\n      .get<InteractionFriend>('interaction_friends')\n      .query()\n      .fetch();\n    for (const if_ of interactionFriends) {\n      await if_.markAsDeleted();\n    }\n\n    // Delete all interactions\n    const interactions = await database.get<InteractionModel>('interactions').query().fetch();\n    for (const interaction of interactions) {\n      await interaction.markAsDeleted();\n    }\n\n    // Delete all friends\n    const friends = await database.get<FriendModel>('friends').query().fetch();\n    for (const friend of friends) {\n      await friend.markAsDeleted();\n    }\n\n    // Delete user progress\n    const userProgressRecords = await database.get<UserProgress>('user_progress').query().fetch();\n    for (const record of userProgressRecords) {\n      await record.markAsDeleted();\n    }\n  });\n\n\n}\n\n/**\n * Import data from JSON export\n * @param jsonString - The exported JSON data\n * @param clearExisting - If true, clears all existing data before import\n */\nexport async function importData(\n  jsonString: string,\n  clearExisting: boolean = true\n): Promise<ImportResult> {\n  const result: ImportResult = {\n    success: false,\n    friendsImported: 0,\n    interactionsImported: 0,\n    userProgressImported: false,\n    errors: [],\n  };\n\n  try {\n\n\n    // Validate data\n    const validation = validateImportData(jsonString);\n    if (!validation.valid || !validation.data) {\n      result.errors.push(validation.error || 'Invalid data');\n      return result;\n    }\n\n    const data = validation.data;\n\n    // Clear existing data if requested\n    if (clearExisting) {\n      try {\n        await clearAllData();\n      } catch (error) {\n        result.errors.push(`Failed to clear existing data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        return result;\n      }\n    }\n\n    // Import in a single transaction\n    await database.write(async () => {\n      const friendsCollection = database.get<FriendModel>('friends');\n      const interactionsCollection = database.get<InteractionModel>('interactions');\n      const interactionFriendsCollection = database.get<InteractionFriend>('interaction_friends');\n      const userProgressCollection = database.get<UserProgress>('user_progress');\n\n      // Import friends\n\n      for (const friendData of data.friends) {\n        try {\n          // Check if friend already exists (in merge mode)\n          if (!clearExisting) {\n            const existing = await friendsCollection.find(friendData.id).catch(() => null);\n            if (existing) {\n\n              continue;\n            }\n          }\n\n          await friendsCollection.create((friend) => {\n            friend._raw.id = friendData.id;\n            friend.name = friendData.name;\n            friend.dunbarTier = friendData.dunbarTier;\n            friend.archetype = friendData.archetype as any;\n            friend.photoUrl = friendData.photoUrl || '';\n            friend.notes = friendData.notes || '';\n            friend.weaveScore = friendData.weaveScore;\n            friend.lastUpdated = new Date(friendData.lastUpdated);\n            friend.resilience = friendData.resilience;\n            friend.ratedWeavesCount = friendData.ratedWeavesCount;\n            friend.momentumScore = friendData.momentumScore;\n            friend.momentumLastUpdated = new Date(friendData.momentumLastUpdated);\n            friend.isDormant = friendData.isDormant;\n            friend.dormantSince = friendData.dormantSince ? new Date(friendData.dormantSince) : undefined;\n            friend.birthday = friendData.birthday || undefined;\n            friend.anniversary = friendData.anniversary || undefined;\n            friend.relationshipType = friendData.relationshipType || undefined;\n          });\n\n          result.friendsImported++;\n        } catch (error) {\n          result.errors.push(\n            `Failed to import friend ${friendData.name}: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n\n      // Import interactions\n\n      for (const interactionData of data.interactions) {\n        try {\n          // Check if interaction already exists (in merge mode)\n          if (!clearExisting) {\n            const existing = await interactionsCollection.find(interactionData.id).catch(() => null);\n            if (existing) {\n\n              continue;\n            }\n          }\n\n          await interactionsCollection.create((interaction) => {\n            interaction._raw.id = interactionData.id;\n            interaction.interactionDate = new Date(interactionData.interactionDate);\n            interaction.interactionType = interactionData.interactionType;\n            interaction.activity = interactionData.activity || '';\n            interaction.status = interactionData.status;\n            interaction.mode = interactionData.mode || '';\n            interaction.note = interactionData.note || '';\n            interaction.vibe = interactionData.vibe || '';\n            interaction.duration = interactionData.duration || '';\n            interaction.title = interactionData.title || undefined;\n            interaction.location = interactionData.location || undefined;\n            interaction.eventImportance = interactionData.eventImportance || undefined;\n            interaction.initiator = interactionData.initiator || undefined;\n          });\n\n          // Create interaction-friend links\n          for (const friendId of interactionData.friendIds) {\n            await interactionFriendsCollection.create((link) => {\n              link.interactionId = interactionData.id;\n              link.friendId = friendId;\n            });\n          }\n\n          result.interactionsImported++;\n        } catch (error) {\n          result.errors.push(\n            `Failed to import interaction ${interactionData.id}: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n\n      // Import user progress\n      if (data.userProgress) {\n\n        try {\n          // Check if user progress exists\n          const existingProgress = await userProgressCollection.query().fetch();\n\n          if (existingProgress.length > 0 && !clearExisting) {\n            // Update existing record\n            await existingProgress[0].update((progress) => {\n              progress.totalWeaves = data.userProgress!.totalWeaves;\n              progress.curatorProgress = data.userProgress!.curatorProgress;\n            });\n          } else {\n            // Create new record\n            await userProgressCollection.create((progress) => {\n              progress.totalWeaves = data.userProgress!.totalWeaves;\n              progress.curatorProgress = data.userProgress!.curatorProgress;\n            });\n          }\n\n          result.userProgressImported = true;\n        } catch (error) {\n          result.errors.push(\n            `Failed to import user progress: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n    });\n\n    result.success = true;\n\n  } catch (error) {\n    result.errors.push(\n      `Import failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n    console.error('[DataImport] Import failed:', error);\n  }\n\n  return result;\n}\n\n/**\n * Get preview of import data without importing\n */\nexport function getImportPreview(jsonString: string): {\n  valid: boolean;\n  preview?: {\n    exportDate: string;\n    totalFriends: number;\n    totalInteractions: number;\n    platform: string;\n    appVersion: string;\n  };\n  error?: string;\n} {\n  const validation = validateImportData(jsonString);\n\n  if (!validation.valid || !validation.data) {\n    return {\n      valid: false,\n      error: validation.error,\n    };\n  }\n\n  const data = validation.data;\n\n  return {\n    valid: true,\n    preview: {\n      exportDate: data.exportDate,\n      totalFriends: data.friends.length,\n      totalInteractions: data.interactions.length,\n      platform: data.platform,\n      appVersion: data.appVersion,\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/subscription-tiers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/supabase.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DummySupabaseClient' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Supabase Client Configuration\n * Handles authentication and cloud sync for Weave\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport * as SecureStore from 'expo-secure-store';\nimport * as WebBrowser from 'expo-web-browser';\n\n// Important: Complete auth session for OAuth flows\nWebBrowser.maybeCompleteAuthSession();\n\n// Supabase configuration\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY;\n\n/**\n * Main Supabase client instance\n * Used for all auth and database operations\n */\n\n// Define a partial interface for the dummy client to avoid 'any'\ninterface DummySupabaseClient {\n  auth: {\n    getSession: () => Promise<{ data: { session: null }, error: null }>;\n    onAuthStateChange: () => { data: { subscription: { unsubscribe: () => void } } };\n    signInWithOAuth: () => Promise<{ error: { message: string } }>;\n    signOut: () => Promise<{ error: null }>;\n  };\n  from: () => {\n    select: () => { data: any[], error: { message: string } };\n    insert: () => { data: null, error: { message: string } };\n    update: () => { data: null, error: { message: string } };\n    delete: () => { data: null, error: { message: string } };\n    upload: () => { data: null, error: { message: string } };\n    getPublicUrl: () => { data: { publicUrl: string } };\n    remove: () => { error: { message: string } };\n  };\n  storage: {\n    from: (bucket: string) => {\n      upload: () => { data: null, error: { message: string } };\n      getPublicUrl: () => { data: { publicUrl: string } };\n      remove: () => { error: { message: string } };\n    };\n  };\n}\n\nconst ExpoSecureStoreAdapter = {\n  getItem: (key: string) => {\n    return SecureStore.getItemAsync(key);\n  },\n  setItem: (key: string, value: string) => {\n    SecureStore.setItemAsync(key, value);\n  },\n  removeItem: (key: string) => {\n    SecureStore.deleteItemAsync(key);\n  },\n};\n\nexport const supabase = (() => {\n  if (!supabaseUrl || !supabaseAnonKey) {\n    console.warn(\n      'Missing Supabase environment variables. Cloud sync will be disabled.\\n' +\n      'Add EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY to .env'\n    );\n\n    // Return a dummy client that warns on usage but doesn't crash\n    // This allows the app to load even if Supabase isn't configured\n    return {\n      auth: {\n        getSession: async () => ({ data: { session: null }, error: null }),\n        onAuthStateChange: () => ({ data: { subscription: { unsubscribe: () => { } } } }),\n        signInWithOAuth: async () => ({ error: { message: 'Supabase not configured' } }),\n        signOut: async () => ({ error: null }),\n      },\n      from: () => ({\n        select: () => ({ data: [], error: { message: 'Supabase not configured' } }),\n        insert: () => ({ data: null, error: { message: 'Supabase not configured' } }),\n        update: () => ({ data: null, error: { message: 'Supabase not configured' } }),\n        delete: () => ({ data: null, error: { message: 'Supabase not configured' } }),\n        upload: () => ({ data: null, error: { message: 'Supabase not configured' } }),\n        getPublicUrl: () => ({ data: { publicUrl: '' } }),\n        remove: () => ({ error: { message: 'Supabase not configured' } }),\n      }),\n      storage: {\n        from: () => ({\n          upload: () => ({ data: null, error: { message: 'Supabase not configured' } }),\n          getPublicUrl: () => ({ data: { publicUrl: '' } }),\n          remove: () => ({ error: { message: 'Supabase not configured' } }),\n        }),\n      }\n    } as unknown as TypedSupabaseClient;\n  }\n\n  return createClient(supabaseUrl, supabaseAnonKey, {\n    auth: {\n      storage: ExpoSecureStoreAdapter as any,\n      autoRefreshToken: true,\n      persistSession: true,\n      detectSessionInUrl: false,\n    },\n  });\n})();\n\n/**\n * Database types for TypeScript\n * Auto-generated from Supabase schema\n */\nexport type Database = {\n  public: {\n    Tables: {\n      user_subscriptions: {\n        Row: {\n          id: string;\n          user_id: string;\n          tier: 'free' | 'plus' | 'premium';\n          status: 'active' | 'canceled' | 'past_due' | 'trialing';\n          stripe_customer_id: string | null;\n          stripe_subscription_id: string | null;\n          trial_ends_at: string | null;\n          current_period_start: string | null;\n          current_period_end: string | null;\n          canceled_at: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: Omit<Database['public']['Tables']['user_subscriptions']['Row'], 'id' | 'created_at' | 'updated_at'>;\n        Update: Partial<Database['public']['Tables']['user_subscriptions']['Insert']>;\n      };\n      usage_tracking: {\n        Row: {\n          id: string;\n          user_id: string;\n          period_start: string;\n          period_end: string;\n          friends_count: number;\n          weaves_this_month: number;\n          created_at: string;\n          updated_at: string;\n        };\n      };\n      friends: {\n        Row: {\n          id: string;\n          user_id: string;\n          name: string;\n          dunbar_tier: string;\n          archetype: string;\n          weave_score: number;\n          // ... other fields\n        };\n      };\n      // ... other tables\n    };\n  };\n};\n\n/**\n * Type-safe Supabase client\n */\nexport type TypedSupabaseClient = ReturnType<typeof createClient<Database>>;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/services/sync-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":168,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":168,"endColumn":27}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SyncConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SyncTable' is defined but never used. Allowed unused vars must match /^_/u.","line":46,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tableName' is defined but never used. Allowed unused args must match /^_/u.","line":320,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":320,"endColumn":54,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Sync Engine - Bidirectional sync between WatermelonDB and Supabase\n * Handles conflict resolution, delta sync, and offline support\n */\n\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nimport { database } from '@/db';\nimport { supabase } from './supabase.service';\nimport { Q } from '@nozbe/watermelondb';\nimport type { Model } from '@nozbe/watermelondb';\nimport Logger from '@/shared/utils/Logger';\nimport { useSyncConflictStore } from '../store/sync-conflict.store';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface SyncConfig {\n  userId: string;\n  lastSyncTimestamp?: number;\n}\n\ninterface SyncResult {\n  success: boolean;\n  pulledRecords: number;\n  pushedRecords: number;\n  conflicts: number;\n  errors: string[];\n}\n\n/**\n * Tables to sync (in dependency order)\n */\nconst SYNC_TABLES = [\n  'friends',\n  'interactions',\n  'interaction_friends',\n  'intentions',\n  'intention_friends',\n  'user_profile',\n  'user_progress',\n  'life_events',\n  'weekly_reflections',\n  'journal_entries',\n] as const;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype SyncTable = typeof SYNC_TABLES[number];\n\n/**\n * Main sync engine class\n */\nexport class SyncEngine {\n  private userId: string;\n  private lastSyncTimestamp: number;\n  private isSyncing: boolean = false;\n\n  constructor(userId: string) {\n    this.userId = userId;\n    this.lastSyncTimestamp = 0;\n  }\n\n  /**\n   * Perform full bidirectional sync\n   */\n  async sync(): Promise<SyncResult> {\n    if (this.isSyncing) {\n      Logger.debug('Sync already in progress, skipping...');\n      return {\n        success: false,\n        pulledRecords: 0,\n        pushedRecords: 0,\n        conflicts: 0,\n        errors: ['Sync already in progress'],\n      };\n    }\n\n    this.isSyncing = true;\n    const result: SyncResult = {\n      success: true,\n      pulledRecords: 0,\n      pushedRecords: 0,\n      conflicts: 0,\n      errors: [],\n    };\n\n    try {\n      // Load last sync timestamp from local storage\n      await this.loadLastSyncTimestamp();\n\n      // Phase 1: Pull changes from server\n      Logger.debug('📥 Pulling changes from server...');\n      const pullResult = await this.pullFromServer();\n      result.pulledRecords = pullResult.count;\n      result.conflicts += pullResult.conflicts;\n\n      // Phase 2: Push local changes to server\n      Logger.debug('📤 Pushing local changes to server...');\n      const pushResult = await this.pushToServer();\n      result.pushedRecords = pushResult.count;\n\n      // Update last sync timestamp\n      this.lastSyncTimestamp = Date.now();\n      await this.saveLastSyncTimestamp();\n\n      Logger.info('✅ Sync completed successfully', result);\n    } catch (error) {\n      Logger.error('❌ Sync failed:', error);\n      result.success = false;\n      result.errors.push(error instanceof Error ? error.message : 'Unknown error');\n    } finally {\n      this.isSyncing = false;\n    }\n\n    return result;\n  }\n\n  /**\n   * Pull changes from server and apply to local database\n   */\n  private async pullFromServer(): Promise<{ count: number; conflicts: number }> {\n    let totalPulled = 0;\n    let totalConflicts = 0;\n\n    for (const tableName of SYNC_TABLES) {\n      try {\n        // Fetch records modified after last sync\n        const { data, error } = await supabase\n          .from(tableName)\n          .select('*')\n          .eq('user_id', this.userId)\n          .gt('server_updated_at', new Date(this.lastSyncTimestamp).toISOString())\n          .order('server_updated_at', { ascending: true });\n\n        if (error) {\n          Logger.error(`Error pulling ${tableName}:`, error);\n          continue;\n        }\n\n        if (!data || data.length === 0) {\n          continue;\n        }\n\n        Logger.debug(`📥 Pulled ${data.length} records from ${tableName}`);\n\n        // Apply changes to local database\n        await database.write(async () => {\n          const collection = database.get(tableName);\n\n          for (const serverRecord of data) {\n            try {\n              // Try to find existing local record\n              const localRecord = await collection.find((serverRecord as any).id);\n\n              // Check for conflicts\n              const hasConflict = await this.detectConflict(localRecord, serverRecord);\n\n              if (hasConflict) {\n                // Resolve conflict (server wins for now - can be customized)\n                await this.resolveConflict(localRecord, serverRecord);\n                totalConflicts++;\n              } else {\n                // No conflict, just update\n                await localRecord.update((record: any) => {\n                  this.applyServerData(record, serverRecord);\n                });\n              }\n\n              totalPulled++;\n            } catch (error) {\n              // Record doesn't exist locally, create it\n              await collection.create((record: any) => {\n                this.applyServerData(record, serverRecord);\n              });\n              totalPulled++;\n            }\n          }\n        });\n      } catch (error) {\n        Logger.error(`Error processing ${tableName}:`, error);\n      }\n    }\n\n    return { count: totalPulled, conflicts: totalConflicts };\n  }\n\n  /**\n   * Push local changes to server\n   */\n  private async pushToServer(): Promise<{ count: number }> {\n    let totalPushed = 0;\n\n    for (const tableName of SYNC_TABLES) {\n      try {\n        const collection = database.get(tableName);\n\n        // Get records with pending sync status\n        const pendingRecords = await collection\n          .query(\n            Q.or(\n              Q.where('sync_status', 'pending'),\n              Q.where('sync_status', null)\n            )\n          )\n          .fetch();\n\n        if (pendingRecords.length === 0) {\n          continue;\n        }\n\n        Logger.debug(`📤 Pushing ${pendingRecords.length} records to ${tableName}`);\n\n        // Upload in batches\n        const batchSize = 50;\n        for (let i = 0; i < pendingRecords.length; i += batchSize) {\n          const batch = pendingRecords.slice(i, i + batchSize);\n          const serverRecords = batch.map(record => this.serializeForServer(record, tableName));\n\n          // Upsert to server\n          const { error } = await (supabase\n            .from(tableName) as any)\n            .upsert(serverRecords as any[], { onConflict: 'id' } as any);\n\n          if (error) {\n            Logger.error(`Error pushing ${tableName}:`, error);\n            continue;\n          }\n\n          // Mark as synced locally\n          await database.write(async () => {\n            const batchOps = batch.map(record =>\n              record.prepareUpdate((r: any) => {\n                r.syncStatus = 'synced';\n                r.syncedAt = Date.now();\n              })\n            );\n            await database.batch(...batchOps);\n          });\n\n          totalPushed += batch.length;\n        }\n      } catch (error) {\n        Logger.error(`Error pushing ${tableName}:`, error);\n      }\n    }\n\n    return { count: totalPushed };\n  }\n\n  /**\n   * Detect if there's a conflict between local and server record\n   */\n  private async detectConflict(localRecord: Model, serverRecord: any): Promise<boolean> {\n    const localUpdated = (localRecord as any).serverUpdatedAt || 0;\n    const serverUpdated = new Date(serverRecord.server_updated_at).getTime();\n\n    // If local has changes that are newer than what server knows, it's a conflict\n    const localSynced = (localRecord as any).syncedAt || 0;\n\n    return localUpdated > localSynced && localUpdated > serverUpdated;\n  }\n\n  /**\n   * Resolve conflict between local and server record\n   * Strategy: Server wins (last-write-wins)\n   * Can be customized to show conflict resolution UI\n   */\n  private async resolveConflict(localRecord: Model, serverRecord: any): Promise<void> {\n    Logger.warn(`⚠️ Conflict detected for ${localRecord.table} record ${localRecord.id}`);\n    Logger.warn(`   Local updated: ${new Date((localRecord as any).serverUpdatedAt || 0).toISOString()}`);\n    Logger.warn(`   Server updated: ${serverRecord.server_updated_at}`);\n\n    // Add to conflict store for user resolution\n    useSyncConflictStore.getState().addConflict({\n      id: localRecord.id,\n      tableName: localRecord.table,\n      localRecord,\n      serverRecord,\n      resolve: async (strategy) => {\n        await database.write(async () => {\n          if (strategy === 'keep_server') {\n            await localRecord.update((record: any) => {\n              this.applyServerData(record, serverRecord);\n              record.syncStatus = 'synced';\n            });\n          } else {\n            // Keep local\n            await localRecord.update((record: any) => {\n              record.serverUpdatedAt = new Date(serverRecord.server_updated_at).getTime();\n              record.syncStatus = 'pending';\n            });\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Apply server data to local record\n   */\n  private applyServerData(localRecord: any, serverRecord: any): void {\n    // Map server columns (snake_case) to local properties (camelCase)\n    Object.keys(serverRecord).forEach(key => {\n      if (key === 'id' || key === 'server_updated_at' || key === 'created_at_ts' || key === 'updated_at_ts') {\n        return; // Skip metadata fields\n      }\n\n      const camelKey = this.snakeToCamel(key);\n      localRecord[camelKey] = serverRecord[key];\n    });\n\n    // Update sync metadata\n    localRecord.syncStatus = 'synced';\n    localRecord.syncedAt = Date.now();\n    localRecord.serverUpdatedAt = new Date(serverRecord.server_updated_at).getTime();\n  }\n\n  /**\n   * Serialize local record for server upload\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private serializeForServer(record: Model, tableName: string): any {\n    const raw = record._raw as any;\n    const serverRecord: any = {\n      id: record.id,\n      user_id: this.userId,\n    };\n\n    // Map local properties (camelCase) to server columns (snake_case)\n    Object.keys(raw).forEach(key => {\n      if (key === '_status' || key === '_changed' || key === 'sync_status' || key === 'synced_at') {\n        return; // Skip WatermelonDB metadata\n      }\n\n      const snakeKey = this.camelToSnake(key);\n      serverRecord[snakeKey] = raw[key];\n    });\n\n    return serverRecord;\n  }\n\n  /**\n   * Convert snake_case to camelCase\n   */\n  private snakeToCamel(str: string): string {\n    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n  }\n\n  /**\n   * Convert camelCase to snake_case\n   */\n  private camelToSnake(str: string): string {\n    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\n  }\n\n  /**\n   * Load last sync timestamp from local storage\n   */\n  private async loadLastSyncTimestamp(): Promise<void> {\n    try {\n      const key = `weave:sync:lastTimestamp:${this.userId}`;\n      const value = await AsyncStorage.getItem(key);\n      this.lastSyncTimestamp = value ? parseInt(value, 10) : 0;\n    } catch (error) {\n      Logger.error('Failed to load last sync timestamp:', error);\n      this.lastSyncTimestamp = 0;\n    }\n  }\n\n  /**\n   * Save last sync timestamp to local storage\n   */\n  private async saveLastSyncTimestamp(): Promise<void> {\n    try {\n      const key = `weave:sync:lastTimestamp:${this.userId}`;\n      await AsyncStorage.setItem(key, this.lastSyncTimestamp.toString());\n    } catch (error) {\n      Logger.error('Failed to save last sync timestamp:', error);\n    }\n  }\n}\n\n/**\n * Initialize sync for current user\n */\nexport function createSyncEngine(userId: string): SyncEngine {\n  return new SyncEngine(userId);\n}\n\n/**\n * Auto-sync hook - triggers sync on app state changes\n */\nexport async function triggerAutoSync(userId: string): Promise<void> {\n  // ADD THIS GUARD CLAUSE\n  const IS_LOCAL_ONLY = true; // Or read from env/constants\n  if (IS_LOCAL_ONLY) return;\n\n  if (!userId) return;\n\n  const engine = createSyncEngine(userId);\n  await engine.sync();\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/store/auth.store.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'feature' is defined but never used. Allowed unused args must match /^_/u.","line":255,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":255,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tier' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":256,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":256,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'feature' is defined but never used. Allowed unused args must match /^_/u.","line":272,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":272,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tier' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":273,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":273,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auth Store with Subscription Support\n * Manages user authentication state and subscription tier\n */\n\nimport { create } from 'zustand';\nimport { supabase } from '../services/supabase.service';\nimport type { User, Session } from '@supabase/supabase-js';\nimport type { SubscriptionTier } from '../services/subscription-tiers';\n\ninterface UserSubscription {\n  tier: SubscriptionTier;\n  status: 'active' | 'canceled' | 'past_due' | 'trialing';\n  trialEndsAt: Date | null;\n  currentPeriodEnd: Date | null;\n}\n\ninterface UsageStats {\n  friendsCount: number;\n  weavesThisMonth: number;\n  periodStart: Date;\n  periodEnd: Date;\n}\n\ninterface AuthState {\n  // Auth state\n  user: User | null;\n  session: Session | null;\n  isLoading: boolean;\n  isAuthenticated: boolean;\n\n  // Subscription state\n  subscription: UserSubscription | null;\n  usage: UsageStats | null;\n\n  // Actions\n  initialize: () => Promise<void>;\n  signOut: () => Promise<void>;\n  refreshSubscription: () => Promise<void>;\n  refreshUsage: () => Promise<void>;\n\n  // Helper getters\n  getTier: () => SubscriptionTier;\n  isFreeTier: () => boolean;\n  isPlusTier: () => boolean;\n  isPremiumTier: () => boolean;\n  isSubscriptionActive: () => boolean;\n}\n\nexport const useAuthStore = create<AuthState>((set, get) => ({\n  user: null,\n  session: null,\n  isLoading: true,\n  isAuthenticated: false,\n  subscription: null,\n  usage: null,\n\n  /**\n   * Initialize auth state on app startup\n   */\n  initialize: async () => {\n    try {\n      // Get initial session\n      const { data: { session } } = await supabase.auth.getSession();\n\n      if (session) {\n        set({\n          user: session.user,\n          session,\n          isAuthenticated: true,\n        });\n\n        // Load subscription and usage data\n        await get().refreshSubscription();\n        await get().refreshUsage();\n      }\n\n      set({ isLoading: false });\n\n      // Listen for auth changes\n      supabase.auth.onAuthStateChange(async (_event, session) => {\n        set({\n          user: session?.user ?? null,\n          session,\n          isAuthenticated: !!session,\n        });\n\n        if (session) {\n          await get().refreshSubscription();\n          await get().refreshUsage();\n        } else {\n          set({\n            subscription: null,\n            usage: null,\n          });\n        }\n      });\n    } catch (error) {\n      console.error('Auth initialization error:', error);\n      set({ isLoading: false });\n    }\n  },\n\n  /**\n   * Sign out current user\n   */\n  signOut: async () => {\n    try {\n      await supabase.auth.signOut();\n      set({\n        user: null,\n        session: null,\n        isAuthenticated: false,\n        subscription: null,\n        usage: null,\n      });\n    } catch (error) {\n      console.error('Sign out error:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Fetch latest subscription data from server\n   */\n  refreshSubscription: async () => {\n    const { user } = get();\n    if (!user) return;\n\n    try {\n      const { data, error } = await supabase\n        .from('user_subscriptions')\n        .select('*')\n        .eq('user_id', user.id)\n        .single();\n\n      if (error) {\n        console.error('Error fetching subscription:', error);\n        // Default to free tier if no subscription found\n        set({\n          subscription: {\n            tier: 'free',\n            status: 'active',\n            trialEndsAt: null,\n            currentPeriodEnd: null,\n          },\n        });\n        return;\n      }\n\n      set({\n        subscription: {\n          tier: (data as any).tier as SubscriptionTier,\n          status: (data as any).status as any,\n          trialEndsAt: (data as any).trial_ends_at ? new Date((data as any).trial_ends_at) : null,\n          currentPeriodEnd: (data as any).current_period_end ? new Date((data as any).current_period_end) : null,\n        },\n      });\n    } catch (error) {\n      console.error('Subscription refresh error:', error);\n    }\n  },\n\n  /**\n   * Fetch latest usage stats from server\n   */\n  refreshUsage: async () => {\n    const { user } = get();\n    if (!user) return;\n\n    try {\n      // Get current period usage\n      const now = new Date();\n      const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);\n\n      const { data, error } = await supabase\n        .from('usage_tracking')\n        .select('*')\n        .eq('user_id', user.id)\n        .gte('period_start', periodStart.toISOString())\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 = no rows\n        console.error('Error fetching usage:', error);\n        return;\n      }\n\n      if (data) {\n        set({\n          usage: {\n            friendsCount: (data as any).friends_count,\n            weavesThisMonth: (data as any).weaves_this_month,\n            periodStart: new Date((data as any).period_start),\n            periodEnd: new Date((data as any).period_end),\n          },\n        });\n      } else {\n        // No usage record for this period yet\n        set({\n          usage: {\n            friendsCount: 0,\n            weavesThisMonth: 0,\n            periodStart,\n            periodEnd: new Date(now.getFullYear(), now.getMonth() + 1, 0),\n          },\n        });\n      }\n    } catch (error) {\n      console.error('Usage refresh error:', error);\n    }\n  },\n\n  /**\n   * Get current subscription tier\n   */\n  getTier: () => {\n    return get().subscription?.tier ?? 'free';\n  },\n\n  /**\n   * Check if user is on free tier\n   */\n  isFreeTier: () => {\n    return get().getTier() === 'free';\n  },\n\n  /**\n   * Check if user is on plus tier\n   */\n  isPlusTier: () => {\n    return get().getTier() === 'plus';\n  },\n\n  /**\n   * Check if user is on premium tier\n   */\n  isPremiumTier: () => {\n    return get().getTier() === 'premium';\n  },\n\n  /**\n   * Check if subscription is active (not canceled or past due)\n   */\n  isSubscriptionActive: () => {\n    const { subscription } = get();\n    if (!subscription) return false;\n    return subscription.status === 'active' || subscription.status === 'trialing';\n  },\n}));\n\n/**\n * Hook to check feature access\n * Returns true if user has access to the feature\n */\nexport function useFeatureAccess(feature: string): boolean {\n  const tier = useAuthStore(state => state.getTier());\n  // Import and use hasFeatureAccess from subscription-tiers.ts\n  // This is a placeholder - implement based on your feature gating logic\n  return true;\n}\n\n/**\n * Hook to get usage stats\n */\nexport function useUsageStats() {\n  return useAuthStore(state => state.usage);\n}\n\n/**\n * Hook to check if at limit\n */\nexport function useIsAtLimit(feature: 'friends' | 'weaves'): boolean {\n  const tier = useAuthStore(state => state.getTier());\n  const usage = useAuthStore(state => state.usage);\n\n  if (!usage) return false;\n\n  // Implement limit checking based on tier and usage\n  // This is a placeholder\n  return false;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/store/sync-conflict.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/store/sync.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/auth/store/user-profile.store.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'days' is assigned a value but never used. Allowed unused args must match /^_/u.","line":266,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":266,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport { database, initializeUserProfile } from '@/db';\nimport UserProfile, { SocialSeason } from '@/db/models/UserProfile';\nimport SocialBatteryLog from '@/db/models/SocialBatteryLog';\nimport { SeasonAnalyticsService } from '@/modules/intelligence';\n// Removed service imports as logic is now inline\n\nimport { Q } from '@nozbe/watermelondb';\nimport { Subscription } from 'rxjs';\n\ninterface UserProfileStore {\n  // State\n  profile: UserProfile | null;\n  isLoading: boolean;\n  batteryStats: {\n    average: number | null;\n    trend: 'rising' | 'falling' | 'stable' | null;\n  };\n\n  // Observables\n  subscription: Subscription | null;\n  observeProfile: () => void;\n  unobserveProfile: () => void;\n\n  // Social Season Actions\n  updateSocialSeason: (season: SocialSeason, durationDays?: number) => Promise<void>;\n\n  // Social Battery Actions\n  submitBatteryCheckin: (value: number, note?: string, customTimestamp?: number, overwriteDay?: boolean) => Promise<void>;\n  updateBatteryPreferences: (enabled: boolean, time?: string) => Promise<void>;\n  refreshBatteryStats: () => Promise<void>;\n\n  // Profile Update\n  updateProfile: (updates: Partial<UserProfile>) => Promise<void>;\n\n  // Getters\n  getSocialSeason: () => SocialSeason | null;\n  getRecentBatteryAverage: (days?: number) => number | null;\n  getBatteryTrend: () => 'rising' | 'falling' | 'stable' | null;\n}\n\nexport const useUserProfileStore = create<UserProfileStore>((set, get) => ({\n  profile: null,\n  isLoading: true,\n  subscription: null,\n  batteryStats: {\n    average: null,\n    trend: null,\n  },\n\n  observeProfile: () => {\n    // Clean up existing subscription if any\n    const existingSub = get().subscription;\n    if (existingSub) {\n      existingSub.unsubscribe();\n    }\n\n    // Initialize profile if it doesn't exist\n    initializeUserProfile();\n\n    // Subscribe to the user profile observable\n    const subscription = database\n      .get<UserProfile>('user_profile')\n      .query()\n      .observe()\n      .subscribe(profiles => {\n        set({\n          profile: profiles[0] || null,\n          isLoading: false\n        });\n        // Refresh stats when profile loads\n        get().refreshBatteryStats();\n      });\n\n    set({ subscription });\n  },\n\n  unobserveProfile: () => {\n    const { subscription } = get();\n    if (subscription) {\n      subscription.unsubscribe();\n      set({ subscription: null });\n    }\n  },\n\n  updateSocialSeason: async (season: SocialSeason, durationDays?: number) => {\n    const { profile } = get();\n    if (!profile) return;\n\n    const now = Date.now();\n    const oldSeason = profile.currentSocialSeason;\n\n    await database.write(async () => {\n      // Update user profile\n      // Update user profile\n      await profile.update(p => {\n        p.currentSocialSeason = season;\n        p.seasonLastCalculated = now;\n\n        if (durationDays) {\n          const expiry = now + (durationDays * 24 * 60 * 60 * 1000);\n          p.seasonOverrideUntil = expiry;\n          p.seasonOverrideReason = 'manual_override';\n        } else {\n          // Clear override if no duration provided (means auto-calculated)\n          p.seasonOverrideUntil = undefined;\n          p.seasonOverrideReason = undefined;\n        }\n      });\n    });\n\n    // Log the season transition with analytics\n    // We do this outside the main write block to avoid nested transactions\n    if (!oldSeason || oldSeason !== season) {\n      await SeasonAnalyticsService.transitionSeason(season, !!durationDays);\n    }\n  },\n\n  submitBatteryCheckin: async (value: number, note?: string, customTimestamp?: number, overwriteDay?: boolean) => {\n    const { profile } = get();\n    if (!profile) return;\n\n    await database.write(async () => {\n      const now = Date.now();\n      const timestamp = customTimestamp || now;\n\n      // If overwriting, delete existing logs for this day\n      if (overwriteDay) {\n        const startOfDay = new Date(timestamp);\n        startOfDay.setHours(0, 0, 0, 0);\n        const endOfDay = new Date(timestamp);\n        endOfDay.setHours(23, 59, 59, 999);\n\n        const logsCollection = database.get<SocialBatteryLog>('social_battery_logs');\n        const existingLogs = await logsCollection.query(\n          Q.where('user_id', profile.id),\n          Q.where('timestamp', Q.gte(startOfDay.getTime())),\n          Q.where('timestamp', Q.lte(endOfDay.getTime()))\n        ).fetch();\n\n        for (const log of existingLogs) {\n          await log.markAsDeleted(); // or log.destroyPermanently() if you prefer hard delete\n        }\n      }\n\n      await profile.update(p => {\n        // Only update current battery level if adding a check-in for today\n        // OR if we are overwriting a past day, we might NOT want to update \"current\" unless it IS today.\n        // The original logic was: if (!customTimestamp || timestamp >= now - 24h)\n        // Let's keep that logic to avoid setting \"current battery\" to a value from 3 months ago.\n        if (!customTimestamp || timestamp >= now - 24 * 60 * 60 * 1000) {\n          p.socialBatteryCurrent = value;\n          p.socialBatteryLastCheckin = timestamp;\n        }\n      });\n\n      // Add to battery logs\n      const logsCollection = database.get<SocialBatteryLog>('social_battery_logs');\n      await logsCollection.create(log => {\n        log.userId = profile.id;\n        log.value = value;\n        log.timestamp = timestamp;\n      });\n    });\n\n    // Trigger smart notification evaluation after battery check-in\n    // This is a good time since user is engaged and we have fresh battery data\n    try {\n      const { SmartSuggestionsChannel, BatteryCheckinChannel } = await import('@/modules/notifications');\n\n      // 1. Reschedule \"Social Battery\" notification (Safety Net)\n      // Since user just checked in, we silence today's reminder and schedule for tomorrow.\n      const batteryTime = profile.batteryCheckinTime || '20:00';\n      await BatteryCheckinChannel.rescheduleForTomorrow(batteryTime);\n\n      // 2. Evaluate other smart notifications\n      await SmartSuggestionsChannel.evaluateAndSchedule();\n    } catch (error) {\n      console.error('Error evaluating smart notifications after battery check-in:', error);\n    }\n  },\n\n  updateBatteryPreferences: async (enabled: boolean, time?: string) => {\n    const { profile } = get();\n    if (!profile) return;\n\n    await database.write(async () => {\n      await profile.update(p => {\n        p.batteryCheckinEnabled = enabled;\n        if (time !== undefined) {\n          p.batteryCheckinTime = time;\n        }\n      });\n    });\n\n    // Update notification schedule\n    const { BatteryCheckinChannel } = await import('@/modules/notifications');\n    if (enabled) {\n      await BatteryCheckinChannel.schedule(time || '20:00');\n    } else {\n      await BatteryCheckinChannel.cancel();\n    }\n  },\n\n  updateProfile: async (updates: Partial<UserProfile>) => {\n    const { profile } = get();\n    if (!profile) return;\n\n    await database.write(async () => {\n      await profile.update(p => {\n        Object.assign(p, updates);\n      });\n    });\n  },\n\n  getSocialSeason: () => {\n    const { profile } = get();\n    return profile?.currentSocialSeason || null;\n  },\n\n  refreshBatteryStats: async () => {\n    const { profile } = get();\n    if (!profile) return;\n\n    try {\n      const logsCollection = database.get<SocialBatteryLog>('social_battery_logs');\n      const cutoff = Date.now() - 90 * 24 * 60 * 60 * 1000; // 90 days history\n\n      const logs = await logsCollection.query(\n        Q.where('user_id', profile.id),\n        Q.where('timestamp', Q.gte(cutoff)),\n        Q.sortBy('timestamp', Q.asc)\n      ).fetch();\n\n      // Calculate Average (last 7 days)\n      const sevenDayCutoff = Date.now() - 7 * 24 * 60 * 60 * 1000;\n      const recentLogs = logs.filter(l => l.timestamp >= sevenDayCutoff);\n      let average = null;\n      if (recentLogs.length > 0) {\n        const sum = recentLogs.reduce((acc, log) => acc + log.value, 0);\n        average = sum / recentLogs.length;\n      }\n\n      // Calculate Trend\n      let trend: 'rising' | 'falling' | 'stable' | null = 'stable';\n      if (logs.length >= 6) {\n        const recent = logs.slice(-6);\n        const currentWindow = recent.slice(-3);\n        const previousWindow = recent.slice(0, 3);\n\n        const currentAvg = currentWindow.reduce((sum, e) => sum + e.value, 0) / 3;\n        const previousAvg = previousWindow.reduce((sum, e) => sum + e.value, 0) / 3;\n\n        if (currentAvg > previousAvg + 0.5) trend = 'rising';\n        else if (currentAvg < previousAvg - 0.5) trend = 'falling';\n      } else {\n        trend = null;\n      }\n\n      set({ batteryStats: { average, trend } });\n    } catch (error) {\n      console.error('Failed to refresh battery stats:', error);\n    }\n  },\n\n  getRecentBatteryAverage: (days: number = 7) => {\n    return get().batteryStats.average;\n  },\n\n  getBatteryTrend: () => {\n    return get().batteryStats.trend;\n  },\n}));\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/backup/AutoBackupService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":26,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":40,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CloudStorage } from 'react-native-cloud-storage';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { Platform } from 'react-native';\nimport { exportAllData } from '../auth/services/data-export';\nimport Logger from '@/shared/utils/Logger';\n\nconst BACKUP_FOLDER = 'Backups';\nconst MAX_BACKUPS = 5;\nconst AUTO_BACKUP_KEY = '@weave:auto_backup_enabled';\nconst LAST_BACKUP_KEY = '@weave:last_backup_time';\n\nexport const AutoBackupService = {\n    /**\n     * Initialize the backup service\n     */\n    init: async (): Promise<boolean> => {\n        // Cloud backup is currently iOS-only (iCloud)\n        if (Platform.OS === 'android') {\n            return false;\n        }\n\n        try {\n            let exists = false;\n            try {\n                exists = await CloudStorage.exists(`/${BACKUP_FOLDER}`);\n            } catch (e) {\n                // If exists() throws, it likely means the directory doesn't exist\n                // We'll treat this as false and attempt to create it\n                exists = false;\n            }\n\n            if (!exists) {\n                try {\n                    await CloudStorage.mkdir(`/${BACKUP_FOLDER}`);\n                } catch (mkdirError: any) {\n                    // Ignore error if folder was created by a parallel process\n                    let checkAgain = false;\n                    try {\n                        checkAgain = await CloudStorage.exists(`/${BACKUP_FOLDER}`);\n                    } catch (e) {\n                        // specific error handling if checkAgain fails\n                        checkAgain = false;\n                    }\n\n                    if (!checkAgain) {\n                        throw mkdirError;\n                    }\n                }\n            }\n            return true;\n        } catch (error) {\n            Logger.error('AutoBackup: Failed to initialize (Code: INIT_FAIL):', error);\n            return false;\n        }\n    },\n\n    /**\n     * Check if auto-backup is enabled\n     */\n    isEnabled: async (): Promise<boolean> => {\n        const enabled = await AsyncStorage.getItem(AUTO_BACKUP_KEY);\n        return enabled ? JSON.parse(enabled) : false;\n    },\n\n    /**\n     * Enable or disable auto-backup\n     */\n    setEnabled: async (enabled: boolean) => {\n        await AsyncStorage.setItem(AUTO_BACKUP_KEY, JSON.stringify(enabled));\n        if (enabled) {\n            await AutoBackupService.init();\n        }\n    },\n\n    /**\n     * Get the timestamp of the last successful backup\n     */\n    getLastBackupTime: async (): Promise<string | null> => {\n        return await AsyncStorage.getItem(LAST_BACKUP_KEY);\n    },\n\n    /**\n     * Perform a backup immediately\n     */\n    performBackup: async () => {\n        try {\n\n            const jsonString = await exportAllData();\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const filename = `weave-backup-${timestamp}.json`;\n            const path = `/${BACKUP_FOLDER}/${filename}`;\n\n            // Ensure directory exists\n            const initSuccess = await AutoBackupService.init();\n            if (!initSuccess) {\n                throw new Error('Failed to initialize backup directory');\n            }\n\n            await CloudStorage.writeFile(path, jsonString);\n            await AsyncStorage.setItem(LAST_BACKUP_KEY, new Date().toISOString());\n\n\n\n            // Prune old backups\n            await AutoBackupService.pruneBackups();\n        } catch (error) {\n            Logger.error('AutoBackup: Backup failed:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Delete old backups, keeping only the most recent ones\n     */\n    pruneBackups: async () => {\n        try {\n            const files = await CloudStorage.readdir(`/${BACKUP_FOLDER}`);\n            const backupFiles = files\n                .filter(f => f.startsWith('weave-backup-'))\n                .sort((a, b) => a.localeCompare(b)); // Oldest first\n\n            if (backupFiles.length > MAX_BACKUPS) {\n                const toDelete = backupFiles.slice(0, backupFiles.length - MAX_BACKUPS);\n                for (const file of toDelete) {\n                    await CloudStorage.unlink(`/${BACKUP_FOLDER}/${file}`);\n\n                }\n            }\n        } catch (error) {\n            Logger.error('AutoBackup: Pruning failed:', error);\n        }\n    },\n\n    /**\n     * Delete all backups\n     */\n    deleteAllBackups: async () => {\n        try {\n            const exists = await CloudStorage.exists(`/${BACKUP_FOLDER}`);\n            if (!exists) return;\n\n            const files = await CloudStorage.readdir(`/${BACKUP_FOLDER}`);\n            for (const file of files) {\n                await CloudStorage.unlink(`/${BACKUP_FOLDER}/${file}`);\n            }\n        } catch (error) {\n            Logger.error('AutoBackup: Failed to delete all backups:', error);\n        }\n    },\n\n    /**\n     * Get list of available backups\n     */\n    getAvailableBackups: async (): Promise<string[]> => {\n        try {\n            const exists = await CloudStorage.exists(`/${BACKUP_FOLDER}`);\n            if (!exists) return [];\n\n            const files = await CloudStorage.readdir(`/${BACKUP_FOLDER}`);\n            return files\n                .filter(f => f.startsWith('weave-backup-') && f.endsWith('.json'))\n                .sort((a, b) => b.localeCompare(a)); // Newest first\n        } catch (error) {\n            Logger.error('AutoBackup: Failed to list backups:', error);\n            return [];\n        }\n    },\n\n    /**\n     * Read a backup file\n     */\n    restoreBackup: async (filename: string): Promise<string> => {\n        try {\n            const path = `/${BACKUP_FOLDER}/${filename}`;\n            const content = await CloudStorage.readFile(path);\n            return content;\n        } catch (error) {\n            Logger.error('AutoBackup: Failed to read backup:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Check if a backup is needed (e.g., once per day)\n     */\n    checkAndBackup: async () => {\n        try {\n            const enabled = await AutoBackupService.isEnabled();\n            if (!enabled) return;\n\n            const lastBackup = await AutoBackupService.getLastBackupTime();\n            const now = new Date();\n\n            if (lastBackup) {\n                const lastBackupDate = new Date(lastBackup);\n                const diffHours = (now.getTime() - lastBackupDate.getTime()) / (1000 * 60 * 60);\n\n                // Backup at most once every 24 hours\n                if (diffHours < 24) {\n\n                    return;\n                }\n            }\n\n            await AutoBackupService.performBackup();\n        } catch (error) {\n            Logger.error('AutoBackup: Check and backup failed:', error);\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/backup/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/data-management/DataWipeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/data-management/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/constants/achievement-definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/constants/badge-definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/hooks/useAchievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/listeners/gamification.listener.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/services/achievement.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Achievement' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HIDDEN_ACHIEVEMENTS' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Friend' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/gamification/services/achievement.service.ts\nimport { Achievement } from '../types';\nimport {\n  GlobalAchievement,\n  GLOBAL_ACHIEVEMENTS,\n  HIDDEN_ACHIEVEMENTS,\n  getAchievementById,\n} from '../constants/achievement-definitions';\nimport { database } from '@/db';\nimport UserProgress from '@/db/models/UserProgress';\nimport AchievementUnlock from '@/db/models/AchievementUnlock';\nimport Interaction from '@/db/models/Interaction';\nimport Friend from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\n\nexport interface AchievementUnlockData {\n  achievement: GlobalAchievement;\n  isHidden: boolean;\n}\n\n/**\n * Check and award global achievements for the user\n */\nexport async function checkAndAwardGlobalAchievements(): Promise<AchievementUnlockData[]> {\n  const newUnlocks: AchievementUnlockData[] = [];\n  const userProgress = await getUserProgress();\n  if (!userProgress) return newUnlocks;\n\n  const unlockedIds = new Set(userProgress.globalAchievements);\n\n  for (const achievement of GLOBAL_ACHIEVEMENTS) {\n    if (unlockedIds.has(achievement.id)) continue;\n\n    const progress = await achievement.calculateProgress(userProgress);\n\n    if (progress >= achievement.threshold) {\n      await awardGlobalAchievement(userProgress, achievement.id);\n      newUnlocks.push({ achievement, isHidden: false });\n    }\n  }\n\n  return newUnlocks;\n}\n\n/**\n * Check for hidden achievement triggers based on context\n */\nexport async function checkHiddenAchievements(\n  trigger: HiddenAchievementTrigger\n): Promise<AchievementUnlockData[]> {\n  const unlocks: AchievementUnlockData[] = [];\n  const userProgress = await getUserProgress();\n  if (!userProgress) return unlocks;\n\n  const unlockedIds = new Set(userProgress.hiddenAchievements);\n\n  switch (trigger.type) {\n    case 'interaction_logged': {\n      const { interaction } = trigger;\n      const hour = new Date(interaction.interactionDate).getHours();\n\n      if (hour === 2 && !unlockedIds.has('night_owl')) {\n        await awardHiddenAchievement(userProgress, 'night_owl');\n        const achievement = getAchievementById('night_owl');\n        if (achievement) unlocks.push({ achievement, isHidden: true });\n      }\n\n      if (interaction.duration === 'Extended' && !unlockedIds.has('marathon_conversation')) {\n        await awardHiddenAchievement(userProgress, 'marathon_conversation');\n        const achievement = getAchievementById('marathon_conversation');\n        if (achievement) unlocks.push({ achievement, isHidden: true });\n      }\n      break;\n    }\n    // ... other cases from the original file\n  }\n\n  return unlocks;\n}\n\n// ... all other helper functions from the original file\n\nasync function getUserProgress(): Promise<UserProgress | null> {\n  const records = await database.get<UserProgress>('user_progress').query().fetch();\n  return records.length > 0 ? records[0] : null;\n}\n\nasync function awardGlobalAchievement(\n  userProgress: UserProgress,\n  achievementId: string\n): Promise<void> {\n  await database.write(async () => {\n    // 1. Update UserProgress\n    await userProgress.update(p => {\n      const current = p.globalAchievements || [];\n      if (!current.includes(achievementId)) {\n        p.globalAchievements = [...current, achievementId];\n      }\n    });\n\n    // 2. Create Unlock Record\n    await database.get<AchievementUnlock>('achievement_unlocks').create(unlock => {\n      unlock.achievementId = achievementId;\n      unlock.achievementType = 'global';\n      unlock.unlockedAt = new Date();\n      unlock.hasBeenCelebrated = false;\n    });\n  });\n}\n\nasync function awardHiddenAchievement(\n  userProgress: UserProgress,\n  achievementId: string\n): Promise<void> {\n  await database.write(async () => {\n    // 1. Update UserProgress\n    await userProgress.update(p => {\n      const current = p.hiddenAchievements || [];\n      if (!current.includes(achievementId)) {\n        p.hiddenAchievements = [...current, achievementId];\n      }\n    });\n\n    // 2. Create Unlock Record\n    await database.get<AchievementUnlock>('achievement_unlocks').create(unlock => {\n      unlock.achievementId = achievementId;\n      unlock.achievementType = 'hidden';\n      unlock.unlockedAt = new Date();\n      unlock.hasBeenCelebrated = false;\n    });\n  });\n}\n\nexport async function markAchievementAsCelebrated(achievementId: string): Promise<void> {\n  const userProgress = await getUserProgress();\n  if (!userProgress) return;\n\n  // This is a placeholder. In a real implementation, we would update a 'celebrated_achievements' field\n  // or similar. For now, we'll just log it or assume it's handled by the UI state if not persisted.\n  // If persistence is needed, we should add a field to UserProgress.\n  console.log(`Marked achievement ${achievementId} as celebrated`);\n}\n\nexport type HiddenAchievementTrigger =\n  | { type: 'interaction_logged'; interaction: Interaction }\n  | { type: 'interaction_type_used' }\n  | { type: 'perfect_week' }\n  | { type: 'dormant_rekindled' }\n  | { type: 'planned_weave_completed' }\n  | { type: 'app_anniversary' };\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/services/badge-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getNextBadgeInCategory' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'differenceInMonths' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":140,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":140,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Badge Calculator\n *\n * Calculates current badge progress for friends\n * Determines which badges are unlocked and progress toward next tier\n */\n\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendBadge from '@/db/models/FriendBadge';\nimport Interaction from '@/db/models/Interaction';\nimport {\n  FRIEND_BADGE_CATEGORIES,\n  BadgeDefinition,\n  getBadgeById,\n  getNextBadgeInCategory,\n} from '../constants/badge-definitions';\nimport { differenceInMonths, startOfMonth } from 'date-fns';\n\nexport interface BadgeProgress {\n  categoryType: string;\n  currentTier: number;\n  currentBadge: BadgeDefinition | null;\n  nextBadge: BadgeDefinition | null;\n  progress: number; // Current value (e.g., weave count)\n  progressPercent: number; // Percentage to next badge\n}\n\n/**\n * Calculate current badge progress for a friend across all categories\n */\nexport async function calculateFriendBadgeProgress(friendId: string): Promise<BadgeProgress[]> {\n  const progressList: BadgeProgress[] = [];\n\n  // Get all unlocked badges for this friend\n  const unlockedBadges = await database\n    .get<FriendBadge>('friend_badges')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  // Calculate progress for each category\n  for (const category of FRIEND_BADGE_CATEGORIES) {\n    const categoryBadges = unlockedBadges.filter(b => b.badgeType === category.type);\n    const currentTier = Math.max(0, ...categoryBadges.map(b => b.tier));\n    const currentBadge = category.badges.find(b => b.tier === currentTier) || null;\n    const nextBadge = category.badges.find(b => b.tier === currentTier + 1) || null;\n\n    // Calculate current progress value\n    let progress = 0;\n\n    switch (category.type) {\n      case 'weave_count':\n        progress = await getWeaveCount(friendId);\n        break;\n      case 'depth':\n        progress = await getReflectionCount(friendId);\n        break;\n      case 'consistency':\n        progress = await getConsecutiveContactMonths(friendId);\n        break;\n      case 'special':\n        // Special badges are event-based, not progressive\n        progress = categoryBadges.length;\n        break;\n    }\n\n    const progressPercent = nextBadge\n      ? Math.min(100, (progress / nextBadge.threshold) * 100)\n      : 100;\n\n    progressList.push({\n      categoryType: category.type,\n      currentTier,\n      currentBadge,\n      nextBadge,\n      progress,\n      progressPercent,\n    });\n  }\n\n  return progressList;\n}\n\n/**\n * Get weave count for a friend\n */\nasync function getWeaveCount(friendId: string): Promise<number> {\n  // 1. Get interaction IDs from join table\n  const links = await database\n    .get('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n  const interactionIds = links.map((link: any) => link.interactionId);\n\n  if (interactionIds.length === 0) return 0;\n\n  // 2. Count interactions with those IDs\n  const count = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'completed'),\n      Q.where('id', Q.oneOf(interactionIds))\n    )\n    .fetchCount();\n\n  return count;\n}\n\n/**\n * Get reflection count for a friend\n */\nasync function getReflectionCount(friendId: string): Promise<number> {\n  // 1. Get interaction IDs from join table\n  const links = await database\n    .get('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n  const interactionIds = links.map((link: any) => link.interactionId);\n\n  if (interactionIds.length === 0) return 0;\n\n  // 2. Fetch interactions\n  const interactions = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'completed'),\n      Q.where('id', Q.oneOf(interactionIds))\n    )\n    .fetch();\n\n  // Count interactions with reflections\n  return interactions.filter(i => {\n    if (!i.reflection) return false;\n    try {\n      const reflection = typeof i.reflection === 'string' ? JSON.parse(i.reflection) : i.reflection;\n      return (\n        (reflection.chips && reflection.chips.length > 0) ||\n        (reflection.customNotes && reflection.customNotes.trim().length > 0)\n      );\n    } catch (e) {\n      return false;\n    }\n  }).length;\n}\n\n/**\n * Get consecutive contact months for a friend\n * Counts how many consecutive months (from current month backward) the friend was contacted\n */\nasync function getConsecutiveContactMonths(friendId: string): Promise<number> {\n  // 1. Get interaction IDs from join table\n  const links = await database\n    .get('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n  const interactionIds = links.map((link: any) => link.interactionId);\n\n  if (interactionIds.length === 0) return 0;\n\n  // 2. Fetch interactions\n  const interactions = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'completed'),\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.sortBy('interaction_date', 'desc')\n    )\n    .fetch();\n\n  if (interactions.length === 0) return 0;\n\n  // Group interactions by month\n  const monthsContacted = new Set<string>();\n  interactions.forEach(i => {\n    const date = new Date(i.interactionDate);\n    const monthKey = `${date.getFullYear()}-${date.getMonth()}`;\n    monthsContacted.add(monthKey);\n  });\n\n  // Count consecutive months from current month backward\n  let streak = 0;\n  const today = new Date();\n  let checkDate = startOfMonth(today);\n\n  // Check current month and previous months\n  for (let i = 0; i < 12; i++) {\n    // Max 12 months check\n    const monthKey = `${checkDate.getFullYear()}-${checkDate.getMonth()}`;\n    if (!monthsContacted.has(monthKey)) {\n      break; // Streak broken\n    }\n    streak++;\n    checkDate = new Date(checkDate.getFullYear(), checkDate.getMonth() - 1, 1);\n  }\n\n  return streak;\n}\n\n/**\n * Get highest badge earned in a category\n */\nexport async function getHighestBadgeInCategory(\n  friendId: string,\n  categoryType: string\n): Promise<BadgeDefinition | null> {\n  const badges = await database\n    .get<FriendBadge>('friend_badges')\n    .query(\n      Q.where('friend_id', friendId),\n      Q.where('badge_type', categoryType)\n    )\n    .fetch();\n\n  if (badges.length === 0) return null;\n\n  const highestTier = Math.max(...badges.map(b => b.tier));\n  const highestBadgeId = badges.find(b => b.tier === highestTier)?.badgeId;\n\n  return highestBadgeId ? getBadgeById(highestBadgeId) : null;\n}\n\n/**\n * Get all unlocked badges for a friend\n */\nexport async function getUnlockedBadges(friendId: string): Promise<FriendBadge[]> {\n  return await database\n    .get<FriendBadge>('friend_badges')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n}\n\n/**\n * Check if a specific badge is unlocked\n */\nexport async function isBadgeUnlocked(\n  friendId: string,\n  badgeId: string\n): Promise<boolean> {\n  const count = await database\n    .get<FriendBadge>('friend_badges')\n    .query(\n      Q.where('friend_id', friendId),\n      Q.where('badge_id', badgeId)\n    )\n    .fetchCount();\n\n  return count > 0;\n}\n\n/**\n * Get badge count for a friend\n */\nexport async function getBadgeCount(friendId: string): Promise<number> {\n  return await database\n    .get<FriendBadge>('friend_badges')\n    .query(Q.where('friend_id', friendId))\n    .fetchCount();\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/services/badge.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Badge' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BadgeCheckResult' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/gamification/services/badge.service.ts\nimport { Badge, BadgeCheckResult } from '../types';\nimport { BadgeDefinition, getBadgeById } from '../constants/badge-definitions';\nimport { database } from '@/db';\nimport FriendBadge from '@/db/models/FriendBadge';\nimport AchievementUnlock from '@/db/models/AchievementUnlock';\nimport Interaction from '@/db/models/Interaction';\nimport Friend from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\n// Relative import to avoid circular dependency via index\nimport { calculateFriendBadgeProgress } from './badge-calculator.service';\n\nexport interface BadgeUnlock {\n  badge: BadgeDefinition;\n  categoryType: string;\n  friendId: string;\n  friendName: string;\n}\n\n/**\n * Check and award progressive badges for a friend (weave_count, depth, consistency)\n * Call this after any interaction is logged/updated\n */\nexport async function checkAndAwardFriendBadges(\n  friendId: string,\n  friendName: string\n): Promise<BadgeUnlock[]> {\n  const newUnlocks: BadgeUnlock[] = [];\n\n  // Get current progress\n  const progressList = await calculateFriendBadgeProgress(friendId);\n\n  for (const progress of progressList) {\n    // Skip special badges (they're event-based, not progressive)\n    if (progress.categoryType === 'special') continue;\n\n    // Check if we've reached the threshold for the next badge\n    if (progress.nextBadge && progress.progress >= progress.nextBadge.threshold) {\n      // Check if already unlocked\n      const existing = await database\n        .get<FriendBadge>('friend_badges')\n        .query(\n          Q.where('friend_id', friendId),\n          Q.where('badge_id', progress.nextBadge.id)\n        )\n        .fetch();\n\n      if (existing.length === 0) {\n        // Award the badge!\n        await awardBadge(friendId, progress.categoryType, progress.nextBadge.id);\n\n        newUnlocks.push({\n          badge: progress.nextBadge,\n          categoryType: progress.categoryType,\n          friendId,\n          friendName,\n        });\n      }\n    }\n  }\n\n  return newUnlocks;\n}\n\n/**\n * Check for special badge triggers based on interaction context\n * Call this when logging a new interaction\n */\nexport async function checkSpecialBadges(\n  friendId: string,\n  friendName: string,\n  interaction: Interaction\n): Promise<BadgeUnlock[]> {\n  const unlocks: BadgeUnlock[] = [];\n\n  // First Connection (automatically awarded on first interaction)\n  if (await isFirstWeave(friendId)) {\n    await awardSpecialBadge(friendId, 'first_connection');\n    const badge = getBadgeById('first_connection');\n    if (badge) {\n      unlocks.push({\n        badge,\n        categoryType: 'special',\n        friendId,\n        friendName,\n      });\n    }\n  }\n\n  const friend = await database.get<Friend>('friends').find(friendId);\n\n  // Birthday Celebrated\n  if (friend.birthday) {\n    const interactionDate = new Date(interaction.interactionDate);\n\n    // Birthday is now in \"MM-DD\" format\n    const [month, day] = friend.birthday.split('-').map(n => parseInt(n, 10));\n\n    if (\n      interactionDate.getMonth() === month - 1 && // JavaScript months are 0-indexed\n      interactionDate.getDate() === day &&\n      !(await isBadgeUnlocked(friendId, 'birthday_celebrated'))\n    ) {\n      await awardSpecialBadge(friendId, 'birthday_celebrated');\n      const badge = getBadgeById('birthday_celebrated');\n      if (badge) {\n        unlocks.push({\n          badge,\n          categoryType: 'special',\n          friendId,\n          friendName,\n        });\n      }\n    }\n  }\n\n  // Anniversary Keeper\n  if (friend.anniversary) {\n    const interactionDate = new Date(interaction.interactionDate);\n\n    // Anniversary is stored in \"MM-DD\" format\n    const [month, day] = friend.anniversary.split('-').map(n => parseInt(n, 10));\n\n    if (\n      interactionDate.getMonth() === month - 1 && // JavaScript months are 0-indexed\n      interactionDate.getDate() === day &&\n      !(await isBadgeUnlocked(friendId, 'anniversary_keeper'))\n    ) {\n      await awardSpecialBadge(friendId, 'anniversary_keeper');\n      const badge = getBadgeById('anniversary_keeper');\n      if (badge) {\n        unlocks.push({\n          badge,\n          categoryType: 'special',\n          friendId,\n          friendName,\n        });\n      }\n    }\n  }\n\n  // Peak Moment (first highly positive interaction)\n  if (\n    (interaction.vibe === 'FullMoon' || interaction.vibe === 'WaxingGibbous') &&\n    !(await isBadgeUnlocked(friendId, 'peak_moment'))\n  ) {\n    await awardSpecialBadge(friendId, 'peak_moment');\n    const badge = getBadgeById('peak_moment');\n    if (badge) {\n      unlocks.push({\n        badge,\n        categoryType: 'special',\n        friendId,\n        friendName,\n      });\n    }\n  }\n\n  // Phoenix Rising (rekindled dormant friendship)\n  if (friend.isDormant && !(await isBadgeUnlocked(friendId, 'phoenix_rising'))) {\n    // Mark friend as no longer dormant\n    await database.write(async () => {\n      await friend.update(f => {\n        f.isDormant = false;\n        f.dormantSince = undefined;\n      });\n    });\n\n    await awardSpecialBadge(friendId, 'phoenix_rising');\n    const badge = getBadgeById('phoenix_rising');\n    if (badge) {\n      unlocks.push({\n        badge,\n        categoryType: 'special',\n        friendId,\n        friendName,\n      });\n    }\n  }\n\n  return unlocks;\n}\n\n/**\n * Award a badge to a friend\n */\nasync function awardBadge(\n  friendId: string,\n  badgeType: string,\n  badgeId: string\n): Promise<void> {\n  const badge = getBadgeById(badgeId);\n  if (!badge) return;\n\n  await database.write(async () => {\n    // Create friend badge record\n    await database.get<FriendBadge>('friend_badges').create(b => {\n      b.friendId = friendId;\n      b.badgeType = badgeType;\n      b.badgeId = badgeId;\n      b.tier = badge.tier;\n      b.unlockedAt = new Date();\n    });\n\n    // Create achievement unlock record for celebration queue\n    await database.get<AchievementUnlock>('achievement_unlocks').create(unlock => {\n      unlock.achievementId = badgeId;\n      unlock.achievementType = 'friend_badge';\n      unlock.relatedFriendId = friendId;\n      unlock.unlockedAt = new Date();\n      unlock.hasBeenCelebrated = false; // Will trigger unlock modal\n    });\n  });\n}\n\n/**\n * Award a special badge to a friend\n */\nasync function awardSpecialBadge(friendId: string, badgeId: string): Promise<void> {\n  await awardBadge(friendId, 'special', badgeId);\n}\n\n/**\n * Check if this is the first weave with a friend\n */\nasync function isFirstWeave(friendId: string): Promise<boolean> {\n  // 1. Get interaction IDs from join table\n  const links = await database\n    .get('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n  const interactionIds = links.map((link: any) => link.interactionId);\n\n  if (interactionIds.length === 0) return false;\n\n  // 2. Count interactions with those IDs\n  const count = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'completed'),\n      Q.where('id', Q.oneOf(interactionIds))\n    )\n    .fetchCount();\n\n  return count === 1;\n}\n\n/**\n * Check if a badge is already unlocked\n */\nasync function isBadgeUnlocked(friendId: string, badgeId: string): Promise<boolean> {\n  const count = await database\n    .get<FriendBadge>('friend_badges')\n    .query(\n      Q.where('friend_id', friendId),\n      Q.where('badge_id', badgeId)\n    )\n    .fetchCount();\n\n  return count > 0;\n}\n\n/**\n * Get all unlocks that haven't been celebrated yet\n * Used to queue unlock modals on app startup\n */\nexport async function getUncelebratedBadgeUnlocks(): Promise<BadgeUnlock[]> {\n  const unlocks = await database\n    .get<AchievementUnlock>('achievement_unlocks')\n    .query(\n      Q.where('achievement_type', 'friend_badge'),\n      Q.where('has_been_celebrated', false),\n      Q.sortBy('unlocked_at', 'asc')\n    )\n    .fetch();\n\n  const badgeUnlocks: BadgeUnlock[] = [];\n\n  for (const unlock of unlocks) {\n    const badge = getBadgeById(unlock.achievementId);\n    if (!badge || !unlock.relatedFriendId) continue;\n\n    const friend = await database.get<Friend>('friends').find(unlock.relatedFriendId);\n\n    badgeUnlocks.push({\n      badge,\n      categoryType: 'friend_badge', // We'll determine from badge ID if needed\n      friendId: unlock.relatedFriendId,\n      friendName: friend.name,\n    });\n  }\n\n  return badgeUnlocks;\n}\n\n/**\n * Mark a badge unlock as celebrated\n */\nexport async function markBadgeAsCelebrated(badgeId: string, friendId: string): Promise<void> {\n  const unlocks = await database\n    .get<AchievementUnlock>('achievement_unlocks')\n    .query(\n      Q.where('achievement_id', badgeId),\n      Q.where('related_friend_id', friendId),\n      Q.where('has_been_celebrated', false)\n    )\n    .fetch();\n\n  if (unlocks.length > 0) {\n    await database.write(async () => {\n      for (const unlock of unlocks) {\n        await unlock.update(u => {\n          u.hasBeenCelebrated = true;\n        });\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/services/milestone-tracker.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/gamification/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/groups/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/groups/services/group.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/__tests__/effectiveness.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/__tests__/prediction.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/__tests__/tier-migration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/components/TierFitBottomSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/components/TierFitCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colors' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":18,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/insights/components/TierFitCard.tsx\nimport React from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\nimport { AlertTriangle } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { useTierFit } from '../hooks/useTierFit';\n\ninterface TierFitCardProps {\n  friendId: string;\n  onPress?: () => void;\n}\n\n/**\n * Subtle warning card showing severe tier misalignment.\n * Only appears when the deviation is critical (>300% or <33% of expected interval).\n */\nexport function TierFitCard({ friendId, onPress }: TierFitCardProps) {\n  const { colors } = useTheme();\n  const { analysis, isLoading } = useTierFit(friendId);\n\n  // Don't render if loading or no analysis\n  if (isLoading || !analysis || analysis.fitCategory !== 'mismatch') {\n    return null;\n  }\n\n  // Calculate deviation ratio\n  // Avoid division by zero\n  const ratio = analysis.expectedIntervalDays > 0\n    ? analysis.actualIntervalDays / analysis.expectedIntervalDays\n    : 1;\n\n  // Define \"Severe\" threshold:\n  // > 3.0x expected interval (e.g. 21 days for weekly friend)\n  // < 0.33x expected interval (e.g. daily for monthly friend)\n  const isSevere = ratio > 3.0 || ratio < 0.33;\n\n  if (!isSevere) {\n    return null;\n  }\n\n  return (\n    <TouchableOpacity\n      style={[styles.container, { backgroundColor: '#F59E0B15' }]}\n      onPress={onPress}\n      activeOpacity={0.7}\n    >\n      <View style={styles.content}>\n        <AlertTriangle size={16} color=\"#F59E0B\" />\n        <Text style={[styles.warningText, { color: '#B45309' }]}>\n          Connection rhythm is off track. <Text style={{ fontWeight: '600' }}>Review Status</Text>\n        </Text>\n      </View>\n    </TouchableOpacity>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    marginHorizontal: 4,\n    marginTop: 8,\n    borderRadius: 8,\n    paddingVertical: 10,\n    paddingHorizontal: 12,\n  },\n  content: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: 8,\n  },\n  warningText: {\n    fontSize: 13,\n    fontWeight: '500',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/components/TierSuggestionAlert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/hooks/useEffectiveness.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/hooks/useFriendPattern.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/hooks/usePortfolio.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'InteractionFriend' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport { Q } from '@nozbe/watermelondb';\nimport {\n  analyzePortfolioAsync,\n  getPortfolioHealthSummary,\n  getWeeklyFocusRecommendation,\n} from '../services/portfolio.service';\nimport { type FriendshipPortfolio } from '../types';\nimport { generatePortfolioSuggestions } from '../services/portfolio-suggestions.service';\nimport { type Suggestion } from '@/shared/types/common';\n\n/**\n * Hook to access portfolio-level friendship network analytics\n * Provides holistic view of relationship health across all friends\n */\nexport function usePortfolio() {\n  const [portfolio, setPortfolio] = useState<FriendshipPortfolio | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadPortfolio = async () => {\n      try {\n        // Get all friends\n        const friends = await database.get<FriendModel>('friends').query().fetch();\n\n        // Get recent interactions (last 90 days for comprehensive analysis)\n        const ninetyDaysAgo = Date.now() - 90 * 24 * 60 * 60 * 1000;\n        const recentInteractions = await database\n          .get<InteractionModel>('interactions')\n          .query(\n            Q.where('interaction_date', Q.gte(ninetyDaysAgo)),\n            Q.where('status', 'completed')\n          )\n          .fetch();\n\n        // Get interaction-friend relationships to map interactions to friends\n        const interactionIds = recentInteractions.map(i => i.id);\n\n        // Batch queries to avoid SQLite 999 parameter limit\n        const BATCH_SIZE = 500;\n        const chunks = [];\n        for (let i = 0; i < interactionIds.length; i += BATCH_SIZE) {\n          chunks.push(interactionIds.slice(i, i + BATCH_SIZE));\n        }\n\n        const interactionFriendLinksResults = await Promise.all(\n          chunks.map(chunk =>\n            database\n              .get('interaction_friends')\n              .query(Q.where('interaction_id', Q.oneOf(chunk)))\n              .fetch()\n          )\n        );\n\n        const interactionFriendLinks = interactionFriendLinksResults.flat();\n\n        // Create a map for O(1) lookups of friends per interaction\n        const interactionFriendMap = new Map<string, string[]>();\n        interactionFriendLinks.forEach(link => {\n          const { interactionId, friendId } = link as any;\n          if (!interactionFriendMap.has(interactionId)) {\n            interactionFriendMap.set(interactionId, []);\n          }\n          interactionFriendMap.get(interactionId)?.push(friendId);\n        });\n\n        // Build interaction data with friend IDs\n        const interactionData = recentInteractions.map(interaction => {\n          const friendIds = interactionFriendMap.get(interaction.id) || [];\n\n          return {\n            interactionDate: interaction.interactionDate,\n            category: interaction.interactionCategory,\n            friendIds,\n          };\n        });\n\n        // Analyze portfolio\n        const portfolioData = await analyzePortfolioAsync({\n          friends,\n          recentInteractions: interactionData,\n        });\n\n        if (isMounted) {\n          setPortfolio(portfolioData);\n          setIsLoading(false);\n        }\n      } catch (error) {\n        console.error('Error loading portfolio:', error);\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    // Initial load\n    loadPortfolio();\n\n    // Subscribe to friends changes\n    const friendsSubscription = database\n      .get<FriendModel>('friends')\n      .query()\n      .observe()\n      .subscribe(() => {\n        loadPortfolio(); // Recalculate when friends change\n      });\n\n    // Subscribe to interactions changes\n    const interactionsSubscription = database\n      .get<InteractionModel>('interactions')\n      .query()\n      .observe()\n      .subscribe(() => {\n        loadPortfolio(); // Recalculate when interactions change\n      });\n\n    return () => {\n      isMounted = false;\n      friendsSubscription?.unsubscribe();\n      interactionsSubscription?.unsubscribe();\n    };\n  }, []);\n\n  return {\n    portfolio,\n    isLoading,\n  };\n}\n\n/**\n * Hook to get portfolio-level suggestions\n * Returns network-wide insights and recommendations\n */\nexport function usePortfolioSuggestions(): {\n  suggestions: Suggestion[];\n  isLoading: boolean;\n} {\n  const { portfolio, isLoading } = usePortfolio();\n  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);\n\n  useEffect(() => {\n    if (portfolio) {\n      const portfolioSuggestions = generatePortfolioSuggestions(portfolio);\n      setSuggestions(portfolioSuggestions);\n    }\n  }, [portfolio]);\n\n  return {\n    suggestions,\n    isLoading,\n  };\n}\n\n/**\n * Hook to get a human-readable portfolio summary\n */\nexport function usePortfolioSummary(): {\n  summary: string;\n  healthScore: number;\n  weeklyFocus: ReturnType<typeof getWeeklyFocusRecommendation> | null;\n  isLoading: boolean;\n} {\n  const { portfolio, isLoading } = usePortfolio();\n\n  if (isLoading || !portfolio) {\n    return {\n      summary: 'Loading your network...',\n      healthScore: 0,\n      weeklyFocus: null,\n      isLoading: true,\n    };\n  }\n\n  return {\n    summary: getPortfolioHealthSummary(portfolio),\n    healthScore: portfolio.overallHealthScore,\n    weeklyFocus: getWeeklyFocusRecommendation(portfolio),\n    isLoading: false,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/hooks/useReciprocity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/hooks/useTierFit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/hooks/useTrendsAndPredictions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/effectiveness.service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friend' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/pattern-detection.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WeeklyReflection' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'STORY_CHIPS' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ChipType' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'calculateTimeWeightedAverage' is defined but never used. Allowed unused vars must match /^_/u.","line":172,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'direction' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":563,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":563,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pattern Detection Algorithm\n * Analyzes battery history and weaves to detect meaningful patterns\n */\n\nimport { database } from '@/db';\nimport UserProfile, { BatteryHistoryEntry } from '@/db/models/UserProfile';\nimport SocialBatteryLog from '@/db/models/SocialBatteryLog';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport { Q } from '@nozbe/watermelondb';\nimport { calculateInteractionQuality } from '@/modules/intelligence';\nimport { STORY_CHIPS, ChipType } from '@/modules/reflection';\n\nexport interface Pattern {\n  id: string;\n  type: 'cyclical' | 'correlation' | 'best_days' | 'consistency' | 'trend' | 'quality_depth' | 'adaptive_decay' | 'archetype_affinity' | 'momentum' | 'reflection' | 'emotional' | 'thematic';\n  title: string;\n  description: string;\n  insight: string;\n  confidence: 'high' | 'medium' | 'low'; // How confident we are in this pattern\n  icon: string; // Emoji\n  data?: unknown; // Optional supporting data (use type guards before accessing)\n}\n\ninterface DayOfWeekData {\n  day: number; // 0-6 (Sunday-Saturday)\n  avgBattery: number;\n  count: number;\n}\n\ninterface WeaveDay {\n  date: string; // YYYY-MM-DD\n  weaveCount: number;\n  batteryLevel: number | null;\n}\n\n/**\n * Fetch battery history from social_battery_logs table\n */\nasync function fetchBatteryHistory(): Promise<BatteryHistoryEntry[]> {\n  try {\n    const profiles = await database.get<UserProfile>('user_profile').query().fetch();\n    if (profiles.length === 0) return [];\n\n    const userId = profiles[0].id;\n    const logs = await database\n      .get<SocialBatteryLog>('social_battery_logs')\n      .query(\n        Q.where('user_id', userId),\n        Q.sortBy('timestamp', Q.asc)\n      )\n      .fetch();\n\n    // Convert to BatteryHistoryEntry format\n    return logs.map(log => ({\n      value: log.value,\n      timestamp: log.timestamp,\n    }));\n  } catch (error) {\n    console.error('Error fetching battery history:', error);\n    return [];\n  }\n}\n\n/**\n * Fetch weaves for pattern analysis\n */\nasync function fetchWeaves(daysBack: number = 90): Promise<Interaction[]> {\n  try {\n    const cutoff = Date.now() - daysBack * 24 * 60 * 60 * 1000;\n    return await database\n      .get<Interaction>('interactions')\n      .query(\n        Q.where('status', 'completed'),\n        Q.where('interaction_date', Q.gte(cutoff))\n      )\n      .fetch();\n  } catch (error) {\n    console.error('Error fetching weaves:', error);\n    return [];\n  }\n}\n\n/**\n * Detect day-of-week cyclical patterns\n */\nfunction detectDayOfWeekPatterns(history: BatteryHistoryEntry[]): Pattern | null {\n  if (history.length < 10) return null; // Lowered from 21 to 10 - need at least ~1.5 weeks of data\n\n  // Group by day of week\n  const dayData: DayOfWeekData[] = Array.from({ length: 7 }, (_, i) => ({\n    day: i,\n    avgBattery: 0,\n    count: 0,\n  }));\n\n  history.forEach((entry) => {\n    const date = new Date(entry.timestamp);\n    const dayOfWeek = date.getDay();\n    dayData[dayOfWeek].avgBattery += entry.value;\n    dayData[dayOfWeek].count += 1;\n  });\n\n  // Calculate averages\n  dayData.forEach((day) => {\n    if (day.count > 0) {\n      day.avgBattery = day.avgBattery / day.count;\n    }\n  });\n\n  // Find highest and lowest energy days\n  const validDays = dayData.filter((d) => d.count >= 2); // Lowered from 3 to 2 data points per day\n  if (validDays.length < 3) return null; // Lowered from 4 to 3 valid days\n\n  const highestDay = validDays.reduce((max, day) => (day.avgBattery > max.avgBattery ? day : max));\n  const lowestDay = validDays.reduce((min, day) => (day.avgBattery < min.avgBattery ? day : min));\n\n  const difference = highestDay.avgBattery - lowestDay.avgBattery;\n\n  // Only report if difference is significant (>= 0.6, lowered from 0.8)\n  if (difference < 0.6) return null;\n\n  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\n  return {\n    id: 'day-of-week-cycle',\n    type: 'cyclical',\n    title: 'Weekly Energy Rhythm',\n    description: `Your energy peaks on ${dayNames[highestDay.day]}s (${highestDay.avgBattery.toFixed(1)}/5) and dips on ${dayNames[lowestDay.day]}s (${lowestDay.avgBattery.toFixed(1)}/5).`,\n    insight: `Plan important connections on ${dayNames[highestDay.day]}s when your battery is naturally higher.`,\n    confidence: difference >= 1.5 ? 'high' : difference >= 1.0 ? 'medium' : 'low',\n    icon: 'calendar',\n    data: { dayData, highestDay, lowestDay },\n  };\n}\n\n/**\n * Calculate Pearson correlation coefficient\n * Returns value between -1 and 1\n */\nfunction calculatePearsonCorrelation(x: number[], y: number[]): number {\n  if (x.length !== y.length || x.length === 0) return 0;\n\n  const n = x.length;\n  const meanX = x.reduce((sum, val) => sum + val, 0) / n;\n  const meanY = y.reduce((sum, val) => sum + val, 0) / n;\n\n  let numerator = 0;\n  let denomX = 0;\n  let denomY = 0;\n\n  for (let i = 0; i < n; i++) {\n    const diffX = x[i] - meanX;\n    const diffY = y[i] - meanY;\n    numerator += diffX * diffY;\n    denomX += diffX * diffX;\n    denomY += diffY * diffY;\n  }\n\n  if (denomX === 0 || denomY === 0) return 0;\n\n  return numerator / (Math.sqrt(denomX) * Math.sqrt(denomY));\n}\n\n/**\n * Calculate time-weighted average\n * Recent values have higher weight based on exponential decay\n */\nfunction calculateTimeWeightedAverage(\n  values: { value: number; timestamp: number }[],\n  decayDays: number = 30\n): number {\n  if (values.length === 0) return 0;\n\n  const now = Date.now();\n  let weightedSum = 0;\n  let totalWeight = 0;\n  const msPerDay = 1000 * 60 * 60 * 24;\n\n  values.forEach(({ value, timestamp }) => {\n    const daysSince = Math.max(0, (now - timestamp) / msPerDay);\n    const weight = Math.exp(-daysSince / decayDays); // Exponential decay\n    weightedSum += value * weight;\n    totalWeight += weight;\n  });\n\n  return totalWeight > 0 ? weightedSum / totalWeight : 0;\n}\n\n/**\n * Detect battery-weave correlation using Pearson coefficient\n */\nasync function detectBatteryWeaveCorrelation(\n  history: BatteryHistoryEntry[],\n  weaves: Interaction[]\n): Promise<Pattern | null> {\n  if (history.length < 8 || weaves.length < 3) return null;\n\n  // Create map of date -> weave count\n  const weavesByDate = new Map<string, number>();\n  weaves.forEach((weave) => {\n    const date = new Date(weave.interactionDate);\n    const dateKey = date.toISOString().split('T')[0];\n    weavesByDate.set(dateKey, (weavesByDate.get(dateKey) || 0) + 1);\n  });\n\n  // Create paired data: days with both battery and weave data\n  const pairedData: WeaveDay[] = [];\n  history.forEach((entry) => {\n    const date = new Date(entry.timestamp);\n    const dateKey = date.toISOString().split('T')[0];\n    const weaveCount = weavesByDate.get(dateKey) || 0;\n\n    pairedData.push({\n      date: dateKey,\n      weaveCount,\n      batteryLevel: entry.value,\n    });\n  });\n\n  if (pairedData.length < 6) return null;\n\n  // Calculate Pearson correlation\n  const batteryLevels = pairedData.map((d) => d.batteryLevel || 0);\n  const weaveCounts = pairedData.map((d) => d.weaveCount);\n\n  const correlation = calculatePearsonCorrelation(batteryLevels, weaveCounts);\n\n  // Strong positive correlation (> 0.5)\n  if (correlation > 0.5) {\n    // Calculate averages for description context\n    const highBatteryDays = pairedData.filter((d) => d.batteryLevel && d.batteryLevel >= 4);\n    const lowBatteryDays = pairedData.filter((d) => d.batteryLevel && d.batteryLevel <= 2);\n\n    const avgWeavesHigh = highBatteryDays.length > 0\n      ? highBatteryDays.reduce((sum, d) => sum + d.weaveCount, 0) / highBatteryDays.length\n      : 0;\n    const avgWeavesLow = lowBatteryDays.length > 0\n      ? lowBatteryDays.reduce((sum, d) => sum + d.weaveCount, 0) / lowBatteryDays.length\n      : 0;\n\n    return {\n      id: 'battery-weave-positive',\n      type: 'correlation',\n      title: 'Energy Fuels Connection',\n      description: `Strong correlation (${correlation.toFixed(2)}) between your energy and social activity. You weave significantly more when your battery is full.`,\n      insight: 'Your social energy directly supports connection. Prioritize recharge when depleted.',\n      confidence: correlation > 0.7 ? 'high' : 'medium',\n      icon: 'zap',\n      data: { correlation, avgWeavesHigh, avgWeavesLow },\n    };\n  }\n\n  // Strong negative correlation (< -0.5)\n  if (correlation < -0.5) {\n    // Calculate averages for description context\n    const highBatteryDays = pairedData.filter((d) => d.batteryLevel && d.batteryLevel >= 4);\n    const lowBatteryDays = pairedData.filter((d) => d.batteryLevel && d.batteryLevel <= 2);\n\n    const avgWeavesHigh = highBatteryDays.length > 0\n      ? highBatteryDays.reduce((sum, d) => sum + d.weaveCount, 0) / highBatteryDays.length\n      : 0;\n    const avgWeavesLow = lowBatteryDays.length > 0\n      ? lowBatteryDays.reduce((sum, d) => sum + d.weaveCount, 0) / lowBatteryDays.length\n      : 0;\n\n    return {\n      id: 'battery-weave-inverse',\n      type: 'correlation',\n      title: 'Connection Energizes You',\n      description: `Inverse correlation (${correlation.toFixed(2)}) detected. You tend to weave more when your reported battery is lower.`,\n      insight: 'Connection might be recharging you. Your friendships could be your battery source.',\n      confidence: Math.abs(correlation) > 0.7 ? 'high' : 'medium',\n      icon: 'sparkles',\n      data: { correlation, avgWeavesHigh, avgWeavesLow },\n    };\n  }\n\n  return null;\n}\n\n/**\n * Detect best days for connection (high battery + high weaves)\n */\nasync function detectBestConnectionDays(\n  history: BatteryHistoryEntry[],\n  weaves: Interaction[]\n): Promise<Pattern | null> {\n  if (history.length < 12) return null; // Lowered from 21 to 12\n\n  // Analyze by day of week\n  const dayScores = Array.from({ length: 7 }, (_, i) => ({\n    day: i,\n    totalBattery: 0,\n    totalWeaves: 0,\n    count: 0,\n  }));\n\n  // Sum up battery by day of week\n  history.forEach((entry) => {\n    const date = new Date(entry.timestamp);\n    const dayOfWeek = date.getDay();\n    dayScores[dayOfWeek].totalBattery += entry.value;\n    dayScores[dayOfWeek].count += 1;\n  });\n\n  // Sum up weaves by day of week\n  weaves.forEach((weave) => {\n    const date = new Date(weave.interactionDate);\n    const dayOfWeek = date.getDay();\n    dayScores[dayOfWeek].totalWeaves += 1;\n  });\n\n  // Calculate composite score: (avgBattery * 0.5) + (avgWeaves * 0.5)\n  const scored = dayScores\n    .filter((d) => d.count >= 2) // Lowered from 3 to 2\n    .map((d) => ({\n      day: d.day,\n      avgBattery: d.totalBattery / d.count,\n      avgWeaves: d.totalWeaves / d.count,\n      compositeScore: (d.totalBattery / d.count) * 0.5 + (d.totalWeaves / d.count) * 0.5,\n    }))\n    .sort((a, b) => b.compositeScore - a.compositeScore);\n\n  if (scored.length < 3) return null; // Lowered from 4 to 3\n\n  const bestDay = scored[0];\n  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\n  return {\n    id: 'best-connection-days',\n    type: 'best_days',\n    title: 'Your Sweet Spot',\n    description: `${dayNames[bestDay.day]}s are your best connection days—high energy (${bestDay.avgBattery.toFixed(1)}/5) and active weaving (${bestDay.avgWeaves.toFixed(1)} weaves).`,\n    insight: `Schedule meaningful catch-ups on ${dayNames[bestDay.day]}s when you're naturally in sync.`,\n    confidence: bestDay.compositeScore >= 3 ? 'high' : bestDay.compositeScore >= 2 ? 'medium' : 'low',\n    icon: 'star',\n    data: { bestDay, allDays: scored },\n  };\n}\n\n/**\n * Detect consistency patterns\n */\nfunction detectConsistencyPattern(history: BatteryHistoryEntry[]): Pattern | null {\n  if (history.length < 14) return null; // Lowered from 30 to 14 (2 weeks)\n\n  // Calculate variance in battery levels\n  const avg = history.reduce((sum, e) => sum + e.value, 0) / history.length;\n  const variance =\n    history.reduce((sum, e) => sum + Math.pow(e.value - avg, 2), 0) / history.length;\n  const stdDev = Math.sqrt(variance);\n\n  // Low variance = consistent, high variance = volatile\n  if (stdDev <= 0.8) {\n    return {\n      id: 'high-consistency',\n      type: 'consistency',\n      title: 'Steady Energy Flow',\n      description: `Your battery stays remarkably consistent around ${avg.toFixed(1)}/5 (variance: ${stdDev.toFixed(2)}).`,\n      insight: 'Your steady rhythm suggests strong self-awareness and energy management.',\n      confidence: 'high',\n      icon: 'scale',\n      data: { avg, stdDev },\n    };\n  }\n\n  if (stdDev >= 1.5) {\n    return {\n      id: 'high-volatility',\n      type: 'consistency',\n      title: 'Dynamic Energy Shifts',\n      description: `Your battery fluctuates significantly (variance: ${stdDev.toFixed(2)}), ranging across ${Math.max(...history.map((h) => h.value)) - Math.min(...history.map((h) => h.value))} levels.`,\n      insight: 'Your energy is responsive to external factors. Consider tracking what influences your shifts.',\n      confidence: 'high',\n      icon: 'activity',\n      data: { avg, stdDev },\n    };\n  }\n\n  return null;\n}\n\n/**\n * Detect battery trend (improving, declining, stable)\n */\nfunction detectTrendPattern(history: BatteryHistoryEntry[]): Pattern | null {\n  if (history.length < 8) return null; // Lowered from 14 to 8\n\n  // Split into first half and second half\n  const midpoint = Math.floor(history.length / 2);\n  const firstHalf = history.slice(0, midpoint);\n  const secondHalf = history.slice(midpoint);\n\n  const avgFirst = firstHalf.reduce((sum, e) => sum + e.value, 0) / firstHalf.length;\n  const avgSecond = secondHalf.reduce((sum, e) => sum + e.value, 0) / secondHalf.length;\n\n  const change = avgSecond - avgFirst;\n\n  // Rising trend\n  if (change >= 0.6) {\n    return {\n      id: 'rising-trend',\n      type: 'trend',\n      title: 'Energy on the Rise',\n      description: `Your battery has increased from ${avgFirst.toFixed(1)}/5 to ${avgSecond.toFixed(1)}/5 recently (+${change.toFixed(1)}).`,\n      insight: 'Something is working! Reflect on what has been different lately.',\n      confidence: change >= 1.0 ? 'high' : 'medium',\n      icon: 'trending-up',\n      data: { avgFirst, avgSecond, change },\n    };\n  }\n\n  // Declining trend\n  if (change <= -0.6) {\n    return {\n      id: 'declining-trend',\n      type: 'trend',\n      title: 'Energy Drifting Lower',\n      description: `Your battery has decreased from ${avgFirst.toFixed(1)}/5 to ${avgSecond.toFixed(1)}/5 recently (${change.toFixed(1)}).`,\n      insight: 'This might be a signal to prioritize rest and recalibrate your pace.',\n      confidence: Math.abs(change) >= 1.0 ? 'high' : 'medium',\n      icon: 'trending-down',\n      data: { avgFirst, avgSecond, change },\n    };\n  }\n\n  // Stable\n  return {\n    id: 'stable-trend',\n    type: 'trend',\n    title: 'Steady State',\n    description: `Your battery has remained stable around ${avgSecond.toFixed(1)}/5.`,\n    insight: 'Your current rhythm is sustainable. Keep doing what works.',\n    confidence: 'medium',\n    icon: 'arrow-right',\n    data: { avgFirst, avgSecond, change },\n  };\n}\n\n/**\n * Detect quality depth patterns - analyzes interaction quality metrics\n */\nasync function detectQualityDepthPattern(weaves: Interaction[]): Promise<Pattern | null> {\n  if (weaves.length < 6) return null; // Lowered from 10 to 6\n\n  // Calculate quality metrics for all weaves\n  const qualityData = await Promise.all(\n    weaves.map(async (weave) => {\n      const quality = calculateInteractionQuality({\n        vibe: weave.vibe as any,\n        duration: weave.duration as any,\n        note: weave.note || null,\n        reflectionJSON: weave.reflectionJSON || null,\n      });\n\n      // Get friend names\n      const interactionFriends = await database\n        .get<InteractionFriend>('interaction_friends')\n        .query(Q.where('interaction_id', weave.id))\n        .fetch();\n\n      const friendNames = await Promise.all(\n        interactionFriends.map(async (ifriend: InteractionFriend) => {\n          try {\n            const friendId = ifriend.friendId;\n            const friend = await database.get<FriendModel>('friends').find(friendId);\n            return friend.name;\n          } catch {\n            return null;\n          }\n        })\n      );\n\n      return {\n        quality,\n        friendNames: friendNames.filter((n): n is string => n !== null),\n      };\n    })\n  );\n\n  // Group by friend and calculate average quality\n  const friendQualityMap = new Map<string, { totalQuality: number; count: number }>();\n\n  qualityData.forEach(({ quality, friendNames }) => {\n    friendNames.forEach((name) => {\n      const existing = friendQualityMap.get(name) || { totalQuality: 0, count: 0 };\n      friendQualityMap.set(name, {\n        totalQuality: existing.totalQuality + quality.overallQuality,\n        count: existing.count + 1,\n      });\n    });\n  });\n\n  // Find friends with highest quality scores (need at least 2 interactions) - lowered from 3\n  const qualityFriends = Array.from(friendQualityMap.entries())\n    .filter(([_, data]) => data.count >= 2)\n    .map(([name, data]) => ({ name, avgQuality: data.totalQuality / data.count, count: data.count }))\n    .sort((a, b) => b.avgQuality - a.avgQuality);\n\n  if (qualityFriends.length === 0) return null;\n\n  const topFriend = qualityFriends[0];\n  const avgAllQuality =\n    qualityData.reduce((sum, d) => sum + d.quality.overallQuality, 0) / qualityData.length;\n\n  // Only show pattern if there's a meaningful difference (lowered from 0.5 to 0.3)\n  if (topFriend.avgQuality - avgAllQuality < 0.3) return null;\n\n  const topFriendsList = qualityFriends.slice(0, 3).map((f) => f.name);\n\n  return {\n    id: 'quality-depth',\n    type: 'quality_depth',\n    title: 'Deep Connections',\n    description: `Your deepest, most intentional interactions are with ${topFriendsList.join(', ')} (${topFriend.avgQuality.toFixed(1)}/5 quality vs ${avgAllQuality.toFixed(1)}/5 average).`,\n    insight: `Consider bringing this level of intentionality to other friendships. Depth creates lasting bonds.`,\n    confidence: topFriend.avgQuality >= 4 ? 'high' : topFriend.avgQuality >= 3.5 ? 'medium' : 'low',\n    icon: 'gem',\n    data: { topFriends: qualityFriends.slice(0, 5), avgAllQuality },\n  };\n}\n\n/**\n * Detect adaptive decay patterns - shows learned tolerance windows\n */\nasync function detectAdaptiveDecayPattern(): Promise<Pattern | null> {\n  const allFriends = await database.get<FriendModel>('friends').query().fetch();\n\n  // Filter friends with learned tolerance windows (3+ rated weaves) - lowered from 5\n  // Note: Using ratedWeavesCount as proxy for interaction history\n  const adaptedFriends = allFriends.filter(\n    (f) => f.toleranceWindowDays && f.ratedWeavesCount >= 3\n  );\n\n  if (adaptedFriends.length < 2) return null; // Lowered from 3 to 2\n\n  // Find the most interesting adaptive pattern\n  const defaultWindows: Record<string, number> = {\n    InnerCircle: 7,\n    CloseFriends: 14,\n    Community: 21,\n  };\n\n  const adaptations = adaptedFriends.map((f) => {\n    const defaultWindow = defaultWindows[f.dunbarTier] || 14;\n    const learnedWindow = f.toleranceWindowDays || defaultWindow;\n    const difference = learnedWindow - defaultWindow;\n    return { name: f.name, tier: f.dunbarTier, learnedWindow, defaultWindow, difference };\n  });\n\n  // Sort by most significant adaptation (positive or negative)\n  adaptations.sort((a, b) => Math.abs(b.difference) - Math.abs(a.difference));\n\n  const mostAdapted = adaptations[0];\n\n  // Only show if there's meaningful learning (at least 2 days difference) - lowered from 3\n  if (Math.abs(mostAdapted.difference) < 2) return null;\n\n  const direction = mostAdapted.difference > 0 ? 'comfortable' : 'closer';\n  const rhythm = mostAdapted.difference > 0 ? 'relaxed' : 'frequent';\n\n  return {\n    id: 'adaptive-decay',\n    type: 'adaptive_decay',\n    title: 'Natural Rhythms Learned',\n    description: `You and ${mostAdapted.name} have settled into a ${rhythm} ${mostAdapted.learnedWindow}-day rhythm (vs typical ${mostAdapted.defaultWindow}-day for ${mostAdapted.tier}).`,\n    insight: `The app has adapted to honor this natural flow. Your authentic connection patterns are being respected.`,\n    confidence: adaptedFriends.length >= 5 ? 'high' : 'medium',\n    icon: 'brain',\n    data: { mostAdapted, allAdaptations: adaptations.slice(0, 5) },\n  };\n}\n\n/**\n * Detect archetype affinity patterns - which archetypes you connect best with\n */\nasync function detectArchetypeAffinityPattern(weaves: Interaction[]): Promise<Pattern | null> {\n  if (weaves.length < 10) return null; // Lowered from 15 to 10\n\n  // Get all friends to map archetypes\n  const allFriends = await database.get<FriendModel>('friends').query().fetch();\n  const friendArchetypeMap = new Map<string, string>();\n  allFriends.forEach((f) => friendArchetypeMap.set(f.id, f.archetype));\n\n  // Build archetype -> scores mapping\n  const archetypeData = new Map<\n    string,\n    { totalScore: number; count: number; friends: Set<string> }\n  >();\n\n  for (const weave of weaves) {\n    const interactionFriends = await database\n      .get<InteractionFriend>('interaction_friends')\n      .query(Q.where('interaction_id', weave.id))\n      .fetch();\n\n    for (const ifriend of interactionFriends) {\n      const friendId = ifriend.friendId;\n      const archetype = friendArchetypeMap.get(friendId);\n      if (!archetype) continue;\n\n      try {\n        const friend = await database.get<FriendModel>('friends').find(friendId);\n        const existing = archetypeData.get(archetype) || {\n          totalScore: 0,\n          count: 0,\n          friends: new Set(),\n        };\n        archetypeData.set(archetype, {\n          totalScore: existing.totalScore + friend.weaveScore,\n          count: existing.count + 1,\n          friends: existing.friends.add(friend.name),\n        });\n      } catch {\n        continue;\n      }\n    }\n  }\n\n  // Calculate average scores per archetype\n  const archetypeScores = Array.from(archetypeData.entries())\n    .filter(([_, data]) => data.count >= 2) // Lowered from 3 to 2 interactions\n    .map(([archetype, data]) => ({\n      archetype,\n      avgScore: data.totalScore / data.count,\n      count: data.count,\n      friendNames: Array.from(data.friends).slice(0, 3),\n    }))\n    .sort((a, b) => b.avgScore - a.avgScore);\n\n  if (archetypeScores.length < 2) return null;\n\n  const best = archetypeScores[0];\n  const worst = archetypeScores[archetypeScores.length - 1];\n  const scoreDifference = best.avgScore - worst.avgScore;\n\n  // Only show if there's a meaningful difference (lowered from 15 to 10)\n  if (scoreDifference < 10) return null;\n\n  return {\n    id: 'archetype-affinity',\n    type: 'archetype_affinity',\n    title: 'Archetype Affinity',\n    description: `You thrive with ${best.archetype} friends (avg ${Math.round(best.avgScore)} health), but ${worst.archetype} connections need more attention (avg ${Math.round(worst.avgScore)}).`,\n    insight: `Your ${best.archetype} relationships come naturally. Consider being more intentional with ${worst.archetype} friends to maintain balance.`,\n    confidence: scoreDifference >= 20 ? 'high' : scoreDifference >= 10 ? 'medium' : 'low', // Adjusted thresholds\n    icon: 'users',\n    data: { best, worst, allArchetypes: archetypeScores },\n  };\n}\n\n/**\n * Main function: detect all patterns\n */\nexport async function detectPatterns(): Promise<Pattern[]> {\n  const history = await fetchBatteryHistory();\n  const weaves = await fetchWeaves(90); // Last 90 days\n\n  if (history.length < 5) {\n    return []; // Not enough data (lowered from 7 to 5)\n  }\n\n  const patterns: Pattern[] = [];\n\n  // Run all detection algorithms (existing patterns)\n  const cyclicalPattern = detectDayOfWeekPatterns(history);\n  if (cyclicalPattern) patterns.push(cyclicalPattern);\n\n  const correlationPattern = await detectBatteryWeaveCorrelation(history, weaves);\n  if (correlationPattern) patterns.push(correlationPattern);\n\n  const bestDaysPattern = await detectBestConnectionDays(history, weaves);\n  if (bestDaysPattern) patterns.push(bestDaysPattern);\n\n  const consistencyPattern = detectConsistencyPattern(history);\n  if (consistencyPattern) patterns.push(consistencyPattern);\n\n  const trendPattern = detectTrendPattern(history);\n  if (trendPattern) patterns.push(trendPattern);\n\n  // Run new pattern detection algorithms\n  const qualityDepthPattern = await detectQualityDepthPattern(weaves);\n  if (qualityDepthPattern) patterns.push(qualityDepthPattern);\n\n  const adaptiveDecayPattern = await detectAdaptiveDecayPattern();\n  if (adaptiveDecayPattern) patterns.push(adaptiveDecayPattern);\n\n  const archetypeAffinityPattern = await detectArchetypeAffinityPattern(weaves);\n  if (archetypeAffinityPattern) patterns.push(archetypeAffinityPattern);\n\n  // Sort by confidence\n  const confidenceOrder = { high: 3, medium: 2, low: 1 };\n  patterns.sort((a, b) => confidenceOrder[b.confidence] - confidenceOrder[a.confidence]);\n\n  return patterns;\n}\n\n/**\n * Get statistics about the data available for pattern detection\n */\nexport async function getPatternDataStats(): Promise<{ batteryDays: number; weaveCount: number }> {\n  const history = await fetchBatteryHistory();\n  const weaves = await fetchWeaves(90);\n  return { batteryDays: history.length, weaveCount: weaves.length };\n}\n\n/**\n * Data about best connection days for smart scheduling\n */\n\n\n/**\n * Get best connection days data for smart scheduling\n * Returns the analyzed day-of-week data for battery and weave patterns\n */\nexport async function getBestConnectionDaysData(): Promise<BestDaysData | null> {\n  const history = await fetchBatteryHistory();\n  const weaves = await fetchWeaves(90);\n\n  if (history.length < 12) return null; // Need enough history\n\n  // Analyze by day of week\n  const dayScores = Array.from({ length: 7 }, (_, i) => ({\n    day: i,\n    totalBattery: 0,\n    totalWeaves: 0,\n    count: 0,\n  }));\n\n  // Sum up battery by day of week\n  history.forEach((entry) => {\n    const date = new Date(entry.timestamp);\n    const dayOfWeek = date.getDay();\n    dayScores[dayOfWeek].totalBattery += entry.value;\n    dayScores[dayOfWeek].count += 1;\n  });\n\n  // Sum up weaves by day of week\n  weaves.forEach((weave) => {\n    const date = new Date(weave.interactionDate);\n    const dayOfWeek = date.getDay();\n    dayScores[dayOfWeek].totalWeaves += 1;\n  });\n\n  // Calculate composite score and averages for each day\n  const scored = dayScores\n    .filter((d) => d.count >= 2)\n    .map((d) => ({\n      day: d.day,\n      avgBattery: d.totalBattery / d.count,\n      avgWeaves: d.totalWeaves / d.count,\n      compositeScore: (d.totalBattery / d.count) * 0.5 + (d.totalWeaves / d.count) * 0.5,\n    }))\n    .sort((a, b) => b.compositeScore - a.compositeScore);\n\n  if (scored.length < 3) return null;\n\n  const bestDay = scored[0];\n\n  return {\n    bestDay: {\n      day: bestDay.day,\n      avgBattery: bestDay.avgBattery,\n      avgWeaves: bestDay.avgWeaves,\n    },\n    allDays: scored.map(d => ({\n      day: d.day,\n      avgBattery: d.avgBattery,\n      avgWeaves: d.avgWeaves,\n    })),\n  };\n}\n\n/**\n * Get current battery level from the most recent check-in\n * Returns undefined if no recent battery data\n */\nexport async function getCurrentBatteryLevel(): Promise<number | undefined> {\n  const history = await fetchBatteryHistory();\n  if (history.length === 0) return undefined;\n\n  // Get the most recent entry\n  const mostRecent = history[history.length - 1];\n\n  // Only return if checked in within last 24 hours\n  const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;\n  if (mostRecent.timestamp < oneDayAgo) return undefined;\n\n  return mostRecent.value;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/pattern.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/portfolio-suggestions.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FlexibilityMode' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":81},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'portfolio' is defined but never used. Allowed unused args must match /^_/u.","line":27,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Suggestion } from '@/shared/types/common';\nimport { type FriendshipPortfolio, type PortfolioImbalance, type FlexibilityMode } from '../types';\n\n/**\n * Generates portfolio-level suggestions based on network-wide imbalances\n * These are shown alongside individual friend suggestions to provide holistic guidance\n */\nexport function generatePortfolioSuggestions(portfolio: FriendshipPortfolio): Suggestion[] {\n    const suggestions: Suggestion[] = [];\n\n    // Process each imbalance\n    portfolio.imbalances.forEach(imbalance => {\n        const suggestion = convertImbalanceToSuggestion(imbalance, portfolio);\n        if (suggestion) {\n            suggestions.push(suggestion);\n        }\n    });\n\n    return suggestions;\n}\n\n/**\n * Converts a portfolio imbalance into an actionable suggestion\n */\nfunction convertImbalanceToSuggestion(\n    imbalance: PortfolioImbalance,\n    portfolio: FriendshipPortfolio\n): Suggestion | null {\n    const baseId = `portfolio-${imbalance.type}`;\n\n    switch (imbalance.type) {\n        case 'inner-circle-drift':\n            const urgency = imbalance.severity === 'critical' ? 'critical' : 'high';\n            return {\n                id: `${baseId}-inner-circle`,\n                friendId: '', // Portfolio suggestions aren't tied to a specific friend\n                friendName: '',\n                urgency: urgency,\n                category: 'portfolio',\n                title: imbalance.title,\n                subtitle: imbalance.description,\n                actionLabel: 'View Inner Circle',\n                icon: '⚠️',\n                action: { type: 'plan' }, // Could navigate to Inner Circle view\n                dismissible: urgency !== 'critical',\n                createdAt: new Date(),\n                type: 'reconnect',\n            };\n\n        case 'tier-neglect':\n            return {\n                id: `${baseId}-${imbalance.affectedTier}`,\n                friendId: '',\n                friendName: '',\n                urgency: imbalance.severity === 'high' ? 'high' : 'medium',\n                category: 'portfolio',\n                title: imbalance.title,\n                subtitle: imbalance.recommendedAction,\n                actionLabel: `View ${imbalance.affectedTier}`,\n                icon: '📊',\n                action: { type: 'plan' },\n                dismissible: true,\n                createdAt: new Date(),\n                type: 'connect',\n            };\n\n        case 'overcommitment':\n            return {\n                id: baseId,\n                friendId: '',\n                friendName: '',\n                urgency: 'medium',\n                category: 'portfolio',\n                title: imbalance.title,\n                subtitle: imbalance.recommendedAction,\n                actionLabel: 'Review Network',\n                icon: '🧘',\n                action: { type: 'plan' },\n                dismissible: true,\n                createdAt: new Date(),\n                type: 'connect',\n            };\n\n        case 'monotony':\n            return {\n                id: baseId,\n                friendId: '',\n                friendName: '',\n                urgency: 'low',\n                category: 'portfolio',\n                title: imbalance.title,\n                subtitle: imbalance.recommendedAction,\n                actionLabel: 'Explore Ideas',\n                icon: '🎨',\n                action: { type: 'plan' },\n                dismissible: true,\n                createdAt: new Date(),\n                type: 'deepen',\n            };\n\n        case 'lack-diversity':\n            return {\n                id: baseId,\n                friendId: '',\n                friendName: '',\n                urgency: 'low',\n                category: 'portfolio',\n                title: imbalance.title,\n                subtitle: imbalance.recommendedAction,\n                actionLabel: 'Try Something New',\n                icon: '🌈',\n                action: { type: 'plan' },\n                dismissible: true,\n                createdAt: new Date(),\n                type: 'deepen',\n            };\n\n        default:\n            return null;\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/portfolio.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friends' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":23,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'recentInteractions' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":23,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Tier, Archetype } from '@/shared/types/common';\nimport { InteractionCategory } from '@/shared/types/common';\nimport { calculateCurrentScore } from '@/modules/intelligence';\nimport FriendModel from '@/db/models/Friend';\nimport { capturePortfolioSnapshot } from './trend.service';\nimport { FriendshipPortfolio, PortfolioImbalance } from '../types';\nimport { Suggestion } from '@/shared/types/common';\n\n// Types for analysis\nexport interface PortfolioAnalysisInput {\n  friends: FriendModel[];\n  recentInteractions: Array<{\n    interactionDate: Date;\n    category?: InteractionCategory | string | null;\n    friendIds: string[];\n  }>;\n}\n\n/**\n * Analyzes the entire friendship portfolio to provide network-level insights\n */\nexport function analyzePortfolio(input: PortfolioAnalysisInput): FriendshipPortfolio {\n  const { friends, recentInteractions } = input;\n\n  // Calculate current scores for all friends\n  // NOTE: Intelligence module's calculateCurrentScore is async, but here we are mapping synchronously.\n  // However, calculateCurrentScore in intelligence module MIGHT be async.\n  // Let's check if calculateCurrentScore takes a FriendModel directly and returns a number.\n  // In legacy lib/portfolio-analyzer.ts, it imported from orchestrator.service which was async in Phase 2 spec?\n  // Wait, I need to check calculateCurrentScore signature.\n  // Assuming for now we can get the score. Ideally we should fetch scores async.\n  // But let's stick to the structure. If calculateCurrentScore is async, we need to make this function async.\n  // I will assume it accepts FriendModel and returns number or Promise<number>.\n  // Checking lib/portfolio-analyzer.ts, it imported `calculateCurrentScore` from `orchestrator.service`.\n  // Let's assume synchronous for now or I'll fix it if I see an error.\n  // Wait, `calculateCurrentScore` usually triggers a DB calc.\n  // But `FriendModel` usually has `weave_score` property.\n  // Let's use the `weave_score` property directly from the model for sync analysis if possible,\n  // or make this function async. Making it async is safer.\n\n  // REVISION: I'll make `analyzePortfolio` async to be safe.\n  throw new Error(\"analyzePortfolio should be async. Please use analyzePortfolioAsync\");\n}\n\nexport async function analyzePortfolioAsync(input: PortfolioAnalysisInput): Promise<FriendshipPortfolio> {\n  const { friends, recentInteractions } = input;\n\n  // Calculate current scores for all friends\n  const friendsWithScores = await Promise.all(friends.map(async friend => {\n    const score = calculateCurrentScore(friend);\n    return {\n      friend,\n      currentScore: isNaN(score) ? 0 : score,\n    };\n  }));\n\n  // Overall health score (weighted by tier importance)\n  const tierWeights: Record<Tier, number> = {\n    InnerCircle: 3.0,\n    CloseFriends: 2.0,\n    Community: 1.0,\n  };\n\n  let weightedSum = 0;\n  let weightTotal = 0;\n\n  friendsWithScores.forEach(({ friend, currentScore }) => {\n    const weight = tierWeights[friend.dunbarTier as Tier] || 1.0;\n    weightedSum += currentScore * weight;\n    weightTotal += weight;\n  });\n\n  const overallHealthScore = weightTotal > 0 ? Math.round(weightedSum / weightTotal) : 0;\n\n  // Friend status counts\n  const activeFriends = friendsWithScores.filter(f => f.currentScore > 30).length;\n  const driftingFriends = friendsWithScores.filter(f => f.currentScore < 40).length;\n  const thrivingFriends = friendsWithScores.filter(f => f.currentScore > 80).length;\n\n  // Tier distribution\n  const tierGroups = groupByTier(friendsWithScores);\n  const tierDistribution = Object.entries(tierGroups).map(([tier, group]) => {\n    const avgScore = group.reduce((sum, f) => sum + (isNaN(f.currentScore) ? 0 : f.currentScore), 0) / (group.length || 1);\n    const safeAvgScore = isNaN(avgScore) ? 0 : avgScore;\n    const needsAttention = safeAvgScore < 50 || (tier === 'InnerCircle' && safeAvgScore < 60);\n\n    return {\n      tier: tier as Tier,\n      count: group.length,\n      percentage: Math.round((group.length / friends.length) * 100) || 0,\n      avgScore: Math.round(safeAvgScore),\n      needsAttention,\n    };\n  });\n\n  // Recent activity metrics (last 30 days)\n  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n  const recentOnly = recentInteractions.filter(i => i.interactionDate >= thirtyDaysAgo);\n\n  const totalInteractions = recentOnly.length;\n  const interactionsPerWeek = Math.round((totalInteractions / 30) * 7 * 10) / 10;\n\n  // Calculate how many unique friends were interacted with\n  const uniqueFriendIds = new Set<string>();\n  recentOnly.forEach(i => i.friendIds.forEach(id => uniqueFriendIds.add(id)));\n  const avgInteractionsPerFriend = uniqueFriendIds.size > 0\n    ? Math.round((totalInteractions / uniqueFriendIds.size) * 10) / 10\n    : 0;\n\n  // Diversity score (variety of interaction categories)\n  const categorySet = new Set(\n    recentOnly\n      .map(i => i.category)\n      .filter((c): c is InteractionCategory => !!c)\n  );\n  const diversityScore = Math.min(1, categorySet.size / 6); // 6+ categories = max diversity\n\n  const recentActivityMetrics = {\n    totalInteractions,\n    interactionsPerWeek,\n    avgInteractionsPerFriend,\n    diversityScore,\n  };\n\n  // Category distribution\n  const categoryCounts = new Map<InteractionCategory, number>();\n  recentOnly.forEach(i => {\n    if (i.category) {\n      const cat = i.category as InteractionCategory;\n      categoryCounts.set(cat, (categoryCounts.get(cat) || 0) + 1);\n    }\n  });\n\n  const categoryDistribution = Array.from(categoryCounts.entries())\n    .map(([category, count]) => ({\n      category,\n      count,\n      percentage: Math.round((count / (totalInteractions || 1)) * 100),\n    }))\n    .sort((a, b) => b.count - a.count);\n\n  // Archetype distribution\n  const archetypeCounts = new Map<Archetype, number>();\n  friends.forEach(f => {\n    const archetype = f.archetype as Archetype;\n    archetypeCounts.set(archetype, (archetypeCounts.get(archetype) || 0) + 1);\n  });\n\n  const archetypeDistribution = Array.from(archetypeCounts.entries())\n    .map(([archetype, count]) => ({\n      archetype,\n      count,\n      percentage: Math.round((count / friends.length) * 100),\n    }))\n    .sort((a, b) => b.count - a.count);\n\n  // Detect imbalances\n  const imbalances = detectImbalances({\n    friends,\n    friendsWithScores,\n    tierDistribution,\n    recentActivityMetrics,\n    categoryDistribution,\n  });\n\n  const portfolio = {\n    overallHealthScore,\n    totalFriends: friends.length,\n    activeFriends,\n    driftingFriends,\n    thrivingFriends,\n    tierDistribution,\n    recentActivityMetrics,\n    categoryDistribution,\n    archetypeDistribution,\n    imbalances,\n    lastAnalyzed: new Date(),\n  };\n\n  // Automatically capture snapshot for trend tracking (fire and forget)\n  capturePortfolioSnapshot(portfolio).catch(err =>\n    console.warn('Failed to capture portfolio snapshot:', err)\n  );\n\n  return portfolio;\n}\n\nfunction groupByTier(\n  friendsWithScores: Array<{ friend: FriendModel; currentScore: number }>\n): Record<Tier, Array<{ friend: FriendModel; currentScore: number }>> {\n  const groups: Record<Tier, Array<{ friend: FriendModel; currentScore: number }>> = {\n    InnerCircle: [],\n    CloseFriends: [],\n    Community: [],\n  };\n\n  friendsWithScores.forEach(item => {\n    const tier = item.friend.dunbarTier as Tier;\n    if (groups[tier]) {\n      groups[tier].push(item);\n    }\n  });\n\n  return groups;\n}\n\nfunction detectImbalances(context: {\n  friends: FriendModel[];\n  friendsWithScores: Array<{ friend: FriendModel; currentScore: number }>;\n  tierDistribution: FriendshipPortfolio['tierDistribution'];\n  recentActivityMetrics: FriendshipPortfolio['recentActivityMetrics'];\n  categoryDistribution: FriendshipPortfolio['categoryDistribution'];\n}): PortfolioImbalance[] {\n  const imbalances: PortfolioImbalance[] = [];\n\n  // Check for Inner Circle drift (CRITICAL)\n  const innerCircle = context.tierDistribution.find(t => t.tier === 'InnerCircle');\n  if (innerCircle && innerCircle.avgScore < 50) {\n    imbalances.push({\n      type: 'inner-circle-drift',\n      severity: 'critical',\n      title: 'Your closest friends need attention',\n      description: `Your Inner Circle is drifting (avg score: ${innerCircle.avgScore}). These are your most important relationships.`,\n      affectedTier: 'InnerCircle',\n      recommendedAction: 'Prioritize quality time with your Inner Circle this week',\n    });\n  } else if (innerCircle && innerCircle.avgScore < 65) {\n    imbalances.push({\n      type: 'inner-circle-drift',\n      severity: 'high',\n      title: 'Inner Circle could use more attention',\n      description: `Your closest friends are maintaining (avg score: ${innerCircle.avgScore}), but could be stronger.`,\n      affectedTier: 'InnerCircle',\n      recommendedAction: 'Schedule meaningful time with your Inner Circle',\n    });\n  }\n\n  // Check for tier neglect\n  context.tierDistribution.forEach(tier => {\n    if (tier.needsAttention && tier.tier !== 'InnerCircle') {\n      imbalances.push({\n        type: 'tier-neglect',\n        severity: tier.avgScore < 40 ? 'high' : 'medium',\n        title: `${tier.tier} needs attention`,\n        description: `Your ${tier.tier} tier is drifting (avg score: ${tier.avgScore}).`,\n        affectedTier: tier.tier,\n        recommendedAction: `Plan lighter-touch connections with your ${tier.tier} friends`,\n      });\n    }\n  });\n\n  // Check for overcommitment (too many interactions per week)\n  if (context.recentActivityMetrics.interactionsPerWeek > 12) {\n    imbalances.push({\n      type: 'overcommitment',\n      severity: 'medium',\n      title: 'You might be overcommitted',\n      description: `You're averaging ${context.recentActivityMetrics.interactionsPerWeek} interactions per week. This is a lot!`,\n      recommendedAction: 'Consider focusing on quality over quantity. Your Inner Circle might need deeper time.',\n    });\n  }\n\n  // Check for lack of diversity (doing same things)\n  if (context.recentActivityMetrics.diversityScore < 0.3) {\n    const topCategory = context.categoryDistribution[0];\n    if (topCategory && topCategory.percentage > 60) {\n      imbalances.push({\n        type: 'monotony',\n        severity: 'low',\n        title: 'Your interactions are getting repetitive',\n        description: `${topCategory.percentage}% of your recent interactions have been the same type.`,\n        recommendedAction: 'Try mixing in different types of connection - variety deepens bonds',\n      });\n    }\n  }\n\n  // Check for lack of overall activity\n  if (context.recentActivityMetrics.interactionsPerWeek < 2 && context.friends.length >= 5) {\n    imbalances.push({\n      type: 'tier-neglect',\n      severity: 'medium',\n      title: 'Your network needs more connection',\n      description: `You're only averaging ${context.recentActivityMetrics.interactionsPerWeek} interactions per week.`,\n      recommendedAction: 'Even small gestures count. Send a text or make a quick call.',\n    });\n  }\n\n  // Sort by severity\n  const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n  return imbalances.sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity]);\n}\n\nexport function getPortfolioHealthSummary(portfolio: FriendshipPortfolio): string {\n  if (portfolio.overallHealthScore >= 80) {\n    return `Your friendship network is thriving! ${portfolio.thrivingFriends} friends are doing great.`;\n  } else if (portfolio.overallHealthScore >= 60) {\n    return `Your network is healthy overall. ${portfolio.activeFriends} of ${portfolio.totalFriends} friends are active.`;\n  } else if (portfolio.overallHealthScore >= 40) {\n    return `Your network needs some attention. ${portfolio.driftingFriends} friends are drifting.`;\n  } else {\n    return `Your network needs urgent attention. Focus on your Inner Circle first.`;\n  }\n}\n\nexport function getWeeklyFocusRecommendation(portfolio: FriendshipPortfolio): {\n  tier: Tier;\n  reason: string;\n  suggestedActions: string[];\n} {\n  // Always prioritize Inner Circle if drifting\n  const innerCircle = portfolio.tierDistribution.find(t => t.tier === 'InnerCircle');\n  if (innerCircle && innerCircle.avgScore < 60) {\n    return {\n      tier: 'InnerCircle',\n      reason: `Your closest friends need attention (avg score: ${innerCircle.avgScore})`,\n      suggestedActions: [\n        'Schedule quality one-on-one time',\n        'Have a meaningful conversation',\n        'Plan something you both love',\n      ],\n    };\n  }\n\n  // Otherwise focus on the tier with lowest average score\n  const sortedTiers = [...portfolio.tierDistribution]\n    .filter(t => t.count > 0) // Ignore empty tiers\n    .sort((a, b) => a.avgScore - b.avgScore);\n\n  if (sortedTiers.length === 0) {\n    return {\n      tier: 'InnerCircle',\n      reason: 'Start connecting with friends',\n      suggestedActions: ['Reach out to someone new'],\n    };\n  }\n\n  const lowestTier = sortedTiers[0];\n\n  return {\n    tier: lowestTier.tier,\n    reason: `${lowestTier.tier} has the lowest average score (${lowestTier.avgScore})`,\n    suggestedActions:\n      lowestTier.tier === 'InnerCircle'\n        ? ['Plan deep, quality time together', 'Have vulnerable conversations']\n        : lowestTier.tier === 'CloseFriends'\n          ? ['Grab coffee or a meal', 'Send a thoughtful message', 'Plan a group hangout']\n          : ['Send quick check-in texts', 'React to their social media', 'Plan a casual group event'],\n  };\n}\n\n// --- Insights Generation (merged from portfolio-insights.ts) ---\n\ninterface FriendStats {\n  id: string;\n  name: string;\n  tier: Tier;\n  archetype: Archetype;\n  score: number;\n  daysSinceInteraction: number;\n}\n\nexport interface PortfolioAnalysisStats {\n  friends: FriendStats[];\n  tierScores: {\n    inner: { avg: number; count: number; drifting: number };\n    close: { avg: number; count: number; drifting: number };\n    community: { avg: number; count: number; drifting: number };\n  };\n  archetypeBalance: Record<Archetype, number>;\n}\n\nexport function generatePortfolioInsights(analysis: PortfolioAnalysisStats): Suggestion | null {\n  const { tierScores, friends, archetypeBalance } = analysis;\n\n  // INSIGHT 1: Tier Imbalance Alert\n  // Inner Circle thriving but Close Friends neglected\n  if (\n    tierScores.inner.avg > 70 &&\n    tierScores.close.avg < 50 &&\n    tierScores.close.count >= 3 &&\n    tierScores.close.drifting >= 2\n  ) {\n    const driftingFriends = friends\n      .filter(f => f.tier === 'CloseFriends' && f.score < 50)\n      .slice(0, 3)\n      .map(f => f.name);\n\n    return {\n      id: `portfolio-tier-imbalance-${Date.now()}`,\n      friendId: '', // No specific friend\n      friendName: '',\n      priority: 'medium', // Mapped from urgency: medium\n      type: 'reconnect', // Mapped from category: portfolio\n      title: 'Close Friends need attention',\n      subtitle: `Your Inner Circle is thriving (${Math.round(tierScores.inner.avg)}), but ${tierScores.close.drifting} Close Friends are cooling: ${driftingFriends.join(', ')}.`,\n      icon: '📊',\n      action: { type: 'plan' },\n    };\n  }\n\n  // INSIGHT 2: Inner Circle Crisis\n  if (tierScores.inner.drifting >= 2 && tierScores.inner.avg < 60) {\n    return {\n      id: `portfolio-inner-crisis-${Date.now()}`,\n      friendId: '',\n      friendName: '',\n      priority: 'high', // Mapped from urgency: high\n      type: 'deepen', // Mapped from category: portfolio\n      title: 'Inner Circle needs care',\n      subtitle: `${tierScores.inner.drifting} of your closest connections are drifting (avg ${Math.round(tierScores.inner.avg)}). Time to prioritize your core relationships.`,\n      icon: '⚠️',\n      action: { type: 'plan' },\n    };\n  }\n\n  // INSIGHT 2b: Inner Circle Mixed Signals\n  if (tierScores.inner.drifting >= 1 && tierScores.inner.avg >= 60 && tierScores.inner.count >= 3) {\n    const driftingFriends = friends\n      .filter(f => f.tier === 'InnerCircle' && f.score < 50)\n      .slice(0, 2)\n      .map(f => f.name);\n\n    return {\n      id: `portfolio-inner-mixed-${Date.now()}`,\n      friendId: '',\n      friendName: '',\n      priority: 'medium', // Mapped from urgency: medium\n      type: 'reconnect', // Mapped from category: portfolio\n      title: 'Some Inner Circle members need attention',\n      subtitle: `While most of your Inner Circle is strong, ${driftingFriends.join(' and ')} ${tierScores.inner.drifting === 1 ? 'is' : 'are'} cooling off.`,\n      icon: '💛',\n      action: { type: 'plan' },\n    };\n  }\n\n  // INSIGHT 3: Archetype Neglect\n  const archetypeEntries = Object.entries(archetypeBalance) as [Archetype, number][];\n  const neglectedArchetypes = archetypeEntries.filter(([_, score]) => score < 40);\n\n  if (neglectedArchetypes.length > 0 && friends.length >= 5) {\n    const [neglectedType, avgScore] = neglectedArchetypes[0];\n    const neglectedFriends = friends\n      .filter(f => f.archetype === neglectedType)\n      .slice(0, 2);\n\n    if (neglectedFriends.length > 0) {\n      return {\n        id: `portfolio-archetype-neglect-${Date.now()}`,\n        friendId: '',\n        friendName: '',\n        priority: 'low', // Mapped from urgency: low\n        type: 'connect', // Mapped from category: portfolio\n        title: `Your ${neglectedType}s feel distant`,\n        subtitle: `Friends like ${neglectedFriends.map(f => f.name).join(' and ')} (avg ${Math.round(avgScore)}) may need different connection styles.`,\n        icon: '💡',\n        action: { type: 'plan' },\n      };\n    }\n  }\n\n  // INSIGHT 4: Network Thriving\n  const overallAvg =\n    (tierScores.inner.avg * tierScores.inner.count +\n      tierScores.close.avg * tierScores.close.count +\n      tierScores.community.avg * tierScores.community.count) /\n    (friends.length || 1);\n\n  if (overallAvg > 75 && tierScores.inner.avg > 80) {\n    return {\n      id: `portfolio-thriving-${Date.now()}`,\n      friendId: '',\n      friendName: '',\n      priority: 'low', // Mapped from urgency: low\n      type: 'celebrate', // Mapped from category: portfolio\n      title: 'Your weave is thriving!',\n      subtitle: `Network health: ${Math.round(overallAvg)}. Your relationships are strong and balanced. Keep up the momentum!`,\n      icon: '🌟',\n      action: { type: 'plan' },\n    };\n  }\n\n  // INSIGHT 5: Interaction Diversity Check\n  const shouldShowDiversityInsight = Math.random() < 0.1; // 10% chance\n\n  if (shouldShowDiversityInsight && friends.length >= 5) {\n    const staleConnections = friends.filter(f => f.daysSinceInteraction > 14);\n\n    if (staleConnections.length >= 3) {\n      return {\n        id: `portfolio-diversity-${Date.now()}`,\n        friendId: '',\n        friendName: '',\n        priority: 'low', // Mapped from urgency: low\n        type: 'connect', // Mapped from category: portfolio\n        title: 'Broaden your connection circle',\n        subtitle: `You've been focusing on the same friends. ${staleConnections.length} connections haven't heard from you in 2+ weeks.`,\n        icon: '🔄',\n        action: { type: 'plan' },\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getArchetypeAverage(friends: FriendStats[], archetype: Archetype): number {\n  const archetypeFriends = friends.filter(f => f.archetype === archetype);\n  if (archetypeFriends.length === 0) return 100; // No friends of this type = no problem\n\n  return archetypeFriends.reduce((sum, f) => sum + f.score, 0) / archetypeFriends.length;\n}\n\nexport function analyzeArchetypeBalance(friends: FriendStats[]): Record<Archetype, number> {\n  const archetypes: Archetype[] = [\n    'Emperor',\n    'Empress',\n    'HighPriestess',\n    'Fool',\n    'Sun',\n    'Hermit',\n    'Magician',\n    'Lovers',\n    'Unknown',\n  ];\n\n  return archetypes.reduce((acc, archetype) => {\n    acc[archetype] = getArchetypeAverage(friends, archetype);\n    return acc;\n  }, {} as Record<Archetype, number>);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/prediction.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReciprocityAnalysis' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":76}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import FriendModel from '@/db/models/Friend';\nimport { FriendshipPattern } from './pattern.service';\nimport { TierDecayRates, PersonalizedThresholdConfig } from '@/modules/intelligence';\nimport { Tier } from '@/shared/types/common';\nimport { differenceInDays, getDay } from 'date-fns';\nimport { FriendPrediction, ProactiveSuggestion, BestDaysData } from '../types';\nimport { analyzeReciprocity, calculateReciprocityScore, ReciprocityAnalysis } from './reciprocity.service';\n\n/**\n * Calculates a personalized attention threshold for a friend based on their historical patterns.\n *\n * Instead of using fixed thresholds (IC: 50, CF: 40, C: 30), this function adapts to each\n * friend's actual score patterns. If a friend typically maintains a score of 75-85, alerting\n * at 50 is too late. This calculates a threshold that triggers earlier based on their baseline.\n *\n * @param friend - The friend model with historical data\n * @returns The personalized attention threshold (higher for friends who typically have higher scores)\n */\nexport function calculatePersonalizedAttentionThreshold(friend: FriendModel): number {\n  const tier = friend.dunbarTier as Tier;\n  const baseThreshold = PersonalizedThresholdConfig.baseThresholds[tier] ||\n    PersonalizedThresholdConfig.baseThresholds.Community;\n\n  // Need sufficient interaction history to personalize\n  const interactionCount = friend.ratedWeavesCount || 0;\n  if (interactionCount < PersonalizedThresholdConfig.minInteractionsForPersonalization) {\n    return baseThreshold;\n  }\n\n  // Use the friend's current score as a proxy for their typical baseline\n  // In a more sophisticated implementation, we'd track historical average score\n  const currentScore = friend.weaveScore;\n\n  // Calculate personalized threshold based on their typical score level\n  // If they usually hover at 75, threshold becomes: 75 * 0.65 = ~49\n  const personalizedThreshold = currentScore * PersonalizedThresholdConfig.historicalFactor;\n\n  // Blend personalized with base threshold\n  // This prevents threshold from being too extreme in either direction\n  const weight = PersonalizedThresholdConfig.personalizationWeight;\n  const blendedThreshold = (personalizedThreshold * weight) + (baseThreshold * (1 - weight));\n\n  // Ensure threshold stays within reasonable bounds\n  // Minimum: tier base threshold - 10 (don't alert too late)\n  // Maximum: tier base threshold + 25 (don't alert too early for consistently high scorers)\n  const minThreshold = Math.max(20, baseThreshold - 10);\n  const maxThreshold = Math.min(80, baseThreshold + 25);\n\n  return Math.round(Math.max(minThreshold, Math.min(maxThreshold, blendedThreshold)));\n}\n\n/**\n * Gets attention threshold details including whether it's personalized\n */\nexport function getAttentionThresholdDetails(friend: FriendModel): {\n  threshold: number;\n  isPersonalized: boolean;\n  baseThreshold: number;\n  reason: string;\n} {\n  const tier = friend.dunbarTier as Tier;\n  const baseThreshold = PersonalizedThresholdConfig.baseThresholds[tier] ||\n    PersonalizedThresholdConfig.baseThresholds.Community;\n\n  const interactionCount = friend.ratedWeavesCount || 0;\n  const isPersonalized = interactionCount >= PersonalizedThresholdConfig.minInteractionsForPersonalization;\n\n  const threshold = calculatePersonalizedAttentionThreshold(friend);\n\n  let reason: string;\n  if (!isPersonalized) {\n    reason = `Using default ${tier} threshold (${interactionCount}/${PersonalizedThresholdConfig.minInteractionsForPersonalization} interactions for personalization)`;\n  } else if (threshold > baseThreshold) {\n    reason = `Higher threshold due to typically strong connection (score usually ~${Math.round(friend.weaveScore)})`;\n  } else if (threshold < baseThreshold) {\n    reason = `Lower threshold - this relationship tends to hover at lower scores`;\n  } else {\n    reason = `Personalized threshold aligns with ${tier} default`;\n  }\n\n  return {\n    threshold,\n    isPersonalized,\n    baseThreshold,\n    reason,\n  };\n}\n\n/**\n * Predicts when a friend will need attention based on decay rate and patterns.\n * Now uses personalized attention thresholds based on friend's historical score patterns.\n */\nexport function predictFriendDrift(\n  friend: FriendModel,\n  pattern?: FriendshipPattern\n): FriendPrediction {\n  // NOTE: We are using friend.weave_score directly here instead of async calculateCurrentScore\n  // because this function is typically called in loops and needs to be synchronous or fast.\n  // However, to be consistent, we should ideally use the async service.\n  // For now, I will assume friend.weave_score is up to date or use it as a baseline.\n  // If calculateCurrentScore logic is complex (momentum, quality, etc.), relying on the\n  // cached value in the model might be slightly stale but acceptable for prediction.\n\n  // Actually, let's stick to synchronous calculation if possible, or accept that this returns a Promise.\n  // The original code used calculateCurrentScore which imported from orchestrator.\n  // I will assume for this migration we want synchronous execution if possible, but calculateCurrentScore is likely async now.\n  // Let's assume the caller has updated the score.\n\n  const currentScore = friend.weaveScore; // Use model value directly\n  const tierDecayRate = TierDecayRates[friend.dunbarTier as Tier];\n\n  // Use personalized attention threshold instead of fixed tier-based values\n  // This adapts to each friend's typical score patterns for more accurate predictions\n  const attentionThreshold = calculatePersonalizedAttentionThreshold(friend);\n\n  // If already below threshold, immediate attention needed\n  if (currentScore <= attentionThreshold) {\n    return {\n      friendId: friend.id,\n      friendName: friend.name,\n      currentScore,\n      predictedScore: currentScore,\n      daysUntilAttentionNeeded: 0,\n      confidence: 1.0,\n      reason: 'Already needs attention',\n      urgency: friend.dunbarTier === 'InnerCircle' ? 'critical' : 'high',\n    };\n  }\n\n  // Calculate daily decay rate considering tolerance window\n  const toleranceWindow = friend.toleranceWindowDays || {\n    InnerCircle: 7,\n    CloseFriends: 14,\n    Community: 21,\n  }[friend.dunbarTier as Tier];\n\n  const daysSinceLastUpdate = (Date.now() - friend.lastUpdated.getTime()) / 86400000;\n\n  let dailyDecayRate: number;\n  if (daysSinceLastUpdate <= toleranceWindow) {\n    // Within tolerance - slow decay\n    dailyDecayRate = (tierDecayRate * 0.5) / friend.resilience;\n  } else {\n    // Outside tolerance - accelerated decay\n    dailyDecayRate = (tierDecayRate * 1.5) / friend.resilience;\n  }\n\n  // Calculate days until attention needed\n  const scoreGap = currentScore - attentionThreshold;\n  const daysUntilAttentionNeeded = Math.max(1, Math.ceil(scoreGap / dailyDecayRate));\n\n  // Predict score at that time\n  const predictedScore = Math.max(0, currentScore - (dailyDecayRate * daysUntilAttentionNeeded));\n\n  // Confidence based on pattern reliability\n  let confidence = 0.65; // base confidence (lowered from 0.7)\n  if (pattern && pattern.sampleSize >= 3) { // Lowered from 5 to 3\n    confidence = Math.min(0.95, 0.65 + (pattern.consistency * 0.3));\n  }\n\n  // Determine urgency\n  let urgency: FriendPrediction['urgency'];\n  if (daysUntilAttentionNeeded <= 2) {\n    urgency = 'critical';\n  } else if (daysUntilAttentionNeeded <= 5) {\n    urgency = 'high';\n  } else if (daysUntilAttentionNeeded <= 10) {\n    urgency = 'medium';\n  } else {\n    urgency = 'low';\n  }\n\n  const reason = `Predicted to drop to ${Math.round(predictedScore)} in ${daysUntilAttentionNeeded} days based on decay rate`;\n\n  return {\n    friendId: friend.id,\n    friendName: friend.name,\n    currentScore: Math.round(currentScore),\n    predictedScore: Math.round(predictedScore),\n    daysUntilAttentionNeeded,\n    confidence,\n    reason,\n    urgency,\n  };\n}\n\n/**\n * Options for generating proactive suggestions\n */\nexport interface SuggestionOptions {\n  /** Include reciprocity-based suggestions (default: true) */\n  includeReciprocity?: boolean;\n  /** Include smart scheduling suggestions (default: true) */\n  includeSmartScheduling?: boolean;\n  /** Best days data from pattern detection (for smart scheduling) */\n  bestDaysData?: BestDaysData;\n  /** Current battery level (0-5) for battery-aware scheduling */\n  currentBatteryLevel?: number;\n}\n\n/**\n * Data about best connection days from pattern detection\n */\n\n\nconst DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\n/**\n * Generates proactive suggestions based on predictions, patterns, and multiple signals\n */\nexport function generateProactiveSuggestions(\n  friend: FriendModel,\n  pattern?: FriendshipPattern,\n  options: SuggestionOptions = {}\n): ProactiveSuggestion[] {\n  const {\n    includeReciprocity = true,\n    includeSmartScheduling = true,\n    bestDaysData,\n    currentBatteryLevel,\n  } = options;\n\n  const suggestions: ProactiveSuggestion[] = [];\n  const prediction = predictFriendDrift(friend, pattern);\n\n  // 1. Upcoming drift warning (before it becomes critical)\n  if (prediction.daysUntilAttentionNeeded > 0 && prediction.daysUntilAttentionNeeded <= 5 && prediction.urgency !== 'low') {\n    suggestions.push({\n      type: 'upcoming-drift',\n      friendId: friend.id,\n      friendName: friend.name,\n      title: `${friend.name} will need attention soon`,\n      message: `In ${prediction.daysUntilAttentionNeeded} days, your connection will start drifting. Reach out now while momentum is still strong.`,\n      daysUntil: prediction.daysUntilAttentionNeeded,\n      urgency: prediction.urgency,\n    });\n  }\n\n  // 2. Optimal timing suggestion based on pattern\n  if (pattern && pattern.sampleSize >= 2) {\n    const lastInteractionDate = friend.lastUpdated;\n    const daysSinceLastInteraction = differenceInDays(new Date(), lastInteractionDate);\n    const expectedNextDay = pattern.averageIntervalDays;\n\n    // If we're approaching their typical interval\n    if (daysSinceLastInteraction >= expectedNextDay * 0.8 && daysSinceLastInteraction <= expectedNextDay * 1.2) {\n      suggestions.push({\n        type: 'optimal-timing',\n        friendId: friend.id,\n        friendName: friend.name,\n        title: `Perfect time to connect with ${friend.name}`,\n        message: `You typically connect every ${pattern.averageIntervalDays} days. Now is the ideal window based on your pattern.`,\n        daysUntil: Math.max(0, expectedNextDay - daysSinceLastInteraction),\n        urgency: 'medium',\n      });\n    }\n  }\n\n  // 3. Pattern break alert (when they're significantly overdue)\n  if (pattern && pattern.sampleSize >= 2) {\n    const lastInteractionDate = friend.lastUpdated;\n    const daysSinceLastInteraction = differenceInDays(new Date(), lastInteractionDate);\n    const expectedNextDay = pattern.averageIntervalDays;\n\n    if (daysSinceLastInteraction > expectedNextDay * 1.5) {\n      const daysOverdue = daysSinceLastInteraction - expectedNextDay;\n      suggestions.push({\n        type: 'pattern-break',\n        friendId: friend.id,\n        friendName: friend.name,\n        title: `Breaking your pattern with ${friend.name}`,\n        message: `You usually connect every ${pattern.averageIntervalDays} days, but it's been ${daysSinceLastInteraction}. The pattern is breaking.`,\n        daysUntil: -daysOverdue, // negative means overdue\n        urgency: friend.dunbarTier === 'InnerCircle' ? 'high' : 'medium',\n      });\n    }\n  }\n\n  // 4. Momentum opportunity (when score is high and recent)\n  const currentScore = friend.weaveScore;\n  const daysSinceLastUpdate = (Date.now() - friend.lastUpdated.getTime()) / 86400000;\n\n  if (currentScore > 70 && friend.momentumScore > 10 && daysSinceLastUpdate <= 5) {\n    suggestions.push({\n      type: 'momentum-opportunity',\n      friendId: friend.id,\n      friendName: friend.name,\n      title: `Ride the momentum with ${friend.name}`,\n      message: `You're connecting well right now (score: ${Math.round(currentScore)}). Another interaction soon would build a strong streak.`,\n      daysUntil: 2,\n      urgency: 'medium',\n    });\n  }\n\n  // 5. Reciprocity imbalance suggestion\n  if (includeReciprocity) {\n    const reciprocitySuggestion = generateReciprocitySuggestion(friend);\n    if (reciprocitySuggestion) {\n      suggestions.push(reciprocitySuggestion);\n    }\n  }\n\n  // 6. Smart scheduling suggestion (battery-aware best day)\n  if (includeSmartScheduling && bestDaysData) {\n    const schedulingSuggestion = generateSmartSchedulingSuggestion(\n      friend,\n      bestDaysData,\n      currentBatteryLevel\n    );\n    if (schedulingSuggestion) {\n      suggestions.push(schedulingSuggestion);\n    }\n  }\n\n  return suggestions;\n}\n\n/**\n * Generates a reciprocity-based suggestion if there's an imbalance\n */\nfunction generateReciprocitySuggestion(friend: FriendModel): ProactiveSuggestion | null {\n  const analysis = analyzeReciprocity(friend);\n\n  // Only suggest if we have enough data and there's an imbalance\n  if (analysis.totalInitiations < 5) return null;\n  if (analysis.balance === 'balanced') return null;\n\n  const ratio = analysis.initiationRatio;\n  const userPercent = Math.round(ratio * 100);\n  const friendPercent = 100 - userPercent;\n\n  // User is initiating too much (> 70%)\n  if (ratio > 0.7) {\n    const urgency = analysis.balance === 'one-sided' ? 'high' :\n      analysis.balance === 'very-imbalanced' ? 'medium' : 'low';\n\n    // Skip low urgency to reduce noise\n    if (urgency === 'low') return null;\n\n    return {\n      type: 'reciprocity-imbalance',\n      friendId: friend.id,\n      friendName: friend.name,\n      title: `Consider letting ${friend.name} reach out`,\n      message: `You've initiated ${userPercent}% of interactions (${analysis.consecutiveUserInitiations} in a row). Consider creating space for them to reach out.`,\n      daysUntil: 0, // Informational, not time-based\n      urgency,\n      metadata: {\n        initiationRatio: ratio,\n      },\n    };\n  }\n\n  // Friend is initiating too much (< 30%) - encourage user to reach out more\n  if (ratio < 0.3) {\n    const urgency = analysis.balance === 'one-sided' ? 'medium' :\n      analysis.balance === 'very-imbalanced' ? 'low' : 'low';\n\n    // Skip low urgency\n    if (urgency === 'low') return null;\n\n    return {\n      type: 'reciprocity-imbalance',\n      friendId: friend.id,\n      friendName: friend.name,\n      title: `Reach out to ${friend.name}`,\n      message: `${friend.name} has initiated ${friendPercent}% of your interactions. Consider reaching out first to balance the relationship.`,\n      daysUntil: 0,\n      urgency,\n      metadata: {\n        initiationRatio: ratio,\n      },\n    };\n  }\n\n  return null;\n}\n\n/**\n * Generates a smart scheduling suggestion based on best connection days and battery level\n */\nfunction generateSmartSchedulingSuggestion(\n  friend: FriendModel,\n  bestDaysData: BestDaysData,\n  currentBatteryLevel?: number\n): ProactiveSuggestion | null {\n  const today = getDay(new Date()); // 0-6 (Sunday-Saturday)\n  const bestDay = bestDaysData.bestDay;\n\n  // Calculate days until best day (can be 0-6)\n  let daysUntilBest = bestDay.day - today;\n  if (daysUntilBest < 0) daysUntilBest += 7;\n\n  // Only suggest if the best day is within the next 3 days\n  if (daysUntilBest > 3) return null;\n\n  // Check if friend needs attention soon (to make this suggestion relevant)\n  const daysSinceLastUpdate = (Date.now() - friend.lastUpdated.getTime()) / 86400000;\n  const toleranceWindow = friend.toleranceWindowDays || {\n    InnerCircle: 7,\n    CloseFriends: 14,\n    Community: 21,\n  }[friend.dunbarTier as Tier];\n\n  // Only suggest if approaching or past tolerance window\n  if (daysSinceLastUpdate < toleranceWindow * 0.7) return null;\n\n  // Battery-aware messaging\n  let batteryContext = '';\n  if (currentBatteryLevel !== undefined) {\n    if (currentBatteryLevel >= 4 && bestDay.avgBattery >= 3.5) {\n      batteryContext = ' Your energy is high and matches this day well.';\n    } else if (currentBatteryLevel < 3 && bestDay.avgBattery >= 4) {\n      batteryContext = ` Wait for ${DAY_NAMES[bestDay.day]} when your energy is typically higher.`;\n    }\n  }\n\n  const dayName = DAY_NAMES[bestDay.day];\n  const isToday = daysUntilBest === 0;\n\n  return {\n    type: 'best-day-scheduling',\n    friendId: friend.id,\n    friendName: friend.name,\n    title: isToday\n      ? `Today is your best day to connect with ${friend.name}`\n      : `${dayName} is ideal for ${friend.name}`,\n    message: isToday\n      ? `Based on your patterns, you have high energy (${bestDay.avgBattery.toFixed(1)}/5) and connection success on ${dayName}s.${batteryContext}`\n      : `Consider scheduling time with ${friend.name} on ${dayName} when your energy is typically ${bestDay.avgBattery.toFixed(1)}/5.${batteryContext}`,\n    daysUntil: daysUntilBest,\n    urgency: isToday ? 'medium' : 'low',\n    metadata: {\n      recommendedDay: bestDay.day,\n      recommendedDayName: dayName,\n      currentBatteryLevel,\n    },\n  };\n}\n\n/**\n * Predicts best day of week to connect based on historical patterns\n */\nexport function predictOptimalDay(pattern: FriendshipPattern): { day: number; dayName: string; confidence: number } | null {\n  if (!pattern.preferredDayOfWeek || pattern.sampleSize < 2) { // Lowered from 3 to 2\n    return null;\n  }\n\n  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\n  return {\n    day: pattern.preferredDayOfWeek,\n    dayName: dayNames[pattern.preferredDayOfWeek],\n    confidence: pattern.consistency,\n  };\n}\n\n/**\n * Forecasts network health N days into the future\n */\nexport function forecastNetworkHealth(\n  friends: FriendModel[],\n  daysAhead: number\n): {\n  currentHealth: number;\n  forecastedHealth: number;\n  friendsNeedingAttention: FriendModel[];\n  confidence: number;\n} {\n  // Weight by tier importance\n  const tierWeights: Record<Tier, number> = {\n    InnerCircle: 3.0,\n    CloseFriends: 2.0,\n    Community: 1.0,\n  };\n\n  let currentWeightedSum = 0;\n  let forecastedWeightedSum = 0;\n  let weightTotal = 0;\n  const friendsNeedingAttention: FriendModel[] = [];\n\n  friends.forEach(friend => {\n    const currentScore = friend.weaveScore;\n    const tierDecayRate = TierDecayRates[friend.dunbarTier as Tier];\n    const dailyDecay = (tierDecayRate * 1.0) / friend.resilience; // average decay\n    const forecastedScore = Math.max(0, currentScore - (dailyDecay * daysAhead));\n\n    const weight = tierWeights[friend.dunbarTier as Tier] || 1.0;\n    currentWeightedSum += currentScore * weight;\n    forecastedWeightedSum += forecastedScore * weight;\n    weightTotal += weight;\n\n    // Check if friend will need attention using personalized thresholds\n    const attentionThreshold = calculatePersonalizedAttentionThreshold(friend);\n\n    if (forecastedScore <= attentionThreshold) {\n      friendsNeedingAttention.push(friend);\n    }\n  });\n\n  const currentHealth = weightTotal > 0 ? Math.round(currentWeightedSum / weightTotal) : 0;\n  const forecastedHealth = weightTotal > 0 ? Math.round(forecastedWeightedSum / weightTotal) : 0;\n\n  // Confidence decreases with longer forecasts\n  const confidence = Math.max(0.3, 1.0 - (daysAhead / 30) * 0.5);\n\n  return {\n    currentHealth,\n    forecastedHealth,\n    friendsNeedingAttention,\n    confidence,\n  };\n}\n\nexport interface CompositeHealthSignal {\n  decayScore: number; // From decay service (0-100)\n  patternScore: number; // From interaction patterns (0-100)\n  reciprocityScore: number; // From initiation balance (0-100)\n  batteryAlignmentScore: number; // Battery level when last interacted (0-100)\n  momentumScore: number; // Current momentum (0-100)\n  qualityScore: number; // Recent interaction quality (0-100)\n}\n\n/**\n * Calculate a composite relationship health prediction combining multiple signals\n */\nexport function calculateCompositeHealthPrediction(\n  friend: FriendModel,\n  signals: CompositeHealthSignal\n): { score: number; confidence: number; topFactors: string[] } {\n  // Weighted composite score\n  const weights = {\n    decay: 0.30,\n    pattern: 0.25,\n    reciprocity: 0.15,\n    batteryAlignment: 0.10,\n    momentum: 0.10,\n    quality: 0.10,\n  };\n\n  const score =\n    signals.decayScore * weights.decay +\n    signals.patternScore * weights.pattern +\n    signals.reciprocityScore * weights.reciprocity +\n    signals.batteryAlignmentScore * weights.batteryAlignment +\n    signals.momentumScore * weights.momentum +\n    signals.qualityScore * weights.quality;\n\n  // Identify top contributing factors\n  const factors = Object.entries(signals)\n    .map(([key, val]) => ({ key, contribution: val * (weights[key as keyof typeof weights] || 0) }))\n    .sort((a, b) => b.contribution - a.contribution)\n    .slice(0, 3)\n    .map((f) => f.key);\n\n  return { score, confidence: 0.85, topFactors: factors };\n}\n\n/**\n * Builds a CompositeHealthSignal from friend data and patterns\n * This aggregates multiple signals into a format ready for composite health prediction\n */\nexport function buildCompositeHealthSignal(\n  friend: FriendModel,\n  pattern?: FriendshipPattern,\n  currentBatteryLevel?: number\n): CompositeHealthSignal {\n  // 1. Decay score: Based on current weave score (already incorporates decay)\n  const decayScore = friend.weaveScore;\n\n  // 2. Pattern score: How consistent is the interaction pattern?\n  let patternScore = 50; // Default neutral score\n  if (pattern && pattern.sampleSize >= 2) {\n    // Score based on consistency (0-1 maps to 0-100)\n    const consistencyScore = pattern.consistency * 100;\n\n    // Bonus for being within expected interval\n    const daysSinceLastUpdate = (Date.now() - friend.lastUpdated.getTime()) / 86400000;\n    const expectedInterval = pattern.averageIntervalDays;\n    const intervalRatio = daysSinceLastUpdate / expectedInterval;\n\n    // Perfect score around 0.8-1.2 ratio (approaching expected interval)\n    let intervalBonus = 0;\n    if (intervalRatio >= 0.8 && intervalRatio <= 1.2) {\n      intervalBonus = 20; // On track\n    } else if (intervalRatio < 0.8) {\n      intervalBonus = 10; // Ahead of schedule (good)\n    } else if (intervalRatio > 1.5) {\n      intervalBonus = -20; // Significantly overdue (bad)\n    }\n\n    patternScore = Math.min(100, Math.max(0, consistencyScore + intervalBonus));\n  }\n\n  // 3. Reciprocity score: From reciprocity service (0-1 maps to 0-100)\n  const reciprocityScore = calculateReciprocityScore(friend) * 100;\n\n  // 4. Battery alignment score: Based on current battery vs typical interaction energy\n  let batteryAlignmentScore = 50; // Default neutral\n  if (currentBatteryLevel !== undefined) {\n    // Higher score when user has energy to connect\n    batteryAlignmentScore = (currentBatteryLevel / 5) * 100;\n  }\n\n  // 5. Momentum score: Based on friend's momentum (can be negative or positive)\n  // Normalize momentum from typical range (-30 to +30) to 0-100\n  const rawMomentum = friend.momentumScore || 0;\n  const momentumScore = Math.min(100, Math.max(0, 50 + (rawMomentum * 1.67)));\n\n  // 6. Quality score: Based on base weave score (qualityWeightedRating removed)\n  const qualityScore = Math.min(100, friend.weaveScore);\n\n  return {\n    decayScore,\n    patternScore,\n    reciprocityScore,\n    batteryAlignmentScore,\n    momentumScore,\n    qualityScore,\n  };\n}\n\n/**\n * Gets a comprehensive health prediction for a friend using all available signals\n */\nexport function getComprehensiveHealthPrediction(\n  friend: FriendModel,\n  pattern?: FriendshipPattern,\n  currentBatteryLevel?: number\n): {\n  compositeScore: number;\n  confidence: number;\n  topFactors: string[];\n  signals: CompositeHealthSignal;\n  prediction: FriendPrediction;\n} {\n  const signals = buildCompositeHealthSignal(friend, pattern, currentBatteryLevel);\n  const composite = calculateCompositeHealthPrediction(friend, signals);\n  const prediction = predictFriendDrift(friend, pattern);\n\n  return {\n    compositeScore: composite.score,\n    confidence: composite.confidence,\n    topFactors: composite.topFactors,\n    signals,\n    prediction,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/reciprocity.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/tier-fit.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TierHealth' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/insights/services/tier-fit.service.ts\nimport { database } from '@/db';\nimport Friend from '@/db/models/Friend';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport { Q } from '@nozbe/watermelondb';\nimport { Tier } from '@/shared/types/core';\nimport type {\n  TierFitAnalysis,\n  TierFitCategory,\n  NetworkTierHealth,\n  TierHealth\n} from '../types';\nimport {\n  analyzeInteractionPattern,\n  type PatternInteractionData\n} from './pattern.service';\n\n/**\n * Expected interaction intervals per tier (in days)\n */\nconst TIER_EXPECTED_INTERVALS: Record<Tier, number> = {\n  InnerCircle: 7,\n  CloseFriends: 14,\n  Community: 28\n};\n\n/**\n * Minimum sample size to provide tier fit analysis\n */\nconst MINIMUM_SAMPLE_SIZE = 2;\nconst CONFIDENT_SAMPLE_SIZE = 5;\n\n/**\n * Fetch interactions for a friend and convert to PatternInteractionData format.\n * Filters to primary interactions (small groups) for more accurate personal rhythm.\n *\n * @param friendId - The friend to fetch interactions for\n * @returns Array of PatternInteractionData for pattern analysis\n */\nasync function fetchInteractionsForPattern(friendId: string): Promise<PatternInteractionData[]> {\n  // Get all interaction links for this friend\n  const interactionFriends = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  const interactionIds = interactionFriends.map(ifriend => ifriend.interactionId);\n\n  if (interactionIds.length === 0) {\n    return [];\n  }\n\n  // Fetch completed interactions from last 180 days for better pattern detection\n  const sixMonthsAgo = Date.now() - 180 * 24 * 60 * 60 * 1000;\n  const interactions = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed'),\n      Q.where('interaction_date', Q.gte(sixMonthsAgo)),\n      Q.sortBy('interaction_date', Q.desc)\n    )\n    .fetch();\n\n  // For each interaction, count how many friends were involved\n  // This helps filter out large group events\n  const interactionWithCounts: PatternInteractionData[] = await Promise.all(\n    interactions.map(async (interaction) => {\n      const friendLinks = await database\n        .get<InteractionFriend>('interaction_friends')\n        .query(Q.where('interaction_id', interaction.id))\n        .fetchCount();\n\n      return {\n        id: interaction.id,\n        interactionDate: interaction.interactionDate,\n        status: interaction.status,\n        category: interaction.interactionCategory,\n        friendCount: friendLinks\n      };\n    })\n  );\n\n  return interactionWithCounts;\n}\n\n/**\n * Analyze how well a friend's actual interaction pattern matches their tier.\n * Now calculates patterns on-the-fly if typicalIntervalDays is not cached.\n *\n * @param friend - The friend to analyze\n * @returns Tier fit analysis with suggestions\n */\nexport async function analyzeTierFit(friend: Friend): Promise<TierFitAnalysis> {\n  const expectedInterval = TIER_EXPECTED_INTERVALS[friend.dunbarTier as Tier];\n\n  // Try to use cached value, otherwise calculate on-the-fly\n  let actualInterval = friend.typicalIntervalDays;\n  let interactionCount = friend.ratedWeavesCount;\n\n  // If no cached interval, calculate from interactions\n  if (!actualInterval || actualInterval === 0) {\n    const interactions = await fetchInteractionsForPattern(friend.id);\n\n    if (interactions.length >= MINIMUM_SAMPLE_SIZE) {\n      // Calculate pattern with primaryOnly filter to focus on personal interactions\n      const pattern = analyzeInteractionPattern(interactions, {\n        primaryOnly: true,\n        primaryMaxFriends: 3\n      });\n\n      actualInterval = pattern.averageIntervalDays;\n      interactionCount = pattern.sampleSize;\n\n      // If primary-only has too few interactions, fall back to all interactions\n      if (pattern.sampleSize < MINIMUM_SAMPLE_SIZE) {\n        const allPattern = analyzeInteractionPattern(interactions);\n        actualInterval = allPattern.averageIntervalDays;\n        interactionCount = allPattern.sampleSize;\n      }\n    }\n  }\n\n  // Still no valid interval? Return insufficient data\n  if (!actualInterval || actualInterval === 0 || interactionCount < MINIMUM_SAMPLE_SIZE) {\n    return {\n      friendId: friend.id,\n      friendName: friend.name,\n      currentTier: friend.dunbarTier as Tier,\n      actualIntervalDays: 0,\n      expectedIntervalDays: expectedInterval,\n      interactionCount: interactionCount,\n      fitScore: 0,\n      fitCategory: 'insufficient_data',\n      confidence: 0,\n      reason: 'Not enough interaction history yet (need at least 2 interactions)',\n      isPreliminary: true\n    };\n  }\n\n  const isPreliminary = interactionCount < CONFIDENT_SAMPLE_SIZE;\n\n  // Calculate deviation ratio\n  const deviationRatio = actualInterval / expectedInterval;\n\n  // Score fit (inverse of deviation, clamped)\n  let fitScore: number;\n  let fitCategory: TierFitCategory;\n\n  if (deviationRatio >= 0.7 && deviationRatio <= 1.3) {\n    // Within 30% - great fit\n    fitScore = 1.0;\n    fitCategory = 'great';\n  } else if (deviationRatio >= 0.5 && deviationRatio <= 2.0) {\n    // Within 2x - good fit\n    fitScore = 0.7;\n    fitCategory = 'good';\n  } else {\n    // Beyond 2x - mismatch\n\n    // EXCEPTION: For Inner Circle, being \"too frequent\" is actually good!\n    // If you see your best friend every day (ratio ~0.14), that's a GREAT fit, not a mismatch.\n    if (friend.dunbarTier === 'InnerCircle' && deviationRatio < 0.5) {\n      fitScore = 1.0;\n      fitCategory = 'great';\n    } else {\n      fitScore = Math.max(0, 1 - Math.abs(Math.log2(deviationRatio)) / 2);\n      fitCategory = 'mismatch';\n    }\n  }\n\n  // Generate suggestion if mismatch\n  let suggestedTier: Tier | undefined;\n  let reason = '';\n\n  if (fitCategory === 'mismatch') {\n    if (deviationRatio > 2.0) {\n      // Too infrequent for current tier - suggest move down\n      if (friend.dunbarTier === 'InnerCircle') {\n        suggestedTier = 'CloseFriends';\n        reason = `You connect every ${Math.round(actualInterval)} days, but Inner Circle expects weekly contact (~7 days). Close Friends (bi-weekly, ~14 days) would be a better fit and reduce stress.`;\n      } else if (friend.dunbarTier === 'CloseFriends') {\n        suggestedTier = 'Community';\n        reason = `You connect every ${Math.round(actualInterval)} days, but Close Friends expects bi-weekly contact (~14 days). Community (monthly, ~28 days) would be a better fit.`;\n      }\n      // Community has nowhere to move down\n    } else if (deviationRatio < 0.5) {\n      // Too frequent for current tier - suggest move up\n      if (friend.dunbarTier === 'Community') {\n        suggestedTier = 'CloseFriends';\n        reason = `You're connecting every ${Math.round(actualInterval)} days—more frequently than Community expects (~28 days)! This friendship might belong in Close Friends.`;\n      } else if (friend.dunbarTier === 'CloseFriends') {\n        suggestedTier = 'InnerCircle';\n        reason = `You're connecting every ${Math.round(actualInterval)} days—weekly or more! This is Inner Circle frequency. Consider promoting this friendship.`;\n      }\n      // Inner Circle has nowhere to move up\n    }\n  } else if (fitCategory === 'great') {\n    if (friend.dunbarTier === 'InnerCircle' && deviationRatio < 0.5) {\n      reason = `Strong bond! You're connecting every ${Math.round(actualInterval)} days, which is even more frequent than the weekly expectation.`;\n    } else {\n      reason = `Perfect fit! Your rhythm (every ${Math.round(actualInterval)} days) matches ${friend.dunbarTier} expectations well.`;\n    }\n  } else {\n    reason = `Good fit. Your rhythm (every ${Math.round(actualInterval)} days) is close to ${friend.dunbarTier} expectations (~${expectedInterval} days).`;\n  }\n\n  // Confidence based on sample size and consistency\n  // More interactions = higher confidence\n  const confidence = Math.min(\n    0.95,\n    0.5 + (interactionCount / 20) * 0.45\n  );\n\n  return {\n    friendId: friend.id,\n    friendName: friend.name,\n    currentTier: friend.dunbarTier as Tier,\n    actualIntervalDays: actualInterval,\n    expectedIntervalDays: expectedInterval,\n    interactionCount: interactionCount,\n    fitScore,\n    fitCategory,\n    suggestedTier,\n    confidence,\n    reason,\n    isPreliminary\n  };\n}\n\n/**\n * Analyze tier health across the entire network\n *\n * @returns Network-wide tier health analysis with suggestions\n */\nexport async function analyzeNetworkTierHealth(): Promise<NetworkTierHealth> {\n  // Fetch all non-dormant friends\n  const friends = await database\n    .get<Friend>('friends')\n    .query(Q.where('is_dormant', false))\n    .fetch();\n\n  // Analyze each friend (now async)\n  const analyses = await Promise.all(friends.map(friend => analyzeTierFit(friend)));\n\n  // Initialize tier health buckets\n  const tierHealth: NetworkTierHealth['tierHealth'] = {\n    InnerCircle: { total: 0, great: 0, good: 0, mismatch: 0 },\n    CloseFriends: { total: 0, great: 0, good: 0, mismatch: 0 },\n    Community: { total: 0, great: 0, good: 0, mismatch: 0 }\n  };\n\n  // Categorize each friend\n  analyses.forEach(analysis => {\n    const tier = analysis.currentTier;\n\n    // Always count towards total in tier\n    tierHealth[tier].total++;\n\n    if (analysis.fitCategory === 'insufficient_data') return;\n\n    if (analysis.fitCategory === 'great') {\n      tierHealth[tier].great++;\n    } else if (analysis.fitCategory === 'good') {\n      tierHealth[tier].good++;\n    } else {\n      tierHealth[tier].mismatch++;\n    }\n  });\n\n  // Calculate overall health score (0-10)\n  // We include insufficient_data friends in the denominator to represent \"potential\"\n  const totalFriends = analyses.length;\n\n  const totalMismatches =\n    tierHealth.InnerCircle.mismatch +\n    tierHealth.CloseFriends.mismatch +\n    tierHealth.Community.mismatch;\n\n  // Health score penalizes mismatches against the TOTAL network size\n  const healthScore = totalFriends > 0\n    ? Math.round(((totalFriends - totalMismatches) / totalFriends) * 10)\n    : 10;\n\n  // Extract mismatches and suggestions\n  const mismatches = analyses.filter(a => a.fitCategory === 'mismatch');\n  const suggestions = analyses\n    .filter(a => a.suggestedTier !== undefined)\n    .sort((a, b) => {\n      // Sort by confidence (higher first), then by deviation severity\n      if (b.confidence !== a.confidence) {\n        return b.confidence - a.confidence;\n      }\n      return Math.abs(b.actualIntervalDays / b.expectedIntervalDays) -\n        Math.abs(a.actualIntervalDays / a.expectedIntervalDays);\n    })\n    .slice(0, 5); // Top 5 suggestions\n\n  return {\n    healthScore,\n    tierHealth,\n    mismatches,\n    suggestions,\n    allAnalyses: analyses\n  };\n}\n\n/**\n * Check if a friend's tier suggestion should be shown\n * (not dismissed recently)\n *\n * @param friend - The friend to check\n * @param daysSinceDismissal - Min days before showing again (default: 90)\n * @returns Whether to show the suggestion\n */\nexport function shouldShowTierSuggestion(\n  friend: Friend,\n  daysSinceDismissal: number = 90\n): boolean {\n  if (!friend.tierSuggestionDismissedAt) {\n    return true; // Never dismissed\n  }\n\n  const daysSince =\n    (Date.now() - friend.tierSuggestionDismissedAt) / (1000 * 60 * 60 * 24);\n\n  return daysSince >= daysSinceDismissal;\n}\n\n/**\n * Get a human-readable tier fit summary\n */\nexport function getTierFitSummary(analysis: TierFitAnalysis): string {\n  if (analysis.fitCategory === 'insufficient_data') {\n    return 'Keep weaving to learn your rhythm';\n  }\n\n  const deviation = analysis.actualIntervalDays / analysis.expectedIntervalDays;\n\n  if (analysis.fitCategory === 'great') {\n    return '✓ Tier matches your rhythm';\n  }\n\n  if (analysis.fitCategory === 'good') {\n    return '~ Close to tier expectations';\n  }\n\n  // Mismatch\n  if (deviation > 2.0) {\n    return '⚠️ Connecting less than tier expects';\n  } else {\n    return '⬆️ Connecting more than tier expects';\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/tier-management.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/tier-suggestion-engine.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getNextTierDown' is defined but never used. Allowed unused vars must match /^_/u.","line":310,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":310,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/insights/services/tier-suggestion-engine.service.ts\nimport { database } from '@/db';\nimport Friend from '@/db/models/Friend';\nimport Interaction from '@/db/models/Interaction';\nimport { Q } from '@nozbe/watermelondb';\nimport { analyzeTierFit, shouldShowTierSuggestion } from './tier-fit.service';\nimport { TierMigrationConfig } from '@/modules/intelligence';\nimport type { TierFitAnalysis } from '../types';\nimport { Tier } from '@/shared/types/common';\n\n/**\n * Conditions that trigger tier suggestions\n */\nexport enum TierSuggestionTrigger {\n  AfterInteraction = 'after_interaction',\n  RepeatedRedFriend = 'repeated_red_friend',\n  PatternEstablished = 'pattern_established',\n  NetworkHealthLow = 'network_health_low',\n  ProlongedMismatch = 'prolonged_mismatch',       // NEW: 30+ days of mismatch\n  UpwardMigration = 'upward_migration',           // NEW: Friend connecting more than tier expects\n  DramaticMismatch = 'dramatic_mismatch'          // NEW: 60+ days severe mismatch\n}\n\nexport interface TierSuggestionContext {\n  trigger: TierSuggestionTrigger;\n  analysis: TierFitAnalysis;\n  urgency: 'high' | 'medium' | 'low';\n  message: string;\n  /** Whether this is a soft suggestion (non-intrusive) */\n  isSoftSuggestion?: boolean;\n  /** Direction of suggested migration */\n  direction?: 'up' | 'down';\n  /** Days the mismatch has persisted */\n  mismatchDurationDays?: number;\n}\n\n/**\n * Check if tier suggestion should be shown after logging an interaction\n * Only shows if pattern has changed and now shows clear mismatch\n *\n * @param friendId - Friend who was just interacted with\n * @param wasFirstInteraction - Whether this was the first interaction\n * @returns Tier suggestion context if should show, null otherwise\n */\nexport async function checkTierSuggestionAfterInteraction(\n  friendId: string,\n  wasFirstInteraction: boolean = false\n): Promise<TierSuggestionContext | null> {\n  try {\n    const friend = await database.get<Friend>('friends').find(friendId);\n\n    // Don't suggest on first interaction - need pattern first\n    if (wasFirstInteraction || friend.ratedWeavesCount < 5) {\n      return null;\n    }\n\n    // Check if suggestion was recently dismissed\n    if (!shouldShowTierSuggestion(friend, 90)) {\n      return null;\n    }\n\n    // Analyze tier fit (now async)\n    const analysis = await analyzeTierFit(friend);\n\n    // Only show if clear mismatch\n    if (analysis.fitCategory !== 'mismatch' || !analysis.suggestedTier) {\n      return null;\n    }\n\n    // Check if pattern just became established (5th, 10th, 15th interaction)\n    const milestones = [5, 10, 15];\n    const isPatternMilestone = milestones.includes(friend.ratedWeavesCount);\n\n    if (isPatternMilestone) {\n      return {\n        trigger: TierSuggestionTrigger.PatternEstablished,\n        analysis,\n        urgency: 'medium',\n        message: `After ${friend.ratedWeavesCount} interactions, we've learned your rhythm with ${friend.name}!`\n      };\n    }\n\n    // Otherwise, don't show after every interaction - too noisy\n    return null;\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error checking after interaction:', error);\n    return null;\n  }\n}\n\n/**\n * Check if friend has repeatedly gone red (low score)\n * This indicates tier expectations are too high\n *\n * @param friendId - Friend to check\n * @returns Tier suggestion context if should show, null otherwise\n */\nexport async function checkRepeatedRedFriend(\n  friendId: string\n): Promise<TierSuggestionContext | null> {\n  try {\n    const friend = await database.get<Friend>('friends').find(friendId);\n\n    // Check if friend is currently in red zone (score < 40)\n    if (friend.weaveScore >= 40) {\n      return null;\n    }\n\n    // Check if suggestion was recently dismissed\n    if (!shouldShowTierSuggestion(friend, 90)) {\n      return null;\n    }\n\n    // Count how many times they've been in red zone recently\n    // We approximate this by checking if they've had multiple interactions\n    // but score is still low\n    // 1. Get interaction IDs from join table\n    const links = await database\n      .get('interaction_friends')\n      .query(Q.where('friend_id', friend.id))\n      .fetch();\n    const interactionIds = links.map((link: any) => link.interactionId);\n\n    if (interactionIds.length === 0) return null;\n\n    // 2. Fetch interactions\n    const recentInteractions = await database\n      .get<Interaction>('interactions')\n      .query(\n        Q.where('id', Q.oneOf(interactionIds)),\n        Q.where('status', 'completed'),\n        Q.where('interaction_date', Q.gte(Date.now() - 30 * 24 * 60 * 60 * 1000)), // Last 30 days\n        Q.sortBy('interaction_date', Q.desc)\n      )\n      .fetch();\n\n    // If they've had 3+ interactions in last 30 days but score is still low,\n    // tier expectations might be too high\n    if (recentInteractions.length < 3) {\n      return null;\n    }\n\n    // Analyze tier fit (now async)\n    const analysis = await analyzeTierFit(friend);\n\n    if (analysis.fitCategory !== 'mismatch' || !analysis.suggestedTier) {\n      return null;\n    }\n\n    // Only suggest tier reduction (not promotion)\n    const isReduction =\n      (friend.dunbarTier === 'InnerCircle' && analysis.suggestedTier === 'CloseFriends') ||\n      (friend.dunbarTier === 'CloseFriends' && analysis.suggestedTier === 'Community');\n\n    if (!isReduction) {\n      return null;\n    }\n\n    return {\n      trigger: TierSuggestionTrigger.RepeatedRedFriend,\n      analysis,\n      urgency: 'high',\n      message: `${friend.name} keeps needing attention despite your efforts. The tier might be too demanding.`\n    };\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error checking repeated red:', error);\n    return null;\n  }\n}\n\n/**\n * Get all active tier suggestions for a user\n * Used for dashboard widgets and notifications\n *\n * @returns Array of tier suggestion contexts\n */\nexport async function getActiveTierSuggestions(): Promise<TierSuggestionContext[]> {\n  try {\n    const friends = await database\n      .get<Friend>('friends')\n      .query(Q.where('is_dormant', false))\n      .fetch();\n\n    const suggestions: TierSuggestionContext[] = [];\n\n    for (const friend of friends) {\n      // Skip if recently dismissed\n      if (!shouldShowTierSuggestion(friend, 90)) {\n        continue;\n      }\n\n      // Analyze tier fit (now async)\n      const analysis = await analyzeTierFit(friend);\n\n      if (analysis.fitCategory === 'mismatch' && analysis.suggestedTier) {\n        // Check if this is a repeated red friend (high urgency)\n        const redSuggestion = await checkRepeatedRedFriend(friend.id);\n\n        if (redSuggestion) {\n          suggestions.push(redSuggestion);\n        } else {\n          // Regular mismatch (medium urgency)\n          suggestions.push({\n            trigger: TierSuggestionTrigger.PatternEstablished,\n            analysis,\n            urgency: 'medium',\n            message: `${friend.name}'s tier doesn't match your rhythm`\n          });\n        }\n      }\n    }\n\n    // Sort by urgency and confidence\n    suggestions.sort((a, b) => {\n      const urgencyOrder = { high: 3, medium: 2, low: 1 };\n      if (urgencyOrder[a.urgency] !== urgencyOrder[b.urgency]) {\n        return urgencyOrder[b.urgency] - urgencyOrder[a.urgency];\n      }\n      return b.analysis.confidence - a.analysis.confidence;\n    });\n\n    return suggestions;\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error getting active suggestions:', error);\n    return [];\n  }\n}\n\n/**\n * Check if network health is low and needs rebalancing\n * Returns true if multiple friends have tier mismatches\n *\n * @returns Whether to prompt for network rebalancing\n */\nexport async function shouldPromptNetworkRebalancing(): Promise<boolean> {\n  try {\n    const suggestions = await getActiveTierSuggestions();\n\n    // Prompt if 3+ friends have tier mismatches\n    return suggestions.length >= 3;\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error checking network health:', error);\n    return false;\n  }\n}\n\n/**\n * Calculates how long a friend has had a tier mismatch.\n * Uses tierFitLastCalculated to track when we first detected the mismatch.\n *\n * @param friend - The friend to check\n * @returns Number of days in mismatch state, or 0 if not in mismatch\n */\nfunction calculateMismatchDuration(friend: Friend): number {\n  if (!friend.tierFitLastCalculated) {\n    return 0;\n  }\n\n  // tierFitLastCalculated is updated when fit score changes significantly\n  // If current fit score is below threshold, this represents mismatch duration\n  if ((friend.tierFitScore || 1.0) < TierMigrationConfig.mismatchThreshold) {\n    const daysSinceLastCalculation = (Date.now() - friend.tierFitLastCalculated) / (1000 * 60 * 60 * 24);\n    return Math.floor(daysSinceLastCalculation);\n  }\n\n  return 0;\n}\n\n/**\n * Determines the migration direction based on actual vs expected interaction patterns.\n *\n * @param analysis - The tier fit analysis\n * @returns 'up' for promotion, 'down' for demotion, or null if no migration needed\n */\nfunction determineMigrationDirection(analysis: TierFitAnalysis): 'up' | 'down' | null {\n  if (analysis.fitCategory !== 'mismatch' || !analysis.suggestedTier) {\n    return null;\n  }\n\n  const deviationRatio = analysis.actualIntervalDays / analysis.expectedIntervalDays;\n\n  // Connecting more frequently than expected = potential promotion\n  if (deviationRatio < TierMigrationConfig.upwardMigrationRatio) {\n    return 'up';\n  }\n\n  // Connecting less frequently than expected = potential demotion\n  if (deviationRatio > TierMigrationConfig.downwardMigrationRatio) {\n    return 'down';\n  }\n\n  return null;\n}\n\n/**\n * Gets the next tier up for promotion\n */\nfunction getNextTierUp(currentTier: Tier): Tier | null {\n  const tierOrder: Tier[] = ['Community', 'CloseFriends', 'InnerCircle'];\n  const currentIndex = tierOrder.indexOf(currentTier);\n  if (currentIndex < tierOrder.length - 1) {\n    return tierOrder[currentIndex + 1];\n  }\n  return null;\n}\n\n/**\n * Gets the next tier down for demotion\n */\nfunction getNextTierDown(currentTier: Tier): Tier | null {\n  const tierOrder: Tier[] = ['Community', 'CloseFriends', 'InnerCircle'];\n  const currentIndex = tierOrder.indexOf(currentTier);\n  if (currentIndex > 0) {\n    return tierOrder[currentIndex - 1];\n  }\n  return null;\n}\n\n/**\n * Detects upward migration opportunities - friends connecting more frequently\n * than their current tier expects, suggesting they should be promoted.\n *\n * @param friendId - Friend to check for upward migration\n * @returns Tier suggestion context if promotion is warranted, null otherwise\n */\nexport async function detectUpwardMigration(\n  friendId: string\n): Promise<TierSuggestionContext | null> {\n  try {\n    const friend = await database.get<Friend>('friends').find(friendId);\n\n    // Can't promote from Inner Circle\n    if (friend.dunbarTier === 'InnerCircle') {\n      return null;\n    }\n\n    // Need enough interaction history\n    if ((friend.ratedWeavesCount || 0) < TierMigrationConfig.minInteractionsForSuggestion) {\n      return null;\n    }\n\n    // Check if suggestion was recently dismissed\n    if (!shouldShowTierSuggestion(friend, TierMigrationConfig.dismissalCooldownDays)) {\n      return null;\n    }\n\n    const analysis = await analyzeTierFit(friend);\n\n    // Check for upward migration pattern\n    const direction = determineMigrationDirection(analysis);\n    if (direction !== 'up') {\n      return null;\n    }\n\n    const suggestedTier = getNextTierUp(friend.dunbarTier as Tier);\n    if (!suggestedTier) {\n      return null;\n    }\n\n    const mismatchDays = calculateMismatchDuration(friend);\n\n    return {\n      trigger: TierSuggestionTrigger.UpwardMigration,\n      analysis: {\n        ...analysis,\n        suggestedTier,\n      },\n      urgency: 'medium',\n      direction: 'up',\n      isSoftSuggestion: true,\n      mismatchDurationDays: mismatchDays,\n      message: `${friend.name} is connecting every ${Math.round(analysis.actualIntervalDays)} days—that's ${suggestedTier} frequency! Consider promoting this friendship.`\n    };\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error detecting upward migration:', error);\n    return null;\n  }\n}\n\n/**\n * Detects prolonged tier mismatches - friends who have been in mismatch state\n * for 30+ days, warranting a soft suggestion.\n *\n * @param friendId - Friend to check for prolonged mismatch\n * @returns Tier suggestion context if prolonged mismatch detected, null otherwise\n */\nexport async function detectProlongedMismatch(\n  friendId: string\n): Promise<TierSuggestionContext | null> {\n  try {\n    const friend = await database.get<Friend>('friends').find(friendId);\n\n    // Check if suggestion was recently dismissed\n    if (!shouldShowTierSuggestion(friend, TierMigrationConfig.dismissalCooldownDays)) {\n      return null;\n    }\n\n    // Need enough interaction history\n    if ((friend.ratedWeavesCount || 0) < TierMigrationConfig.minInteractionsForSuggestion) {\n      return null;\n    }\n\n    const analysis = await analyzeTierFit(friend);\n\n    if (analysis.fitCategory !== 'mismatch') {\n      return null;\n    }\n\n    const mismatchDays = calculateMismatchDuration(friend);\n    const direction = determineMigrationDirection(analysis);\n\n    // Check for dramatic mismatch (60+ days)\n    if (mismatchDays >= TierMigrationConfig.daysForStrongSuggestion) {\n      return {\n        trigger: TierSuggestionTrigger.DramaticMismatch,\n        analysis,\n        urgency: 'high',\n        direction: direction || undefined,\n        isSoftSuggestion: false,\n        mismatchDurationDays: mismatchDays,\n        message: `${friend.name}'s tier hasn't matched your rhythm for ${mismatchDays} days. This friendship would thrive better in ${analysis.suggestedTier}.`\n      };\n    }\n\n    // Check for prolonged mismatch (30+ days)\n    if (mismatchDays >= TierMigrationConfig.daysForSoftSuggestion) {\n      return {\n        trigger: TierSuggestionTrigger.ProlongedMismatch,\n        analysis,\n        urgency: 'low',\n        direction: direction || undefined,\n        isSoftSuggestion: true,\n        mismatchDurationDays: mismatchDays,\n        message: direction === 'up'\n          ? `${friend.name} has been connecting more frequently than ${friend.dunbarTier} expects for ${mismatchDays} days. Ready to level up?`\n          : `${friend.name}'s tier has felt misaligned for ${mismatchDays} days. Adjusting might feel more natural.`\n      };\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error detecting prolonged mismatch:', error);\n    return null;\n  }\n}\n\n/**\n * Updates the tier fit tracking for a friend.\n * Should be called after each interaction to track mismatch duration.\n *\n * @param friendId - Friend to update\n */\nexport async function updateTierFitTracking(friendId: string): Promise<void> {\n  try {\n    const friend = await database.get<Friend>('friends').find(friendId);\n    const analysis = await analyzeTierFit(friend);\n\n    await database.write(async () => {\n      await friend.update(record => {\n        const previousFitScore = record.tierFitScore || 1.0;\n        const currentFitScore = analysis.fitScore;\n\n        // Update fit score\n        record.tierFitScore = currentFitScore;\n\n        // Only reset the timestamp if fit score crosses the mismatch threshold\n        // This preserves duration tracking for persistent mismatches\n        const wasInMismatch = previousFitScore < TierMigrationConfig.mismatchThreshold;\n        const isInMismatch = currentFitScore < TierMigrationConfig.mismatchThreshold;\n\n        if (isInMismatch && !wasInMismatch) {\n          // Just entered mismatch state - start tracking\n          record.tierFitLastCalculated = Date.now();\n        } else if (!isInMismatch && wasInMismatch) {\n          // Exited mismatch state - reset tracking\n          record.tierFitLastCalculated = Date.now();\n        }\n        // If staying in same state, preserve the timestamp for duration tracking\n\n        // Update suggested tier if there's a mismatch\n        if (analysis.suggestedTier) {\n          record.suggestedTier = analysis.suggestedTier;\n        }\n      });\n    });\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error updating tier fit tracking:', error);\n  }\n}\n\n/**\n * Gets comprehensive tier migration suggestions including:\n * - Prolonged mismatches (soft suggestions)\n * - Upward migration opportunities\n * - Dramatic mismatches (strong suggestions)\n *\n * @returns Array of tier suggestion contexts, sorted by urgency\n */\nexport async function getComprehensiveTierSuggestions(): Promise<TierSuggestionContext[]> {\n  try {\n    const friends = await database\n      .get<Friend>('friends')\n      .query(Q.where('is_dormant', false))\n      .fetch();\n\n    const suggestions: TierSuggestionContext[] = [];\n\n    for (const friend of friends) {\n      // Skip if recently dismissed\n      if (!shouldShowTierSuggestion(friend, TierMigrationConfig.dismissalCooldownDays)) {\n        continue;\n      }\n\n      // Check for upward migration (promotion opportunity)\n      const upwardSuggestion = await detectUpwardMigration(friend.id);\n      if (upwardSuggestion) {\n        suggestions.push(upwardSuggestion);\n        continue; // Don't double-suggest\n      }\n\n      // Check for prolonged/dramatic mismatch\n      const prolongedSuggestion = await detectProlongedMismatch(friend.id);\n      if (prolongedSuggestion) {\n        suggestions.push(prolongedSuggestion);\n        continue;\n      }\n\n      // Fall back to regular mismatch detection\n      const analysis = await analyzeTierFit(friend);\n      if (analysis.fitCategory === 'mismatch' && analysis.suggestedTier) {\n        // Check if this is a repeated red friend (high urgency)\n        const redSuggestion = await checkRepeatedRedFriend(friend.id);\n\n        if (redSuggestion) {\n          suggestions.push(redSuggestion);\n        } else {\n          // Regular mismatch (medium urgency)\n          suggestions.push({\n            trigger: TierSuggestionTrigger.PatternEstablished,\n            analysis,\n            urgency: 'medium',\n            direction: determineMigrationDirection(analysis) || undefined,\n            message: `${friend.name}'s tier doesn't match your rhythm`\n          });\n        }\n      }\n    }\n\n    // Sort by urgency (high first), then by mismatch duration\n    suggestions.sort((a, b) => {\n      const urgencyOrder = { high: 3, medium: 2, low: 1 };\n      if (urgencyOrder[a.urgency] !== urgencyOrder[b.urgency]) {\n        return urgencyOrder[b.urgency] - urgencyOrder[a.urgency];\n      }\n      // Secondary sort by mismatch duration\n      return (b.mismatchDurationDays || 0) - (a.mismatchDurationDays || 0);\n    });\n\n    return suggestions;\n  } catch (error) {\n    console.error('[TierSuggestionEngine] Error getting comprehensive suggestions:', error);\n    return [];\n  }\n}\n\n/**\n * Gets only soft suggestions (non-intrusive, for subtle UI hints)\n */\nexport async function getSoftTierSuggestions(): Promise<TierSuggestionContext[]> {\n  const allSuggestions = await getComprehensiveTierSuggestions();\n  return allSuggestions.filter(s => s.isSoftSuggestion);\n}\n\n/**\n * Gets only strong suggestions (for prominent UI alerts)\n */\nexport async function getStrongTierSuggestions(): Promise<TierSuggestionContext[]> {\n  const allSuggestions = await getComprehensiveTierSuggestions();\n  return allSuggestions.filter(s => !s.isSoftSuggestion && s.urgency !== 'low');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/trend.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/services/weaving-insights.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startOfDay' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { startOfWeek, startOfDay } from 'date-fns';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport Friend from '@/db/models/Friend';\n\n/**\n * Weaving Insights Generator\n *\n * Transforms quantitative data into qualitative, human-readable narratives\n * that celebrate the user's weaving practice without creating anxiety.\n *\n * Philosophy: \"No numbers, all feeling\"\n */\n\nexport interface WeeklyInsight {\n  summary: string; // Main narrative about the week\n  reflectionAcknowledgment?: string; // Optional: celebrates reflections\n}\n\n// ============================================================================\n// DEPTH ANALYSIS\n// ============================================================================\n\ninterface DepthAnalysis {\n  deepCount: number; // Heart-to-heart, deep talk, etc.\n  meaningfulCount: number; // Meals, events, activities\n  casualCount: number; // Hangouts, games\n  quickCount: number; // Texts, calls\n}\n\n/**\n * Analyze interaction depth by category\n */\nfunction analyzeDepth(interactions: Interaction[]): DepthAnalysis {\n  const analysis: DepthAnalysis = {\n    deepCount: 0,\n    meaningfulCount: 0,\n    casualCount: 0,\n    quickCount: 0,\n  };\n\n  const deepCategories = ['deep-talk'];\n  const meaningfulCategories = ['meal-drink', 'event-party', 'activity-hobby'];\n  const casualCategories = ['hangout', 'movie-tv'];\n  const quickCategories = ['text-call'];\n\n  for (const interaction of interactions) {\n    const category = interaction.interactionCategory;\n    if (!category) continue;\n\n    if (deepCategories.includes(category)) {\n      analysis.deepCount++;\n    } else if (meaningfulCategories.includes(category)) {\n      analysis.meaningfulCount++;\n    } else if (casualCategories.includes(category)) {\n      analysis.casualCount++;\n    } else if (quickCategories.includes(category)) {\n      analysis.quickCount++;\n    }\n  }\n\n  return analysis;\n}\n\n/**\n * Generate qualitative description of interaction depth\n * Instead of \"Depth Score: 7.2\", returns human narrative\n */\nfunction generateDepthNarrative(analysis: DepthAnalysis): string {\n  const total = analysis.deepCount + analysis.meaningfulCount + analysis.casualCount + analysis.quickCount;\n\n  if (total === 0) return '';\n\n  // High depth week (3+ deep interactions or 50%+ deep/meaningful)\n  if (\n    analysis.deepCount >= 3 ||\n    (analysis.deepCount + analysis.meaningfulCount) / total >= 0.5\n  ) {\n    const phrases = [\n      'Your connections had a quality of depth and presence',\n      'filled with deep and meaningful moments',\n      'marked by profound conversations and genuine presence',\n    ];\n    return phrases[Math.floor(Math.random() * phrases.length)];\n  }\n\n  // Balanced week\n  if (analysis.deepCount >= 1 && analysis.casualCount >= 1) {\n    const phrases = [\n      'balanced mix of meaningful presence and lighthearted joy',\n      'beautifully balanced between depth and lightness',\n      'a harmonious blend of deep connection and easy joy',\n    ];\n    return phrases[Math.floor(Math.random() * phrases.length)];\n  }\n\n  // Social/celebratory week\n  if (analysis.meaningfulCount >= analysis.deepCount * 2) {\n    const phrases = [\n      'alive with celebration and community',\n      'filled with joyful gatherings and shared experiences',\n      'vibrant with social energy and connection',\n    ];\n    return phrases[Math.floor(Math.random() * phrases.length)];\n  }\n\n  // Intimate week\n  if (analysis.deepCount > 0 || (analysis.casualCount + analysis.quickCount) / total >= 0.7) {\n    const phrases = [\n      'marked by quiet, intimate conversations',\n      'intimate and intentional',\n      'focused on quality over quantity',\n    ];\n    return phrases[Math.floor(Math.random() * phrases.length)];\n  }\n\n  // Default: gentle presence\n  return 'filled with gentle moments of connection';\n}\n\n// ============================================================================\n// TIER DISTRIBUTION ANALYSIS\n// ============================================================================\n\ninterface TierDistribution {\n  inner: number;\n  close: number;\n  community: number;\n}\n\n/**\n * Analyze which Dunbar tiers received attention\n */\nasync function analyzeTierDistribution(\n  interactions: Interaction[]\n): Promise<TierDistribution> {\n  const distribution: TierDistribution = {\n    inner: 0,\n    close: 0,\n    community: 0,\n  };\n\n  for (const interaction of interactions) {\n    // Get friends for this interaction\n    const interactionFriends = await database\n      .get<InteractionFriend>('interaction_friends')\n      .query(Q.where('interaction_id', interaction.id))\n      .fetch();\n\n    for (const ifriend of interactionFriends) {\n      const friend = await database.get<Friend>('friends').find(ifriend.friendId);\n\n      if (friend.dunbarTier === 'InnerCircle') {\n        distribution.inner++;\n      } else if (friend.dunbarTier === 'CloseFriends') {\n        distribution.close++;\n      } else if (friend.dunbarTier === 'Community') {\n        distribution.community++;\n      }\n    }\n  }\n\n  return distribution;\n}\n\n/**\n * Generate qualitative description of tier focus\n * Instead of \"60% Inner Circle\", returns human narrative\n */\nfunction generateTierNarrative(distribution: TierDistribution): string {\n  const total = distribution.inner + distribution.close + distribution.community;\n  if (total === 0) return '';\n\n  const innerPct = distribution.inner / total;\n  const closePct = distribution.close / total;\n\n  if (innerPct >= 0.6) {\n    return 'focused energy on your closest bonds';\n  } else if (closePct >= 0.5) {\n    return 'nurtured your broader circle of close friends';\n  } else if (distribution.community >= distribution.inner + distribution.close) {\n    return 'wove connections across your wider community';\n  } else {\n    return 'wove threads across your inner circle and close friends';\n  }\n}\n\n// ============================================================================\n// REFLECTION ACKNOWLEDGMENT\n// ============================================================================\n\n/**\n * Generate acknowledgment for reflections\n * Instead of \"Reflection Rate: 80%\", returns celebration\n */\nfunction generateReflectionAcknowledgment(reflectionCount: number): string | undefined {\n  if (reflectionCount === 0) return undefined;\n\n  if (reflectionCount === 1) {\n    return 'You also took a thoughtful moment for reflection.';\n  } else if (reflectionCount <= 2) {\n    return 'You also took a few quiet moments for reflection.';\n  } else if (reflectionCount <= 4) {\n    return 'You also took several quiet moments for reflection.';\n  } else if (reflectionCount <= 6) {\n    return 'You also took many mindful pauses to reflect.';\n  } else {\n    return 'You showed deep commitment to self-awareness this week.';\n  }\n}\n\n// ============================================================================\n// MAIN INSIGHT GENERATOR\n// ============================================================================\n\n/**\n * Generate weekly insight for \"Your Weaving Practice\" widget\n * Returns qualitative narrative instead of metrics\n *\n * Analyzes Monday-Sunday of current week\n */\nexport async function generateWeeklyInsight(): Promise<WeeklyInsight> {\n  const weekStart = startOfWeek(new Date(), { weekStartsOn: 1 }); // Monday\n  const weekEnd = new Date();\n\n  // Get this week's completed interactions\n  const interactions = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'completed'),\n      Q.where('interaction_date', Q.gte(weekStart.getTime())),\n      Q.where('interaction_date', Q.lte(weekEnd.getTime())),\n      Q.sortBy('interaction_date', Q.desc)\n    )\n    .fetch();\n\n  const weaveCount = interactions.length;\n\n  // Count reflections (interactions with notes OR vibe)\n  const reflectionCount = interactions.filter(\n    i => (i.note && i.note.trim().length > 0) || i.vibe\n  ).length;\n\n  // If no weaves this week\n  if (weaveCount === 0) {\n    return {\n      summary: \"Take a moment to weave a thread this week. Your connections are waiting to be nurtured.\",\n    };\n  }\n\n  // Analyze depth and tier distribution\n  const depthAnalysis = analyzeDepth(interactions);\n  const tierDistribution = await analyzeTierDistribution(interactions);\n\n  // Build narrative\n  const depthNarrative = generateDepthNarrative(depthAnalysis);\n  const tierNarrative = generateTierNarrative(tierDistribution);\n\n  // Count descriptor\n  let countPhrase = '';\n  if (weaveCount === 1) {\n    countPhrase = 'you wove a thread';\n  } else if (weaveCount === 2) {\n    countPhrase = 'you wove a couple of threads';\n  } else if (weaveCount <= 4) {\n    countPhrase = `you wove ${weaveCount} threads`;\n  } else if (weaveCount <= 7) {\n    countPhrase = `you wove several threads`;\n  } else {\n    countPhrase = `you wove many threads`;\n  }\n\n  // Highlight special interactions (3+ deep talks)\n  let specialMoment = '';\n  if (depthAnalysis.deepCount >= 3) {\n    specialMoment = ` ${depthAnalysis.deepCount === 3 ? 'Three' : 'Several'} heart-to-heart moments stood out.`;\n  } else if (depthAnalysis.deepCount >= 1) {\n    specialMoment = depthAnalysis.deepCount === 1\n      ? ' A heart-to-heart moment stood out.'\n      : ' A couple of heart-to-heart moments stood out.';\n  }\n\n  // Assemble summary\n  const summary = `This week, ${countPhrase} ${tierNarrative}. Your connections were ${depthNarrative}.${specialMoment}`;\n\n  // Add reflection acknowledgment\n  const reflectionAcknowledgment = generateReflectionAcknowledgment(reflectionCount);\n\n  return {\n    summary,\n    reflectionAcknowledgment,\n  };\n}\n\n/**\n * Get simple week count for compact display\n * Returns actual number for \"This week: X\" stat\n */\nexport async function getThisWeekCount(): Promise<number> {\n  const weekStart = startOfWeek(new Date(), { weekStartsOn: 1 });\n  const weekEnd = new Date();\n\n  const interactions = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'completed'),\n      Q.where('interaction_date', Q.gte(weekStart.getTime())),\n      Q.where('interaction_date', Q.lte(weekEnd.getTime()))\n    )\n    .fetch();\n\n  return interactions.length;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/insights/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/__tests__/decay.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Tier' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { applyDecay, calculateDecayAmount } from '../services/decay.service';\nimport FriendModel from '@/db/models/Friend';\nimport { Tier } from '@/components/types';\n\n// Helper to create a date in the past\nconst daysAgo = (days: number): Date => {\n  const date = new Date();\n  date.setDate(date.getDate() - days);\n  return date;\n};\n\ndescribe('Decay Service', () => {\n  let mockFriend: Partial<FriendModel>;\n\n  beforeEach(() => {\n    mockFriend = {\n      weaveScore: 80,\n      dunbarTier: 'CloseFriends', // Tolerance window: 14 days\n      resilience: 1.0,\n    };\n  });\n\n  describe('calculateDecayAmount', () => {\n    it('calculates decay for arbitrary days correctly', () => {\n      // 10 days (within limit) \n      // 10 * 1.5 * 0.5 = 7.5\n      expect(calculateDecayAmount(mockFriend as FriendModel, 10)).toBeCloseTo(7.5);\n    });\n\n    it('calculates accelerated decay correctly', () => {\n      // 20 days (6 days over limit)\n      // Base: 10.5, Accel: 13.5 -> 24\n      expect(calculateDecayAmount(mockFriend as FriendModel, 20)).toBeCloseTo(24);\n    });\n\n    it('returns 0 for negative or zero days', () => {\n      expect(calculateDecayAmount(mockFriend as FriendModel, 0)).toBe(0);\n      expect(calculateDecayAmount(mockFriend as FriendModel, -5)).toBe(0);\n    });\n  });\n\n  describe('applyDecay', () => {\n    it('applies no decay if last update was today', () => {\n      mockFriend.lastUpdated = daysAgo(0);\n      const newScore = applyDecay(mockFriend as FriendModel);\n      expect(newScore).toBeCloseTo(80);\n    });\n\n    it('applies minimal decay within the tolerance window', () => {\n      mockFriend.lastUpdated = daysAgo(10); // 10 days ago, within 14-day window\n      const newScore = applyDecay(mockFriend as FriendModel);\n      // Decay rate for CloseFriends is 1.5\n      // Within tolerance, decay is half: 1.5 * 0.5 = 0.75 per day\n      // Total decay: 10 * 0.75 = 7.5\n      // Expected score: 80 - 7.5 = 72.5\n      expect(newScore).toBeCloseTo(72.5);\n    });\n\n    it('applies accelerated decay outside the tolerance window', () => {\n      mockFriend.lastUpdated = daysAgo(20); // 20 days ago, 6 days past 14-day window\n      const newScore = applyDecay(mockFriend as FriendModel);\n      // Base decay for 14 days: 14 * (1.5 * 0.5) = 10.5\n      // Accelerated decay for 6 days: 6 * (1.5 * 1.5) = 13.5\n      // Total decay: 10.5 + 13.5 = 24\n      // Expected score: 80 - 24 = 56\n      expect(newScore).toBeCloseTo(56);\n    });\n\n    it('calculates decay correctly for InnerCircle tier', () => {\n      mockFriend.dunbarTier = 'InnerCircle'; // Tolerance: 7 days, Decay Rate: 2.5\n      mockFriend.lastUpdated = daysAgo(10); // 3 days past window\n      const newScore = applyDecay(mockFriend as FriendModel);\n      // Base decay: 7 * (2.5 * 0.5) = 8.75\n      // Accelerated decay: 3 * (2.5 * 1.5) = 11.25\n      // Total decay: 8.75 + 11.25 = 20\n      // Expected score: 80 - 20 = 60\n      expect(newScore).toBeCloseTo(60);\n    });\n\n    it('uses a learned tolerance window if available', () => {\n      mockFriend.toleranceWindowDays = 30; // Custom learned pattern\n      mockFriend.lastUpdated = daysAgo(20); // Still within the learned window\n      const newScore = applyDecay(mockFriend as FriendModel);\n      // Should use minimal decay rate\n      // Total decay: 20 * (1.5 * 0.5) = 15\n      // Expected score: 80 - 15 = 65\n      expect(newScore).toBeCloseTo(65);\n    });\n\n    it('is mitigated by higher resilience', () => {\n      mockFriend.resilience = 1.5; // High resilience\n      mockFriend.lastUpdated = daysAgo(10); // Within window\n      const newScore = applyDecay(mockFriend as FriendModel);\n      // Base decay was 7.5, with resilience it should be 7.5 / 1.5 = 5\n      // Expected score: 80 - 5 = 75\n      expect(newScore).toBeCloseTo(75);\n    });\n\n    it('is amplified by lower resilience', () => {\n      mockFriend.resilience = 0.8; // Low resilience\n      mockFriend.lastUpdated = daysAgo(10); // Within window\n      const newScore = applyDecay(mockFriend as FriendModel);\n      // Base decay was 7.5, with resilience it should be 7.5 / 0.8 = 9.375\n      // Expected score: 80 - 9.375 = 70.625\n      expect(newScore).toBeCloseTo(70.625);\n    });\n\n    it('never drops the score below zero', () => {\n      mockFriend.weaveScore = 10;\n      mockFriend.lastUpdated = daysAgo(30); // High decay\n      const newScore = applyDecay(mockFriend as FriendModel);\n      expect(newScore).toBe(0);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/__tests__/momentum.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/__tests__/resilience.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Vibe' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { updateResilience } from '../services/resilience.service';\nimport FriendModel from '@/db/models/Friend';\nimport { Vibe } from '@/shared/types/common';\n\ndescribe('Resilience Service', () => {\n  let mockFriend: Partial<FriendModel>;\n\n  beforeEach(() => {\n    mockFriend = {\n      resilience: 1.0,\n      ratedWeavesCount: 5, // Assume friend is eligible for updates\n    };\n  });\n\n  it('does not update resilience if ratedWeavesCount is less than 5', () => {\n    mockFriend.ratedWeavesCount = 4;\n    const newResilience = updateResilience(mockFriend as FriendModel, 'FullMoon');\n    expect(newResilience).toBeNull();\n  });\n\n  it('does not update resilience if vibe is null', () => {\n    const newResilience = updateResilience(mockFriend as FriendModel, null);\n    expect(newResilience).toBeNull();\n  });\n\n  it('increases resilience for a positive vibe (FullMoon)', () => {\n    const newResilience = updateResilience(mockFriend as FriendModel, 'FullMoon');\n    expect(newResilience).toBeCloseTo(1.008);\n  });\n\n  it('increases resilience for a positive vibe (WaxingGibbous)', () => {\n    const newResilience = updateResilience(mockFriend as FriendModel, 'WaxingGibbous');\n    expect(newResilience).toBeCloseTo(1.008);\n  });\n\n  it('decreases resilience for a negative vibe (NewMoon)', () => {\n    const newResilience = updateResilience(mockFriend as FriendModel, 'NewMoon');\n    expect(newResilience).toBeCloseTo(0.995);\n  });\n\n  it('does not change resilience for neutral vibes', () => {\n    const newResilience = updateResilience(mockFriend as FriendModel, 'FirstQuarter');\n    expect(newResilience).toBeNull(); // No change means null is returned\n  });\n\n  it('clamps the resilience score at the maximum of 1.5', () => {\n    mockFriend.resilience = 1.495;\n    const newResilience = updateResilience(mockFriend as FriendModel, 'FullMoon');\n    expect(newResilience).toBe(1.5);\n  });\n\n  it('clamps the resilience score at the minimum of 0.8', () => {\n    mockFriend.resilience = 0.803;\n    const newResilience = updateResilience(mockFriend as FriendModel, 'NewMoon');\n    expect(newResilience).toBe(0.8);\n  });\n\n  it('returns null if the resilience does not change after calculation', () => {\n    mockFriend.resilience = 1.5;\n    const newResilience = updateResilience(mockFriend as FriendModel, 'FullMoon');\n    expect(newResilience).toBeNull();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/__tests__/scoring-enhancements.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VibeMultipliers' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLearnedEffectiveness' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { calculatePointsForWeave } from '../services/scoring.service';\nimport FriendModel from '@/db/models/Friend';\nimport { VibeMultipliers } from '../constants';\nimport { getLearnedEffectiveness } from '@/modules/insights';\n\njest.mock('@/modules/insights', () => ({\n    getLearnedEffectiveness: jest.fn().mockReturnValue(1.0),\n}));\n\n// Mock FriendModel\nconst mockFriend = {\n    id: 'test-friend',\n    archetype: 'Sun',\n    momentumScore: 0,\n    momentumLastUpdated: new Date(),\n    outcomeCount: 0,\n} as unknown as FriendModel;\n\ndescribe('Scoring Enhancements', () => {\n    describe('Vibe Multipliers', () => {\n        it('should apply higher multiplier for FullMoon (5/5) vibe', () => {\n            const points = calculatePointsForWeave(mockFriend, {\n                category: 'text-call',\n                duration: 'Standard',\n                vibe: 'FullMoon',\n                interactionHistoryCount: 0,\n            });\n\n            // Base: 10 (text-call) * 1.0 (Sun archetype) * 1.0 (Standard duration) = 10\n            // Multiplier: 1.5 (FullMoon)\n            // Expected: 15\n            // Quality multiplier (default neutral): 1.0\n            // Total: 15\n\n            // Note: There might be slight variations due to quality calculation defaults, \n            // but we expect it to be significantly higher than the old 1.3x (which would be 13)\n            expect(points).toBeGreaterThan(14);\n        });\n\n        it('should apply lower multiplier for NewMoon (1/5) vibe', () => {\n            const points = calculatePointsForWeave(mockFriend, {\n                category: 'text-call',\n                duration: 'Standard',\n                vibe: 'NewMoon',\n                interactionHistoryCount: 0,\n            });\n\n            // Base: 10\n            // Multiplier: 0.8 (NewMoon)\n            // Expected: 8\n            expect(points).toBeLessThan(9);\n        });\n    });\n\n    describe('Affinity Bonus', () => {\n        it('should apply 1.15x bonus when interaction history count is >= 5', () => {\n            const pointsNormal = calculatePointsForWeave(mockFriend, {\n                category: 'text-call',\n                duration: 'Standard',\n                vibe: 'WaxingCrescent', // 1.0 multiplier\n                interactionHistoryCount: 4,\n            });\n\n            const pointsBonus = calculatePointsForWeave(mockFriend, {\n                category: 'text-call',\n                duration: 'Standard',\n                vibe: 'WaxingCrescent', // 1.0 multiplier\n                interactionHistoryCount: 5,\n            });\n\n            // pointsBonus should be approx 1.15x of pointsNormal\n            const ratio = pointsBonus / pointsNormal;\n            expect(ratio).toBeCloseTo(1.15, 1);\n        });\n\n        it('should not apply bonus when interaction history count is < 5', () => {\n            const pointsLowHistory = calculatePointsForWeave(mockFriend, {\n                category: 'text-call',\n                duration: 'Standard',\n                vibe: 'WaxingCrescent',\n                interactionHistoryCount: 1,\n            });\n\n            const pointsThreshold = calculatePointsForWeave(mockFriend, {\n                category: 'text-call',\n                duration: 'Standard',\n                vibe: 'WaxingCrescent',\n                interactionHistoryCount: 4,\n            });\n\n            // Should be equal as neither gets bonus\n            expect(pointsLowHistory).toBeCloseTo(pointsThreshold, 1);\n        });\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/__tests__/scoring.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GROUP_DILUTION_RATE' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'InteractionFormData' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Archetype' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Duration' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Vibe' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'InteractionCategory' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { calculatePointsForWeave, calculateGroupDilution, calculateEventMultiplier } from '../services/scoring.service';\nimport { MAX_INTERACTION_SCORE, GROUP_DILUTION_RATE, GROUP_DILUTION_FLOOR } from '../constants';\nimport FriendModel from '@/db/models/Friend';\nimport { InteractionFormData } from '@/stores/interactionStore';\nimport { Archetype, Duration, Vibe, InteractionCategory } from '@/components/types';\nimport * as qualityService from '../services/quality.service';\n\n// Mock the quality service to isolate scoring logic\njest.mock('../services/quality.service', () => ({\n  calculateInteractionQuality: jest.fn(),\n}));\n\n// Mock the insights module to prevent DB initialization issues\njest.mock('@/modules/insights', () => ({\n  getLearnedEffectiveness: jest.fn().mockReturnValue(1.0),\n}));\n\n// Mock the database initialization\njest.mock('@/db', () => ({\n  database: {\n    get: jest.fn(),\n  },\n}));\n\ndescribe('Scoring Service', () => {\n  let mockFriend: FriendModel;\n\n  beforeEach(() => {\n    // Reset mock before each test\n    (qualityService.calculateInteractionQuality as jest.Mock).mockReturnValue({ overallQuality: 3 }); // Neutral quality\n\n    mockFriend = {\n      archetype: 'Emperor',\n      momentumScore: 0,\n      momentumLastUpdated: new Date(0), // A long time ago\n      outcomeCount: 0, // No learned effectiveness by default\n    } as FriendModel;\n  });\n\n  describe('calculatePointsForWeave', () => {\n    it('calculates a baseline score correctly with neutral modifiers', () => {\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Standard',\n        vibe: 'WaxingCrescent',\n        groupSize: 1,\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      expect(points).toBeCloseTo(25.652);\n    });\n\n    it('applies a positive vibe multiplier correctly', () => {\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Standard',\n        vibe: 'FullMoon', // 1.5x multiplier\n        groupSize: 1,\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      expect(points).toBeCloseTo(38.478);\n    });\n\n    it('applies a duration modifier correctly', () => {\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Extended', // 1.2x modifier\n        vibe: 'WaxingCrescent',\n        groupSize: 1,\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      expect(points).toBeCloseTo(30.7824);\n    });\n\n    it('applies a different archetype multiplier correctly', () => {\n      mockFriend.archetype = 'Fool';\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Standard',\n        vibe: 'WaxingCrescent',\n        groupSize: 1,\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      expect(points).toBeCloseTo(23.32);\n    });\n\n    it('applies group dilution correctly with smooth curve', () => {\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Standard',\n        vibe: 'WaxingCrescent',\n        groupSize: 4, // Smooth dilution: ~0.74x\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      // With smooth curve: base ~25.65 * 0.74 dilution = ~19.0\n      expect(points).toBeGreaterThan(17);\n      expect(points).toBeLessThan(21);\n    });\n\n    it('applies an event multiplier for celebrations', () => {\n      const interactionData = {\n        category: 'celebration',\n        duration: 'Standard',\n        vibe: 'WaxingCrescent',\n        groupSize: 1,\n        eventImportance: 'high', // 1.3x multiplier\n      } as any;\n      mockFriend.archetype = 'Sun';\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      expect(points).toBeCloseTo(57.3248);\n    });\n\n    it('applies a quality multiplier', () => {\n      (qualityService.calculateInteractionQuality as jest.Mock).mockReturnValue({ overallQuality: 5 }); // High quality -> 1.3x multiplier\n\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Standard',\n        vibe: 'WaxingCrescent',\n        groupSize: 1,\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      expect(points).toBeCloseTo(31.46);\n    });\n\n    it('restores some points from group dilution with high quality', () => {\n      (qualityService.calculateInteractionQuality as jest.Mock).mockReturnValue({ overallQuality: 4 }); // High quality\n\n      const interactionData = {\n        category: 'meal-drink',\n        duration: 'Standard',\n        vibe: 'WaxingCrescent',\n        groupSize: 4, // Smooth dilution with restoration\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      // High quality should restore some dilution points\n      // Should be higher than non-quality-restored diluted score\n      expect(points).toBeGreaterThan(19);\n      expect(points).toBeLessThan(26);\n    });\n\n    it('caps extremely high scores to MAX_INTERACTION_SCORE', () => {\n      (qualityService.calculateInteractionQuality as jest.Mock).mockReturnValue({ overallQuality: 5 }); // Max quality\n\n      // Set up friend with momentum for maximum possible score\n      mockFriend.momentumScore = 15;\n      mockFriend.momentumLastUpdated = new Date();\n      mockFriend.archetype = 'Sun'; // High multiplier for celebrations\n\n      const interactionData = {\n        category: 'celebration', // Highest base score (32)\n        duration: 'Extended',    // 1.2x\n        vibe: 'FullMoon',        // 1.5x\n        groupSize: 1,\n        eventImportance: 'critical', // 1.5x\n        interactionHistoryCount: 10, // 1.15x affinity\n      } as any;\n\n      const points = calculatePointsForWeave(mockFriend, interactionData);\n      // Without cap this would be ~120+ points, but should be capped at MAX_INTERACTION_SCORE\n      expect(points).toBeLessThanOrEqual(MAX_INTERACTION_SCORE);\n      expect(points).toBe(MAX_INTERACTION_SCORE);\n    });\n  });\n\n  describe('calculateGroupDilution (smooth curve)', () => {\n    it('returns 1.0 for a group of 1', () => {\n      expect(calculateGroupDilution(1)).toBe(1.0);\n    });\n\n    it('returns ~0.87 for a group of 2 (smooth decay)', () => {\n      const dilution = calculateGroupDilution(2);\n      expect(dilution).toBeGreaterThan(0.85);\n      expect(dilution).toBeLessThan(0.90);\n    });\n\n    it('returns ~0.74 for a group of 4 (gradual transition from 3)', () => {\n      const dilution3 = calculateGroupDilution(3);\n      const dilution4 = calculateGroupDilution(4);\n      // Group of 4 should have slightly more dilution than group of 3\n      expect(dilution4).toBeLessThan(dilution3);\n      expect(dilution4).toBeGreaterThan(0.70);\n      expect(dilution4).toBeLessThan(0.78);\n    });\n\n    it('returns ~0.58 for a group of 8 (continuous curve)', () => {\n      const dilution = calculateGroupDilution(8);\n      expect(dilution).toBeGreaterThan(0.55);\n      expect(dilution).toBeLessThan(0.62);\n    });\n\n    it('has continuous values between group sizes (no discrete jumps)', () => {\n      // Verify smooth curve - each increment should produce slightly lower value\n      const dilutions = [1, 2, 3, 4, 5, 6, 7, 8].map(calculateGroupDilution);\n      for (let i = 1; i < dilutions.length; i++) {\n        // Each larger group should have slightly more dilution (lower factor)\n        expect(dilutions[i]).toBeLessThan(dilutions[i - 1]);\n        // But the difference should be gradual, not a sharp jump\n        const diff = dilutions[i - 1] - dilutions[i];\n        expect(diff).toBeLessThan(0.15); // No jump greater than 15%\n      }\n    });\n\n    it('respects GROUP_DILUTION_FLOOR for very large groups', () => {\n      expect(calculateGroupDilution(50)).toBeGreaterThanOrEqual(GROUP_DILUTION_FLOOR);\n      expect(calculateGroupDilution(100)).toBeGreaterThanOrEqual(GROUP_DILUTION_FLOOR);\n    });\n\n    it('handles edge cases (0 or negative)', () => {\n      expect(calculateGroupDilution(0)).toBe(1.0);\n      expect(calculateGroupDilution(-1)).toBe(1.0);\n    });\n  });\n\n  describe('calculateEventMultiplier', () => {\n    it('returns 1.0 for a standard interaction', () => {\n      expect(calculateEventMultiplier('meal-drink', 'medium')).toBe(1.0);\n    });\n    it('returns 1.5 for a critical celebration', () => {\n      expect(calculateEventMultiplier('celebration', 'critical')).toBe(1.5);\n    });\n    it('returns 1.4 for critical support', () => {\n      expect(calculateEventMultiplier('favor-support', 'critical')).toBe(1.4);\n    });\n    it('returns 1.2 for a deep talk during a high-importance event', () => {\n      expect(calculateEventMultiplier('deep-talk', 'high')).toBe(1.2);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/listeners/intelligence.listener.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/scripts/verify-scoring.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VibeMultipliers' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { calculatePointsForWeave } from '../services/scoring.service';\nimport { VibeMultipliers } from '../constants';\n\n// Mock FriendModel\nconst mockFriend: any = {\n    id: 'test-friend',\n    archetype: 'Sun',\n    momentumScore: 0,\n    momentumLastUpdated: new Date(),\n    outcomeCount: 0,\n};\n\nconsole.log('--- Verifying Scoring Enhancements ---');\n\n// 1. Verify Vibe Multipliers\nconsole.log('\\n1. Verifying Vibe Multipliers');\nconst pointsFullMoon = calculatePointsForWeave(mockFriend, {\n    category: 'text-call',\n    duration: 'Standard',\n    vibe: 'FullMoon',\n    interactionHistoryCount: 0,\n});\nconsole.log(`FullMoon Points (Expected > 14): ${pointsFullMoon}`);\n\nconst pointsNewMoon = calculatePointsForWeave(mockFriend, {\n    category: 'text-call',\n    duration: 'Standard',\n    vibe: 'NewMoon',\n    interactionHistoryCount: 0,\n});\nconsole.log(`NewMoon Points (Expected < 9): ${pointsNewMoon}`);\n\n// 2. Verify Affinity Bonus\nconsole.log('\\n2. Verifying Affinity Bonus');\nconst pointsNormal = calculatePointsForWeave(mockFriend, {\n    category: 'text-call',\n    duration: 'Standard',\n    vibe: 'WaxingCrescent',\n    interactionHistoryCount: 4,\n});\nconsole.log(`Normal Points (History 4): ${pointsNormal}`);\n\nconst pointsBonus = calculatePointsForWeave(mockFriend, {\n    category: 'text-call',\n    duration: 'Standard',\n    vibe: 'WaxingCrescent',\n    interactionHistoryCount: 5,\n});\nconsole.log(`Bonus Points (History 5): ${pointsBonus}`);\n\nconst ratio = pointsBonus / pointsNormal;\nconsole.log(`Ratio (Expected ~1.15): ${ratio.toFixed(2)}`);\n\nif (pointsFullMoon > 14 && pointsNewMoon < 9 && Math.abs(ratio - 1.15) < 0.05) {\n    console.log('\\n✅ SUCCESS: All checks passed!');\n} else {\n    console.log('\\n❌ FAILURE: Some checks failed.');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/decay.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/deepening.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/flexible-decay.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/focus-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":116,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport Interaction from '@/db/models/Interaction';\nimport LifeEvent from '@/db/models/LifeEvent';\nimport FriendModel from '@/db/models/Friend';\nimport { Suggestion } from '@/shared/types/common';\nimport { fetchSuggestions } from '@/modules/interactions';\nimport type { SocialSeason } from '@/db/models/UserProfile';\nimport { differenceInDays, isSameDay } from 'date-fns';\n\nexport interface UpcomingDate {\n    friend: FriendModel;\n    type: 'birthday' | 'anniversary' | 'life_event';\n    daysUntil: number;\n    title?: string;\n    importance?: 'low' | 'medium' | 'high' | 'critical';\n}\n\nexport interface FocusData {\n    plans: Interaction[];\n    suggestions: Suggestion[];\n    upcomingDates: UpcomingDate[];\n    pendingConfirmations: Interaction[];\n}\n\nexport const FocusGenerator = {\n    /**\n     * Get interactions that require attention (today's plans or pending confirmations)\n     */\n    async getImportantPlans(): Promise<{ plans: Interaction[]; pending: Interaction[] }> {\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        const sevenDaysAgo = new Date(today);\n        sevenDaysAgo.setDate(today.getDate() - 7);\n\n        const tomorrow = new Date(today);\n        tomorrow.setDate(today.getDate() + 1);\n\n        const interactions = await database.get<Interaction>('interactions').query().fetch();\n\n        const filtered = interactions\n            .filter((i: Interaction) => {\n                const iDate = new Date(i.interactionDate);\n                iDate.setHours(0, 0, 0, 0);\n\n                // Filter out plans further than tomorrow\n                if (iDate > tomorrow) return false;\n\n                const isToday = iDate.getTime() === today.getTime();\n                // Today's plans: show unless cancelled\n                if (isToday && i.status !== 'cancelled') return true;\n                // Past plans: show if pending confirmation (not completed/cancelled) for last 7 days\n                if (i.status === 'completed' || i.status === 'cancelled') return false;\n                return iDate >= sevenDaysAgo;\n            })\n            .sort((a, b) => new Date(a.interactionDate).getTime() - new Date(b.interactionDate).getTime());\n\n        const todaysPlans = filtered.filter(p => isSameDay(new Date(p.interactionDate), today));\n        // Pending includes past unconfirmed AND today's unconfirmed plans?\n        // Widget logic: \"visiblePendingPlans\" included today's plans too.\n        // We separate them for Digest purposes, but return all for widget compatibility.\n\n        return {\n            plans: todaysPlans,\n            pending: filtered,\n        };\n    },\n\n    /**\n     * Get upcoming birthdays and life events\n     */\n    async getUpcomingDates(friends?: FriendModel[]): Promise<UpcomingDate[]> {\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        const thirtyDaysFromNow = new Date();\n        thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);\n        const events: UpcomingDate[] = [];\n\n        const allFriends = friends || await database.get<FriendModel>('friends').query().fetch();\n\n        // 1. Life Events\n        const lifeEvents = await database\n            .get<LifeEvent>('life_events')\n            .query(\n                Q.where('event_date', Q.gte(today.getTime())),\n                Q.where('event_date', Q.lte(thirtyDaysFromNow.getTime()))\n            )\n            .fetch();\n\n        lifeEvents.forEach(event => {\n            const friend = allFriends.find(f => f.id === event.friendId);\n            if (friend) {\n                events.push({\n                    friend,\n                    type: 'life_event',\n                    daysUntil: differenceInDays(event.eventDate, today),\n                    title: event.title,\n                    importance: event.importance,\n                });\n            }\n        });\n\n        // 2. Birthdays\n        allFriends.forEach(friend => {\n            try {\n                if (friend.birthday) {\n                    const [month, day] = friend.birthday.split('-').map(n => parseInt(n, 10));\n                    const birthdayThisYear = new Date(today.getFullYear(), month - 1, day);\n                    birthdayThisYear.setHours(0, 0, 0, 0);\n                    if (birthdayThisYear < today) birthdayThisYear.setFullYear(today.getFullYear() + 1);\n                    const daysUntil = differenceInDays(birthdayThisYear, today);\n                    if (daysUntil >= 0 && daysUntil <= 7) {\n                        events.push({ friend, type: 'birthday', daysUntil });\n                    }\n                }\n            } catch (e) {\n                // ignore\n            }\n        });\n\n        events.sort((a, b) => a.daysUntil - b.daysUntil);\n        return events;\n    },\n\n    /**\n     * Get suggestions with optional season-aware filtering\n     */\n    async getSuggestions(limit: number = 3, season?: SocialSeason | null): Promise<Suggestion[]> {\n        return fetchSuggestions(limit, season);\n    },\n\n    /**\n     * Generate full focus data\n     */\n    async generateFocusData(): Promise<FocusData> {\n        const { plans, pending } = await this.getImportantPlans();\n        const upcomingDates = await this.getUpcomingDates();\n        const suggestions = await this.getSuggestions();\n\n        return {\n            plans, // Today's plans\n            pendingConfirmations: pending, // Includes today's plans + past pending\n            upcomingDates,\n            suggestions,\n        };\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/intelligent-status-line.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FriendModel' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HydratedLifeEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { differenceInDays, format, startOfDay } from 'date-fns';\nimport { parseFlexibleDate } from '@/shared/utils/date-utils';\nimport { database } from '@/db';\nimport LifeEvent from '@/db/models/LifeEvent';\nimport FriendModel from '@/db/models/Friend';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport { Q } from '@nozbe/watermelondb';\nimport { calculateCurrentScore } from './orchestrator.service';\nimport { type Friend } from '@/components/types';\nimport { HydratedFriend, HydratedLifeEvent } from '@/types/hydrated';\n\nexport interface StatusLine {\n  text: string;\n  icon?: string;\n  variant?: 'default' | 'accent' | 'warning' | 'success';\n}\n\n// Life event emoji mapping\nconst LIFE_EVENT_ICONS: Record<string, string> = {\n  birthday: '🎂',\n  anniversary: '💝',\n  new_job: '💼',\n  moving: '📦',\n  wedding: '💒',\n  baby: '👶',\n  loss: '🕊️',\n  health_event: '🏥',\n  graduation: '🎓',\n  celebration: '🎉',\n  other: '✨',\n};\n\n// Archetype-driven actionable nudges\nconst ARCHETYPE_NUDGES: Record<string, string[]> = {\n  Emperor: [\n    'Ready to plan something together?',\n    'A structured catch-up would feel good',\n    'Time to reconnect with purpose',\n  ],\n  Empress: [\n    'A good time to nurture this bond',\n    'Ready for some comfort and connection?',\n    'Time to create warmth together',\n  ],\n  HighPriestess: [\n    'A deep conversation would mean a lot',\n    'Space for meaningful connection',\n    'Ready for real talk?',\n  ],\n  Fool: [\n    'Ready for a new adventure together?',\n    'Time for spontaneous fun',\n    'Let\\'s try something unexpected',\n  ],\n  Sun: [\n    'Time to celebrate this friendship',\n    'Ready to bring the energy?',\n    'A bright moment together awaits',\n  ],\n  Hermit: [\n    'Quality one-on-one time would be special',\n    'A quiet moment together sounds nice',\n    'Ready for thoughtful connection?',\n  ],\n  Magician: [\n    'Ready to create something together?',\n    'A collaborative moment would spark joy',\n    'Time to build something meaningful',\n  ],\n};\n\nfunction getRandomNudge(archetype: string): string {\n  const nudges = ARCHETYPE_NUDGES[archetype] || ['Time to reconnect'];\n  return nudges[Math.floor(Math.random() * nudges.length)];\n}\n\n/**\n * PRIORITY 1: Check for urgent life events\n */\nasync function checkLifeEventStatus(friend: HydratedFriend | Friend): Promise<StatusLine | null> {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n\n  try {\n    // Check database life events (past 7 days or upcoming 30 days)\n    const activeLifeEvents = await database\n      .get<LifeEvent>('life_events')\n      .query(\n        Q.where('friend_id', friend.id),\n        Q.or(\n          // Upcoming events (within next 30 days)\n          Q.and(\n            Q.where('event_date', Q.gte(today.getTime())),\n            Q.where('event_date', Q.lte(today.getTime() + 30 * 24 * 60 * 60 * 1000))\n          ),\n          // Recent past events (last 7 days for follow-up)\n          Q.and(\n            Q.where('event_date', Q.gte(today.getTime() - 7 * 24 * 60 * 60 * 1000)),\n            Q.where('event_date', Q.lt(today.getTime()))\n          )\n        )\n      )\n      .fetch();\n\n    // Prioritize by importance and proximity\n    const sortedEvents = activeLifeEvents.sort((a, b) => {\n      const importanceOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n      const aScore = importanceOrder[a.importance];\n      const bScore = importanceOrder[b.importance];\n      if (aScore !== bScore) return bScore - aScore;\n      return Math.abs(differenceInDays(a.eventDate, today)) - Math.abs(differenceInDays(b.eventDate, today));\n    });\n\n    if (sortedEvents.length > 0) {\n      const topEvent = sortedEvents[0];\n      const daysUntil = differenceInDays(topEvent.eventDate, today);\n      const icon = LIFE_EVENT_ICONS[topEvent.eventType] || '✨';\n\n      if (daysUntil === 0) {\n        return { text: `${topEvent.title || topEvent.eventType} is today!`, icon, variant: 'accent' };\n      } else if (daysUntil === 1) {\n        return { text: `${topEvent.title || topEvent.eventType} is tomorrow`, icon, variant: 'accent' };\n      } else if (daysUntil > 1 && daysUntil <= 30) {\n        return { text: `${topEvent.title || topEvent.eventType} in ${daysUntil} days`, icon, variant: 'default' };\n      } else if (daysUntil < 0 && daysUntil >= -7) {\n        const daysAgo = Math.abs(daysUntil);\n        if (daysAgo === 1) {\n          return { text: `${topEvent.title || topEvent.eventType} was yesterday`, icon, variant: 'warning' };\n        }\n        return { text: `${topEvent.title || topEvent.eventType} was ${daysAgo} days ago`, icon, variant: 'warning' };\n      }\n    }\n\n    // Check birthday (legacy Friend model field)\n    if (friend.birthday) {\n      // Use flexible parser\n      const dateParts = parseFlexibleDate(friend.birthday);\n\n      if (!dateParts) {\n        console.warn(`[StatusLine] Invalid birthday format: ${friend.birthday}`);\n      } else {\n        const { month, day } = dateParts;\n\n        // Validate date components (just in case)\n        if (month < 1 || month > 12 || day < 1 || day > 31) {\n          console.warn(`[StatusLine] Invalid birthday date: ${friend.birthday}`);\n        } else {\n          // Create birthday for this year\n          const birthdayThisYear = new Date(today.getFullYear(), month - 1, day);\n          birthdayThisYear.setHours(0, 0, 0, 0);\n\n          if (birthdayThisYear < today) {\n            birthdayThisYear.setFullYear(today.getFullYear() + 1);\n          }\n\n          const daysUntil = differenceInDays(birthdayThisYear, today);\n          if (daysUntil >= 0 && daysUntil <= 7) {\n            if (daysUntil === 0) return { text: 'Birthday is today!', icon: '🎂', variant: 'accent' };\n            if (daysUntil === 1) return { text: 'Birthday is tomorrow', icon: '🎂', variant: 'accent' };\n            return { text: `Birthday in ${daysUntil} days`, icon: '🎂', variant: 'default' };\n          }\n        }\n      }\n    }\n\n    // Check anniversary (legacy Friend model field)\n    if (friend.anniversary) {\n      // Use flexible parser\n      const dateParts = parseFlexibleDate(friend.anniversary);\n\n      if (!dateParts) {\n        console.warn(`[StatusLine] Invalid anniversary format: ${friend.anniversary}`);\n      } else {\n        const { month, day } = dateParts;\n\n        // Validate date components (just in case)\n        if (month < 1 || month > 12 || day < 1 || day > 31) {\n          console.warn(`[StatusLine] Invalid anniversary date: ${friend.anniversary}`);\n        } else {\n          // Create anniversary for this year\n          const anniversaryThisYear = new Date(today.getFullYear(), month - 1, day);\n          anniversaryThisYear.setHours(0, 0, 0, 0);\n\n          if (anniversaryThisYear < today) {\n            anniversaryThisYear.setFullYear(today.getFullYear() + 1);\n          }\n\n          const daysUntil = differenceInDays(anniversaryThisYear, today);\n          if (daysUntil >= 0 && daysUntil <= 7) {\n            if (daysUntil === 0) return { text: 'Friendship anniversary today!', icon: '💝', variant: 'accent' };\n            if (daysUntil === 1) return { text: 'Friendship anniversary tomorrow', icon: '💝', variant: 'accent' };\n            return { text: `Anniversary in ${daysUntil} days`, icon: '💝', variant: 'default' };\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error checking life events:', error);\n  }\n\n  return null;\n}\n\n/**\n * Generate varied, insightful status messages for healthy relationships\n * Analyzes recent interaction patterns to provide specific, meaningful insights\n */\nfunction generateHealthyRelationshipInsight(\n  friend: HydratedFriend | Friend,\n  recentInteractions: Interaction[],\n  recentCount: number\n): StatusLine {\n  // Analyze interaction patterns\n  const categoryCount: Record<string, number> = {};\n  let totalWithVibe = 0;\n  let positiveVibeCount = 0;\n\n  recentInteractions.forEach(interaction => {\n    const cat = interaction.interactionCategory || 'other';\n    categoryCount[cat] = (categoryCount[cat] || 0) + 1;\n\n    // Track vibe quality if available\n    if (interaction.vibe) {\n      totalWithVibe++;\n      if (interaction.vibe === 'great' || interaction.vibe === 'good') {\n        positiveVibeCount++;\n      }\n    }\n  });\n\n  // Find dominant interaction type\n  const dominantCategory = Object.entries(categoryCount)\n    .sort(([, a], [, b]) => b - a)[0];\n  const dominantType = dominantCategory ? dominantCategory[0] : null;\n  const dominantCount = dominantCategory ? dominantCategory[1] : 0;\n  const hasVariety = Object.keys(categoryCount).length >= 3;\n\n  // Calculate consistency (interactions spread over time vs bunched)\n  const daysSinceFirst = differenceInDays(new Date(), recentInteractions[recentInteractions.length - 1].interactionDate);\n  const isConsistent = daysSinceFirst >= 21 && recentCount >= 4; // 4+ weaves over 3+ weeks\n\n  // Quality indicator (if vibe data exists)\n  const hasHighQuality = totalWithVibe >= 2 && (positiveVibeCount / totalWithVibe) >= 0.75;\n\n  // Archetype-aligned insights\n  const archetypeInsights: Record<string, { types: string[], messages: string[] }> = {\n    Emperor: {\n      types: ['meal-drink', 'activity-hobby'],\n      messages: [\n        'Your structured time together is thriving',\n        'Consistent, purposeful connection',\n        'Building a strong routine together',\n      ]\n    },\n    Empress: {\n      types: ['meal-drink', 'favor-support'],\n      messages: [\n        'Nurturing this bond beautifully',\n        'Creating real comfort together',\n        'This warmth is mutual and strong',\n      ]\n    },\n    HighPriestess: {\n      types: ['deep-talk', 'text-call'],\n      messages: [\n        'Your deep conversations are flowing',\n        'Real vulnerability and trust here',\n        'Meaningful exchanges are frequent',\n      ]\n    },\n    Fool: {\n      types: ['activity-hobby', 'event-party'],\n      messages: [\n        'Adventures together are on fire',\n        'Keeping the spontaneity alive',\n        'Your playful energy is strong',\n      ]\n    },\n    Sun: {\n      types: ['event-party', 'celebration'],\n      messages: [\n        'Celebrating life together often',\n        'Your bright energy is consistent',\n        'Joyful moments are abundant',\n      ]\n    },\n    Hermit: {\n      types: ['deep-talk', 'hangout'],\n      messages: [\n        'Quality one-on-one time is rich',\n        'Thoughtful connection is consistent',\n        'Your quiet moments together matter',\n      ]\n    },\n    Magician: {\n      types: ['activity-hobby', 'hangout'],\n      messages: [\n        'Creating and building together',\n        'Collaborative energy is strong',\n        'Making magic through shared projects',\n      ]\n    },\n  };\n\n  // Priority 1: Archetype-aligned insights (if dominant type matches archetype affinity)\n  const archetypeData = archetypeInsights[friend.archetype];\n  if (archetypeData && dominantType && archetypeData.types.includes(dominantType) && dominantCount >= 2) {\n    const message = archetypeData.messages[Math.floor(Math.random() * archetypeData.messages.length)];\n    return { text: message, icon: '✨', variant: 'accent' };\n  }\n\n  // Priority 2: High-quality interactions\n  if (hasHighQuality) {\n    const qualityMessages = [\n      'Quality time together is exceptional',\n      'Really meaningful moments lately',\n      'Deep connection is thriving',\n    ];\n    return { text: qualityMessages[Math.floor(Math.random() * qualityMessages.length)], icon: '💫', variant: 'accent' };\n  }\n\n  // Priority 3: Consistency/streak insights\n  if (isConsistent) {\n    const consistencyMessages = [\n      `${recentCount} weaves in ${Math.floor(daysSinceFirst / 7)} weeks—solid rhythm`,\n      'Consistent connection over time',\n      'Building a reliable pattern together',\n    ];\n    return { text: consistencyMessages[Math.floor(Math.random() * consistencyMessages.length)], icon: '🌱', variant: 'success' };\n  }\n\n  // Priority 4: Interaction type patterns\n  if (dominantType && dominantCount >= 2) {\n    const typeInsights: Record<string, { messages: string[], icon: string }> = {\n      'deep-talk': {\n        messages: [\n          `${dominantCount} deep talks lately—real connection`,\n          'Vulnerability and openness are strong',\n        ],\n        icon: '💭'\n      },\n      'meal-drink': {\n        messages: [\n          `${dominantCount} meals together this month`,\n          'Your dining tradition is strong',\n        ],\n        icon: '🥂'\n      },\n      'activity-hobby': {\n        messages: [\n          `${dominantCount} activities together lately`,\n          'Shared interests are thriving',\n        ],\n        icon: '🏂'\n      },\n      'text-call': {\n        messages: [\n          `${dominantCount} calls/texts—staying close`,\n          'Regular check-ins are working',\n        ],\n        icon: '📱'\n      },\n      'hangout': {\n        messages: [\n          `${dominantCount} hangouts this month`,\n          'Just being together is enough',\n          'Just being together is enough',\n        ],\n        icon: '🛋️'\n      },\n      'event-party': {\n        messages: [\n          `${dominantCount} events together lately`,\n          'Social moments are abundant',\n        ],\n        icon: '🎉'\n      },\n    };\n\n    const insight = typeInsights[dominantType];\n    if (insight) {\n      return { text: insight.messages[Math.floor(Math.random() * insight.messages.length)], icon: insight.icon, variant: 'default' };\n    }\n  }\n\n  // Priority 5: Variety insight\n  if (hasVariety) {\n    return { text: `${recentCount} weaves across ${Object.keys(categoryCount).length} different types`, icon: '🎨', variant: 'default' };\n  }\n\n  // Fallback: Simple momentum message (but more varied)\n  const momentumMessages = [\n    `${recentCount} weaves this month—strong bond`,\n    `Maintaining momentum with ${recentCount} weaves`,\n    `${recentCount} quality moments together`,\n  ];\n  return { text: momentumMessages[Math.floor(Math.random() * momentumMessages.length)], icon: '🌟', variant: 'default' };\n}\n\n/**\n * PRIORITY 2: Connection health & history\n */\nasync function checkConnectionHealth(friend: HydratedFriend | Friend): Promise<StatusLine | null> {\n  const weaveScore = calculateCurrentScore(friend);\n\n  try {\n    // Get recent interactions (last 60 days, completed only)\n    const sixtyDaysAgo = Date.now() - 60 * 24 * 60 * 60 * 1000;\n    const recentInteractions = await database\n      .get<Interaction>('interactions')\n      .query(\n        Q.where('status', 'completed'),\n        Q.where('interaction_date', Q.gte(sixtyDaysAgo)),\n        Q.sortBy('interaction_date', Q.desc)\n      )\n      .fetch();\n\n    // Filter to interactions with this friend\n    const friendInteractions: Interaction[] = [];\n    for (const interaction of recentInteractions) {\n      const interactionFriends = await interaction.interactionFriends.fetch();\n      if (interactionFriends.some((jf: InteractionFriend) => jf.friendId === friend.id)) {\n        friendInteractions.push(interaction);\n      }\n    }\n\n    // Check for warming/momentum (3+ weaves in last 30 days)\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    const recentCount = friendInteractions.filter(\n      i => i.interactionDate.getTime() >= thirtyDaysAgo\n    ).length;\n\n    if (recentCount >= 3 && weaveScore > 65) {\n      // Generate varied, insightful status messages for healthy relationships\n      return generateHealthyRelationshipInsight(friend, friendInteractions.filter(\n        i => i.interactionDate.getTime() >= thirtyDaysAgo\n      ), recentCount);\n    }\n\n    // Check for cooling connection\n    if (friendInteractions.length > 0) {\n      const lastInteraction = friendInteractions[0];\n      const daysSince = differenceInDays(new Date(), lastInteraction.interactionDate);\n\n      // Find most recent meaningful interaction type\n      const lastMeaningfulType = lastInteraction.interactionCategory;\n\n      // For Inner Circle, flag after 2+ weeks\n      if (friend.dunbarTier === 'InnerCircle' && daysSince >= 14 && weaveScore < 65) {\n        const typeLabel = getCategoryLabel(lastMeaningfulType);\n        if (daysSince === 14) {\n          return { text: `Last ${typeLabel}: 2 weeks ago`, variant: 'default' };\n        } else if (daysSince === 21) {\n          return { text: `Last ${typeLabel}: 3 weeks ago`, variant: 'default' };\n        } else if (daysSince >= 28) {\n          const weeks = Math.floor(daysSince / 7);\n          return { text: `Last ${typeLabel}: ${weeks} weeks ago`, variant: 'default' };\n        }\n      }\n\n      // For Close Friends, flag after 3+ weeks\n      if (friend.dunbarTier === 'CloseFriends' && daysSince >= 21 && weaveScore < 65) {\n        const typeLabel = getCategoryLabel(lastMeaningfulType);\n        const weeks = Math.floor(daysSince / 7);\n        return { text: `Last ${typeLabel}: ${weeks} weeks ago`, variant: 'default' };\n      }\n    }\n  } catch (error) {\n    console.error('Error checking connection health:', error);\n  }\n\n  return null;\n}\n\n/**\n * PRIORITY 3: Upcoming plans\n */\nasync function checkUpcomingPlans(friend: HydratedFriend | Friend): Promise<StatusLine | null> {\n  try {\n    const today = startOfDay(new Date());\n\n    const futureInteractions = await database\n      .get<Interaction>('interactions')\n      .query(\n        Q.where('status', 'planned'),\n        Q.where('interaction_date', Q.gte(today.getTime())),\n        Q.sortBy('interaction_date', Q.asc)\n      )\n      .fetch();\n\n    // Find the nearest upcoming interaction with this friend\n    for (const interaction of futureInteractions) {\n      const interactionFriends = await interaction.interactionFriends.fetch();\n      if (interactionFriends.some((jf: InteractionFriend) => jf.friendId === friend.id)) {\n        // Use startOfDay on both dates for accurate calendar-day comparison\n        const daysUntil = differenceInDays(startOfDay(interaction.interactionDate), today);\n        const categoryLabel = getCategoryLabel(interaction.interactionCategory);\n\n        if (daysUntil === 0) {\n          return { text: `${capitalize(categoryLabel)} planned for today!`, icon: '🗓️', variant: 'accent' };\n        } else if (daysUntil === 1) {\n          return { text: `${capitalize(categoryLabel)} planned for tomorrow`, icon: '🗓️', variant: 'accent' };\n        } else if (daysUntil <= 7) {\n          const dayName = format(interaction.interactionDate, 'EEEE');\n          return { text: `${capitalize(categoryLabel)} planned for ${dayName}`, icon: '🗓️', variant: 'default' };\n        } else if (daysUntil <= 30) {\n          return { text: `${capitalize(categoryLabel)} planned in ${daysUntil} days`, icon: '🗓️', variant: 'default' };\n        }\n        // If plan is >30 days away, don't show it (falls through to archetype nudge)\n      }\n    }\n  } catch (error) {\n    console.error('Error checking upcoming plans:', error);\n  }\n\n  return null;\n}\n\n/**\n * Helper: Get friendly category label\n */\nfunction getCategoryLabel(category: string | null | undefined): string {\n  const labels: Record<string, string> = {\n    'text-call': 'chat',\n    'meal-drink': 'meal',\n    'hangout': 'hangout',\n    'deep-talk': 'deep talk',\n    'activity-hobby': 'activity',\n    'event-party': 'event',\n    'favor-support': 'time together',\n    'celebration': 'celebration',\n  };\n  return labels[category || ''] || 'catch-up';\n}\n\n/**\n * Helper: Capitalize first letter\n */\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Main function: Generate intelligent status line for a friend\n * Follows priority order:\n * 1. Life events\n * 2. Connection health\n * 3. Upcoming plans\n * 4. Archetype nudge (fallback)\n */\nexport async function generateIntelligentStatusLine(friend: HydratedFriend | Friend): Promise<StatusLine> {\n  // Priority 1: Life events\n  const lifeEventStatus = await checkLifeEventStatus(friend);\n  if (lifeEventStatus) return lifeEventStatus;\n\n  // Priority 2: Connection health\n  const healthStatus = await checkConnectionHealth(friend);\n  if (healthStatus) return healthStatus;\n\n  // Priority 3: Upcoming plans\n  const planStatus = await checkUpcomingPlans(friend);\n  if (planStatus) return planStatus;\n\n  // Priority 4: Archetype-driven nudge (fallback)\n  return {\n    text: getRandomNudge(friend.archetype),\n    icon: undefined,\n    variant: 'default',\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/momentum.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/orchestrator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/quality.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/resilience.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/scoring.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/season-aware-streak.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'todayTimestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":43,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Season-Aware Streak System\n *\n * Compassionate streak tracking that respects the user's current social season:\n * - Resting (🌙): Hides all streak metrics\n * - Balanced (💧): Shows calm, encouraging messaging\n * - Blooming (🌱): Shows celebratory messaging\n *\n * Features:\n * - Streaks count: weaves, battery check-ins, and journal entries\n * - Forgiveness mechanic: \"released\" language instead of \"broken\"\n * - Clean slate when leaving resting season\n */\n\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport { differenceInDays, startOfDay } from 'date-fns';\nimport Interaction from '@/db/models/Interaction';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport UserProfile from '@/db/models/UserProfile';\nimport UserProgress from '@/db/models/UserProgress';\nimport { type SocialSeason } from '@/db/models/UserProfile';\n\nexport interface StreakData {\n  currentStreak: number;\n  longestStreakEver: number;\n  lastStreakCount: number;\n  streakReleasedDate: Date | null;\n  isVisible: boolean; // Based on season\n  message: string;\n  emoji: string;\n  color: string; // For visual treatment\n}\n\n/**\n * Calculate current streak including all activity types\n */\nexport async function calculateCurrentStreak(\n  profile: UserProfile | null\n): Promise<number> {\n  try {\n    const today = startOfDay(new Date());\n    const todayTimestamp = today.getTime();\n\n    // Get all completed interactions\n    const interactions = await database\n      .get<Interaction>('interactions')\n      .query(Q.where('status', 'completed'), Q.sortBy('interaction_date', Q.desc))\n      .fetch();\n\n    // Get battery check-ins\n    const batteryHistory = profile?.socialBatteryHistory || [];\n\n    // Get journal entries\n    const journals = await database\n      .get<WeeklyReflection>('weekly_reflections')\n      .query(Q.sortBy('created_at', Q.desc))\n      .fetch();\n\n    // Build a set of unique activity dates\n    const activityDates = new Set<string>();\n\n    // Add interaction dates\n    interactions.forEach(interaction => {\n      const date = startOfDay(interaction.interactionDate);\n      const dateKey = date.toISOString();\n      activityDates.add(dateKey);\n    });\n\n    // Add battery check-in dates\n    batteryHistory.forEach(entry => {\n      const date = startOfDay(new Date(entry.timestamp));\n      const dateKey = date.toISOString();\n      activityDates.add(dateKey);\n    });\n\n    // Add journal entry dates\n    journals.forEach(journal => {\n      const date = startOfDay(journal.createdAt);\n      const dateKey = date.toISOString();\n      activityDates.add(dateKey);\n    });\n\n    // Convert to sorted array\n    const sortedDates = Array.from(activityDates)\n      .map(d => new Date(d))\n      .sort((a, b) => b.getTime() - a.getTime()); // Most recent first\n\n    if (sortedDates.length === 0) return 0;\n\n    // Calculate consecutive days from today backwards\n    let streak = 0;\n    let checkDate = today;\n\n    for (const activityDate of sortedDates) {\n      const daysDiff = differenceInDays(checkDate, activityDate);\n\n      if (daysDiff === 0) {\n        // Activity on this day\n        streak++;\n        // Move to previous day\n        checkDate = new Date(checkDate);\n        checkDate.setDate(checkDate.getDate() - 1);\n      } else if (daysDiff === 1) {\n        // Gap of exactly 1 day - streak continues\n        streak++;\n        checkDate = new Date(checkDate);\n        checkDate.setDate(checkDate.getDate() - 1);\n      } else {\n        // Gap too large - streak broken\n        break;\n      }\n    }\n\n    return streak;\n  } catch (error) {\n    console.error('Error calculating streak:', error);\n    return 0;\n  }\n}\n\n/**\n * Get season-aware streak data\n */\nexport async function getSeasonAwareStreakData(\n  profile: UserProfile | null,\n  userProgress: UserProgress | null\n): Promise<StreakData> {\n  const currentStreak = await calculateCurrentStreak(profile);\n  const season = profile?.currentSocialSeason || 'balanced';\n\n  // Resting season: hide completely\n  if (season === 'resting') {\n    return {\n      currentStreak,\n      longestStreakEver: userProgress?.longestStreakEver || 0,\n      lastStreakCount: userProgress?.lastStreakCount || 0,\n      streakReleasedDate: userProgress?.streakReleasedDate || null,\n      isVisible: false,\n      message: '',\n      emoji: '',\n      color: '',\n    };\n  }\n\n  // Balanced season: calm messaging\n  if (season === 'balanced') {\n    const message = getBalancedMessage(currentStreak);\n    return {\n      currentStreak,\n      longestStreakEver: userProgress?.longestStreakEver || 0,\n      lastStreakCount: userProgress?.lastStreakCount || 0,\n      streakReleasedDate: userProgress?.streakReleasedDate || null,\n      isVisible: true,\n      message,\n      emoji: '💙',\n      color: '#7DD3FC', // Softer sky blue\n    };\n  }\n\n  // Blooming season: celebratory messaging\n  const message = getBloomingMessage(currentStreak);\n  return {\n    currentStreak,\n    longestStreakEver: userProgress?.longestStreakEver || 0,\n    lastStreakCount: userProgress?.lastStreakCount || 0,\n    streakReleasedDate: userProgress?.streakReleasedDate || null,\n    isVisible: true,\n    message,\n    emoji: '💚✨',\n    color: '#34D399', // Emerald green\n  };\n}\n\n/**\n * Balanced season messaging (calm, encouraging)\n */\nfunction getBalancedMessage(streak: number): string {\n  if (streak === 0) return '';\n  if (streak === 1) return \"You're showing up today. Beautiful.\";\n  if (streak < 7) return `${streak}-day practice streak. You're in a beautiful flow.`;\n  if (streak < 14) return `${streak} days of consistency. This is meaningful.`;\n  if (streak < 30) return `${streak}-day practice streak. You're nurturing your connections beautifully.`;\n  if (streak < 60) return `${streak} days strong. This rhythm is serving you.`;\n  return `${streak}-day practice streak. You've built something remarkable.`;\n}\n\n/**\n * Blooming season messaging (celebratory)\n */\nfunction getBloomingMessage(streak: number): string {\n  if (streak === 0) return '';\n  if (streak === 1) return \"You're radiating connection today!\";\n  if (streak < 7) return `${streak}-day streak! Your connections are thriving.`;\n  if (streak < 14) return `${streak}-day streak! You're a Connection Cultivator 🌱`;\n  if (streak < 30) return `${streak}-day streak! You're a Thread Weaver 🏆`;\n  if (streak < 60) return `${streak}-day streak! You're a Relationship Architect ✨`;\n  return `${streak}-day streak! You're a Thread Master 🏆`;\n}\n\n/**\n * Get forgiveness message when streak is broken\n */\nexport function getForgivenessMessage(lastStreakCount: number): string {\n  if (lastStreakCount === 0) return '';\n  if (lastStreakCount === 1) return 'You took a pause. That\\'s okay—rhythms change.';\n  if (lastStreakCount < 7) return `You released your ${lastStreakCount}-day streak. Some seasons need different rhythms. You can always begin a new one when you're ready.`;\n  if (lastStreakCount < 30) return `You released your ${lastStreakCount}-day streak. Rest is part of the rhythm. Your weave remains strong.`;\n  return `You released your ${lastStreakCount}-day streak. What a beautiful practice that was. When you're ready, you can begin again.`;\n}\n\n/**\n * Update streak when activity happens\n * Handles forgiveness mechanics and longest streak tracking\n */\nexport async function updateStreakAfterActivity(): Promise<void> {\n  try {\n    const profile = await database.get<UserProfile>('user_profile').query().fetch().then(p => p[0]);\n    const userProgress = await database.get<UserProgress>('user_progress').query().fetch().then(p => p[0]);\n\n    if (!userProgress) return;\n\n    const currentStreak = await calculateCurrentStreak(profile);\n    const previousStreak = userProgress.currentStreak;\n\n    await database.write(async () => {\n      await userProgress.update(progress => {\n        // Streak is continuing or starting\n        progress.currentStreak = currentStreak;\n\n        // Update longest streak ever if needed (check if property exists for older DBs)\n        if ('longestStreakEver' in progress) {\n          if (currentStreak > (progress.longestStreakEver || 0)) {\n            progress.longestStreakEver = currentStreak;\n          }\n        }\n\n        // Update best streak (legacy field)\n        if (currentStreak > progress.bestStreak) {\n          progress.bestStreak = currentStreak;\n        }\n\n        // If streak broke (and it was non-zero), store forgiveness data (check if property exists for older DBs)\n        if (previousStreak > 0 && currentStreak === 0) {\n          if ('lastStreakCount' in progress) {\n            progress.lastStreakCount = previousStreak;\n          }\n          if ('streakReleasedDate' in progress) {\n            progress.streakReleasedDate = new Date();\n          }\n        }\n\n        progress.lastPracticeDate = new Date();\n      });\n    });\n  } catch (error) {\n    console.error('Error updating streak:', error);\n  }\n}\n\n/**\n * Check if we should show forgiveness message\n * Only show for 7 days after streak was released\n */\nexport function shouldShowForgivenessMessage(\n  streakData: StreakData,\n  season: SocialSeason\n): boolean {\n  if (season === 'resting') return false; // Never show in resting\n  if (!streakData.streakReleasedDate) return false;\n  if (streakData.currentStreak > 0) return false; // Already back on track\n  if (streakData.lastStreakCount === 0) return false;\n\n  const daysSinceRelease = differenceInDays(new Date(), streakData.streakReleasedDate);\n  return daysSinceRelease <= 7; // Show for one week\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-analytics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-calculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-content.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-decay.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-manager.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'calculateSocialSeason' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport UserProfile from '@/db/models/UserProfile';\nimport { calculateSocialSeason } from './season-calculator';\n// We might need to trigger a full recalculation which depends on stats.\n// A simpler approach is to just clear the override and let the widget/app flow handle recalculation on next load, \n// OR we can explicitly call the update store action if available, but we are in a service layer here.\n\nexport const SeasonManager = {\n    /**\n     * Checks if the active season override has expired.\n     * If expired, it clears the override fields in the database.\n     * Returns true if an override was cleared, false otherwise.\n     */\n    checkSeasonOverrideExpiry: async (): Promise<boolean> => {\n        try {\n            const profiles = await database.get<UserProfile>('user_profile').query().fetch();\n            const profile = profiles[0];\n\n            if (!profile) return false;\n            if (!profile.seasonOverrideUntil) return false;\n\n            const now = Date.now();\n            if (profile.seasonOverrideUntil <= now) {\n                // Override expired\n                await database.write(async () => {\n                    await profile.update(p => {\n                        p.seasonOverrideUntil = undefined;\n                        p.seasonOverrideReason = undefined;\n                        // We reset seasonLastCalculated to 0 to force a strict recalculation next time the widget loads\n                        p.seasonLastCalculated = 0;\n                    });\n                });\n                return true;\n            }\n\n            return false;\n        } catch (error) {\n            console.error('[SeasonManager] Error checking override expiry:', error);\n            return false;\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-scoring.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-suggestions.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/social-season/season-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/services/status-line-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/intelligence/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/PlanWizard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BlurView' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isSaturday' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'nextSaturday' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":68,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport { View, Text, TouchableOpacity, Modal, ScrollView, SafeAreaView } from 'react-native';\nimport Animated, { SlideInLeft, SlideInRight, SlideOutLeft, SlideOutRight } from 'react-native-reanimated';\nimport { BlurView } from 'expo-blur';\nimport { X, ArrowLeft } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport FriendModel from '@/db/models/Friend';\nimport { InteractionCategory } from '@/shared/types/common';\nimport { usePlanSuggestion } from '../hooks/usePlanSuggestion';\nimport { PlanWizardStep1 } from './plan-wizard/PlanWizardStep1';\nimport { PlanWizardStep2 } from './plan-wizard/PlanWizardStep2';\nimport { PlanWizardStep3 } from './plan-wizard/PlanWizardStep3';\nimport { usePlans } from '../hooks/usePlans';\nimport * as CalendarService from '../services/calendar.service';\nimport { getCategoryMetadata } from '@/shared/constants/interaction-categories';\nimport { getDefaultTimeForCategory, calculateActivityPriorities, isSmartDefaultsEnabled } from '../services/smart-defaults.service';\nimport { database } from '@/db';\nimport Interaction from '@/db/models/Interaction';\nimport { startOfDay, addDays, isSaturday, nextSaturday, getDay } from 'date-fns';\nimport { Q } from '@nozbe/watermelondb';\nimport { InitiatorType } from '@/components/ReciprocitySelector';\nimport { useDebounceCallback } from '@/shared/hooks/useDebounceCallback';\n\nconst CATEGORIES: Array<{\n  value: InteractionCategory;\n  label: string;\n  icon: string;\n  description: string;\n}> = [\n    { value: 'text-call', label: 'Chat', icon: '💬', description: 'Call or video chat' },\n    { value: 'meal-drink', label: 'Meal', icon: '🍽️', description: 'Coffee, lunch, or dinner' },\n    { value: 'hangout', label: 'Hangout', icon: '👥', description: 'Casual time together' },\n    { value: 'deep-talk', label: 'Deep Talk', icon: '💭', description: 'Meaningful conversation' },\n    { value: 'activity-hobby', label: 'Activity', icon: '🚶', description: 'Sport, hobby, or adventure' },\n    { value: 'event-party', label: 'Event', icon: '🎉', description: 'Party or social gathering' },\n    { value: 'favor-support', label: 'Support', icon: '🤝', description: 'Help or emotional support' },\n    { value: 'celebration', label: 'Celebration', icon: '🎊', description: 'Special occasion' },\n  ];\n\ninterface PlanWizardProps {\n  visible: boolean;\n  onClose: () => void;\n  initialFriend: FriendModel; // The friend from whose profile the wizard was opened\n  // Optional prefill from suggestions or reschedule\n  prefillData?: {\n    date?: Date;\n    category?: InteractionCategory;\n    title?: string;\n    location?: string;\n  };\n  // Optional: ID of existing interaction to replace (for reschedule)\n  replaceInteractionId?: string;\n  // Optional: Starting step (1-3), defaults to 1\n  initialStep?: number;\n}\n\nexport interface PlanFormData {\n  date: Date;\n  category: InteractionCategory;\n  title?: string;\n  location?: string;\n  time?: Date; // Optional time of day\n  notes?: string;\n  initiator?: InitiatorType;\n}\n\nexport function PlanWizard({ visible, onClose, initialFriend, prefillData, replaceInteractionId, initialStep = 1 }: PlanWizardProps) {\n  const { colors, isDarkMode } = useTheme();\n  const { planWeave, deleteWeave } = usePlans();\n  const suggestion = usePlanSuggestion(initialFriend);\n\n  const [currentStep, setCurrentStep] = useState(initialStep); // Start from initialStep\n  const [direction, setDirection] = useState<'forward' | 'backward'>('forward');\n  const [selectedFriends, setSelectedFriends] = useState<FriendModel[]>([initialFriend]); // Manage internally\n  const [formData, setFormData] = useState<Partial<PlanFormData>>({\n    date: prefillData?.date,\n    category: prefillData?.category || suggestion?.suggestedCategory,\n    title: prefillData?.title,\n    location: prefillData?.location,\n  });\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Lifted state for performance\n  const [plannedDates, setPlannedDates] = useState<Date[]>([]);\n  const [mostCommonDay, setMostCommonDay] = useState<{ day: number; name: string; date: Date } | null>(null);\n  const [orderedCategories, setOrderedCategories] = useState(CATEGORIES);\n\n  // Fetch all data once on mount\n  useEffect(() => {\n    const loadData = async () => {\n      const today = startOfDay(new Date());\n      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\n      try {\n        // 1. Fetch Planned Dates (Safe 2-step query)\n        // Step A: Get all interaction IDs for this friend\n        const interactionLinks = await database\n          .get('interaction_friends')\n          .query(Q.where('friend_id', initialFriend.id))\n          .fetch();\n\n        const interactionIds = interactionLinks.map((link: any) => link.interactionId);\n\n        // Step B: Fetch the actual interactions if we have any links\n        let plannedInteractions: Interaction[] = [];\n        if (interactionIds.length > 0) {\n          plannedInteractions = await database\n            .get<Interaction>('interactions')\n            .query(\n              Q.where('id', Q.oneOf(interactionIds)),\n              Q.where('status', 'planned'),\n              Q.where('interaction_date', Q.gte(today.getTime()))\n            )\n            .fetch();\n        }\n\n        setPlannedDates(plannedInteractions.map(i => startOfDay(i.interactionDate)));\n\n        // 2. Calculate Most Common Day (Safe 2-step query)\n        let completedInteractions: Interaction[] = [];\n        if (interactionIds.length > 0) {\n          completedInteractions = await database\n            .get<Interaction>('interactions')\n            .query(\n              Q.where('id', Q.oneOf(interactionIds)),\n              Q.where('status', 'completed')\n            )\n            .fetch();\n        }\n\n        if (completedInteractions.length > 0) {\n          const dayCounts: Record<number, number> = {};\n          completedInteractions.forEach(interaction => {\n            const dayOfWeek = getDay(interaction.interactionDate);\n            dayCounts[dayOfWeek] = (dayCounts[dayOfWeek] || 0) + 1;\n          });\n\n          let maxCount = 0;\n          let commonDay = 0;\n          Object.entries(dayCounts).forEach(([day, count]) => {\n            if (count > maxCount) {\n              maxCount = count;\n              commonDay = parseInt(day);\n            }\n          });\n\n          const currentDay = getDay(today);\n          let nextOccurrence: Date;\n          if (commonDay === currentDay) {\n            nextOccurrence = today;\n          } else if (commonDay > currentDay) {\n            nextOccurrence = addDays(today, commonDay - currentDay);\n          } else {\n            nextOccurrence = addDays(today, 7 - currentDay + commonDay);\n          }\n\n          setMostCommonDay({\n            day: commonDay,\n            name: dayNames[commonDay],\n            date: nextOccurrence,\n          });\n        }\n\n        // 3. Calculate Category Priorities\n        const smartDefaultsEnabled = await isSmartDefaultsEnabled();\n        if (smartDefaultsEnabled) {\n          const priorities = await calculateActivityPriorities(initialFriend);\n          const scoreMap = new Map(priorities.map(p => [p.category, p.score]));\n          const sorted = [...CATEGORIES].sort((a, b) => {\n            const scoreA = scoreMap.get(a.value) || 0;\n            const scoreB = scoreMap.get(b.value) || 0;\n            return scoreB - scoreA;\n          });\n          setOrderedCategories(sorted);\n        }\n      } catch (error) {\n        console.error('Error loading plan wizard data:', error);\n      }\n    };\n\n    loadData();\n  }, [initialFriend.id]);\n\n  // Track whether we've transitioned between steps (vs initial render)\n  const hasTransitioned = useRef(false);\n\n  const updateFormData = (updates: Partial<PlanFormData>) => {\n    setFormData(prev => ({ ...prev, ...updates }));\n  };\n\n  // Handler for category selection with smart time defaults\n  const handleCategorySelect = (category: InteractionCategory) => {\n    // Apply smart default time when category is selected\n    const planDate = formData.date || new Date();\n    const defaultTime = getDefaultTimeForCategory(category, planDate);\n\n    updateFormData({\n      category,\n      time: defaultTime, // Set smart default time\n    });\n  };\n\n  // Reset to initialStep when modal opens or initialStep changes\n  useEffect(() => {\n    if (visible) {\n      setCurrentStep(initialStep);\n      hasTransitioned.current = false; // Reset on modal open\n    }\n  }, [visible, initialStep]);\n\n  const goToNextStep = () => {\n    if (currentStep < 3) { // Max step is 3\n      setDirection('forward');\n      hasTransitioned.current = true; // Mark that we've transitioned\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const goToPreviousStep = () => {\n    if (currentStep > 1) { // Min step is 1\n      setDirection('backward');\n      hasTransitioned.current = true; // Mark that we've transitioned\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const handleClose = () => {\n    // Reset state\n    setCurrentStep(initialStep);\n    setSelectedFriends([initialFriend]); // Reset selected friends\n    setFormData({});\n    onClose();\n  };\n\n  const handleSubmit = useDebounceCallback(async () => {\n    if (!formData.date || !formData.category) {\n      console.error('Missing required fields');\n      return;\n    }\n\n    setIsSubmitting(true);\n    try {\n      // If rescheduling, delete the old plan first\n      if (replaceInteractionId) {\n        await deleteWeave(replaceInteractionId);\n      }\n\n      // Merge date and time if time is set\n      let finalDate = formData.date;\n      if (formData.time) {\n        finalDate = new Date(formData.date);\n        finalDate.setHours(\n          formData.time.getHours(),\n          formData.time.getMinutes(),\n          0,\n          0\n        );\n      }\n\n      // Create the interaction\n      const newPlan = await planWeave({\n        friendIds: selectedFriends.map(f => f.id),\n        activity: formData.category,\n        category: formData.category,\n        notes: formData.notes,\n        date: finalDate,\n        type: 'plan',\n        status: 'planned',\n        mode: selectedFriends.length > 1 ? 'group' : 'one-on-one',\n        // Include title and location\n        title: formData.title?.trim() || undefined,\n        location: formData.location?.trim() || undefined,\n        initiator: formData.initiator,\n      });\n\n      // Try to create calendar event if settings enabled\n      try {\n        const settings = await CalendarService.getCalendarSettings();\n        if (settings.enabled) {\n          const categoryMeta = getCategoryMetadata(formData.category);\n          const friendNames = selectedFriends.map(f => f.name).join(', ');\n          const eventTitle = formData.title?.trim() || `${categoryMeta?.label || formData.category} with ${friendNames}`;\n\n          const calendarEventId = await CalendarService.createWeaveCalendarEvent({\n            title: eventTitle,\n            friendNames: friendNames, // Pass all friend names\n            category: categoryMeta?.label || formData.category,\n            date: finalDate, // Use the merged date with time\n            location: formData.location?.trim(),\n            notes: formData.notes?.trim(),\n          });\n\n          // If calendar event created successfully, update the interaction with the event ID\n          if (calendarEventId && newPlan.id) {\n            await database.write(async () => {\n              const interaction = await database.get<Interaction>('interactions').find(newPlan.id);\n              await interaction.update(i => {\n                i.calendarEventId = calendarEventId;\n              });\n            });\n          }\n        }\n      } catch (calendarError) {\n        // Don't fail the plan creation if calendar sync fails\n        console.warn('Calendar event creation failed:', calendarError);\n      }\n\n      handleClose();\n    } catch (error) {\n      console.error('Error creating plan:', error);\n    } finally {\n      setIsSubmitting(false);\n    }\n  });\n\n  const canProceedFromStep1 = !!formData.date;\n  const canProceedFromStep2 = !!formData.category;\n\n  return (\n    <Modal visible={visible} animationType=\"slide\" presentationStyle=\"pageSheet\" onRequestClose={handleClose}>\n      <SafeAreaView className=\"flex-1\" style={{ backgroundColor: colors.background }}>\n        {/* Header */}\n        <View\n          className=\"flex-row items-center justify-between px-5 py-4 border-b\"\n          style={{ borderColor: colors.border }}\n        >\n          {currentStep > 1 ? (\n            <TouchableOpacity onPress={goToPreviousStep} className=\"p-2\">\n              <ArrowLeft size={20} color={colors.foreground} />\n            </TouchableOpacity>\n          ) : (\n            <TouchableOpacity onPress={handleClose} className=\"p-2\">\n              <X size={20} color={colors.foreground} />\n            </TouchableOpacity>\n          )}\n\n          <View className=\"flex-1 items-center\">\n            <Text className=\"font-lora-bold text-lg\" style={{ color: colors.foreground }}>\n              Schedule with {selectedFriends.map(f => f.name).join(', ')}\n            </Text>\n            <Text className=\"font-inter-regular text-sm mt-1\" style={{ color: colors['muted-foreground'] }}>\n              Step {currentStep} of 3\n            </Text>\n          </View>\n\n          <View style={{ width: 40 }} />\n        </View>\n\n        {/* Progress indicator */}\n        <View className=\"flex-row px-5 py-3\">\n          {[1, 2, 3].map(step => (\n            <View\n              key={step}\n              className=\"flex-1 h-1 rounded mx-1\"\n              style={{\n                backgroundColor: step <= currentStep ? colors.primary : colors.muted,\n              }}\n            />\n          ))}\n        </View>\n\n        {/* Step content with animations */}\n        <ScrollView className=\"flex-1\" contentContainerStyle={{ paddingBottom: 20 }}>\n          {currentStep === 1 && (\n            <Animated.View\n              key=\"step1\"\n              entering={hasTransitioned.current ? (direction === 'forward' ? SlideInRight.duration(300) : SlideInLeft.duration(300)) : undefined}\n              exiting={direction === 'forward' ? SlideOutLeft.duration(300) : SlideOutRight.duration(300)}\n            >\n              <PlanWizardStep1\n                selectedDate={formData.date}\n                onDateSelect={date => updateFormData({ date })}\n                onContinue={goToNextStep}\n                canContinue={canProceedFromStep1}\n                friend={initialFriend}\n                plannedDates={plannedDates}\n                mostCommonDay={mostCommonDay}\n              />\n            </Animated.View>\n          )}\n\n          {currentStep === 2 && (\n            <Animated.View\n              key=\"step2\"\n              entering={hasTransitioned.current ? (direction === 'forward' ? SlideInRight.duration(300) : SlideInLeft.duration(300)) : undefined}\n              exiting={direction === 'forward' ? SlideOutLeft.duration(300) : SlideOutRight.duration(300)}\n            >\n              <PlanWizardStep2\n                selectedCategory={formData.category}\n                onCategorySelect={handleCategorySelect}\n                onContinue={goToNextStep}\n                canContinue={canProceedFromStep2}\n                friend={initialFriend}\n                suggestion={suggestion}\n                orderedCategories={orderedCategories}\n              />\n            </Animated.View>\n          )}\n\n          {currentStep === 3 && (\n            <Animated.View\n              key=\"step3\"\n              entering={hasTransitioned.current ? (direction === 'forward' ? SlideInRight.duration(300) : SlideInLeft.duration(300)) : undefined}\n              exiting={direction === 'forward' ? SlideOutLeft.duration(300) : SlideOutRight.duration(300)}\n            >\n              <PlanWizardStep3\n                formData={formData}\n                onUpdate={updateFormData}\n                onSubmit={handleSubmit}\n                isSubmitting={isSubmitting}\n                friend={initialFriend}\n                suggestion={suggestion}\n                selectedFriends={selectedFriends}\n                onFriendsSelect={setSelectedFriends}\n              />\n            </Animated.View>\n          )}\n        </ScrollView>\n      </SafeAreaView>\n    </Modal>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/PostWeaveRatingModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setSkippedIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":26,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":37},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":73,"column":17,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":73,"endColumn":30,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[3203,3216],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport { useDebounceCallback } from '@/shared/hooks/useDebounceCallback';\nimport { View, Text, StyleSheet, TouchableOpacity, TextInput, ScrollView, Keyboard } from 'react-native';\nimport * as Haptics from 'expo-haptics';\nimport { usePlans } from '../hooks/usePlans';\nimport { useInteractions } from '../hooks/useInteractions';\nimport { useUIStore } from '@/stores/uiStore';\nimport { MoonPhaseSelector } from '@/components/MoonPhaseSelector';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { Vibe } from '@/shared/types/common';\nimport { Check } from 'lucide-react-native';\nimport { format } from 'date-fns';\nimport { AnimatedBottomSheet } from '@/shared/ui/Sheet';\nimport { SeasonAnalyticsService } from '@/modules/intelligence';\n\nexport function PostWeaveRatingModal() {\n    const { colors } = useTheme();\n    const { isPostWeaveRatingOpen, postWeaveRatingTargetId, closePostWeaveRating, showToast } = useUIStore();\n    const { pendingConfirmations, completePlan, cancelPlan } = usePlans();\n    const { allInteractions } = useInteractions();\n    const [currentPlanId, setCurrentPlanId] = useState<string | null>(null);\n\n    // Local state for the form\n    const [selectedVibe, setSelectedVibe] = useState<Vibe | null>(null);\n    const [notes, setNotes] = useState('');\n    const [skippedIds, setSkippedIds] = useState<Set<string>>(new Set());\n    const [completedIds, setCompletedIds] = useState<Set<string>>(new Set());\n    const [friendNames, setFriendNames] = useState<string>('');\n    const [isSubmitting, setIsSubmitting] = useState(false);\n\n    // Track pending action for close animation\n    const pendingActionRef = useRef<'confirm' | 'didnt-happen' | 'skip' | null>(null);\n    const pendingDataRef = useRef<{ vibe?: Vibe; note?: string } | null>(null);\n\n    // Effect to update current plan when new ones arrive OR target changes\n    useEffect(() => {\n        if (postWeaveRatingTargetId) {\n            setCurrentPlanId(postWeaveRatingTargetId);\n            setSelectedVibe(null);\n            setNotes('');\n            return;\n        }\n\n        const nextPlan = pendingConfirmations.find(p => !skippedIds.has(p.id) && !completedIds.has(p.id));\n\n        if (nextPlan && currentPlanId !== nextPlan.id) {\n            setCurrentPlanId(nextPlan.id);\n            setSelectedVibe(null);\n            setNotes('');\n        } else if (!nextPlan && currentPlanId) {\n            const isCurrentValid = pendingConfirmations.some(p => p.id === currentPlanId)\n                && !skippedIds.has(currentPlanId)\n                && !completedIds.has(currentPlanId);\n\n            if (!isCurrentValid) {\n                setCurrentPlanId(null);\n            }\n        }\n    }, [pendingConfirmations, skippedIds, completedIds, currentPlanId, postWeaveRatingTargetId]);\n\n    // Effect to fetch friend names\n    useEffect(() => {\n        if (!isPostWeaveRatingOpen || !currentPlanId) {\n            setFriendNames('');\n            return;\n        }\n\n        const currentPlan = pendingConfirmations.find(p => p.id === currentPlanId);\n        if (!currentPlan) return;\n\n        const fetchFriends = async () => {\n            try {\n                // @ts-ignore\n                const friends = await currentPlan.interactionFriends.fetch();\n                if (friends.length > 0) {\n                    const names = friends.map((f: any) => f.name).join(', ');\n                    const truncated = names.length > 30 ? names.substring(0, 30) + '...' : names;\n                    setFriendNames(truncated);\n                } else {\n                    setFriendNames('');\n                }\n            } catch (error) {\n                console.error('Error fetching friends for rating modal:', error);\n                setFriendNames('');\n            }\n        };\n\n        fetchFriends();\n    }, [currentPlanId, pendingConfirmations, isPostWeaveRatingOpen]);\n\n    const currentPlan = currentPlanId\n        ? (pendingConfirmations.find(p => p.id === currentPlanId) || allInteractions.find(p => p.id === currentPlanId))\n        : null;\n\n    const handleConfirm = useDebounceCallback(async () => {\n        if (!currentPlanId || isSubmitting) return;\n\n        Keyboard.dismiss();\n\n        // ANALYTICS: Track rating (if vibe selected)\n        if (selectedVibe) {\n            // Map Moon Phases to Score (1-5)\n            const vibeScores: Record<string, number> = {\n                'FullMoon': 5,\n                'WaxingGibbous': 4,\n                'WaningGibbous': 4,\n                'FirstQuarter': 3,\n                'LastQuarter': 3,\n                'WaxingCrescent': 2,\n                'WaningCrescent': 2,\n                'NewMoon': 1\n            };\n            const rating = vibeScores[selectedVibe as string] || 3;\n            SeasonAnalyticsService.trackInteractionRating(rating).catch(console.error);\n        }\n\n        pendingActionRef.current = 'confirm';\n        pendingDataRef.current = { vibe: selectedVibe || undefined, note: notes };\n        closePostWeaveRating();\n    });\n\n    const handleDidntHappen = useDebounceCallback(async () => {\n        if (!currentPlanId || isSubmitting) return;\n\n        Keyboard.dismiss();\n        pendingActionRef.current = 'didnt-happen';\n        closePostWeaveRating();\n    });\n\n    const handleSkip = () => {\n        Keyboard.dismiss();\n        pendingActionRef.current = 'skip';\n        closePostWeaveRating();\n    };\n\n    const handleCloseComplete = async () => {\n        const planId = currentPlanId;\n        const action = pendingActionRef.current;\n        const data = pendingDataRef.current;\n\n        // Reset refs\n        pendingActionRef.current = null;\n        pendingDataRef.current = null;\n\n        if (!planId) return;\n\n        if (action === 'confirm' && data) {\n            setIsSubmitting(true);\n            try {\n                console.log('[PostWeaveRatingModal] Completing plan:', planId, data);\n                await completePlan(planId, {\n                    vibe: data.vibe || undefined,\n                    note: data.note\n                });\n                console.log('[PostWeaveRatingModal] Plan completed successfully');\n                setCompletedIds(prev => new Set(prev).add(planId));\n\n                // Provide success feedback\n                Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n                showToast(\"Weave completed\", friendNames || 'Friend');\n            } catch (e) {\n                console.error(\"[PostWeaveRatingModal] Failed to complete plan\", e);\n                // Provide error feedback\n                Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n                showToast(\"Failed to complete weave\", friendNames || 'Friend');\n            } finally {\n                setIsSubmitting(false);\n            }\n        } else if (action === 'didnt-happen') {\n            setIsSubmitting(true);\n            try {\n                await cancelPlan(planId);\n\n                // Provide feedback for cancellation\n                Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n                showToast(\"Plan cancelled\", friendNames || 'Friend');\n            } catch (e) {\n                console.error(\"Failed to cancel plan\", e);\n                // Provide error feedback\n                Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n                showToast(\"Failed to cancel plan\", friendNames || 'Friend');\n            } finally {\n                setIsSubmitting(false);\n            }\n        }\n\n        // Reset form state\n        setSelectedVibe(null);\n        setNotes('');\n    };\n\n    const isVisible = isPostWeaveRatingOpen && !!currentPlanId && !!currentPlan;\n\n    if (!currentPlan) return null;\n\n    return (\n        <AnimatedBottomSheet\n            visible={isVisible}\n            onClose={handleSkip}\n            onCloseComplete={handleCloseComplete}\n            height=\"form\"\n            scrollable\n        >\n            {/* Header */}\n            <View style={styles.header}>\n                <Text style={[styles.title, { color: colors.foreground }]}>\n                    How was the {currentPlan.activity}{friendNames ? ` with ${friendNames}` : ''}?\n                </Text>\n                <Text style={[styles.subtitle, { color: colors['muted-foreground'] }]}>\n                    {format(new Date(currentPlan.interactionDate), 'EEEE, MMMM do')}\n                </Text>\n            </View>\n\n            {/* Moon Phase Selector */}\n            <View style={styles.section}>\n                <MoonPhaseSelector\n                    selectedVibe={selectedVibe}\n                    onSelect={setSelectedVibe}\n                />\n            </View>\n\n            {/* Notes Input */}\n            <View style={styles.section}>\n                <Text style={[styles.label, { color: colors.foreground }]}>Notes (Optional)</Text>\n                <TextInput\n                    style={[styles.input, { backgroundColor: colors.background, color: colors.foreground }]}\n                    placeholder=\"Capture a memory or feeling...\"\n                    placeholderTextColor={colors['muted-foreground']}\n                    multiline\n                    value={notes}\n                    onChangeText={setNotes}\n                    numberOfLines={3}\n                />\n            </View>\n\n            {/* Actions */}\n            <View style={styles.actions}>\n                <TouchableOpacity\n                    style={[styles.secondaryButton, isSubmitting && styles.buttonDisabled]}\n                    onPress={handleDidntHappen}\n                    disabled={isSubmitting}\n                >\n                    <Text style={[styles.secondaryButtonText, { color: colors['muted-foreground'] }]}>\n                        It didn't happen\n                    </Text>\n                </TouchableOpacity>\n\n                <TouchableOpacity\n                    style={[\n                        styles.primaryButton,\n                        { backgroundColor: colors.primary },\n                        isSubmitting && styles.buttonDisabled\n                    ]}\n                    onPress={handleConfirm}\n                    disabled={isSubmitting}\n                >\n                    <Text style={[styles.primaryButtonText, { color: colors['primary-foreground'] }]}>\n                        {isSubmitting ? 'Weaving...' : 'Complete'}\n                    </Text>\n                    {!isSubmitting && <Check size={20} color={colors['primary-foreground']} />}\n                </TouchableOpacity>\n            </View>\n        </AnimatedBottomSheet>\n    );\n}\n\nconst styles = StyleSheet.create({\n    header: {\n        marginBottom: 24,\n    },\n    title: {\n        fontSize: 24,\n        fontFamily: 'Lora_700Bold',\n        marginBottom: 4,\n    },\n    subtitle: {\n        fontSize: 14,\n        fontFamily: 'Inter_400Regular',\n    },\n    section: {\n        gap: 12,\n        marginBottom: 24,\n    },\n    label: {\n        fontSize: 14,\n        fontFamily: 'Inter_600SemiBold',\n    },\n    input: {\n        borderRadius: 12,\n        padding: 12,\n        paddingTop: 12,\n        minHeight: 100,\n        fontSize: 16,\n        fontFamily: 'Inter_400Regular',\n        textAlignVertical: 'top',\n    },\n    actions: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        marginTop: 8,\n    },\n    secondaryButton: {\n        paddingVertical: 12,\n        paddingHorizontal: 16,\n    },\n    secondaryButtonText: {\n        fontSize: 16,\n        fontFamily: 'Inter_500Medium',\n    },\n    primaryButton: {\n        borderRadius: 999,\n        paddingVertical: 12,\n        paddingHorizontal: 24,\n        flexDirection: 'row',\n        alignItems: 'center',\n        gap: 8,\n    },\n    buttonDisabled: {\n        opacity: 0.5,\n    },\n    primaryButtonText: {\n        fontSize: 16,\n        fontFamily: 'Inter_600SemiBold',\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/QuickWeaveOverlay.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withSequence' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Haptics' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SELECTION_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":40,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { View, Text, Platform } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  runOnJS,\n  interpolate,\n  withSpring,\n  withSequence,\n} from 'react-native-reanimated';\nimport * as Haptics from 'expo-haptics';\nimport { BlurView } from 'expo-blur';\nimport {\n  Phone,\n  Utensils,\n  Users,\n  MessageCircle,\n  Palette,\n  Mic,\n  PartyPopper,\n  HeartHandshake,\n  Star,\n  HelpCircle\n} from 'lucide-react-native';\n\nimport { useUIStore } from '@/stores/uiStore';\nimport { useCardGesture } from '@/context/CardGestureContext';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\nimport { InteractionCategory } from '@/components/types';\n\n// Compact sizing for sleeker feel\nconst MENU_RADIUS = 88; // Increased from 75px (was 100px originally)\nconst ITEM_SIZE = 50;\nconst CENTER_SIZE = 44;\nconst HIGHLIGHT_THRESHOLD = 25;\nconst SELECTION_THRESHOLD = 40;\n\ninterface RadialMenuItem {\n  id: InteractionCategory;\n  icon: React.ElementType;\n  label: string;\n}\n\n// Category metadata mapping\nconst CATEGORY_METADATA: Record<InteractionCategory, { icon: React.ElementType; label: string }> = {\n  'text-call': { icon: Phone, label: 'Call' },\n  'meal-drink': { icon: Utensils, label: 'Meal' },\n  'hangout': { icon: Users, label: 'Hang' },\n  'deep-talk': { icon: MessageCircle, label: 'Talk' },\n  'activity-hobby': { icon: Palette, label: 'Do' },\n  'voice-note': { icon: Mic, label: 'Voice' },\n  'event-party': { icon: PartyPopper, label: 'Event' },\n  'favor-support': { icon: HeartHandshake, label: 'Help' },\n  'celebration': { icon: Star, label: 'Celebrate' },\n};\n\n// Default fallback activities\nconst DEFAULT_ACTIVITIES: InteractionCategory[] = [\n  'text-call',\n  'meal-drink',\n  'hangout',\n  'deep-talk',\n  'activity-hobby',\n  'voice-note',\n];\n\nexport function QuickWeaveOverlay() {\n  const {\n    quickWeaveFriendId,\n    quickWeaveCenterPoint,\n    quickWeaveActivities,\n    isQuickWeaveClosing,\n    _finishClosingQuickWeave,\n  } = useUIStore();\n  const [allFriends, setAllFriends] = React.useState<FriendModel[]>([]);\n  const friend = allFriends.find(f => f.id === quickWeaveFriendId);\n  const { dragX, dragY, highlightedIndex } = useCardGesture();\n  const { colors, isDarkMode } = useTheme();\n\n  useEffect(() => {\n    const subscription = database\n      .get<FriendModel>('friends')\n      .query(Q.sortBy('created_at', Q.desc))\n      .observe()\n      .subscribe(setAllFriends);\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  const overlayOpacity = useSharedValue(0);\n  const menuScale = useSharedValue(0.3);\n  const centerPulse = useSharedValue(1);\n\n  // Entrance Animation - Fast and snappy\n  useEffect(() => {\n    if (quickWeaveFriendId) {\n      overlayOpacity.value = withTiming(1, { duration: 200 });\n      menuScale.value = withSpring(1, { damping: 12, stiffness: 100 });\n    } else if (!isQuickWeaveClosing) {\n      overlayOpacity.value = 0;\n      menuScale.value = 0.8;\n    }\n  }, [quickWeaveFriendId, isQuickWeaveClosing]);\n\n  // Exit Animation - Fast dismiss\n  useEffect(() => {\n    if (isQuickWeaveClosing) {\n      menuScale.value = withTiming(0.3, { duration: 60 });\n      overlayOpacity.value = withTiming(0, { duration: 80 }, (finished) => {\n        if (finished) {\n          runOnJS(_finishClosingQuickWeave)();\n        }\n      });\n    }\n  }, [isQuickWeaveClosing]);\n\n  const overlayStyle = useAnimatedStyle(() => ({\n    opacity: overlayOpacity.value,\n  }));\n\n  const menuContainerStyle = useAnimatedStyle(() => ({\n    opacity: interpolate(menuScale.value, [0.3, 1], [0, 1]),\n    transform: [{ scale: menuScale.value }],\n  }));\n\n  const centerStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: centerPulse.value }],\n  }));\n\n  // Early return AFTER all hooks have been called\n  if (!quickWeaveCenterPoint || !quickWeaveFriendId || !friend) {\n    return null;\n  }\n\n  // Use smart-ordered activities or fallback to default\n  const orderedCategories = quickWeaveActivities.length > 0\n    ? quickWeaveActivities.slice(0, 6) // Take first 6\n    : DEFAULT_ACTIVITIES;\n\n  // Map to RadialMenuItem format\n  const ACTIVITIES: RadialMenuItem[] = orderedCategories.map(category => ({\n    id: category,\n    icon: CATEGORY_METADATA[category]?.icon || HelpCircle,\n    label: CATEGORY_METADATA[category]?.label || category,\n  }));\n\n  // Calculate positions dynamically based on actual activity count\n  const itemPositions = ACTIVITIES.map((_, i) => {\n    const angle = (i / ACTIVITIES.length) * 2 * Math.PI - Math.PI / 2;\n    return {\n      x: MENU_RADIUS * Math.cos(angle),\n      y: MENU_RADIUS * Math.sin(angle),\n      angle,\n    };\n  });\n\n  const friendInitial = friend.name.charAt(0).toUpperCase();\n\n  return (\n    <View className=\"absolute inset-0\" pointerEvents=\"none\">\n      <Animated.View style={overlayStyle}>\n        <BlurView\n          intensity={isDarkMode ? 25 : 15}\n          tint={isDarkMode ? 'dark' : 'light'}\n          className=\"absolute inset-0\"\n        />\n      </Animated.View>\n\n      <Animated.View\n        style={[\n          {\n            position: 'absolute',\n            width: MENU_RADIUS * 2,\n            height: MENU_RADIUS * 2,\n            left: quickWeaveCenterPoint.x - MENU_RADIUS,\n            top: quickWeaveCenterPoint.y - MENU_RADIUS,\n            alignItems: 'center',\n            justifyContent: 'center',\n          },\n          menuContainerStyle,\n        ]}\n      >\n        {/* Center Circle - Anchor Point */}\n        <Animated.View\n          style={[\n            {\n              width: CENTER_SIZE,\n              height: CENTER_SIZE,\n              borderRadius: CENTER_SIZE / 2,\n              // Softened center circle\n              backgroundColor: isDarkMode ? 'rgba(40, 40, 40, 0.6)' : 'rgba(255, 255, 255, 0.6)',\n              alignItems: 'center',\n              justifyContent: 'center',\n              position: 'absolute',\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: 2 },\n              shadowOpacity: 0.1,\n              shadowRadius: 4,\n              elevation: 2,\n              borderWidth: 1,\n              borderColor: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)',\n              overflow: 'hidden', // For BlurView if we wanted it inside, but background color is enough for \"soft\"\n            },\n            centerStyle,\n          ]}\n        >\n          {/* Optional: Add BlurView inside for extra softness if supported */}\n          {Platform.OS === 'ios' && (\n            <BlurView\n              intensity={20}\n              tint={isDarkMode ? 'dark' : 'light'}\n              style={{ position: 'absolute', width: '100%', height: '100%' }}\n            />\n          )}\n          <Text\n            style={{\n              fontSize: 18,\n              fontWeight: '700',\n              color: isDarkMode ? 'white' : colors.foreground, // Adapted to theme\n              fontFamily: 'Lora_700Bold',\n            }}\n          >\n            {friendInitial}\n          </Text>\n        </Animated.View>\n\n        {/* Radial Menu Items */}\n        {ACTIVITIES.map((item, index) => (\n          <MenuItem\n            key={item.id}\n            item={item}\n            index={index}\n            position={itemPositions[index]}\n            highlightedIndex={highlightedIndex}\n            dragX={dragX}\n            dragY={dragY}\n            isDarkMode={isDarkMode}\n            primaryColor={colors.primary}\n          />\n        ))}\n      </Animated.View>\n    </View>\n  );\n}\n\nfunction MenuItem({\n  item,\n  index,\n  position,\n  highlightedIndex,\n  dragX,\n  dragY,\n  isDarkMode,\n  primaryColor,\n}: {\n  item: RadialMenuItem;\n  index: number;\n  position: { x: number; y: number; angle: number };\n  highlightedIndex: Animated.SharedValue<number>;\n  dragX: Animated.SharedValue<number>;\n  dragY: Animated.SharedValue<number>;\n  isDarkMode: boolean;\n  primaryColor: string;\n}) {\n  const { x: finalX, y: finalY } = position;\n  const IconComponent = item.icon;\n\n  const animatedStyle = useAnimatedStyle(() => {\n    const isHighlighted = highlightedIndex.value === index;\n    const dragDistance = Math.sqrt(dragX.value ** 2 + dragY.value ** 2);\n    const hasDragged = dragDistance > HIGHLIGHT_THRESHOLD;\n\n    // Subtle scale - snappy, not bouncy\n    const targetScale = isHighlighted && hasDragged ? 1.12 : 1;\n    const scale = withTiming(targetScale, { duration: 100 });\n\n    // Clearer opacity states\n    const targetOpacity = hasDragged ? (isHighlighted ? 1 : 0.5) : 0.85;\n    const opacity = withTiming(targetOpacity, { duration: 80 });\n\n    return {\n      opacity,\n      transform: [\n        { translateX: finalX },\n        { translateY: finalY },\n        { scale },\n      ],\n    };\n  });\n\n  const itemBgStyle = useAnimatedStyle(() => {\n    const isHighlighted = highlightedIndex.value === index;\n    const dragDistance = Math.sqrt(dragX.value ** 2 + dragY.value ** 2);\n    const hasDragged = dragDistance > HIGHLIGHT_THRESHOLD;\n\n    // Keep it clean - white/frosted always, just slightly brighter when highlighted\n    const backgroundColor = isHighlighted && hasDragged\n      ? isDarkMode\n        ? 'rgba(255, 255, 255, 0.25)' // Slightly brighter frosted\n        : 'rgba(255, 255, 255, 1)' // Pure white\n      : isDarkMode\n        ? 'rgba(255, 255, 255, 0.15)' // Frosted glass\n        : 'rgba(255, 255, 255, 0.95)'; // Near white\n\n    return {\n      backgroundColor: withTiming(backgroundColor, { duration: 80 }),\n    };\n  });\n\n  const labelStyle = useAnimatedStyle(() => {\n    const isHighlighted = highlightedIndex.value === index;\n    const dragDistance = Math.sqrt(dragX.value ** 2 + dragY.value ** 2);\n    const hasDragged = dragDistance > HIGHLIGHT_THRESHOLD;\n\n    // Always visible, subtle highlight\n    const targetOpacity = isHighlighted && hasDragged ? 1 : 0.75;\n\n    return {\n      opacity: withTiming(targetOpacity, { duration: 80 }),\n    };\n  });\n\n  return (\n    <Animated.View\n      style={[\n        {\n          position: 'absolute',\n          left: MENU_RADIUS - ITEM_SIZE / 2,\n          top: MENU_RADIUS - ITEM_SIZE / 2,\n          width: ITEM_SIZE,\n          height: ITEM_SIZE,\n          alignItems: 'center',\n          justifyContent: 'center',\n        },\n        animatedStyle,\n      ]}\n    >\n      {/* Item Circle with Icon */}\n      <Animated.View\n        style={[\n          {\n            width: ITEM_SIZE,\n            height: ITEM_SIZE,\n            borderRadius: ITEM_SIZE / 2,\n            alignItems: 'center',\n            justifyContent: 'center',\n            shadowColor: '#000',\n            shadowOffset: { width: 0, height: 2 },\n            shadowOpacity: isDarkMode ? 0.3 : 0.15,\n            shadowRadius: 6,\n            elevation: 4,\n            borderWidth: 1.5,\n            borderColor: isDarkMode ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.05)',\n          },\n          itemBgStyle,\n        ]}\n      >\n        <IconComponent\n          size={24}\n          color={primaryColor}\n          strokeWidth={2}\n        />\n      </Animated.View>\n\n      {/* Label with Backdrop Blur */}\n      <Animated.View\n        style={[\n          {\n            position: 'absolute',\n            top: ITEM_SIZE + 6,\n            alignItems: 'center',\n            justifyContent: 'center',\n            overflow: 'hidden',\n            borderRadius: 8,\n          },\n          labelStyle,\n        ]}\n      >\n        <BlurView\n          intensity={isDarkMode ? 30 : 20}\n          tint={isDarkMode ? 'dark' : 'light'}\n          style={{\n            position: 'absolute',\n            width: '100%',\n            height: '100%',\n            backgroundColor: isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(255,255,255,0.3)',\n          }}\n        />\n        <Text\n          style={{\n            fontSize: 11,\n            fontWeight: '600',\n            color: isDarkMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.8)',\n            letterSpacing: 0.2,\n            textAlign: 'center',\n            paddingHorizontal: 8,\n            paddingVertical: 2,\n          }}\n          numberOfLines={1}\n        >\n          {item.label}\n        </Text>\n      </Animated.View>\n    </Animated.View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/plan-wizard/PlanWizardStep0.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/plan-wizard/PlanWizardStep1.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDay' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":71},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'database' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friend' is defined but never used. Allowed unused args must match /^_/u.","line":23,"column":88,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":94},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dayNames' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity, Modal } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, FadeIn } from 'react-native-reanimated';\nimport { Calendar, Sun, X, TrendingUp, CalendarDays } from 'lucide-react-native';\nimport { BlurView } from 'expo-blur';\nimport { startOfDay, addDays, format, isSaturday, nextSaturday, getDay } from 'date-fns';\nimport { Q } from '@nozbe/watermelondb';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { CustomCalendar } from '@/components/CustomCalendar';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\n\ninterface PlanWizardStep1Props {\n  selectedDate?: Date;\n  onDateSelect: (date: Date) => void;\n  onContinue: () => void;\n  canContinue: boolean;\n  friend: FriendModel;\n  plannedDates: Date[];\n  mostCommonDay: { day: number; name: string; date: Date } | null;\n}\n\nexport function PlanWizardStep1({ selectedDate, onDateSelect, onContinue, canContinue, friend, plannedDates, mostCommonDay }: PlanWizardStep1Props) {\n  const { colors, isDarkMode } = useTheme();\n  const [showDatePicker, setShowDatePicker] = useState(false);\n  const [selectedKey, setSelectedKey] = useState<string | null>(null);\n  const scale = useSharedValue(1);\n\n  // Create animated style once at the top level\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const today = startOfDay(new Date());\n\n  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\n  const handleQuickSelect = (option: 'today' | 'weekend' | 'usual' | 'next-week') => {\n    setSelectedKey(option);\n    let targetDate: Date;\n\n    switch (option) {\n      case 'today':\n        targetDate = today;\n        break;\n      case 'weekend':\n        // If today is Saturday, use today. Otherwise, next Saturday\n        targetDate = isSaturday(today) ? today : nextSaturday(today);\n        break;\n      case 'usual':\n        // Use the calculated most common day\n        targetDate = mostCommonDay?.date || today;\n        break;\n      case 'next-week':\n        // Next week = 7 days from now\n        targetDate = addDays(today, 7);\n        break;\n      default:\n        targetDate = today;\n    }\n\n    onDateSelect(targetDate);\n  };\n\n  return (\n    <View className=\"px-5 py-6\">\n      <Text className=\"font-lora-bold text-2xl mb-2\" style={{ color: colors.foreground }}>\n        When?\n      </Text>\n      <Text className=\"font-inter-regular text-base mb-8\" style={{ color: colors['muted-foreground'] }}>\n        Pick a time that works for both of you\n      </Text>\n\n      {/* Quick select options */}\n      <View className=\"gap-3 mb-6\">\n        {/* Today */}\n        <Animated.View style={selectedKey === 'today' ? animatedStyle : {}}>\n          <TouchableOpacity\n            onPress={() => handleQuickSelect('today')}\n            className=\"p-5 rounded-2xl flex-row items-center justify-between\"\n            style={{\n              backgroundColor: colors.card,\n              borderWidth: selectedKey === 'today' ? 2 : 1,\n              borderColor: selectedKey === 'today' ? colors.primary : colors.border,\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: 2 },\n              shadowOpacity: 0.05,\n              shadowRadius: 8,\n              elevation: 2,\n            }}\n          >\n            <View className=\"flex-row items-center gap-3\">\n              <View\n                className=\"w-12 h-12 rounded-full items-center justify-center\"\n                style={{ backgroundColor: colors.background }}\n              >\n                <Sun size={24} color={colors.primary} />\n              </View>\n              <View>\n                <Text className=\"font-inter-semibold text-base\" style={{ color: colors.foreground }}>\n                  Today\n                </Text>\n                <Text className=\"font-inter-regular text-sm\" style={{ color: colors['muted-foreground'] }}>\n                  {format(today, 'EEEE, MMM d')}\n                </Text>\n              </View>\n            </View>\n          </TouchableOpacity>\n        </Animated.View>\n\n        {/* This Weekend */}\n        <Animated.View style={selectedKey === 'weekend' ? animatedStyle : {}}>\n          <TouchableOpacity\n            onPress={() => handleQuickSelect('weekend')}\n            className=\"p-5 rounded-2xl flex-row items-center justify-between\"\n            style={{\n              backgroundColor: colors.card,\n              borderWidth: selectedKey === 'weekend' ? 2 : 1,\n              borderColor: selectedKey === 'weekend' ? colors.primary : colors.border,\n              shadowColor: '#000',\n              shadowOffset: { width: 0, height: 2 },\n              shadowOpacity: 0.05,\n              shadowRadius: 8,\n              elevation: 2,\n            }}\n          >\n            <View className=\"flex-row items-center gap-3\">\n              <View\n                className=\"w-12 h-12 rounded-full items-center justify-center\"\n                style={{ backgroundColor: colors.background }}\n              >\n                <Calendar size={24} color={colors.primary} />\n              </View>\n              <View>\n                <Text className=\"font-inter-semibold text-base\" style={{ color: colors.foreground }}>\n                  This Weekend\n                </Text>\n                <Text className=\"font-inter-regular text-sm\" style={{ color: colors['muted-foreground'] }}>\n                  {format(isSaturday(today) ? today : nextSaturday(today), 'EEEE, MMM d')}\n                </Text>\n              </View>\n            </View>\n          </TouchableOpacity>\n        </Animated.View>\n\n        {/* Your Usual Day (dynamic) */}\n        {mostCommonDay && (\n          <Animated.View style={selectedKey === 'usual' ? animatedStyle : {}}>\n            <TouchableOpacity\n              onPress={() => handleQuickSelect('usual')}\n              className=\"p-5 rounded-2xl flex-row items-center justify-between\"\n              style={{\n                backgroundColor: colors.card,\n                borderWidth: selectedKey === 'usual' ? 2 : 1,\n                borderColor: selectedKey === 'usual' ? colors.primary : colors.border,\n                shadowColor: '#000',\n                shadowOffset: { width: 0, height: 2 },\n                shadowOpacity: 0.05,\n                shadowRadius: 8,\n                elevation: 2,\n              }}\n            >\n              <View className=\"flex-row items-center gap-3\">\n                <View\n                  className=\"w-12 h-12 rounded-full items-center justify-center\"\n                  style={{ backgroundColor: colors.background }}\n                >\n                  <TrendingUp size={24} color={colors.primary} />\n                </View>\n                <View>\n                  <Text className=\"font-inter-semibold text-base\" style={{ color: colors.foreground }}>\n                    Your usual {mostCommonDay.name}\n                  </Text>\n                  <Text className=\"font-inter-regular text-sm\" style={{ color: colors['muted-foreground'] }}>\n                    {format(mostCommonDay.date, 'EEEE, MMM d')}\n                  </Text>\n                </View>\n              </View>\n            </TouchableOpacity>\n          </Animated.View>\n        )}\n\n        {/* Pick a Date */}\n        <TouchableOpacity\n          onPress={() => {\n            if (!selectedDate) {\n              onDateSelect(today);\n            }\n            setShowDatePicker(true);\n          }}\n          className=\"p-5 rounded-2xl flex-row items-center justify-between\"\n          style={{\n            backgroundColor: colors.card,\n            borderWidth: selectedKey === 'calendar' ? 2 : 1,\n            borderColor: selectedKey === 'calendar' ? colors.primary : colors.border,\n            shadowColor: '#000',\n            shadowOffset: { width: 0, height: 2 },\n            shadowOpacity: 0.05,\n            shadowRadius: 8,\n            elevation: 2,\n          }}\n        >\n          <View className=\"flex-row items-center gap-3\">\n            <View\n              className=\"w-12 h-12 rounded-full items-center justify-center\"\n              style={{ backgroundColor: colors.background }}\n            >\n              <CalendarDays size={24} color={colors.primary} />\n            </View>\n            <View>\n              <Text className=\"font-inter-semibold text-base\" style={{ color: colors.foreground }}>\n                Pick a Date\n              </Text>\n              <Text className=\"font-inter-regular text-sm\" style={{ color: colors['muted-foreground'] }}>\n                Choose from calendar\n              </Text>\n            </View>\n          </View>\n        </TouchableOpacity>\n      </View>\n\n      {/* Calendar Popup Modal */}\n      {showDatePicker && (\n        <Modal\n          visible={true}\n          transparent\n          animationType=\"none\"\n          onRequestClose={() => setShowDatePicker(false)}\n        >\n          <BlurView intensity={isDarkMode ? 20 : 40} tint={isDarkMode ? 'dark' : 'light'} className=\"flex-1\">\n            <TouchableOpacity\n              className=\"flex-1 justify-center items-center px-5\"\n              activeOpacity={1}\n              onPress={() => setShowDatePicker(false)}\n            >\n              <Animated.View\n                entering={FadeIn.duration(200).springify()}\n                className=\"w-full max-w-md rounded-3xl p-6\"\n                style={{\n                  backgroundColor: colors.background,\n                  shadowColor: '#000',\n                  shadowOffset: { width: 0, height: 20 },\n                  shadowOpacity: 0.25,\n                  shadowRadius: 30,\n                  elevation: 20,\n                }}\n                onStartShouldSetResponder={() => true}\n              >\n                {/* Header */}\n                <View className=\"flex-row justify-between items-center mb-4\">\n                  <Text className=\"font-lora-bold text-xl\" style={{ color: colors.foreground }}>\n                    Pick a Date\n                  </Text>\n                  <TouchableOpacity onPress={() => setShowDatePicker(false)} className=\"p-2 -mr-2\">\n                    <X color={colors['muted-foreground']} size={22} />\n                  </TouchableOpacity>\n                </View>\n\n                <CustomCalendar\n                  selectedDate={selectedDate}\n                  onDateSelect={(date) => {\n                    setSelectedKey('calendar');\n                    onDateSelect(date);\n                    setShowDatePicker(false);\n                  }}\n                  minDate={today}\n                  plannedDates={plannedDates}\n                />\n              </Animated.View>\n            </TouchableOpacity>\n          </BlurView>\n        </Modal>\n      )}\n\n      {/* Continue button (after date is selected) */}\n      {selectedDate && (\n        <View className=\"mt-6\">\n          <TouchableOpacity\n            onPress={onContinue}\n            disabled={!canContinue}\n            className=\"p-5 rounded-2xl items-center\"\n            style={{\n              backgroundColor: canContinue ? colors.primary : colors.card,\n              opacity: canContinue ? 1 : 0.5,\n            }}\n          >\n            <Text\n              className=\"font-inter-semibold text-base\"\n              style={{ color: canContinue ? '#FFFFFF' : colors['muted-foreground'] }}\n            >\n              Continue\n            </Text>\n          </TouchableOpacity>\n        </View>\n      )}\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/plan-wizard/PlanWizardStep2.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ScrollView' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'format' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":16},{"ruleId":"no-restricted-imports","severity":2,"message":"'../../hooks/usePlanSuggestion' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":9,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":9,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'canContinue' is defined but never used. Allowed unused args must match /^_/u.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friend' is defined but never used. Allowed unused args must match /^_/u.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { View, Text, TouchableOpacity, ScrollView } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';\nimport { Sparkles } from 'lucide-react-native';\nimport { format } from 'date-fns';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { type InteractionCategory } from '@/shared/types/common';\nimport FriendModel from '@/db/models/Friend';\nimport { PlanSuggestion } from '../../hooks/usePlanSuggestion';\n\ninterface PlanWizardStep2Props {\n  selectedCategory?: InteractionCategory;\n  onCategorySelect: (category: InteractionCategory) => void;\n  onContinue: () => void;\n  canContinue: boolean;\n  friend: FriendModel;\n  suggestion: PlanSuggestion | null;\n  orderedCategories: Array<{\n    value: InteractionCategory;\n    label: string;\n    icon: string;\n    description: string;\n  }>;\n}\n\nexport function PlanWizardStep2({\n  selectedCategory,\n  onCategorySelect,\n  onContinue,\n  canContinue,\n  friend,\n  suggestion,\n  orderedCategories,\n}: PlanWizardStep2Props) {\n  const { colors } = useTheme();\n  const [selectedKey, setSelectedKey] = useState<string | null>(null);\n  const scale = useSharedValue(1);\n\n  // Ref to track timeout for cleanup\n  const timeoutRef = React.useRef<NodeJS.Timeout>();\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Create animated style once at the top level\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handleUseSuggestion = () => {\n    if (suggestion?.suggestedCategory) {\n      setSelectedKey(suggestion.suggestedCategory);\n      onCategorySelect(suggestion.suggestedCategory);\n\n      // Visual feedback: scale down then advance\n      scale.value = withSpring(0.95, { damping: 15 });\n      timeoutRef.current = setTimeout(() => {\n        scale.value = withSpring(1, { damping: 15 });\n        onContinue();\n      }, 200);\n    }\n  };\n\n  const handleCategorySelect = (category: InteractionCategory) => {\n    setSelectedKey(category);\n    onCategorySelect(category);\n\n    // Visual feedback: scale down then advance\n    scale.value = withSpring(0.95, { damping: 15 });\n    timeoutRef.current = setTimeout(() => {\n      scale.value = withSpring(1, { damping: 15 });\n      onContinue();\n    }, 200);\n  };\n  // ... rest of file\n\n  const getCategoryData = (value: InteractionCategory) => {\n    return orderedCategories.find(c => c.value === value);\n  };\n\n  return (\n    <View className=\"px-5 py-6\">\n      <Text className=\"font-lora-bold text-2xl mb-2\" style={{ color: colors.foreground }}>\n        What kind of connection?\n      </Text>\n      <Text className=\"font-inter-regular text-base mb-6\" style={{ color: colors['muted-foreground'] }}>\n        Choose what feels right for this moment\n      </Text>\n\n      {/* Suggestion banner */}\n      {suggestion && suggestion.confidence !== 'low' && (\n        <TouchableOpacity\n          onPress={handleUseSuggestion}\n          className=\"p-4 rounded-2xl mb-6 flex-row items-center\"\n          style={{\n            backgroundColor: `${colors.primary}10`,\n            borderWidth: selectedCategory === suggestion.suggestedCategory ? 2 : 1,\n            borderColor: selectedCategory === suggestion.suggestedCategory ? colors.primary : `${colors.primary}30`,\n            shadowColor: '#000',\n            shadowOffset: { width: 0, height: 2 },\n            shadowOpacity: 0.05,\n            shadowRadius: 8,\n            elevation: 2,\n          }}\n        >\n          <View\n            className=\"w-12 h-12 rounded-full items-center justify-center mr-4\"\n            style={{ backgroundColor: `${colors.primary}20` }}\n          >\n            <Sparkles size={20} color={colors.primary} />\n          </View>\n          <View className=\"flex-1\">\n            <Text className=\"font-inter-semibold text-sm\" style={{ color: colors.primary }}>\n              💡 Suggested\n            </Text>\n            {suggestion.suggestedCategory && (\n              <Text className=\"font-inter-semibold text-base mt-1\" style={{ color: colors.foreground }}>\n                {getCategoryData(suggestion.suggestedCategory)?.icon}{' '}\n                {getCategoryData(suggestion.suggestedCategory)?.label}\n              </Text>\n            )}\n            <Text className=\"font-inter-regular text-sm mt-1\" style={{ color: colors['muted-foreground'] }}>\n              {suggestion.reason}\n            </Text>\n          </View>\n        </TouchableOpacity>\n      )}\n\n      {/* Category grid */}\n      <View className=\"gap-3\">\n        {orderedCategories.map(category => {\n          const isSelected = selectedCategory === category.value;\n          const isSuggested = suggestion?.suggestedCategory === category.value;\n          const isJustSelected = selectedKey === category.value;\n\n          return (\n            <Animated.View\n              key={category.value}\n              style={isJustSelected ? animatedStyle : {}}\n            >\n              <TouchableOpacity\n                onPress={() => handleCategorySelect(category.value)}\n                className=\"p-4 rounded-xl flex-row items-center\"\n                style={{\n                  backgroundColor: isSelected ? `${colors.primary}15` : colors.card,\n                  borderWidth: isSelected ? 2 : 1,\n                  borderColor: isSelected ? colors.primary : isSuggested ? `${colors.primary}50` : colors.border,\n                  shadowColor: '#000',\n                  shadowOffset: { width: 0, height: 2 },\n                  shadowOpacity: 0.05,\n                  shadowRadius: 8,\n                  elevation: 2,\n                }}\n              >\n                <Text className=\"text-3xl mr-3\">{category.icon}</Text>\n                <View className=\"flex-1\">\n                  <Text\n                    className=\"font-inter-semibold text-base\"\n                    style={{ color: isSelected ? colors.primary : colors.foreground }}\n                  >\n                    {category.label}\n                  </Text>\n                  <Text className=\"font-inter-regular text-sm\" style={{ color: colors['muted-foreground'] }}>\n                    {category.description}\n                  </Text>\n                </View>\n              </TouchableOpacity>\n            </Animated.View>\n          );\n        })}\n      </View>\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/components/plan-wizard/PlanWizardStep3.tsx","messages":[{"ruleId":"no-restricted-imports","severity":2,"message":"'../../hooks/usePlanSuggestion' import is restricted from being used by a pattern. Use absolute imports (@/) instead of relative imports that go up two levels.","line":9,"column":1,"nodeType":"ImportDeclaration","messageId":"patternWithCustomMessage","endLine":9,"endColumn":83},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'usePlanSuggestion' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { View, Text, TouchableOpacity, TextInput, Platform } from 'react-native';\nimport { ChevronDown, ChevronUp, Clock, Users } from 'lucide-react-native';\nimport { format } from 'date-fns';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { PlanFormData } from '../PlanWizard';\nimport FriendModel from '@/db/models/Friend';\nimport { usePlanSuggestion, PlanSuggestion } from '../../hooks/usePlanSuggestion';\nimport { FriendSelector } from '@/components/FriendSelector';\nimport { ReciprocitySelector } from '@/components/ReciprocitySelector';\n\ninterface PlanWizardStep3Props {\n  formData: Partial<PlanFormData>;\n  onUpdate: (updates: Partial<PlanFormData>) => void;\n  onSubmit: () => void;\n  isSubmitting: boolean;\n  friend: FriendModel;\n  suggestion: PlanSuggestion | null;\n  selectedFriends: FriendModel[];\n  onFriendsSelect: (friends: FriendModel[]) => void;\n}\n\nconst CATEGORY_LABELS: Record<string, string> = {\n  'text-call': 'Chat',\n  'meal-drink': 'Meal',\n  'hangout': 'Hangout',\n  'deep-talk': 'Deep Talk',\n  'activity-hobby': 'Activity',\n  'event-party': 'Event',\n  'favor-support': 'Support',\n  'celebration': 'Celebration',\n};\n\nexport function PlanWizardStep3({\n  formData,\n  onUpdate,\n  onSubmit,\n  isSubmitting,\n  friend,\n  suggestion,\n  selectedFriends,\n  onFriendsSelect,\n}: PlanWizardStep3Props) {\n  const { colors } = useTheme();\n  const [showDetails, setShowDetails] = useState(false);\n  const [showTimePicker, setShowTimePicker] = useState(false);\n  const [showFriendSelection, setShowFriendSelection] = useState(false);\n\n  const categoryLabel = formData.category ? CATEGORY_LABELS[formData.category] : 'Time together';\n  const dateText = formData.date ? format(formData.date, 'EEEE, MMM d') : '';\n\n  return (\n    <View className=\"px-5 py-6\">\n      {/* Summary */}\n      <View\n        className=\"p-4 rounded-2xl mb-6\"\n        style={{ backgroundColor: colors.muted }}\n      >\n        <Text className=\"font-inter-medium text-sm\" style={{ color: colors['muted-foreground'] }}>\n          Planning\n        </Text>\n        <Text className=\"font-lora-bold text-xl mt-1\" style={{ color: colors.foreground }}>\n          {categoryLabel} with {selectedFriends.map(f => f.name).join(', ')}\n        </Text>\n        <Text className=\"font-inter-regular text-base mt-1\" style={{ color: colors.foreground }}>\n          {dateText}\n        </Text>\n      </View>\n\n      {/* Add Others Button */}\n      <TouchableOpacity\n        onPress={() => setShowFriendSelection(true)}\n        className=\"flex-row items-center justify-center py-3 px-4 rounded-xl mb-6\"\n        style={{ backgroundColor: colors.secondary }}\n      >\n        <Users size={20} color={colors.foreground} />\n        <Text className=\"font-inter-semibold text-base ml-3\" style={{ color: colors.foreground }}>\n          Add Others\n        </Text>\n      </TouchableOpacity>\n\n      {/* Title input */}\n      <Text className=\"font-inter-semibold text-base mb-2\" style={{ color: colors.foreground }}>\n        Give it a title? <Text style={{ color: colors['muted-foreground'] }}>(optional)</Text>\n      </Text>\n      <TextInput\n        value={formData.title}\n        onChangeText={title => onUpdate({ title })}\n        placeholder={`e.g., Birthday ${categoryLabel.toLowerCase()}, Catch-up coffee`}\n        placeholderTextColor={colors['muted-foreground']}\n        className=\"p-4 rounded-xl mb-6 font-inter-regular text-base\"\n        style={{ backgroundColor: colors.muted, color: colors.foreground }}\n      />\n\n      {/* Collapsible details section */}\n      <TouchableOpacity\n        onPress={() => setShowDetails(!showDetails)}\n        className=\"flex-row items-center justify-between py-3 mb-3\"\n      >\n        <Text className=\"font-inter-semibold text-base\" style={{ color: colors.foreground }}>\n          Add more specifics <Text style={{ color: colors['muted-foreground'] }}>(optional)</Text>\n        </Text>\n        {showDetails ? (\n          <ChevronUp size={20} color={colors['muted-foreground']} />\n        ) : (\n          <ChevronDown size={20} color={colors['muted-foreground']} />\n        )}\n      </TouchableOpacity>\n\n      {showDetails && (\n        <View className=\"mb-6\">\n          {/* Time picker */}\n          <View className=\"flex-row items-center justify-between mb-2\">\n            <Text className=\"font-inter-semibold text-sm\" style={{ color: colors.foreground }}>\n              What time?\n            </Text>\n            {formData.time && (\n              <TouchableOpacity onPress={() => onUpdate({ time: undefined })}>\n                <Text className=\"font-inter-medium text-sm\" style={{ color: colors.primary }}>\n                  Clear\n                </Text>\n              </TouchableOpacity>\n            )}\n          </View>\n          <TouchableOpacity\n            onPress={() => setShowTimePicker(true)}\n            className=\"p-4 rounded-xl mb-4 flex-row items-center justify-between\"\n            style={{ backgroundColor: colors.muted }}\n          >\n            <View className=\"flex-row items-center\">\n              <Clock size={20} color={colors['muted-foreground']} />\n              <Text className=\"font-inter-regular text-base ml-3\" style={{ color: formData.time ? colors.foreground : colors['muted-foreground'] }}>\n                {formData.time ? format(formData.time, 'h:mm a') : 'Add a time'}\n              </Text>\n            </View>\n          </TouchableOpacity>\n\n          {showTimePicker && (\n            <View className=\"mb-4\">\n              <DateTimePicker\n                value={formData.time || new Date()}\n                mode=\"time\"\n                display={Platform.OS === 'ios' ? 'spinner' : 'default'}\n                onChange={(event, time) => {\n                  setShowTimePicker(Platform.OS === 'ios');\n                  if (time && event.type === 'set') {\n                    onUpdate({ time });\n                  }\n                  // On Android, close picker after selection\n                  if (Platform.OS === 'android') {\n                    setShowTimePicker(false);\n                  }\n                }}\n              />\n              {/* iOS: Add Done button to dismiss picker */}\n              {Platform.OS === 'ios' && (\n                <TouchableOpacity\n                  onPress={() => setShowTimePicker(false)}\n                  className=\"py-3 px-6 rounded-full items-center self-center mt-2\"\n                  style={{ backgroundColor: colors.primary }}\n                >\n                  <Text className=\"font-inter-semibold text-base text-white\">Done</Text>\n                </TouchableOpacity>\n              )}\n            </View>\n          )}\n\n          {/* Location with history */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Where?\n          </Text>\n\n          {/* Recent locations */}\n          {suggestion?.recentLocations && suggestion.recentLocations.length > 0 && (\n            <View className=\"mb-3\">\n              <Text className=\"font-inter-regular text-xs mb-2\" style={{ color: colors['muted-foreground'] }}>\n                You've been here before:\n              </Text>\n              <View className=\"flex-row flex-wrap gap-2\">\n                {suggestion.recentLocations.map((location: string, idx: number) => (\n                  <TouchableOpacity\n                    key={idx}\n                    onPress={() => onUpdate({ location })}\n                    className=\"px-3 py-2 rounded-full\"\n                    style={{\n                      backgroundColor: formData.location === location ? `${colors.primary}20` : colors.muted,\n                      borderWidth: formData.location === location ? 1 : 0,\n                      borderColor: colors.primary,\n                    }}\n                  >\n                    <Text\n                      className=\"font-inter-medium text-sm\"\n                      style={{ color: formData.location === location ? colors.primary : colors.foreground }}\n                    >\n                      {location}\n                    </Text>\n                  </TouchableOpacity>\n                ))}\n              </View>\n            </View>\n          )}\n\n          <TextInput\n            value={formData.location}\n            onChangeText={location => onUpdate({ location })}\n            placeholder=\"e.g., Blue Bottle Coffee, Their place\"\n            placeholderTextColor={colors['muted-foreground']}\n            className=\"p-4 rounded-xl mb-4 font-inter-regular text-base\"\n            style={{ backgroundColor: colors.muted, color: colors.foreground }}\n          />\n\n          {/* Reciprocity Section */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Who initiated?\n          </Text>\n          <ReciprocitySelector\n            value={formData.initiator}\n            onChange={(initiator) => onUpdate({ initiator })}\n            friendName={selectedFriends.length === 1 ? selectedFriends[0].name : 'Them'}\n            hideLabel\n          />\n\n          {/* Notes */}\n          <Text className=\"font-inter-semibold text-sm mb-2\" style={{ color: colors.foreground }}>\n            Notes\n          </Text>\n          <TextInput\n            value={formData.notes}\n            onChangeText={notes => onUpdate({ notes })}\n            placeholder=\"e.g., Discuss her new job, Bring birthday gift\"\n            placeholderTextColor={colors['muted-foreground']}\n            multiline\n            numberOfLines={3}\n            className=\"p-4 rounded-xl font-inter-regular text-base\"\n            style={{\n              backgroundColor: colors.muted,\n              color: colors.foreground,\n              textAlignVertical: 'top',\n            }}\n          />\n\n\n        </View>\n      )}\n\n      {/* Create button */}\n      <TouchableOpacity\n        onPress={onSubmit}\n        disabled={isSubmitting}\n        className=\"py-4 rounded-full items-center mt-4\"\n        style={{\n          backgroundColor: colors.primary,\n          opacity: isSubmitting ? 0.6 : 1,\n        }}\n      >\n        <Text className=\"font-inter-semibold text-base text-white\">\n          {isSubmitting ? 'Creating Plan...' : 'Create Plan'}\n        </Text>\n      </TouchableOpacity>\n\n      <FriendSelector\n        visible={showFriendSelection}\n        onClose={() => setShowFriendSelection(false)}\n        initialFriendId={friend.id}\n        selectedFriends={selectedFriends}\n        onSelectionChange={onFriendsSelect}\n        asModal={true}\n      />\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/hooks/useInteractions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/hooks/usePlanSuggestion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/hooks/usePlans.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/hooks/useQuickWeave.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/hooks/useSuggestions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState, useRef } from 'react';\nimport { Q } from '@nozbe/watermelondb';\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport { fetchSuggestions } from '../services/suggestion-provider.service';\nimport { calculateCurrentScore } from '@/modules/intelligence';\nimport { SuggestionTrackerService } from '../services/suggestion-tracker.service';\nimport * as SuggestionStorageService from '../services/suggestion-storage.service';\nimport { useUserProfileStore } from '@/modules/auth';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\n\nexport function useSuggestions() {\n  const queryClient = useQueryClient();\n  const trackedSuggestions = useRef<Set<string>>(new Set()); // Track which suggestions we've already logged as \"shown\"\n\n  // Get current social season from profile\n  const { profile } = useUserProfileStore();\n  const currentSeason = profile?.currentSocialSeason || null;\n\n  const { data: suggestions = [] } = useQuery({\n    queryKey: ['suggestions', 'all', currentSeason], // Include season in query key for proper cache invalidation\n    queryFn: () => fetchSuggestions(3, currentSeason),\n    // Re-fetch when the query is invalidated or season changes\n  });\n\n  // Observe friends table for changes\n  useEffect(() => {\n    const subscription = database\n      .get<FriendModel>('friends')\n      .query()\n      .observe()\n      .subscribe(() => {\n        queryClient.invalidateQueries({ queryKey: ['suggestions', 'all'] });\n      });\n\n    return () => subscription.unsubscribe();\n  }, [queryClient]);\n\n  // Observe interactions table for changes to trigger suggestion regeneration\n  useEffect(() => {\n    const subscription = database\n      .get<Interaction>('interactions')\n      .query()\n      .observe()\n      .subscribe(() => {\n        queryClient.invalidateQueries({ queryKey: ['suggestions', 'all'] });\n      });\n\n    return () => subscription.unsubscribe();\n  }, [queryClient]);\n\n  // Track when suggestions are shown (only track each suggestion once)\n  useEffect(() => {\n    let isMounted = true;\n\n    const trackSuggestions = async () => {\n      const suggestionsToTrack = suggestions.filter(s => !trackedSuggestions.current.has(s.id));\n\n      if (suggestionsToTrack.length === 0) return;\n\n      try {\n        await Promise.all(suggestionsToTrack.map(async (suggestion) => {\n          if (!isMounted) return;\n\n          if (!suggestion.friendId) return; // Portfolio insights might not have friendId\n\n          // Find the friend to get context\n          const friend = await database.get<FriendModel>('friends').find(suggestion.friendId).catch(() => null);\n\n          if (friend) {\n            const currentScore = calculateCurrentScore(friend);\n\n            // Calculate days since last interaction\n            const interactionFriends = await database\n              .get<InteractionFriend>('interaction_friends')\n              .query(Q.where('friend_id', friend.id))\n              .fetch();\n\n            if (!isMounted) return;\n\n            const interactionIds = interactionFriends.map(ifriend => ifriend.interactionId);\n            let daysSinceLastInteraction = 999;\n\n            if (interactionIds.length > 0) {\n              const friendInteractions = await database\n                .get<Interaction>('interactions')\n                .query(\n                  Q.where('id', Q.oneOf(interactionIds)),\n                  Q.where('status', 'completed') // Only include completed interactions\n                )\n                .fetch();\n\n              if (!isMounted) return;\n\n              const sortedInteractions = friendInteractions.sort(\n                (a, b) => {\n                  const timeA = a.interactionDate instanceof Date ? a.interactionDate.getTime() : new Date(a.interactionDate || 0).getTime();\n                  const timeB = b.interactionDate instanceof Date ? b.interactionDate.getTime() : new Date(b.interactionDate || 0).getTime();\n                  return timeB - timeA;\n                }\n              );\n\n              if (sortedInteractions.length > 0 && sortedInteractions[0].interactionDate) {\n                const date = sortedInteractions[0].interactionDate;\n                const time = date instanceof Date ? date.getTime() : new Date(date).getTime();\n                daysSinceLastInteraction = (Date.now() - time) / 86400000;\n              }\n            }\n\n            // Track this suggestion as shown\n            if (isMounted) {\n              await SuggestionTrackerService.trackSuggestionShown(suggestion, {\n                friendScore: currentScore,\n                daysSinceLastInteraction: Math.round(daysSinceLastInteraction),\n              });\n\n              trackedSuggestions.current.add(suggestion.id);\n            }\n          }\n        }));\n      } catch (error) {\n        console.error('Error tracking suggestions:', error);\n      }\n    };\n\n    trackSuggestions();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [suggestions]);\n\n  const invalidateSuggestions = () => {\n    queryClient.invalidateQueries({ queryKey: ['suggestions', 'all'] });\n  };\n\n  const dismissSuggestion = async (id: string, cooldownDays: number) => {\n    // Track the dismissal\n    await SuggestionTrackerService.trackSuggestionDismissed(id);\n\n    // Store the dismissal\n    await SuggestionStorageService.dismissSuggestion(id, cooldownDays);\n\n    invalidateSuggestions();\n  };\n\n  const hasCritical = suggestions.some(s => s.urgency === 'critical');\n\n  return {\n    suggestions,\n    suggestionCount: suggestions.length,\n    hasCritical,\n    dismissSuggestion,\n    invalidateSuggestions\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/__tests__/plan.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/__tests__/suggestion-storage.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/__tests__/suggestion-tracker.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport * as SuggestionTracker from '../suggestion-tracker.service';\nimport { Suggestion } from '@/types/suggestions';\n\n// Mock database\njest.mock('@/db', () => ({\n  database: {\n    write: jest.fn((callback) => callback()),\n    get: jest.fn(),\n  },\n}));\n\ndescribe('SuggestionTrackerService', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('trackSuggestionShown', () => {\n    it('should create a shown event', async () => {\n      const mockCreate = jest.fn();\n      (database.get as jest.Mock).mockReturnValue({\n        create: mockCreate,\n      });\n\n      const suggestion: Suggestion = {\n        id: 's1',\n        friendId: 'f1',\n        friendName: 'Friend',\n        category: 'drift',\n        urgency: 'high',\n        action: { type: 'log' },\n      } as any;\n\n      const context = {\n        friendScore: 50,\n        daysSinceLastInteraction: 10,\n      };\n\n      await SuggestionTracker.trackSuggestionShown(suggestion, context);\n\n      expect(database.get).toHaveBeenCalledWith('suggestion_events');\n      expect(mockCreate).toHaveBeenCalled();\n    });\n  });\n\n  describe('trackSuggestionActed', () => {\n    it('should create an acted event and calculate time to action', async () => {\n      const mockCreate = jest.fn();\n      const mockQuery = jest.fn();\n      const mockFetch = jest.fn();\n\n      // Mock finding the shown event\n      const shownEvent = {\n        eventTimestamp: new Date(Date.now() - 60000 * 30), // 30 mins ago\n        friendId: 'f1',\n        suggestionType: 'drift',\n        urgency: 'high',\n        actionType: 'log',\n      };\n\n      mockFetch.mockResolvedValue([shownEvent]);\n      mockQuery.mockReturnValue({ fetch: mockFetch });\n\n      (database.get as jest.Mock).mockReturnValue({\n        create: mockCreate,\n        query: mockQuery,\n      });\n\n      await SuggestionTracker.trackSuggestionActed('s1');\n\n      expect(mockCreate).toHaveBeenCalledWith(expect.any(Function));\n      // We verify the callback logic by mocking the create function implementation if needed,\n      // but here we just check it was called.\n      // To verify the values passed to the callback, we would need to simulate the model instance passed to it.\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/__tests__/weave-logging.service.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AnalyticsEvents' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'analyzeAndTagLifeEvents' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":33},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":11,"column":3,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":11,"endColumn":60}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport { logWeave, planWeave, deleteWeave } from '../weave-logging.service';\nimport { InteractionFormData } from '@/modules/interactions';\nimport { processWeaveScoring } from '@/modules/intelligence';\nimport { checkAndAwardFriendBadges, checkAndAwardGlobalAchievements, recordPractice } from '@/modules/gamification';\nimport { trackEvent, AnalyticsEvents, updateLastInteractionTimestamp } from '@/shared/services/analytics.service';\nimport { analyzeAndTagLifeEvents } from '@/modules/relationships';\nimport { deleteWeaveCalendarEvent } from '../calendar.service';\n\njest.mock('@react-native-async-storage/async-storage', () =>\n  require('../../../../../__mocks__/async-storage-mock.js')\n);\n\njest.mock('@/db', () => ({\n  database: {\n    get: jest.fn().mockReturnValue({\n      query: jest.fn().mockReturnThis(),\n      fetch: jest.fn(),\n      create: jest.fn(),\n      prepareCreate: jest.fn(),\n      find: jest.fn(),\n      prepareDestroyPermanently: jest.fn(),\n    }),\n    query: jest.fn().mockReturnThis(),\n    fetch: jest.fn(),\n    find: jest.fn(),\n    write: jest.fn(async (fn) => fn()),\n    batch: jest.fn(),\n    create: jest.fn(),\n    prepareDestroyPermanently: jest.fn(),\n  },\n}));\n\njest.mock('@/modules/intelligence', () => ({\n  processWeaveScoring: jest.fn(),\n}));\n\njest.mock('@/modules/gamification', () => ({\n  checkAndAwardFriendBadges: jest.fn(),\n  checkAndAwardGlobalAchievements: jest.fn(),\n  recordPractice: jest.fn(),\n}));\n\njest.mock('@/shared/services/analytics.service', () => ({\n  trackEvent: jest.fn(),\n  AnalyticsEvents: {\n    INTERACTION_LOGGED: 'INTERACTION_LOGGED',\n    INTERACTION_PLANNED: 'INTERACTION_PLANNED',\n  },\n  updateLastInteractionTimestamp: jest.fn(),\n}));\n\njest.mock('@/modules/relationships', () => ({\n  analyzeAndTagLifeEvents: jest.fn(),\n}));\n\njest.mock('../calendar.service', () => ({\n  deleteWeaveCalendarEvent: jest.fn().mockResolvedValue(undefined),\n}));\n\ndescribe('WeaveLoggingService', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should log a new weave and call related services', async () => {\n    const mockFriend = { id: 'friend1', name: 'Test Friend' };\n    const mockInteraction = { id: 'interaction1', activity: 'Test Activity' };\n\n    (database.get as jest.Mock).mockReturnValue({\n      query: jest.fn().mockReturnThis(),\n      fetch: jest.fn().mockResolvedValue([mockFriend]),\n      find: jest.fn().mockResolvedValue({ ...mockFriend, ratedWeavesCount: 2 }), // Mock find for side effects\n      create: jest.fn().mockResolvedValue(mockInteraction),\n      prepareCreate: jest.fn().mockImplementation((fn) => {\n        const mockObj = {\n          ...mockInteraction,\n          interaction: { set: jest.fn() },\n          friend: { set: jest.fn() },\n        };\n        fn(mockObj);\n        return mockObj;\n      }),\n    });\n\n    const formData: InteractionFormData = {\n      friendIds: [mockFriend.id],\n      activity: 'Test Activity',\n      date: new Date(),\n      type: 'log',\n      status: 'completed',\n      mode: 'one-on-one',\n    };\n\n    const interaction = await logWeave(formData);\n\n    expect(interaction).toMatchObject(mockInteraction);\n    expect(database.write).toHaveBeenCalled();\n    expect(database.get).toHaveBeenCalledWith('friends');\n    expect(database.get).toHaveBeenCalledWith('interactions');\n    expect(processWeaveScoring).toHaveBeenCalledWith([mockFriend], formData, expect.anything());\n    expect(checkAndAwardFriendBadges).toHaveBeenCalledWith(mockFriend.id, mockFriend.name);\n    expect(checkAndAwardGlobalAchievements).toHaveBeenCalled();\n    expect(trackEvent).toHaveBeenCalledWith('INTERACTION_LOGGED', expect.any(Object));\n    expect(updateLastInteractionTimestamp).toHaveBeenCalled();\n    expect(recordPractice).toHaveBeenCalledWith('log_weave', mockInteraction.id);\n  });\n\n  it('should throw validation error if data is invalid', async () => {\n    const invalidData: any = {\n      friendIds: [], // Invalid: min(1)\n      activity: '', // Invalid: min(1)\n      date: new Date(),\n      type: 'log',\n      status: 'completed',\n      mode: 'one-on-one',\n    };\n\n    await expect(logWeave(invalidData)).rejects.toThrow(/Invalid weave data/);\n  });\n\n  it('should plan a new weave', async () => {\n    const mockFriend = { id: 'friend1', name: 'Test Friend' };\n    const mockInteraction = { id: 'interaction1', activity: 'Test Plan', status: 'planned' };\n\n    (database.get as jest.Mock).mockReturnValue({\n      query: jest.fn().mockReturnThis(),\n      fetch: jest.fn().mockResolvedValue([mockFriend]),\n      create: jest.fn().mockResolvedValue(mockInteraction),\n      prepareCreate: jest.fn().mockImplementation((fn) => {\n        const mockObj = {\n          ...mockInteraction,\n          interaction: { set: jest.fn() },\n          friend: { set: jest.fn() },\n        };\n        fn(mockObj);\n        return mockObj;\n      }),\n    });\n\n    const formData: InteractionFormData = {\n      friendIds: [mockFriend.id],\n      activity: 'Test Plan',\n      date: new Date(),\n      type: 'plan',\n      status: 'planned',\n      mode: 'one-on-one',\n    };\n\n    const interaction = await planWeave(formData);\n\n    expect(interaction).toMatchObject(mockInteraction);\n    expect(database.write).toHaveBeenCalled();\n    expect(database.get).toHaveBeenCalledWith('friends');\n    expect(database.get).toHaveBeenCalledWith('interactions');\n    expect(trackEvent).toHaveBeenCalledWith('INTERACTION_PLANNED', expect.any(Object));\n  });\n\n  it('should delete a weave and its calendar event', async () => {\n    const mockInteraction = {\n      id: 'interaction1',\n      calendarEventId: 'cal123',\n      prepareDestroyPermanently: jest.fn(),\n    };\n    const mockInteractionFriend = { prepareDestroyPermanently: jest.fn() };\n\n    (database.get as jest.Mock).mockReturnValue({\n      find: jest.fn().mockResolvedValue(mockInteraction),\n      query: jest.fn().mockReturnThis(),\n      fetch: jest.fn().mockResolvedValue([mockInteractionFriend]),\n    });\n\n    await deleteWeave(mockInteraction.id);\n\n    expect(database.get).toHaveBeenCalledWith('interactions');\n    expect(database.get).toHaveBeenCalledWith('interaction_friends');\n    expect(database.write).toHaveBeenCalled();\n    expect(database.batch).toHaveBeenCalledWith(\n      mockInteractionFriend.prepareDestroyPermanently(),\n      mockInteraction.prepareDestroyPermanently()\n    );\n    expect(deleteWeaveCalendarEvent).toHaveBeenCalledWith('cal123');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/calendar-export.service.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":13,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Share, Platform } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\nimport { database } from '@/db';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\n\n// Dynamically import expo-sharing if available\nlet Sharing: any = null;\ntry {\n  Sharing = require('expo-sharing');\n} catch (error) {\n  console.log('expo-sharing not available, using fallback Share API');\n}\n\n/**\n * ICS Calendar Export Service\n *\n * Generates .ics (iCalendar) files from Weave interactions for sharing\n * via SMS, WhatsApp, Email, or any other app.\n */\n\n// --- Types ---\n\nexport interface ICSEvent {\n  title: string;\n  description: string;\n  location?: string;\n  startDate: Date;\n  endDate: Date;\n  allDay: boolean;\n}\n\n// --- Helper Functions ---\n\n/**\n * Formats a date for ICS format: YYYYMMDDTHHmmssZ\n * ICS spec requires UTC times in this exact format\n */\nfunction formatICSDate(date: Date, allDay: boolean = false): string {\n  if (allDay) {\n    // All-day events use VALUE=DATE format: YYYYMMDD\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}${month}${day}`;\n  }\n\n  // Convert to UTC for timed events\n  const utcDate = new Date(date.getTime());\n  const year = utcDate.getUTCFullYear();\n  const month = String(utcDate.getUTCMonth() + 1).padStart(2, '0');\n  const day = String(utcDate.getUTCDate()).padStart(2, '0');\n  const hours = String(utcDate.getUTCHours()).padStart(2, '0');\n  const minutes = String(utcDate.getUTCMinutes()).padStart(2, '0');\n  const seconds = String(utcDate.getUTCSeconds()).padStart(2, '0');\n\n  return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;\n}\n\n/**\n * Escapes text for ICS format\n * Special characters like newlines, commas, and semicolons must be escaped\n */\nfunction escapeICSText(text: string): string {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')  // Escape backslashes\n    .replace(/;/g, '\\\\;')    // Escape semicolons\n    .replace(/,/g, '\\\\,')    // Escape commas\n    .replace(/\\n/g, '\\\\n');  // Escape newlines\n}\n\n/**\n * Folds long lines to 75 characters (ICS spec requirement)\n * Lines should be broken with CRLF + space\n */\nfunction foldICSLine(line: string): string {\n  if (line.length <= 75) return line;\n\n  const lines: string[] = [];\n  let currentLine = line;\n\n  while (currentLine.length > 75) {\n    lines.push(currentLine.substring(0, 75));\n    currentLine = ' ' + currentLine.substring(75); // Continuation lines start with space\n  }\n  lines.push(currentLine);\n\n  return lines.join('\\r\\n');\n}\n\n/**\n * Generates a unique UID for the event\n * Format: timestamp-randomhex@weave.app\n */\nfunction generateUID(): string {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 15);\n  return `${timestamp}-${random}@weave.app`;\n}\n\n/**\n * Gets friend names for an interaction from the database\n */\nasync function getFriendNamesForInteraction(interactionId: string): Promise<string[]> {\n  const interactionFriends = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('interaction_id', interactionId))\n    .fetch();\n\n  const friendIds = interactionFriends.map((f) => f.friendId);\n  const friends = await database\n    .get<FriendModel>('friends')\n    .query(Q.where('id', Q.oneOf(friendIds)))\n    .fetch();\n\n  return friends.map((f) => f.name);\n}\n\n// --- Core ICS Generation ---\n\n/**\n * Generates ICS file content from an event object\n */\nfunction generateICSContent(event: ICSEvent): string {\n  const uid = generateUID();\n  const now = formatICSDate(new Date());\n  const startDate = formatICSDate(event.startDate, event.allDay);\n  const endDate = formatICSDate(event.endDate, event.allDay);\n\n  // Build the ICS content line by line\n  const lines: string[] = [\n    'BEGIN:VCALENDAR',\n    'VERSION:2.0',\n    'PRODID:-//Weave//Weave Calendar//EN',\n    'CALSCALE:GREGORIAN',\n    'METHOD:PUBLISH',\n    'BEGIN:VEVENT',\n    `UID:${uid}`,\n    `DTSTAMP:${now}`,\n  ];\n\n  // Add date fields with proper format\n  if (event.allDay) {\n    lines.push(`DTSTART;VALUE=DATE:${startDate}`);\n    lines.push(`DTEND;VALUE=DATE:${endDate}`);\n  } else {\n    lines.push(`DTSTART:${startDate}`);\n    lines.push(`DTEND:${endDate}`);\n  }\n\n  // Add required fields\n  lines.push(foldICSLine(`SUMMARY:${escapeICSText(event.title)}`));\n  lines.push(foldICSLine(`DESCRIPTION:${escapeICSText(event.description)}`));\n\n  // Add optional fields\n  if (event.location) {\n    lines.push(foldICSLine(`LOCATION:${escapeICSText(event.location)}`));\n  }\n\n  lines.push('STATUS:CONFIRMED');\n  lines.push('SEQUENCE:0');\n  lines.push('END:VEVENT');\n  lines.push('END:VCALENDAR');\n\n  // ICS files must use CRLF line endings\n  return lines.join('\\r\\n');\n}\n\n/**\n * Generates ICS content from a Weave Interaction\n */\nexport async function generateICSFromInteraction(interaction: Interaction): Promise<string> {\n  // Get friend names\n  const friendNames = await getFriendNamesForInteraction(interaction.id);\n  const friendsText = friendNames.join(', ');\n\n  // Determine if this is an all-day event\n  const startDate = new Date(interaction.interactionDate);\n  const hasTime = startDate.getHours() !== 0 || startDate.getMinutes() !== 0;\n  const allDay = !hasTime;\n\n  // Calculate end time (2 hours later for timed events, same day for all-day)\n  const endDate = allDay\n    ? new Date(startDate)\n    : new Date(startDate.getTime() + 2 * 60 * 60 * 1000);\n\n  // Build title\n  const title = interaction.title\n    ? `🧵 Weave: ${interaction.title}`\n    : `🧵 Weave with ${friendsText} - ${interaction.activity}`;\n\n  // Build description\n  let description = `Planned weave with ${friendsText}\\n\\n`;\n  description += `Activity: ${interaction.activity}\\n`;\n\n  if (interaction.location) {\n    description += `Location: ${interaction.location}\\n`;\n  }\n\n  if (interaction.note) {\n    description += `\\nNotes:\\n${interaction.note}\\n`;\n  }\n\n  description += '\\n---\\nCreated by Weave';\n\n  // Generate ICS\n  return generateICSContent({\n    title,\n    description,\n    location: interaction.location || undefined,\n    startDate,\n    endDate,\n    allDay,\n  });\n}\n\n// --- Sharing Functions ---\n\n/**\n * Shares an interaction as an ICS file via the native share sheet\n * Works on both iOS and Android\n */\nexport async function shareInteractionAsICS(interaction: Interaction): Promise<boolean> {\n  try {\n    // Generate ICS content\n    const icsContent = await generateICSFromInteraction(interaction);\n\n    // Get friend names for the filename\n    const friendNames = await getFriendNamesForInteraction(interaction.id);\n    const friendsSlug = friendNames.join('-').replace(/[^a-zA-Z0-9-]/g, '').toLowerCase();\n    const dateSlug = interaction.interactionDate.toISOString().split('T')[0];\n    const filename = `weave-${friendsSlug}-${dateSlug}.ics`;\n\n    // Check if expo-sharing is available and can share\n    const canUseExpoSharing = Sharing && await Sharing.isAvailableAsync();\n\n    if (canUseExpoSharing) {\n      // Use Expo Sharing API (better for files)\n      const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n      await FileSystem.writeAsStringAsync(fileUri, icsContent, {\n        encoding: FileSystem.EncodingType.UTF8,\n      });\n\n      await Sharing.shareAsync(fileUri, {\n        mimeType: 'text/calendar',\n        dialogTitle: 'Share Weave Plan',\n        UTI: 'public.calendar-event', // iOS UTI for calendar events\n      });\n\n      return true;\n    } else {\n      // Fallback to React Native Share API\n      // On iOS we can share the ICS content directly\n      // On Android we share a formatted text version\n      const result = await Share.share(\n        Platform.OS === 'ios'\n          ? {\n              message: icsContent,\n              title: 'Share Weave Plan',\n            }\n          : {\n              message: `Here's our plan:\\n\\n${interaction.title || interaction.activity}\\nDate: ${interaction.interactionDate.toLocaleDateString()}\\n${interaction.location ? `Location: ${interaction.location}\\n` : ''}`,\n              title: 'Share Weave Plan',\n            }\n      );\n\n      return result.action === Share.sharedAction;\n    }\n  } catch (error) {\n    console.error('Error sharing interaction as ICS:', error);\n    return false;\n  }\n}\n\n/**\n * Generates and returns the ICS file URI for an interaction\n * Useful if you want to store or process the file separately\n */\nexport async function generateICSFile(interaction: Interaction): Promise<string | null> {\n  try {\n    const icsContent = await generateICSFromInteraction(interaction);\n\n    const friendNames = await getFriendNamesForInteraction(interaction.id);\n    const friendsSlug = friendNames.join('-').replace(/[^a-zA-Z0-9-]/g, '').toLowerCase();\n    const dateSlug = interaction.interactionDate.toISOString().split('T')[0];\n    const filename = `weave-${friendsSlug}-${dateSlug}.ics`;\n\n    const fileUri = `${FileSystem.cacheDirectory}${filename}`;\n    await FileSystem.writeAsStringAsync(fileUri, icsContent, {\n      encoding: FileSystem.EncodingType.UTF8,\n    });\n\n    return fileUri;\n  } catch (error) {\n    console.error('Error generating ICS file:', error);\n    return null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/calendar.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":261,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":261,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as Calendar from 'expo-calendar';\nimport { Linking, Alert } from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { database } from '@/db';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\n\nconst CALENDAR_SETTINGS_KEY = '@weave_calendar_settings';\n\n// --- Types ---\n\nexport interface CalendarSettings {\n  enabled: boolean;\n  calendarId: string | null;\n  reminderMinutes: number;\n  twoWaySync: boolean;\n}\n\nconst DEFAULT_SETTINGS: CalendarSettings = {\n  enabled: false,\n  calendarId: null,\n  reminderMinutes: 60,\n  twoWaySync: true,\n};\n\nexport interface CalendarSyncResult {\n  synced: number;\n  deleted: number;\n  errors: number;\n  changes: CalendarChange[];\n}\n\nexport interface CalendarChange {\n  interactionId: string;\n  friendNames: string;\n  changeType: 'updated' | 'deleted';\n  fields: string[];\n}\n\n\n// --- Permissions and Settings ---\n\nexport async function checkCalendarPermissions(): Promise<{ granted: boolean; canAskAgain: boolean; }> {\n  try {\n    const { status, canAskAgain } = await Calendar.getCalendarPermissionsAsync();\n    return { granted: status === 'granted', canAskAgain: canAskAgain !== false };\n  } catch (error) {\n    console.error('Error checking calendar permissions:', error);\n    return { granted: false, canAskAgain: true };\n  }\n}\n\nexport async function requestCalendarPermissions(): Promise<boolean> {\n  try {\n    const currentStatus = await checkCalendarPermissions();\n    if (currentStatus.granted) return true;\n\n    if (!currentStatus.canAskAgain) {\n      Alert.alert(\n        'Calendar Permission Required',\n        'Please enable calendar access in your device Settings.',\n        [\n          { text: 'Cancel', style: 'cancel' },\n          { text: 'Open Settings', onPress: () => Linking.openSettings() },\n        ]\n      );\n      return false;\n    }\n\n    const { status } = await Calendar.requestCalendarPermissionsAsync();\n    return status === 'granted';\n  } catch (error) {\n    console.error('Error requesting calendar permissions:', error);\n    return false;\n  }\n}\n\nexport async function getCalendarSettings(): Promise<CalendarSettings> {\n  try {\n    const settings = await AsyncStorage.getItem(CALENDAR_SETTINGS_KEY);\n    return settings ? JSON.parse(settings) : DEFAULT_SETTINGS;\n  } catch (error) {\n    console.error('Error loading calendar settings:', error);\n    return DEFAULT_SETTINGS;\n  }\n}\n\nexport async function saveCalendarSettings(settings: CalendarSettings): Promise<void> {\n  try {\n    await AsyncStorage.setItem(CALENDAR_SETTINGS_KEY, JSON.stringify(settings));\n  } catch (error) {\n    console.error('Error saving calendar settings:', error);\n  }\n}\n\nexport async function getAvailableCalendars(): Promise<Calendar.Calendar[]> {\n  try {\n    const hasPermission = await requestCalendarPermissions();\n    if (!hasPermission) return [];\n\n    const calendars = await Calendar.getCalendarsAsync(Calendar.EntityTypes.EVENT);\n    return calendars.filter(cal => cal.allowsModifications);\n  } catch (error) {\n    console.error('Error fetching calendars:', error);\n    return [];\n  }\n}\n\n// --- Event Management ---\n\nasync function getDefaultCalendarId(): Promise<string | null> {\n  const settings = await getCalendarSettings();\n  if (settings.calendarId) return settings.calendarId;\n\n  const calendars = await getAvailableCalendars();\n  if (calendars.length === 0) return null;\n\n  const defaultCal = calendars.find(cal => cal.isPrimary) || calendars[0];\n  return defaultCal.id;\n}\n\nexport async function createWeaveCalendarEvent(params: {\n  title: string;\n  friendNames: string;\n  category: string;\n  date: Date;\n  location?: string;\n  notes?: string;\n}): Promise<string | null> {\n  try {\n    const settings = await getCalendarSettings();\n    if (!settings.enabled) return null;\n\n    const hasPermission = await requestCalendarPermissions();\n    if (!hasPermission) return null;\n\n    const calendarId = await getDefaultCalendarId();\n    if (!calendarId) return null;\n\n    const startDate = new Date(params.date);\n    const hasTime = startDate.getHours() !== 0 || startDate.getMinutes() !== 0;\n\n    const eventTitle = `🧵 Weave with ${params.friendNames} - ${params.title || params.category}`;\n    const eventNotes = `📅 Planned weave with ${params.friendNames}\\n\\nActivity: ${params.category}\\nLocation: ${params.location || 'N/A'}\\n\\nNotes:\\n${params.notes || ''}\\n\\n---\\nCreated by Weave`;\n\n    const eventDetails: Partial<Calendar.Event> = {\n      title: eventTitle,\n      startDate,\n      endDate: hasTime ? new Date(startDate.getTime() + 2 * 60 * 60 * 1000) : startDate,\n      notes: eventNotes,\n      location: params.location || '',\n      allDay: !hasTime,\n      alarms: settings.reminderMinutes > 0 && hasTime ? [{ relativeOffset: -settings.reminderMinutes }] : [],\n    };\n\n    const eventId = await Calendar.createEventAsync(calendarId, eventDetails);\n    return eventId;\n  } catch (error) {\n    console.error('Error creating calendar event:', error);\n    return null;\n  }\n}\n\nexport async function updateWeaveCalendarEvent(eventId: string, params: { title?: string; date?: Date; location?: string; notes?: string; }): Promise<boolean> {\n  try {\n    const settings = await getCalendarSettings();\n    if (!settings.enabled) return false;\n\n    await Calendar.updateEventAsync(eventId, params);\n    return true;\n  } catch (error) {\n    console.error('Error updating calendar event:', error);\n    return false;\n  }\n}\n\nexport async function deleteWeaveCalendarEvent(eventId: string): Promise<boolean> {\n  try {\n    await Calendar.deleteEventAsync(eventId);\n    return true;\n  } catch (error) {\n    console.error('Error deleting calendar event:', error);\n    return false;\n  }\n}\n\n// --- Two-Way Sync ---\n\nfunction detectChanges(calendarEvent: Calendar.Event, interaction: Interaction): { hasChanges: boolean; fields: string[] } {\n  const fields: string[] = [];\n  const calEventDate = new Date(calendarEvent.startDate);\n  const interactionDate = new Date(interaction.interactionDate);\n\n  if (Math.abs(calEventDate.getTime() - interactionDate.getTime()) > 60000) {\n    fields.push('date');\n  }\n  if ((calendarEvent.location || '').trim() !== (interaction.location || '').trim()) {\n    fields.push('location');\n  }\n\n  return { hasChanges: fields.length > 0, fields };\n}\n\nasync function getFriendNamesForInteraction(interactionId: string): Promise<string> {\n  const interactionFriends = await database.get<InteractionFriend>('interaction_friends').query(Q.where('interaction_id', interactionId)).fetch();\n  const friendIds = interactionFriends.map((f) => f.friendId);\n  const friends = await database.get<FriendModel>('friends').query(Q.where('id', Q.oneOf(friendIds))).fetch();\n  return friends.map((f) => f.name).join(', ');\n}\n\nlet isSyncing = false;\n\nexport async function syncCalendarChanges(): Promise<CalendarSyncResult> {\n  if (isSyncing) {\n    console.log('[CalendarService] Sync already in progress, skipping.');\n    return { synced: 0, deleted: 0, errors: 0, changes: [] };\n  }\n\n  isSyncing = true;\n  const result: CalendarSyncResult = { synced: 0, deleted: 0, errors: 0, changes: [] };\n\n  try {\n    const settings = await getCalendarSettings();\n    if (!settings.enabled || !settings.twoWaySync) return result;\n\n    const hasPermission = await checkCalendarPermissions();\n    if (!hasPermission.granted) return result;\n\n    const plannedInteractions = await database.get<Interaction>('interactions').query(\n      Q.where('status', Q.oneOf(['planned', 'pending_confirm'])),\n      Q.where('calendar_event_id', Q.notEq(null))\n    ).fetch();\n\n    const batchOps: any[] = [];\n\n    // Prepare all updates first (outside of write transaction)\n    for (const interaction of plannedInteractions) {\n      const calendarEventId = interaction.calendarEventId;\n      if (!calendarEventId) continue;\n\n      try {\n        const calendarEvent = await Calendar.getEventAsync(calendarEventId);\n        const { hasChanges, fields } = detectChanges(calendarEvent, interaction);\n\n        if (hasChanges) {\n          batchOps.push(interaction.prepareUpdate((i) => {\n            if (fields.includes('date')) i.interactionDate = new Date(calendarEvent.startDate);\n            if (fields.includes('location')) i.location = calendarEvent.location || '';\n          }));\n\n          result.synced++;\n          result.changes.push({\n            interactionId: interaction.id,\n            friendNames: await getFriendNamesForInteraction(interaction.id),\n            changeType: 'updated',\n            fields,\n          });\n        }\n      } catch (error) {\n        // Assuming error means event was deleted\n        batchOps.push(interaction.prepareUpdate((i) => { i.status = 'cancelled'; }));\n\n        result.deleted++;\n        result.changes.push({\n          interactionId: interaction.id,\n          friendNames: await getFriendNamesForInteraction(interaction.id),\n          changeType: 'deleted',\n          fields: [],\n        });\n      }\n    }\n\n    // Execute all updates in a single batch\n    if (batchOps.length > 0) {\n      await database.write(async () => {\n        await database.batch(batchOps);\n      });\n    }\n\n  } catch (error) {\n    console.error('[CalendarService] Error during sync:', error);\n    result.errors++;\n  } finally {\n    isSyncing = false;\n  }\n\n  return result;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/event-scanner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/event-suggestion-learning.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FriendModel' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pattern' is defined but never used. Allowed unused args must match /^_/u.","line":331,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":331,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Event Suggestion Learning System\n *\n * Learns from user feedback to improve calendar event suggestions over time.\n * Tracks dismissals, corrections, and patterns to become more intelligent.\n */\n\nimport { database } from '@/db';\nimport EventSuggestionFeedback from '@/db/models/EventSuggestionFeedback';\nimport FriendModel from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\nimport type { ScannedEvent } from './event-scanner';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst SNOOZE_STORAGE_KEY = '@weave_event_suggestion_snoozes';\n\nexport interface SnoozeConfig {\n  friendId?: string; // Snooze specific friend\n  eventPattern?: string; // Snooze events matching pattern (e.g., \"Team Lunch\")\n  until: number; // Timestamp when snooze expires\n  type: 'friend' | 'event-pattern' | 'all';\n}\n\nexport interface LearningInsights {\n  // Dismissal patterns\n  frequentlyDismissedFriends: string[]; // Friend IDs user often dismisses\n  frequentlyDismissedEventPatterns: string[]; // Event titles user often dismisses\n\n  // Correction patterns\n  friendCorrectionRate: Record<string, number>; // How often user corrects each friend\n  categoryCorrectionRate: Record<string, number>; // How often user corrects each category\n\n  // Acceptance patterns\n  preferredEventTypes: string[]; // Event types user accepts most\n  preferredFriends: string[]; // Friends user accepts most\n\n  // Overall metrics\n  totalSuggestions: number;\n  acceptanceRate: number;\n  correctionRate: number;\n  dismissalRate: number;\n}\n\n/**\n * Check if an event should be filtered based on learned patterns\n */\nexport async function shouldFilterEvent(event: ScannedEvent): Promise<{\n  shouldFilter: boolean;\n  reason?: string;\n}> {\n  try {\n    // Check for active snoozes\n    const snoozesStr = await AsyncStorage.getItem(SNOOZE_STORAGE_KEY);\n    if (snoozesStr) {\n      const snoozes: SnoozeConfig[] = JSON.parse(snoozesStr);\n      const now = Date.now();\n\n      // Remove expired snoozes\n      const activeSnoozes = snoozes.filter(s => s.until > now);\n      if (activeSnoozes.length !== snoozes.length) {\n        await AsyncStorage.setItem(SNOOZE_STORAGE_KEY, JSON.stringify(activeSnoozes));\n      }\n\n      // Check if event matches any active snooze\n      for (const snooze of activeSnoozes) {\n        if (snooze.type === 'all') {\n          return { shouldFilter: true, reason: 'all-snoozed' };\n        }\n\n        if (snooze.type === 'friend' && snooze.friendId) {\n          const friendMatch = event.matchedFriends.some(m => m.friend.id === snooze.friendId);\n          if (friendMatch) {\n            return { shouldFilter: true, reason: `friend-snoozed:${snooze.friendId}` };\n          }\n        }\n\n        if (snooze.type === 'event-pattern' && snooze.eventPattern) {\n          const patternMatch = event.title.toLowerCase().includes(snooze.eventPattern.toLowerCase());\n          if (patternMatch) {\n            return { shouldFilter: true, reason: `pattern-snoozed:${snooze.eventPattern}` };\n          }\n        }\n      }\n    }\n\n    // Check dismissal history\n    const dismissalCount = await database\n      .get<EventSuggestionFeedback>('event_suggestion_feedback')\n      .query(\n        Q.where('calendar_event_id', event.id),\n        Q.where('action', 'dismissed')\n      )\n      .fetchCount();\n\n    if (dismissalCount >= 3) {\n      return { shouldFilter: true, reason: 'frequently-dismissed' };\n    }\n\n    // Check if event title matches frequently dismissed patterns\n    const recentDismissals = await database\n      .get<EventSuggestionFeedback>('event_suggestion_feedback')\n      .query(\n        Q.where('action', 'dismissed'),\n        Q.where('dismissal_reason', 'not-relevant'),\n        Q.sortBy('created_at', Q.desc),\n        Q.take(50)\n      )\n      .fetch();\n\n    // Look for similar event titles\n    const similarDismissals = recentDismissals.filter(d => {\n      const similarity = calculateTitleSimilarity(d.eventTitle, event.title);\n      return similarity > 0.7;\n    });\n\n    if (similarDismissals.length >= 3) {\n      return { shouldFilter: true, reason: 'similar-events-dismissed' };\n    }\n\n    // Check friend dismissal patterns\n    for (const match of event.matchedFriends) {\n      const friendDismissals = await database\n        .get<EventSuggestionFeedback>('event_suggestion_feedback')\n        .query(\n          Q.where('action', 'dismissed'),\n          Q.where('suggested_friend_ids', Q.like(`%${match.friend.id}%`))\n        )\n        .fetchCount();\n\n      const friendAcceptances = await database\n        .get<EventSuggestionFeedback>('event_suggestion_feedback')\n        .query(\n          Q.where('action', Q.oneOf(['accepted', 'corrected'])),\n          Q.where('suggested_friend_ids', Q.like(`%${match.friend.id}%`))\n        )\n        .fetchCount();\n\n      const totalFriendSuggestions = friendDismissals + friendAcceptances;\n      if (totalFriendSuggestions >= 5 && friendDismissals / totalFriendSuggestions > 0.8) {\n        return { shouldFilter: true, reason: `friend-low-acceptance:${match.friend.id}` };\n      }\n    }\n\n    return { shouldFilter: false };\n  } catch (error) {\n    console.error('[Learning] Error checking filters:', error);\n    return { shouldFilter: false };\n  }\n}\n\n/**\n * Detect if event has ambiguous title that needs friend selection\n */\nexport function isAmbiguousEvent(event: ScannedEvent): boolean {\n  const ambiguousPatterns = [\n    /\\b(friends?|team|group|everyone|folks|gang|crew|squad)\\b/i,\n    /\\b(dinner|lunch|coffee|drinks?) party\\b/i,\n    /\\b(happy hour|get-together|hangout|meetup)\\b/i,\n  ];\n\n  // Check if title matches ambiguous patterns\n  const hasAmbiguousPattern = ambiguousPatterns.some(pattern =>\n    pattern.test(event.title)\n  );\n\n  // And has no specific friend matches\n  const hasNoMatches = event.matchedFriends.length === 0;\n\n  return hasAmbiguousPattern && hasNoMatches;\n}\n\n/**\n * Record user feedback for a suggestion\n */\nexport async function recordFeedback(params: {\n  event: ScannedEvent;\n  action: 'accepted' | 'dismissed' | 'corrected' | 'snoozed';\n  dismissalReason?: 'wrong-friends' | 'not-social' | 'already-logged' | 'not-relevant';\n  correctedFriendIds?: string[];\n  correctedCategory?: string;\n  snoozeConfig?: SnoozeConfig;\n  emotionalRating?: number;\n  reflectionNotes?: string;\n  resultingInteractionId?: string;\n}): Promise<void> {\n  const {\n    event,\n    action,\n    dismissalReason,\n    correctedFriendIds,\n    correctedCategory,\n    snoozeConfig,\n    emotionalRating,\n    reflectionNotes,\n    resultingInteractionId,\n  } = params;\n\n  try {\n    await database.write(async () => {\n      await database.get<EventSuggestionFeedback>('event_suggestion_feedback').create((feedback) => {\n        feedback.calendarEventId = event.id;\n        feedback.eventTitle = event.title;\n        feedback.eventDate = event.startDate;\n        feedback.eventLocation = event.location;\n\n        feedback.suggestedFriendIds = event.matchedFriends.map(m => m.friend.id);\n        feedback.suggestedCategory = event.suggestedCategory;\n\n        feedback.action = action;\n        feedback.dismissalReason = dismissalReason;\n\n        feedback.correctedFriendIds = correctedFriendIds;\n        feedback.correctedCategory = correctedCategory;\n\n        if (snoozeConfig) {\n          feedback.snoozedUntil = new Date(snoozeConfig.until);\n          feedback.snoozeType = snoozeConfig.type;\n          if (snoozeConfig.friendId) {\n            feedback.snoozedFriendIds = [snoozeConfig.friendId];\n          }\n        }\n\n        feedback.emotionalRating = emotionalRating;\n        feedback.reflectionNotes = reflectionNotes;\n        feedback.resultingInteractionId = resultingInteractionId;\n\n        // Calculate confidence and match quality\n        feedback.confidenceScore = event.confidence;\n        feedback.matchQuality = event.matchedFriends.length > 0\n          ? event.matchedFriends.reduce((sum, m) => sum + m.confidence, 0) / event.matchedFriends.length\n          : 0;\n\n        feedback.suggestedAt = new Date();\n        feedback.respondedAt = new Date();\n      });\n    });\n\n    // If snoozing, store in AsyncStorage for quick access\n    if (action === 'snoozed' && snoozeConfig) {\n      const snoozesStr = await AsyncStorage.getItem(SNOOZE_STORAGE_KEY);\n      const snoozes: SnoozeConfig[] = snoozesStr ? JSON.parse(snoozesStr) : [];\n      snoozes.push(snoozeConfig);\n      await AsyncStorage.setItem(SNOOZE_STORAGE_KEY, JSON.stringify(snoozes));\n    }\n\n    console.log(`[Learning] Recorded ${action} feedback for event: ${event.title}`);\n  } catch (error) {\n    console.error('[Learning] Error recording feedback:', error);\n  }\n}\n\n/**\n * Get learning insights from historical feedback\n */\nexport async function getLearningInsights(): Promise<LearningInsights> {\n  try {\n    const allFeedback = await database\n      .get<EventSuggestionFeedback>('event_suggestion_feedback')\n      .query()\n      .fetch();\n\n    const totalSuggestions = allFeedback.length;\n    const accepted = allFeedback.filter(f => f.action === 'accepted').length;\n    const corrected = allFeedback.filter(f => f.action === 'corrected').length;\n    const dismissed = allFeedback.filter(f => f.action === 'dismissed').length;\n\n    // Analyze dismissal patterns\n    const dismissedFeedback = allFeedback.filter(f => f.action === 'dismissed');\n    const friendDismissalCounts: Record<string, number> = {};\n    const eventPatternDismissalCounts: Record<string, number> = {};\n\n    for (const feedback of dismissedFeedback) {\n      // Track friend dismissals\n      for (const friendId of feedback.suggestedFriendIds) {\n        friendDismissalCounts[friendId] = (friendDismissalCounts[friendId] || 0) + 1;\n      }\n\n      // Track event pattern dismissals\n      const pattern = extractEventPattern(feedback.eventTitle);\n      if (pattern) {\n        eventPatternDismissalCounts[pattern] = (eventPatternDismissalCounts[pattern] || 0) + 1;\n      }\n    }\n\n    // Analyze correction patterns\n    const correctedFeedback = allFeedback.filter(f => f.action === 'corrected');\n    const friendCorrectionCounts: Record<string, number> = {};\n    const categoryCorrectionCounts: Record<string, number> = {};\n\n    for (const feedback of correctedFeedback) {\n      if (feedback.correctedFriendIds && feedback.correctedFriendIds.length > 0) {\n        for (const friendId of feedback.suggestedFriendIds) {\n          if (!feedback.correctedFriendIds.includes(friendId)) {\n            friendCorrectionCounts[friendId] = (friendCorrectionCounts[friendId] || 0) + 1;\n          }\n        }\n      }\n\n      if (feedback.correctedCategory && feedback.correctedCategory !== feedback.suggestedCategory) {\n        const originalCategory = feedback.suggestedCategory || 'unknown';\n        categoryCorrectionCounts[originalCategory] = (categoryCorrectionCounts[originalCategory] || 0) + 1;\n      }\n    }\n\n    // Calculate rates\n    const friendCorrectionRate: Record<string, number> = {};\n    for (const friendId in friendCorrectionCounts) {\n      const totalForFriend = allFeedback.filter(f =>\n        f.suggestedFriendIds.includes(friendId)\n      ).length;\n      friendCorrectionRate[friendId] = friendCorrectionCounts[friendId] / totalForFriend;\n    }\n\n    const categoryCorrectionRate: Record<string, number> = {};\n    for (const category in categoryCorrectionCounts) {\n      const totalForCategory = allFeedback.filter(f =>\n        f.suggestedCategory === category\n      ).length;\n      categoryCorrectionRate[category] = categoryCorrectionCounts[category] / totalForCategory;\n    }\n\n    // Find frequently dismissed friends/patterns (>50% dismissal rate with at least 3 suggestions)\n    const frequentlyDismissedFriends = Object.entries(friendDismissalCounts)\n      .filter(([friendId, count]) => {\n        const total = allFeedback.filter(f => f.suggestedFriendIds.includes(friendId)).length;\n        return total >= 3 && count / total > 0.5;\n      })\n      .map(([friendId]) => friendId);\n\n    const frequentlyDismissedEventPatterns = Object.entries(eventPatternDismissalCounts)\n      .filter(([pattern, count]) => count >= 3)\n      .map(([pattern]) => pattern);\n\n    // Analyze acceptance patterns\n    const acceptedFeedback = allFeedback.filter(f => f.action === 'accepted' || f.action === 'corrected');\n    const friendAcceptanceCounts: Record<string, number> = {};\n    const eventTypeAcceptanceCounts: Record<string, number> = {};\n\n    for (const feedback of acceptedFeedback) {\n      for (const friendId of feedback.suggestedFriendIds) {\n        friendAcceptanceCounts[friendId] = (friendAcceptanceCounts[friendId] || 0) + 1;\n      }\n\n      const eventType = extractEventPattern(feedback.eventTitle);\n      if (eventType) {\n        eventTypeAcceptanceCounts[eventType] = (eventTypeAcceptanceCounts[eventType] || 0) + 1;\n      }\n    }\n\n    const preferredFriends = Object.entries(friendAcceptanceCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([friendId]) => friendId);\n\n    const preferredEventTypes = Object.entries(eventTypeAcceptanceCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([type]) => type);\n\n    return {\n      frequentlyDismissedFriends,\n      frequentlyDismissedEventPatterns,\n      friendCorrectionRate,\n      categoryCorrectionRate,\n      preferredEventTypes,\n      preferredFriends,\n      totalSuggestions,\n      acceptanceRate: totalSuggestions > 0 ? accepted / totalSuggestions : 0,\n      correctionRate: totalSuggestions > 0 ? corrected / totalSuggestions : 0,\n      dismissalRate: totalSuggestions > 0 ? dismissed / totalSuggestions : 0,\n    };\n  } catch (error) {\n    console.error('[Learning] Error getting insights:', error);\n    return {\n      frequentlyDismissedFriends: [],\n      frequentlyDismissedEventPatterns: [],\n      friendCorrectionRate: {},\n      categoryCorrectionRate: {},\n      preferredEventTypes: [],\n      preferredFriends: [],\n      totalSuggestions: 0,\n      acceptanceRate: 0,\n      correctionRate: 0,\n      dismissalRate: 0,\n    };\n  }\n}\n\n/**\n * Calculate similarity between two event titles\n */\nfunction calculateTitleSimilarity(title1: string, title2: string): number {\n  const words1 = new Set(title1.toLowerCase().split(/\\s+/));\n  const words2 = new Set(title2.toLowerCase().split(/\\s+/));\n\n  const intersection = new Set([...words1].filter(w => words2.has(w)));\n  const union = new Set([...words1, ...words2]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Extract a normalized event pattern from title\n */\nfunction extractEventPattern(title: string): string | null {\n  // Remove dates, times, and common noise words\n  let pattern = title.toLowerCase()\n    .replace(/\\d+:\\d+\\s*(am|pm)?/gi, '')\n    .replace(/\\b(at|on|in|with|for)\\b/gi, '')\n    .trim();\n\n  // Remove names (simple heuristic: capitalized words)\n  pattern = pattern.split(' ')\n    .filter(word => word === word.toLowerCase())\n    .join(' ')\n    .trim();\n\n  return pattern.length > 0 ? pattern : null;\n}\n\n/**\n * Clear all snoozes (for testing or user request)\n */\nexport async function clearAllSnoozes(): Promise<void> {\n  await AsyncStorage.removeItem(SNOOZE_STORAGE_KEY);\n  console.log('[Learning] Cleared all snoozes');\n}\n\n/**\n * Get active snoozes\n */\nexport async function getActiveSnoozes(): Promise<SnoozeConfig[]> {\n  const snoozesStr = await AsyncStorage.getItem(SNOOZE_STORAGE_KEY);\n  if (!snoozesStr) return [];\n\n  const snoozes: SnoozeConfig[] = JSON.parse(snoozesStr);\n  const now = Date.now();\n\n  return snoozes.filter(s => s.until > now);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/plan.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'subDays' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { startOfDay, subDays } from 'date-fns';\nimport { database } from '@/db';\nimport Interaction from '@/db/models/Interaction';\nimport Intention from '@/db/models/Intention';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport { Q } from '@nozbe/watermelondb';\nimport { processWeaveScoring } from '@/modules/intelligence';\nimport { useUserProfileStore } from '@/modules/auth';\nimport { recordPractice } from '@/modules/gamification';\nimport { deleteWeaveCalendarEvent } from './calendar.service';\nimport { InteractionFormData } from '../types';\n\n/**\n * Completes a plan, updating its status, applying scoring, and tracking milestones.\n * @param interactionId - The ID of the interaction to complete.\n */\nexport async function completePlan(interactionId: string, data?: { vibe?: string; note?: string }): Promise<void> {\n  const interaction = await database.get<Interaction>('interactions').find(interactionId);\n  const previousStatus = interaction.status;\n\n  console.log('[PlanService] Completing interaction:', interactionId, 'Status:', previousStatus);\n  if (previousStatus !== 'planned' && previousStatus !== 'pending_confirm') {\n    console.warn('[PlanService] Interaction not in planned/pending state:', previousStatus);\n    return;\n  }\n\n  await database.write(async () => {\n    await interaction.update(i => {\n      i.status = 'completed';\n      if (data?.vibe) {\n        console.log('[PlanService] Setting vibe:', data.vibe);\n        i.vibe = data.vibe;\n      }\n      if (data?.note) {\n        i.note = data.note;\n      }\n    });\n  });\n  console.log('[PlanService] DB Update committed. Status is now completed.');\n\n  const interactionFriends = await database.get<InteractionFriend>('interaction_friends').query(Q.where('interaction_id', interactionId)).fetch();\n  const friendIds = interactionFriends.map(ifriend => ifriend.friendId);\n  const friends = await database.get<FriendModel>('friends').query(Q.where('id', Q.oneOf(friendIds))).fetch();\n\n  const interactionData: InteractionFormData = {\n    friendIds,\n    activity: interaction.activity,\n    notes: interaction.note,\n    date: interaction.interactionDate,\n    type: 'log',\n    status: 'completed',\n    mode: interaction.mode,\n    vibe: interaction.vibe as any,\n    duration: interaction.duration as any,\n    category: interaction.interactionCategory as any,\n    reflection: interaction.reflectionJSON ? JSON.parse(interaction.reflectionJSON) : undefined,\n  };\n\n  // Apply scoring with season-aware bonuses\n  const currentSeason = useUserProfileStore.getState().getSocialSeason();\n  await processWeaveScoring(friends, interactionData, database, currentSeason);\n  await recordPractice('log_weave');\n  // TODO: Trigger UI celebration from the hook/store that calls this service.\n}\n\n/**\n * Cancels a plan, updating its status and removing any associated calendar events.\n * @param interactionId - The ID of the interaction to cancel.\n */\nexport async function cancelPlan(interactionId: string): Promise<void> {\n  const interaction = await database.get<Interaction>('interactions').find(interactionId);\n\n  await database.write(async () => {\n    await interaction.update(i => {\n      i.status = 'cancelled';\n    });\n  });\n\n  if (interaction.calendarEventId) {\n    deleteWeaveCalendarEvent(interaction.calendarEventId).catch(err => {\n      console.warn(`Failed to delete calendar event for cancelled plan ${interactionId}:`, err);\n    });\n  }\n}\n/**\n * Converts an intention to a plan by updating its status to 'converted'.\n * @param intentionId - The ID of the intention to convert.\n */\nexport async function convertIntentionToPlan(intentionId: string): Promise<void> {\n  await database.write(async () => {\n    const intention = await database.get<Intention>('intentions').find(intentionId);\n    await intention.update(i => {\n      i.status = 'converted';\n    });\n  });\n}\n\n/**\n * Checks for past-due planned interactions and transitions them to 'pending_confirm'.\n */\nexport async function checkPendingPlans(): Promise<void> {\n  const today = startOfDay(new Date());\n  const now = Date.now();\n\n  const pendingPlans = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'planned'),\n      Q.where('interaction_date', Q.lt(now)),\n      Q.where('interaction_date', Q.gte(today.getTime() - 2 * 24 * 60 * 60 * 1000)), // Limit to last 48 hours (previous day + padding)\n      Q.or(\n        Q.where('completion_prompted_at', null),\n        Q.where('completion_prompted_at', Q.lt(now - 24 * 60 * 60 * 1000))\n      )\n    )\n    .fetch();\n\n  if (pendingPlans.length > 0) {\n    await database.write(async () => {\n      for (const plan of pendingPlans) {\n        await plan.update(p => {\n          p.status = 'pending_confirm';\n          p.completionPromptedAt = now;\n        });\n      }\n    });\n  }\n}\n\n/**\n * Checks for old 'pending_confirm' plans and transitions them to 'missed'.\n */\nexport async function checkMissedPlans(): Promise<void> {\n  const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\n\n  const oldPendingPlans = await database\n    .get<Interaction>('interactions')\n    .query(\n      Q.where('status', 'pending_confirm'),\n      Q.where('completion_prompted_at', Q.lt(sevenDaysAgo))\n    )\n    .fetch();\n\n  if (oldPendingPlans.length > 0) {\n    await database.write(async () => {\n      for (const plan of oldPendingPlans) {\n        await plan.update(p => {\n          p.status = 'missed';\n        });\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/smart-defaults.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/suggestion-engine.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FriendModel' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getArchetypeDriftSuggestion' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getArchetypeMomentumSuggestion' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'daysUntil' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isPastService' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLifeEventDisplay' is defined but never used. Allowed unused vars must match /^_/u.","line":289,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":460,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":460,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Suggestion } from '@/shared/types/common';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport { HydratedFriend } from '@/types/hydrated';\n\nexport interface SuggestionInput {\n  friend: HydratedFriend;\n  currentScore: number;\n  lastInteractionDate: Date | null;\n  interactionCount: number;\n  momentumScore: number;\n  recentInteractions: InteractionModel[];\n}\nimport {\n  getArchetypePreferredCategory,\n  getArchetypeDriftSuggestion,\n  getArchetypeMomentumSuggestion,\n  getArchetypeDriftTitle,\n  getArchetypeDormantTitle,\n  getArchetypeNewTitle,\n  getArchetypeWarmingTitle,\n  getArchetypeThrivingTitle,\n} from '@/shared/constants/archetype-content';\nimport { differenceInDays, startOfDay } from 'date-fns';\nimport { database } from '@/db';\nimport LifeEvent, { LifeEventType } from '@/db/models/LifeEvent';\nimport { daysUntil, isPast as isPastService } from '@/modules/relationships';\nimport Intention from '@/db/models/Intention';\nimport { Q } from '@nozbe/watermelondb';\nimport {\n  analyzeInteractionPattern,\n  calculateToleranceWindow,\n  isPatternReliable,\n  getPatternDescription,\n  type FriendshipPattern,\n  type ProactiveSuggestion,\n} from '@/modules/insights';\nimport { parseFlexibleDate } from '@/shared/utils/date-utils';\n\n// Friendly category labels for suggestions\nconst CATEGORY_LABELS: Record<string, string> = {\n  'text-call': 'chat',\n  'meal-drink': 'meal',\n  'hangout': 'hangout',\n  'deep-talk': 'deep conversation',\n  'activity-hobby': 'activity',\n  'event-party': 'event',\n  'favor-support': 'time together',\n  'celebration': 'celebration',\n};\n\nfunction getCategoryLabel(category: string): string {\n  return CATEGORY_LABELS[category] || 'time together';\n}\n\nconst COOLDOWN_DAYS = {\n  'critical-drift': 1,\n  'high-drift': 2,\n  'first-weave': 2,\n  'life-event': 1, // Show again tomorrow if still upcoming\n  'intention-reminder': 2, // Remind about intentions every 2 days\n  'archetype-mismatch': 3,\n  'momentum': 7,\n  'maintenance': 3,\n  'deepen': 7,\n  'reflect': 2,\n};\n\n// Archetype-specific celebration suggestions\nconst ARCHETYPE_CELEBRATION_SUGGESTIONS: Record<string, string[]> = {\n  Emperor: ['Plan a structured celebration dinner', 'Organize a milestone celebration', 'Send a thoughtful, high-quality gift'],\n  Empress: ['Host a cozy dinner party at your place', 'Bake or cook something special for them', 'Plan a comfort-focused celebration'],\n  HighPriestess: ['Schedule a deep one-on-one conversation', 'Send a heartfelt, personal message', 'Arrange intimate tea or coffee time'],\n  Fool: ['Plan a spontaneous surprise adventure', 'Throw an unexpected party', 'Organize something fun and playful'],\n  Sun: ['Throw a big, energetic celebration', 'Host a vibrant party with others', 'Organize a group gathering in their honor'],\n  Hermit: ['Schedule meaningful one-on-one quality time', 'Plan a quiet, thoughtful celebration', 'Arrange a peaceful walk or private dinner'],\n  Magician: ['Collaborate on a creative celebration project', 'Plan a unique, experiential celebration', 'Create something special together'],\n};\n\nfunction getArchetypeCelebrationSuggestion(archetype: string): string {\n  const suggestions = ARCHETYPE_CELEBRATION_SUGGESTIONS[archetype] || [\n    'Reach out with a thoughtful message',\n    'Plan a way to celebrate together',\n  ];\n  const randomIndex = Math.floor(Math.random() * suggestions.length);\n  return suggestions[randomIndex];\n}\n\ninterface LifeEventInfo {\n  type: 'birthday' | 'anniversary' | LifeEventType;\n  daysUntil: number;\n  importance?: 'low' | 'medium' | 'high' | 'critical';\n  title?: string;\n}\n\nasync function checkUpcomingLifeEvent(friend: SuggestionInput['friend']): Promise<LifeEventInfo | null> {\n  const today = startOfDay(new Date());\n\n  // First check database for detected life events (highest priority if critical)\n  try {\n    const activeLifeEvents = await database\n      .get<LifeEvent>('life_events')\n      .query(\n        // friend_id is dynamic\n        Q.where('friend_id', friend.id),\n        Q.or(\n          // Upcoming events (within next 30 days)\n          Q.and(\n            Q.where('event_date', Q.gte(today.getTime())),\n            Q.where('event_date', Q.lte(today.getTime() + 30 * 24 * 60 * 60 * 1000))\n          ),\n          // Recent past events needing follow-up (last 7 days)\n          Q.and(\n            Q.where('event_date', Q.gte(today.getTime() - 7 * 24 * 60 * 60 * 1000)),\n            Q.where('event_date', Q.lt(today.getTime()))\n          )\n        )\n      )\n      .fetch();\n\n    // Filter out anniversaries for non-partners\n    const filteredEvents = activeLifeEvents.filter(event => {\n      if (event.eventType === 'anniversary') {\n        const isPartner = friend.relationshipType?.toLowerCase().includes('partner');\n        return isPartner;\n      }\n      return true;\n    });\n\n    // Prioritize critical and high importance events\n    const sortedEvents = filteredEvents.sort((a, b) => {\n      const importanceOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n      const aScore = importanceOrder[a.importance];\n      const bScore = importanceOrder[b.importance];\n      if (aScore !== bScore) return bScore - aScore;\n      // If same importance, prioritize by proximity (normalize dates to avoid time-of-day issues)\n      return Math.abs(differenceInDays(startOfDay(a.eventDate), today)) - Math.abs(differenceInDays(startOfDay(b.eventDate), today));\n    });\n\n    if (sortedEvents.length > 0) {\n      const topEvent = sortedEvents[0];\n      const daysUntil = differenceInDays(startOfDay(topEvent.eventDate), today);\n\n      return {\n        type: topEvent.eventType,\n        daysUntil,\n        importance: topEvent.importance,\n        title: topEvent.title,\n      };\n    }\n  } catch (error) {\n    console.error('Error checking life events:', error);\n  }\n\n  // Fallback to legacy birthday/anniversary checks from Friend model\n  // Check birthday (within 7 days)\n  if (friend.birthday) {\n    // Use flexible parser\n    const dateParts = parseFlexibleDate(friend.birthday);\n\n    if (!dateParts) {\n      console.warn('Invalid birthday format for friend:', friend.id, friend.birthday);\n      return null;\n    }\n\n    const { month, day } = dateParts;\n\n    // Validate parsed values\n    if (month < 1 || month > 12 || day < 1 || day > 31) {\n      console.warn('Invalid birthday date for friend:', friend.id, friend.birthday);\n      return null;\n    }\n\n    // Create birthday for this year\n    const birthdayThisYear = new Date(today.getFullYear(), month - 1, day);\n    birthdayThisYear.setHours(0, 0, 0, 0);\n\n    // If birthday already passed this year, use next year\n    if (birthdayThisYear < today) {\n      birthdayThisYear.setFullYear(today.getFullYear() + 1);\n    }\n\n    const daysUntil = differenceInDays(birthdayThisYear, today);\n\n    // Extra validation check\n    if (isNaN(daysUntil)) {\n      console.warn('Invalid daysUntil calculation for birthday:', friend.id);\n      return null;\n    }\n\n    if (daysUntil >= 0 && daysUntil <= 7) {\n      return { type: 'birthday', daysUntil, importance: 'high' };\n    }\n  }\n\n  // Check anniversary (within 14 days) - only for partners\n  if (friend.anniversary) {\n    if (!friend.relationshipType?.toLowerCase().includes('partner')) {\n      return null;\n    }\n\n    const dateParts = parseFlexibleDate(friend.anniversary);\n\n    if (!dateParts) {\n      console.warn('[Anniversary Check] Invalid anniversary format for friend:', friend.id, friend.anniversary);\n      return null;\n    }\n\n    const { month, day } = dateParts;\n\n    // Validate parsed values\n    if (month < 1 || month > 12 || day < 1 || day > 31) {\n      console.warn('[Anniversary Check] Invalid anniversary date for friend:', friend.id, friend.anniversary);\n      return null;\n    }\n\n    // Create anniversary for this year\n    const anniversaryThisYear = new Date(today.getFullYear(), month - 1, day);\n\n    // Validate that we have a valid date\n    if (isNaN(anniversaryThisYear.getTime())) {\n      console.warn('[Anniversary Check] Invalid anniversary date for friend:', friend.id, friend.anniversary);\n      return null;\n    }\n    anniversaryThisYear.setHours(0, 0, 0, 0);\n\n    if (anniversaryThisYear < today) {\n      anniversaryThisYear.setFullYear(today.getFullYear() + 1);\n    }\n\n    const daysUntil = differenceInDays(anniversaryThisYear, today);\n\n    // Extra validation check\n    if (isNaN(daysUntil)) {\n      console.warn('[Anniversary Check] Invalid daysUntil calculation for anniversary:', friend.id);\n      return null;\n    }\n\n    if (daysUntil >= 0 && daysUntil <= 14) {\n      return { type: 'anniversary', daysUntil, importance: 'medium' };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if friend has any aging active intentions that should be reminded\n * Returns the oldest active intention if it's been 7+ days\n */\nasync function checkAgingIntention(friend: SuggestionInput['friend']): Promise<Intention | null> {\n  const today = Date.now();\n  const sevenDaysAgo = today - (7 * 24 * 60 * 60 * 1000);\n\n  try {\n    // Get all active intentions for this friend through the join table\n    const intentionFriends = await database\n      .get('intention_friends')\n      .query(Q.where('friend_id', friend.id))\n      .fetch();\n\n    if (intentionFriends.length === 0) return null;\n\n    // Get intention IDs\n    const intentionIds = intentionFriends.map((ifriend: any) => ifriend._raw.intention_id);\n\n    // Query for active intentions that are 7+ days old\n    const agingIntentions = await database\n      .get<Intention>('intentions')\n      .query(\n        Q.where('id', Q.oneOf(intentionIds)),\n        Q.where('status', 'active'),\n        Q.where('created_at', Q.lte(sevenDaysAgo)),\n        Q.sortBy('created_at', Q.asc) // Oldest first\n      )\n      .fetch();\n\n    if (agingIntentions.length > 0) {\n      return agingIntentions[0]; // Return oldest intention\n    }\n  } catch (error) {\n    console.error('Error checking aging intentions:', error);\n  }\n\n  return null;\n}\n\n// Get appropriate emoji and label for life event type\nfunction getLifeEventDisplay(eventType: LifeEventType | 'birthday' | 'anniversary'): { icon: string; label: string } {\n  const displays: Record<string, { icon: string; label: string }> = {\n    birthday: { icon: 'Gift', label: 'birthday' },\n    anniversary: { icon: 'Heart', label: 'anniversary' },\n    new_job: { icon: 'Briefcase', label: 'new job' },\n    moving: { icon: 'Home', label: 'move' },\n    wedding: { icon: 'Heart', label: 'wedding' },\n    baby: { icon: 'Egg', label: 'baby' }, // Using Egg as close proxy for new life or Smile\n    loss: { icon: 'HeartCrack', label: 'difficult time' }, // HeartCrack or Sunrise\n    health_event: { icon: 'Activity', label: 'health event' },\n    graduation: { icon: 'GraduationCap', label: 'graduation' },\n    celebration: { icon: 'PartyPopper', label: 'milestone' },\n    other: { icon: 'Star', label: 'life event' },\n  };\n  return displays[eventType] || { icon: 'Star', label: 'life event' };\n}\n\n// Get appropriate suggestion text for event type\n// Get appropriate suggestion text for event type\nfunction getLifeEventSuggestion(eventType: LifeEventType | 'birthday' | 'anniversary', archetype: string, lifeEvent: LifeEventInfo): string {\n  if (lifeEvent.daysUntil < 0) {\n    // Follow-up suggestions for past events\n    const followUps: Record<string, string> = {\n      wedding: 'Check how married life is going',\n      baby: 'See how they\\'re adjusting',\n      new_job: 'Ask how the new role is',\n      moving: 'See how they\\'re settling in',\n      loss: 'Check how they\\'re doing',\n      health_event: 'Check on their recovery',\n      graduation: 'Celebrate their achievement',\n    };\n    return followUps[eventType] || 'Check in with them';\n  }\n\n  // Use archetype-specific celebration for birthdays\n  if (eventType === 'birthday' || eventType === 'anniversary') {\n    return getArchetypeCelebrationSuggestion(archetype);\n  }\n\n  // Proactive suggestions for upcoming events\n  const suggestions: Record<string, string> = {\n    wedding: 'Offer help or congratulations',\n    baby: 'Offer support or a gift',\n    new_job: 'Send congrats',\n    moving: 'Offer help with the move',\n    loss: 'Reach out with support',\n    health_event: 'Offer support',\n    graduation: 'Congratulate them',\n    celebration: 'Celebrate this milestone',\n  };\n  return suggestions[eventType] || 'Reach out';\n}\n\nfunction getDaysText(days: number | undefined): string {\n  if (days === undefined || isNaN(days)) return 'soon';\n  if (days === 0) return 'today';\n  if (days === 1) return 'tomorrow';\n  return `in ${days} days`;\n}\n\n/**\n * Analyzes past interactions to suggest specific, personalized activities\n * based on what this friendship has done before.\n */\nfunction getContextualSuggestion(\n  recentInteractions: SuggestionInput['recentInteractions'],\n  archetype: string,\n  tier: string,\n  pattern?: FriendshipPattern\n): string {\n  // Use learned pattern preferences if available\n  if (pattern && pattern.preferredCategories.length > 0) {\n    const preferredCategory = pattern.preferredCategories[0];\n    const suggestions: Record<string, string[]> = {\n      'text-call': [\n        \"Send them a quick text like you used to\",\n        \"Give them a call to catch up\",\n        \"Drop them a voice note\",\n        \"Send a funny meme or memory\",\n      ],\n      'meal-drink': [\n        \"Grab coffee at your usual spot\",\n        \"Plan dinner like old times\",\n        \"Meet for drinks and catch up\",\n        \"Grab lunch together this week\",\n      ],\n      'hangout': [\n        \"Hang out like you used to\",\n        \"Plan a chill hangout session\",\n        \"Meet up for quality time\",\n        \"Do something spontaneous together\",\n      ],\n      'deep-talk': [\n        \"Have a heart-to-heart conversation\",\n        \"Set aside time for a deep catch-up\",\n        \"Schedule a meaningful conversation\",\n        \"Create space for vulnerable sharing\",\n      ],\n      'activity-hobby': [\n        \"Do that activity you both love\",\n        \"Revisit your shared hobby together\",\n        \"Plan an adventure like you used to\",\n        \"Get active together again\",\n      ],\n      'event-party': [\n        \"Invite them to something fun\",\n        \"Plan a celebration together\",\n        \"Organize a group hangout\",\n        \"Go to an event together\",\n      ],\n    };\n\n    const options = suggestions[preferredCategory] || [];\n    if (options.length > 0) {\n      return options[Math.floor(Math.random() * options.length)];\n    }\n  }\n\n  // Count interaction types to find patterns (fallback)\n  const categoryCounts: Record<string, number> = {};\n  recentInteractions.forEach(i => {\n    if (i.interactionCategory) {\n      categoryCounts[i.interactionCategory] = (categoryCounts[i.interactionCategory] || 0) + 1;\n    }\n  });\n\n  // Get most common interaction type\n  const mostCommon = Object.entries(categoryCounts).sort(([, a], [, b]) => b - a)[0];\n\n  // Contextual suggestions based on their history + archetype\n  const suggestions: Record<string, string[]> = {\n    'text-call': [\n      \"Send them a quick text like you used to\",\n      \"Give them a call to catch up\",\n      \"Drop them a voice note\",\n      \"Send a funny meme or memory\",\n    ],\n    'meal-drink': [\n      \"Grab coffee at your usual spot\",\n      \"Plan dinner like old times\",\n      \"Meet for drinks and catch up\",\n      \"Grab lunch together this week\",\n    ],\n    'hangout': [\n      \"Hang out like you used to\",\n      \"Plan a chill hangout session\",\n      \"Meet up for quality time\",\n      \"Do something spontaneous together\",\n    ],\n    'deep-talk': [\n      \"Have a heart-to-heart conversation\",\n      \"Set aside time for a deep catch-up\",\n      \"Schedule a meaningful conversation\",\n      \"Create space for vulnerable sharing\",\n    ],\n    'activity-hobby': [\n      \"Do that activity you both love\",\n      \"Revisit your shared hobby together\",\n      \"Plan an adventure like you used to\",\n      \"Get active together again\",\n    ],\n    'event-party': [\n      \"Invite them to something fun\",\n      \"Plan a celebration together\",\n      \"Organize a group hangout\",\n      \"Go to an event together\",\n    ],\n  };\n\n  // If they have a pattern, suggest continuing it\n  if (mostCommon && mostCommon[1] >= 2) {\n    const [category, count] = mostCommon;\n    const options = suggestions[category] || [];\n    if (options.length > 0) {\n      return options[Math.floor(Math.random() * options.length)];\n    }\n  }\n\n  // Fallback to archetype + tier appropriate suggestions\n  if (tier === 'InnerCircle') {\n    const innerCircleSuggestions = [\n      \"Set aside quality time\",\n      \"Plan something meaningful\",\n      \"Have a proper catch-up\",\n      \"Make time for connection\",\n    ];\n    return innerCircleSuggestions[Math.floor(Math.random() * innerCircleSuggestions.length)];\n  } else if (tier === 'CloseFriends') {\n    const closeFriendSuggestions = [\n      \"Send a thoughtful text\",\n      \"Plan a casual meet-up\",\n      \"Grab coffee or a bite\",\n      \"Check in with them\",\n    ];\n    return closeFriendSuggestions[Math.floor(Math.random() * closeFriendSuggestions.length)];\n  } else {\n    return \"Send a friendly message\";\n  }\n}\n\n/**\n * Generates intelligent suggestions for a friend based on their interaction history,\n * relationship health, and upcoming life events.\n *\n * IMPORTANT: Only pass COMPLETED interactions (status === 'completed') that have already\n * occurred (interactionDate <= now). Planned/future interactions should never be included\n * in recentInteractions as they cannot be reflected upon or used for pattern analysis.\n */\nexport async function generateSuggestion(input: SuggestionInput): Promise<Suggestion | null> {\n  const { friend, currentScore, lastInteractionDate, interactionCount, momentumScore, recentInteractions } = input;\n\n  // Analyze friendship pattern from interaction history\n  const pattern = analyzeInteractionPattern(\n    recentInteractions.map(i => ({\n      id: i.id,\n      interactionDate: i.interactionDate,\n      status: 'completed',\n      category: i.interactionCategory,\n    }))\n  );\n\n  // Check for upcoming life event (used in multiple priorities)\n  const lifeEvent = await checkUpcomingLifeEvent(friend);\n\n  // PRIORITY 1: Reflect on recent interaction (only past, completed interactions)\n  const recentReflectSuggestion = checkReflectSuggestion(friend, recentInteractions);\n  if (recentReflectSuggestion) return recentReflectSuggestion;\n\n  // PRIORITY 2: Upcoming life event (birthday within 7 days, anniversary within 14 days)\n  if (lifeEvent) {\n    // Map life event types to appropriate icons and labels\n    const eventIconMap: Record<string, string> = {\n      birthday: 'Gift',\n      anniversary: 'Heart',\n      new_job: 'Briefcase',\n      moving: 'Home',\n      graduation: 'GraduationCap',\n      health_event: 'Activity',\n      celebration: 'PartyPopper',\n      loss: 'HeartCrack',\n      wedding: 'Heart',\n      baby: 'Egg', // Egg or Smile\n    };\n\n    const eventLabelMap: Record<string, string> = {\n      birthday: 'birthday',\n      anniversary: 'anniversary',\n      new_job: 'new job',\n      moving: 'move',\n      graduation: 'graduation',\n      health_event: 'health event',\n      celebration: 'celebration',\n      loss: 'loss',\n      wedding: 'wedding',\n      baby: 'baby',\n    };\n\n    const eventIcon = eventIconMap[lifeEvent.type] || 'Calendar';\n    const eventLabel = lifeEvent.title || eventLabelMap[lifeEvent.type] || lifeEvent.type;\n\n    // Use archetype-specific suggestions for birthdays/anniversaries, otherwise use life event specific\n    const subtitle = (lifeEvent.type === 'birthday' || lifeEvent.type === 'anniversary')\n      ? getArchetypeCelebrationSuggestion(friend.archetype)\n      : getLifeEventSuggestion(lifeEvent.type, friend.archetype, lifeEvent);\n\n    // Different title and action for past vs upcoming events\n    const title = lifeEvent.daysUntil < 0\n      ? `Check in on ${friend.name}'s ${eventLabel}`\n      : `${friend.name}'s ${eventLabel} ${getDaysText(lifeEvent.daysUntil)}`;\n\n    const actionLabel = lifeEvent.daysUntil < 0 ? 'Reach Out' : 'Plan';\n\n    return {\n      id: `life-event-${friend.id}-${lifeEvent.type}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency: lifeEvent.daysUntil <= 1 ? 'high' : 'medium',\n      category: 'life-event',\n      title,\n      subtitle,\n      actionLabel,\n      icon: eventIcon,\n      action: {\n        type: lifeEvent.daysUntil < 0 ? 'log' : 'plan',\n        prefilledCategory: 'celebration' as any,\n      },\n      dismissible: true,\n      createdAt: new Date(),\n      type: 'connect',\n    };\n  }\n\n  // PRIORITY 2.5: Aging intentions (gentle reminder to follow through)\n  const agingIntention = await checkAgingIntention(friend);\n  if (agingIntention) {\n    const daysSinceCreated = differenceInDays(new Date(), agingIntention.createdAt);\n\n    // Determine urgency based on age\n    let urgency: 'medium' | 'high' = 'medium';\n    if (daysSinceCreated >= 14) urgency = 'high';\n\n    // Build subtitle with intention details\n    const categoryHint = agingIntention.interactionCategory\n      ? ` (${getCategoryLabel(agingIntention.interactionCategory)})`\n      : '';\n\n    const subtitle = agingIntention.description\n      ? `\"${agingIntention.description}\"${categoryHint}`\n      : `Complete your intention${categoryHint}`;\n\n    return {\n      id: `intention-reminder-${agingIntention.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency,\n      category: 'maintain',\n      title: `Intention for ${friend.name}`,\n      subtitle,\n      actionLabel: 'Schedule',\n      icon: 'Target',\n      action: {\n        type: 'plan',\n        prefilledCategory: agingIntention.interactionCategory as any,\n      },\n      dismissible: true,\n      createdAt: new Date(),\n      type: 'connect',\n    };\n  }\n\n  // PRIORITY 3: Critical drift (Inner Circle emergency)\n  if (friend.dunbarTier === 'InnerCircle' && currentScore < 30) {\n    const contextualAction = getContextualSuggestion(recentInteractions, friend.archetype, friend.dunbarTier, pattern);\n\n    // Add pattern-aware context if available\n    const patternContext = isPatternReliable(pattern)\n      ? ` ${getPatternDescription(pattern)}.`\n      : '';\n\n    return {\n      id: `critical-drift-${friend.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency: 'critical',\n      category: 'drift',\n      title: getArchetypeDormantTitle(friend.archetype, friend.name),\n      subtitle: `${contextualAction}.${patternContext}`,\n      actionLabel: 'Reach Out',\n      icon: 'Wind',\n      action: {\n        type: 'log',\n        prefilledCategory: getArchetypePreferredCategory(friend.archetype),\n        prefilledMode: 'detailed',\n      },\n      dismissible: false, // Too important to dismiss\n      createdAt: new Date(),\n      type: 'reconnect',\n    };\n  }\n\n  // PRIORITY 4: High drift (attention needed)\n  const isHighDrift =\n    (friend.dunbarTier === 'InnerCircle' && currentScore < 50) ||\n    (friend.dunbarTier === 'CloseFriends' && currentScore < 35);\n\n  if (isHighDrift) {\n    const contextualAction = getContextualSuggestion(recentInteractions, friend.archetype, friend.dunbarTier, pattern);\n\n    // Add pattern-aware context\n    const patternContext = isPatternReliable(pattern)\n      ? ` ${getPatternDescription(pattern)}.`\n      : '';\n\n    return {\n      id: `high-drift-${friend.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency: 'high',\n      category: 'drift',\n      title: getArchetypeDriftTitle(friend.archetype, friend.name),\n      subtitle: `${contextualAction}.${patternContext}`,\n      actionLabel: 'Plan',\n      icon: 'Wind',\n      action: {\n        type: 'plan',\n        prefilledCategory: getArchetypePreferredCategory(friend.archetype),\n      },\n      dismissible: true,\n      createdAt: new Date(),\n      type: 'reconnect',\n    };\n  }\n\n  // PRIORITY 4: First weave (new friend)\n  if (interactionCount === 0) {\n    const daysSinceAdded = friend.createdAt\n      ? (Date.now() - friend.createdAt.getTime()) / 86400000\n      : 0;\n\n    if (daysSinceAdded >= 1) {\n      // Reduce noise: Only suggest first weave for Community friends if their health is low (< 35)\n      if (friend.dunbarTier === 'Community' && currentScore >= 35) {\n        return null;\n      }\n\n      return {\n        id: `first-weave-${friend.id}`,\n        friendId: friend.id,\n        friendName: friend.name,\n        urgency: 'medium',\n        category: 'maintain',\n        title: getArchetypeNewTitle(friend.archetype, friend.name),\n        subtitle: 'Log your first interaction.',\n        actionLabel: 'Log',\n        icon: 'Sparkles',\n        action: { type: 'log' },\n        dismissible: true,\n        createdAt: new Date(),\n        type: 'connect',\n      };\n    }\n  }\n\n  // PRIORITY 5: Archetype mismatch insight\n  const archetypeMismatch = checkArchetypeMismatch(friend, recentInteractions);\n  if (archetypeMismatch) return archetypeMismatch;\n\n  // PRIORITY 6: Momentum opportunity\n  if (currentScore > 60 && momentumScore > 10) {\n    const daysSinceLast = lastInteractionDate\n      ? (Date.now() - lastInteractionDate.getTime()) / 86400000\n      : 999;\n\n    if (daysSinceLast <= 7) {\n      const contextualAction = getContextualSuggestion(recentInteractions, friend.archetype, friend.dunbarTier, pattern);\n\n      return {\n        id: `momentum-${friend.id}`,\n        friendId: friend.id,\n        friendName: friend.name,\n        urgency: 'medium',\n        category: 'deepen',\n        title: getArchetypeWarmingTitle(friend.archetype, friend.name),\n        subtitle: `Ride the wave! ${contextualAction}`,\n        actionLabel: 'Deepen',\n        icon: 'Zap',\n        action: {\n          type: 'plan',\n          prefilledCategory: getArchetypePreferredCategory(friend.archetype),\n        },\n        dismissible: true,\n        createdAt: new Date(),\n        type: 'deepen',\n      };\n    }\n  }\n\n  // PRIORITY 7: Maintenance\n  const daysSinceInteraction = lastInteractionDate\n    ? (Date.now() - lastInteractionDate.getTime()) / 86400000\n    : 999;\n\n  // Use learned pattern for threshold, or fall back to tier defaults\n  const maintenanceThreshold = isPatternReliable(pattern)\n    ? calculateToleranceWindow(pattern)\n    : {\n      InnerCircle: 7,\n      CloseFriends: 14,\n      Community: 21,\n    }[friend.dunbarTier];\n\n  if (currentScore >= 40 && currentScore <= 70 && maintenanceThreshold && daysSinceInteraction > maintenanceThreshold) {\n    const contextualAction = getContextualSuggestion(recentInteractions, friend.archetype, friend.dunbarTier, pattern);\n\n    // Create pattern-aware title\n    const title = isPatternReliable(pattern)\n      ? `${pattern.averageIntervalDays}-day check-in: ${friend.name}`\n      : `Keep warm with ${friend.name}`;\n\n    return {\n      id: `maintenance-${friend.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency: 'low',\n      category: 'maintain',\n      title,\n      subtitle: contextualAction,\n      actionLabel: 'Plan',\n      icon: 'Clock',\n      action: {\n        type: 'plan',\n        prefilledCategory: pattern.preferredCategories[0] || 'text-call',\n      },\n      dismissible: true,\n      createdAt: new Date(),\n      type: 'connect',\n    };\n  }\n\n  // PRIORITY 8: Deepen (thriving)\n  if (currentScore > 85 && friend.dunbarTier !== 'Community') {\n    const contextualAction = getContextualSuggestion(recentInteractions, friend.archetype, friend.dunbarTier, pattern);\n\n    return {\n      id: `deepen-${friend.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency: 'low',\n      category: 'celebrate',\n      title: getArchetypeThrivingTitle(friend.archetype, friend.name),\n      subtitle: `Celebrate! ${contextualAction}`,\n      actionLabel: 'Plan',\n      icon: 'Sparkles',\n      action: { type: 'plan' },\n      dismissible: true,\n      createdAt: new Date(),\n      type: 'celebrate',\n    };\n  }\n\n  return null;\n}\n\nfunction checkReflectSuggestion(\n  friend: SuggestionInput['friend'],\n  recentInteractions: SuggestionInput['recentInteractions']\n): Suggestion | null {\n  if (recentInteractions.length === 0) return null;\n\n  const mostRecent = recentInteractions[0];\n  const now = Date.now();\n  if (!mostRecent.interactionDate) return null;\n  const interactionTime = mostRecent.interactionDate.getTime();\n  const hoursSince = (now - interactionTime) / 3600000;\n\n  // Only suggest reflection for PAST interactions (not future/planned)\n  // Interaction must be in the past and within 24 hours\n  if (interactionTime > now) {\n    return null; // Future interaction, can't reflect yet\n  }\n\n  // Must be recent (within 24 hours) and missing reflection data\n  if (hoursSince < 24 && hoursSince >= 0 && (!mostRecent.note || !mostRecent.vibe)) {\n    const activityLabel = mostRecent.interactionCategory ? getCategoryLabel(mostRecent.interactionCategory) : 'time together';\n\n    return {\n      id: `reflect-${mostRecent.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      urgency: 'high',\n      category: 'reflect',\n      title: 'Deepen this weave',\n      subtitle: `How was your ${activityLabel} with ${friend.name}?`,\n      actionLabel: 'Add Reflection',\n      icon: '✨',\n      action: {\n        type: 'reflect',\n        interactionId: mostRecent.id,\n      },\n      dismissible: true,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // Expires in 24h\n      type: 'reflect',\n    };\n  }\n\n  return null;\n}\n\nfunction checkArchetypeMismatch(\n  friend: SuggestionInput['friend'],\n  recentInteractions: SuggestionInput['recentInteractions']\n): Suggestion | null {\n  if (recentInteractions.length < 3) return null;\n\n  // Filter to only past interactions (recentInteractions should already be filtered to completed,\n  // but adding this as extra safety)\n  const now = Date.now();\n  const pastInteractions = recentInteractions.filter(i => i.interactionDate && i.interactionDate.getTime() <= now);\n\n  if (pastInteractions.length < 3) return null;\n\n  const last3 = pastInteractions.slice(0, 3);\n  const preferredCategory = getArchetypePreferredCategory(friend.archetype);\n\n  const hasPreferred = last3.some(i => i.interactionCategory === preferredCategory);\n\n  if (!hasPreferred) {\n    const categoryLabel = preferredCategory.replace('-', ' ');\n    return {\n      id: `archetype-mismatch-${friend.id}`,\n      friendId: friend.id,\n      friendName: friend.name,\n      type: 'reflect',\n      urgency: 'medium',\n      category: 'insight',\n      title: `Missing ${friend.name}'s depth`,\n      subtitle: `${friend.archetype} values certain types of connection. Your last 3 weaves didn't create space for that. Try ${categoryLabel}.`,\n      actionLabel: 'Plan Deep Connection',\n      icon: '💡',\n      action: {\n        type: 'plan',\n        prefilledCategory: preferredCategory,\n      },\n      dismissible: true,\n      createdAt: new Date(),\n    };\n  }\n\n  return null;\n}\n\nexport function getSuggestionCooldownDays(suggestionId: string): number {\n  if (suggestionId.startsWith('critical-drift')) return COOLDOWN_DAYS['critical-drift'];\n  if (suggestionId.startsWith('high-drift')) return COOLDOWN_DAYS['high-drift'];\n  if (suggestionId.startsWith('first-weave')) return COOLDOWN_DAYS['first-weave'];\n  if (suggestionId.startsWith('life-event')) return COOLDOWN_DAYS['life-event'];\n  if (suggestionId.startsWith('intention-reminder')) return COOLDOWN_DAYS['intention-reminder'];\n  if (suggestionId.startsWith('archetype-mismatch')) return COOLDOWN_DAYS['archetype-mismatch'];\n  if (suggestionId.startsWith('momentum')) return COOLDOWN_DAYS['momentum'];\n  if (suggestionId.startsWith('maintenance')) return COOLDOWN_DAYS['maintenance'];\n  if (suggestionId.startsWith('deepen')) return COOLDOWN_DAYS['deepen'];\n  if (suggestionId.startsWith('reflect')) return COOLDOWN_DAYS['reflect'];\n  if (suggestionId.startsWith('portfolio')) return 7; // Portfolio insights weekly\n  if (suggestionId.startsWith('proactive-')) return 2; // Proactive predictions refresh often\n  return 3; // Default\n}\n\n\n\n/**\n * Converts proactive predictions into standard suggestion format\n * These are shown alongside other suggestions to provide forward-looking guidance\n */\nexport function convertProactiveSuggestionsToSuggestions(\n  proactiveSuggestions: ProactiveSuggestion[]\n): Suggestion[] {\n  return proactiveSuggestions.map(proactive => {\n    const baseId = `proactive-${proactive.type}-${proactive.friendId}`;\n\n    // Map proactive type to icon\n    const iconMap: Record<ProactiveSuggestion['type'], string> = {\n      'upcoming-drift': '⏰',\n      'optimal-timing': '🎯',\n      'pattern-break': '⚠️',\n      'momentum-opportunity': '🚀',\n      'reciprocity-imbalance': '⚖️',\n      'best-day-scheduling': '📅',\n    };\n\n    // Map proactive type to category\n    const categoryMap: Record<ProactiveSuggestion['type'], Suggestion['category']> = {\n      'upcoming-drift': 'drift',\n      'optimal-timing': 'maintain',\n      'pattern-break': 'reconnect',\n      'momentum-opportunity': 'deepen',\n      'reciprocity-imbalance': 'insight',\n      'best-day-scheduling': 'plan',\n    };\n\n    return {\n      id: baseId,\n      friendId: proactive.friendId,\n      friendName: proactive.friendName,\n      urgency: proactive.urgency,\n      category: categoryMap[proactive.type],\n      title: proactive.title,\n      subtitle: proactive.message,\n      actionLabel: 'View Insight',\n      icon: iconMap[proactive.type],\n      action: {\n        type: 'connect', // Default action type\n      },\n      dismissible: true,\n      createdAt: new Date(),\n      type: 'connect',\n    };\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/suggestion-provider.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/suggestion-storage.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/suggestion-tracker.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/services/weave-logging.service.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":114,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":114,"endColumn":22,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4470,4483],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendModel from '@/db/models/Friend';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport { InteractionFormData } from '../types';\nimport { WeaveLogSchema } from '@/shared/types/validators';\n\n// TODO: These should be moved to the insights module\nimport { trackEvent, AnalyticsEvents, updateLastInteractionTimestamp } from '@/shared/services/analytics.service';\nimport { deleteWeaveCalendarEvent } from './calendar.service';\nimport Logger from '@/shared/utils/Logger';\nimport { eventBus } from '@/shared/events/event-bus';\n\nexport async function logWeave(data: InteractionFormData): Promise<Interaction> {\n    // Validate input data\n    try {\n        WeaveLogSchema.parse(data);\n    } catch (error) {\n        throw new Error(`Invalid weave data: ${error instanceof Error ? error.message : String(error)}`);\n    }\n\n    const friends = await database.get<FriendModel>('friends').query(Q.where('id', Q.oneOf(data.friendIds))).fetch();\n\n    if (friends.length === 0) {\n        throw new Error('No friends found for this interaction.');\n    }\n\n    // 1. Create the interaction record (Main Transaction)\n    const { interaction } = await database.write(async () => {\n        const batchOps: any[] = []; // keeping any[] for flexibility with WatermelonDB batch which sometimes requires specific Model types\n\n        const newInteraction = database.get<Interaction>('interactions').prepareCreate((interaction: Interaction) => {\n            interaction.interactionDate = data.date;\n            interaction.interactionType = 'log';\n            interaction.status = 'completed';\n            interaction.activity = data.activity;\n            interaction.mode = data.mode;\n            interaction.note = data.notes;\n            interaction.vibe = data.vibe || undefined;\n            interaction.duration = data.duration || undefined;\n            if (data.title) {\n                interaction.title = data.title;\n            }\n            if (data.category) {\n                interaction.interactionCategory = data.category;\n            }\n            if (data.reflection) {\n                interaction.reflectionJSON = JSON.stringify(data.reflection);\n            }\n            if (data.initiator) {\n                interaction.initiator = data.initiator;\n            }\n        });\n        batchOps.push(newInteraction);\n\n        for (const friend of friends) {\n            batchOps.push(database.get('interaction_friends').prepareCreate((_ifriend: any) => {\n                const ifriend = _ifriend as InteractionFriend;\n                ifriend.interaction.set(newInteraction);\n                ifriend.friend.set(friend);\n            }));\n        }\n\n        await database.batch(batchOps);\n\n        return { interaction: newInteraction };\n    });\n\n\n    // 2. Run Side Effects (Decoupled via Event Bus)\n    // We emit the event and let subscribers handle scoring, gamification, analytics, etc.\n    // This resolves circular dependencies.\n    try {\n        await eventBus.emit('interaction:created', {\n            interactionId: interaction.id,\n            friends,\n            data\n        });\n\n        // Analytics - We keep this here as it's a cross-cutting concern often tied to the action itself,\n        // but it could also be moved to a listener if desired. For now, we leave it to match the plan.\n        trackEvent(AnalyticsEvents.INTERACTION_LOGGED, {\n            activity: data.activity,\n            category: data.category,\n            duration: data.duration,\n            vibe: data.vibe,\n            friends_count: friends.length,\n            has_notes: !!data.notes,\n            has_reflection: !!data.reflection,\n            initiator: data.initiator,\n        });\n        updateLastInteractionTimestamp();\n\n    } catch (error) {\n        Logger.error('Error emitting interaction event:', error);\n        // We do NOT throw here, because the interaction was successfully created.\n    }\n\n\n    return interaction;\n}\n\nexport async function planWeave(data: InteractionFormData): Promise<Interaction> {\n    const friends = await database.get<FriendModel>('friends').query(Q.where('id', Q.oneOf(data.friendIds))).fetch();\n\n    if (friends.length === 0) {\n        throw new Error('No friends found for this plan.');\n    }\n\n    const interaction = await database.write(async () => {\n        const batchOps: any[] = [];\n\n        // @ts-ignore\n        const newInteraction = database.get<Interaction>('interactions').prepareCreate((interaction: Interaction) => {\n            interaction.interactionDate = data.date;\n            interaction.interactionType = 'plan';\n            interaction.status = 'planned';\n            interaction.activity = data.activity;\n            interaction.mode = data.mode;\n            interaction.note = data.notes;\n            interaction.title = data.title;\n            interaction.location = data.location;\n            if (data.category) {\n                interaction.interactionCategory = data.category;\n            }\n            if (data.initiator) {\n                interaction.initiator = data.initiator;\n            }\n        });\n        batchOps.push(newInteraction);\n\n        for (const friend of friends) {\n            batchOps.push(database.get('interaction_friends').prepareCreate((_ifriend: any) => {\n                const ifriend = _ifriend as InteractionFriend;\n                ifriend.interaction.set(newInteraction);\n                ifriend.friend.set(friend);\n            }));\n        }\n\n        await database.batch(batchOps);\n\n        trackEvent(AnalyticsEvents.INTERACTION_PLANNED, {\n            activity: data.activity,\n            category: data.category,\n            friends_count: friends.length,\n        });\n\n        return newInteraction;\n    });\n\n    return interaction;\n}\n\nexport async function deleteWeave(id: string): Promise<void> {\n    const interaction = await database.get('interactions').find(id) as Interaction;\n    const calendarEventId = interaction.calendarEventId;\n\n    await database.write(async () => {\n        const joinRecords = await database.get('interaction_friends').query(Q.where('interaction_id', id)).fetch();\n        const recordsToDelete = joinRecords.map(r => r.prepareDestroyPermanently());\n        await database.batch(...recordsToDelete, interaction.prepareDestroyPermanently());\n    });\n\n    if (calendarEventId) {\n        // We're not awaiting this, as it can happen in the background\n        deleteWeaveCalendarEvent(calendarEventId).catch(err => {\n            Logger.warn('Failed to delete calendar event:', err);\n        });\n    }\n\n    trackEvent(AnalyticsEvents.INTERACTION_DELETED);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/store/event-suggestion.store.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":106,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { scanUpcomingEvents, scanRecentPastEvents, type ScannedEvent } from '../services/event-scanner';\n\nconst DISMISSED_SUGGESTIONS_KEY = '@weave:dismissed_event_suggestions';\nconst LAST_SCAN_KEY = '@weave:last_event_scan';\n\n/**\n * Suggestion type\n */\nexport type SuggestionType = 'upcoming' | 'past';\n\n/**\n * Event suggestion with metadata\n */\nexport interface EventSuggestion {\n  event: ScannedEvent;\n  type: SuggestionType;\n  suggestedAt: Date;\n}\n\ninterface EventSuggestionStore {\n  // Upcoming events (birthdays, holidays, etc.)\n  upcomingEvents: EventSuggestion[];\n  // Past events that might be weaves\n  pastEvents: EventSuggestion[];\n  // Currently showing past event modal\n  showingPastEvent: EventSuggestion | null;\n  // Loading state\n  isScanning: boolean;\n  // Last scan time\n  lastScanTime: Date | null;\n\n  // Actions\n  scanForSuggestions: () => Promise<void>;\n  dismissUpcomingEvent: (eventId: string) => Promise<void>;\n  dismissPastEvent: (eventId: string) => Promise<void>;\n  showPastEventModal: (suggestion: EventSuggestion) => void;\n  hidePastEventModal: () => void;\n  clearAllSuggestions: () => void;\n}\n\n/**\n * Storage for dismissed suggestions\n */\ninterface DismissedSuggestions {\n  eventIds: string[];\n  timestamp: number;\n}\n\n/**\n * Load dismissed suggestions from storage\n */\nasync function loadDismissedSuggestions(): Promise<Set<string>> {\n  try {\n    const data = await AsyncStorage.getItem(DISMISSED_SUGGESTIONS_KEY);\n    if (!data) return new Set();\n\n    const parsed: DismissedSuggestions = JSON.parse(data);\n\n    // Clear dismissed suggestions older than 30 days\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    if (parsed.timestamp < thirtyDaysAgo) {\n      await AsyncStorage.removeItem(DISMISSED_SUGGESTIONS_KEY);\n      return new Set();\n    }\n\n    return new Set(parsed.eventIds);\n  } catch (error) {\n    console.error('[EventSuggestionStore] Error loading dismissed suggestions:', error);\n    return new Set();\n  }\n}\n\n/**\n * Save dismissed suggestion to storage\n */\nasync function saveDismissedSuggestion(eventId: string): Promise<void> {\n  try {\n    const dismissed = await loadDismissedSuggestions();\n    dismissed.add(eventId);\n\n    const data: DismissedSuggestions = {\n      eventIds: Array.from(dismissed),\n      timestamp: Date.now(),\n    };\n\n    await AsyncStorage.setItem(DISMISSED_SUGGESTIONS_KEY, JSON.stringify(data));\n  } catch (error) {\n    console.error('[EventSuggestionStore] Error saving dismissed suggestion:', error);\n  }\n}\n\n/**\n * Check if we should scan (throttle to once per hour)\n */\nasync function shouldScan(): Promise<boolean> {\n  try {\n    const lastScan = await AsyncStorage.getItem(LAST_SCAN_KEY);\n    if (!lastScan) return true;\n\n    const lastScanTime = parseInt(lastScan, 10);\n    const oneHourAgo = Date.now() - 60 * 60 * 1000;\n\n    return lastScanTime < oneHourAgo;\n  } catch (error) {\n    return true;\n  }\n}\n\n/**\n * Update last scan time\n */\nasync function updateLastScanTime(): Promise<void> {\n  try {\n    await AsyncStorage.setItem(LAST_SCAN_KEY, Date.now().toString());\n  } catch (error) {\n    console.error('[EventSuggestionStore] Error updating last scan time:', error);\n  }\n}\n\nexport const useEventSuggestionStore = create<EventSuggestionStore>((set, get) => ({\n  upcomingEvents: [],\n  pastEvents: [],\n  showingPastEvent: null,\n  isScanning: false,\n  lastScanTime: null,\n\n  scanForSuggestions: async () => {\n    const state = get();\n    if (state.isScanning) {\n\n      return;\n    }\n\n    // Check if we should scan (throttle)\n    const should = await shouldScan();\n    if (!should) {\n\n      return;\n    }\n\n    set({ isScanning: true });\n\n    try {\n\n\n      // Load dismissed suggestions\n      const dismissed = await loadDismissedSuggestions();\n\n      // Scan upcoming events (next 30 days)\n      const upcomingResult = await scanUpcomingEvents();\n\n\n      // Scan recent past events (last 7 days)\n      const pastResult = await scanRecentPastEvents();\n\n\n      // Filter out dismissed events and events without friend matches\n      const now = new Date();\n\n      const upcomingSuggestions: EventSuggestion[] = upcomingResult.events\n        .filter((event) => !dismissed.has(event.id))\n        .filter((event) => event.matchedFriends.length > 0) // Only show events with friend matches\n        .map((event) => ({\n          event,\n          type: 'upcoming' as SuggestionType,\n          suggestedAt: now,\n        }));\n\n      const pastSuggestions: EventSuggestion[] = pastResult.events\n        .filter((event) => !dismissed.has(event.id))\n        .filter((event) => event.matchedFriends.length > 0) // Only show events with friend matches\n        .map((event) => ({\n          event,\n          type: 'past' as SuggestionType,\n          suggestedAt: now,\n        }));\n\n      set({\n        upcomingEvents: upcomingSuggestions,\n        pastEvents: pastSuggestions,\n        isScanning: false,\n        lastScanTime: now,\n      });\n\n      // Update last scan time\n      await updateLastScanTime();\n\n\n    } catch (error) {\n      console.error('[EventSuggestionStore] Error scanning for suggestions:', error);\n      set({ isScanning: false });\n    }\n  },\n\n  dismissUpcomingEvent: async (eventId: string) => {\n    await saveDismissedSuggestion(eventId);\n    set((state) => ({\n      upcomingEvents: state.upcomingEvents.filter((s) => s.event.id !== eventId),\n    }));\n  },\n\n  dismissPastEvent: async (eventId: string) => {\n    await saveDismissedSuggestion(eventId);\n    set((state) => ({\n      pastEvents: state.pastEvents.filter((s) => s.event.id !== eventId),\n      showingPastEvent: state.showingPastEvent?.event.id === eventId ? null : state.showingPastEvent,\n    }));\n  },\n\n  showPastEventModal: (suggestion: EventSuggestion) => {\n    set({ showingPastEvent: suggestion });\n  },\n\n  hidePastEventModal: () => {\n    set({ showingPastEvent: null });\n  },\n\n  clearAllSuggestions: () => {\n    set({\n      upcomingEvents: [],\n      pastEvents: [],\n      showingPastEvent: null,\n    });\n  },\n}));\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/store/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/store/interaction.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/interactions/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/journal/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/journal/services/journal-context-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Model' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'friendId' is defined but never used. Allowed unused args must match /^_/u.","line":716,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":716,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Journal Context Engine\n * \n * The brains behind contextual journaling. Powers:\n * - Meaningful weave detection (worthy of deeper reflection)\n * - Friend context retrieval (history, themes, previous entries)\n * - Memory surfacing (anniversaries, patterns, throwbacks)\n * - Friendship arc data (timeline of entries per friend)\n * \n * Designed for LLM handoff — rule-based for now, but interfaces \n * support swapping in AI-generated context later.\n */\n\nimport { database } from '@/db';\nimport { Q, Model } from '@nozbe/watermelondb';\nimport InteractionModel from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport JournalEntry from '@/db/models/JournalEntry';\nimport JournalEntryFriend from '@/db/models/JournalEntryFriend';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface MeaningfulWeave {\n  interaction: InteractionModel;\n  friends: FriendModel[];\n  meaningfulnessScore: number;  // 0-100, higher = more worthy of reflection\n  meaningfulnessReasons: string[];  // Why this is worth reflecting on\n}\n\nexport interface FriendJournalContext {\n  friend: FriendModel;\n  friendshipDuration: string;  // \"2 years, 3 months\"\n  friendshipDurationMonths: number;\n  totalWeaves: number;\n  totalJournalEntries: number;\n  recentWeaves: RecentWeaveItem[];  // Last 5\n  recentEntries: RecentEntryItem[];  // Last 3\n  detectedThemes: string[];  // From past entries\n  thisMonthWeaves: number;\n  daysSinceLastWeave: number;\n  lastEntryDate: Date | null;\n}\n\nexport interface RecentWeaveItem {\n  id: string;\n  date: Date;\n  category: string;\n  activity: string;\n  notes: string | null;\n  vibe: string;\n  duration: string;\n}\n\nexport interface RecentEntryItem {\n  id: string;\n  date: Date;\n  title: string;\n  preview: string;  // First 100 chars\n  type: 'journal' | 'reflection';\n}\n\nexport interface Memory {\n  id: string;\n  type: 'anniversary' | 'pattern' | 'milestone' | 'throwback' | 'first_entry';\n  title: string;\n  description: string;\n  relatedEntryId?: string;\n  relatedFriendId?: string;\n  relatedFriendName?: string;\n  actionLabel: string;  // \"Read entry\", \"Write about this\"\n  priority: number;  // Higher = show first\n}\n\nexport interface FriendshipArc {\n  friend: FriendModel;\n  friendshipDuration: string;\n  totalWeaves: number;\n  totalEntries: number;\n  commonThemes: string[];\n  commonActivities: string[];\n  timeline: FriendshipArcEntry[];\n  firstEntryDate: Date | null;\n  mostRecentEntryDate: Date | null;\n}\n\nexport interface FriendshipArcEntry {\n  id: string;\n  date: Date;\n  type: 'journal' | 'reflection' | 'milestone';\n  title: string;\n  preview: string;\n  weaveCount?: number;  // For reflection entries\n}\n\nexport interface JournalBrowseFilters {\n  friendId?: string;\n  theme?: string;\n  dateFrom?: Date;\n  dateTo?: Date;\n  type?: 'all' | 'journal' | 'reflection';\n}\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nconst MEANINGFUL_WEAVE_THRESHOLDS = {\n  noteLength: 20,           // Notes longer than this are meaningful\n  highVibe: ['FullMoon', 'WaxingGibbous'],\n  deepCategories: ['deep-talk', 'heart-to-heart', 'support'],\n  longDurations: ['Extended', 'Long'],\n};\n\n// Theme keywords to detect from journal text\nconst THEME_KEYWORDS: Record<string, string[]> = {\n  career: ['job', 'work', 'career', 'promotion', 'boss', 'interview', 'office', 'salary', 'resign'],\n  growth: ['grow', 'change', 'learn', 'realiz', 'understand', 'perspective', 'progress'],\n  support: ['support', 'help', 'there for', 'listen', 'advice', 'comfort', 'reassur'],\n  celebration: ['celebrat', 'birthday', 'achievement', 'success', 'happy', 'excited', 'proud'],\n  challenge: ['difficult', 'hard', 'struggle', 'challenge', 'conflict', 'argument', 'disagree'],\n  reconnection: ['reconnect', 'miss', 'long time', 'catch up', 'back in touch'],\n  vulnerability: ['vulnerab', 'open up', 'honest', 'real', 'deep', 'admit', 'confess'],\n  gratitude: ['grateful', 'thankful', 'appreciate', 'lucky', 'blessed'],\n  boundaries: ['boundar', 'space', 'limit', 'say no', 'too much', 'overwhelm'],\n  trust: ['trust', 'rely', 'depend', 'count on', 'safe', 'confide'],\n};\n\n// ============================================================================\n// CORE FUNCTIONS\n// ============================================================================\n\n/**\n * Get recent weaves that are meaningful enough to warrant deeper reflection.\n * \"Meaningful\" = has notes, high vibe, deep category, or long duration.\n */\nexport async function getRecentMeaningfulWeaves(\n  limit: number = 5,\n  hoursBack: number = 48\n): Promise<MeaningfulWeave[]> {\n  const cutoff = Date.now() - (hoursBack * 60 * 60 * 1000);\n\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('interaction_date', Q.gte(cutoff)),\n      Q.where('status', 'completed'),\n      Q.sortBy('interaction_date', Q.desc),\n      Q.take(20)  // Get more than needed, then filter by meaningfulness\n    )\n    .fetch();\n\n  if (interactions.length === 0) return [];\n\n  // Score and filter interactions\n  const scored: MeaningfulWeave[] = [];\n\n  for (const interaction of interactions) {\n    const { score, reasons } = calculateMeaningfulnessScore(interaction);\n\n    if (score >= 30) {  // Minimum threshold to be \"meaningful\"\n      // Get friends for this interaction\n      const friends = await getFriendsForInteraction(interaction.id);\n\n      scored.push({\n        interaction,\n        friends,\n        meaningfulnessScore: score,\n        meaningfulnessReasons: reasons,\n      });\n    }\n  }\n\n  // Sort by score descending, take top N\n  return scored\n    .sort((a, b) => b.meaningfulnessScore - a.meaningfulnessScore)\n    .slice(0, limit);\n}\n\n/**\n * Calculate how meaningful a weave is for reflection purposes.\n */\nfunction calculateMeaningfulnessScore(interaction: InteractionModel): {\n  score: number;\n  reasons: string[];\n} {\n  let score = 0;\n  const reasons: string[] = [];\n\n  // Notes length (most important signal)\n  const noteLength = interaction.note?.length || 0;\n  if (noteLength >= MEANINGFUL_WEAVE_THRESHOLDS.noteLength) {\n    score += 40;\n    reasons.push('has detailed notes');\n  } else if (noteLength > 0) {\n    score += 15;\n    reasons.push('has notes');\n  }\n\n  // Vibe (emotional significance)\n  if (MEANINGFUL_WEAVE_THRESHOLDS.highVibe.includes(interaction.vibe || '')) {\n    score += 25;\n    reasons.push('high emotional impact');\n  }\n\n  // Category (type of interaction)\n  const category = interaction.interactionCategory || interaction.activity || '';\n  if (MEANINGFUL_WEAVE_THRESHOLDS.deepCategories.some(c =>\n    category.toLowerCase().includes(c)\n  )) {\n    score += 20;\n    reasons.push('deep conversation');\n  }\n\n  // Duration\n  if (MEANINGFUL_WEAVE_THRESHOLDS.longDurations.includes(interaction.duration || '')) {\n    score += 15;\n    reasons.push('extended time together');\n  }\n\n  return { score: Math.min(100, score), reasons };\n}\n\n/**\n * Get friends associated with an interaction.\n */\nasync function getFriendsForInteraction(interactionId: string): Promise<FriendModel[]> {\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('interaction_id', interactionId))\n    .fetch();\n\n  if (links.length === 0) return [];\n\n  const friendIds = links.map(l => l.friendId);\n  return database\n    .get<FriendModel>('friends')\n    .query(Q.where('id', Q.oneOf(friendIds)))\n    .fetch();\n}\n\n/**\n * Get comprehensive context for journaling about a specific friend.\n */\nexport async function getFriendContext(friendId: string): Promise<FriendJournalContext | null> {\n  try {\n    const friend = await database.get<FriendModel>('friends').find(friendId);\n    if (!friend) return null;\n\n    const [\n      totalWeaves,\n      totalJournalEntries,\n      recentWeaves,\n      recentEntries,\n      thisMonthWeaves,\n      lastWeaveDate,\n      detectedThemes,\n    ] = await Promise.all([\n      getTotalWeavesForFriend(friendId),\n      getTotalEntriesForFriend(friendId),\n      getRecentWeavesForFriend(friendId, 5),\n      getRecentEntriesForFriend(friendId, 3),\n      getThisMonthWeavesForFriend(friendId),\n      getLastWeaveDateForFriend(friendId),\n      getDetectedThemesForFriend(friendId),\n    ]);\n\n    // Calculate friendship duration\n    const friendCreatedAt = friend.createdAt || new Date();\n    const durationMs = Date.now() - friendCreatedAt.getTime();\n    const durationMonths = Math.floor(durationMs / (30 * 24 * 60 * 60 * 1000));\n    const friendshipDuration = formatDuration(durationMonths);\n\n    // Days since last weave\n    const daysSinceLastWeave = lastWeaveDate\n      ? Math.floor((Date.now() - lastWeaveDate.getTime()) / (1000 * 60 * 60 * 24))\n      : 999;\n\n    // Last entry date\n    const lastEntryDate = recentEntries.length > 0 ? recentEntries[0].date : null;\n\n    return {\n      friend,\n      friendshipDuration,\n      friendshipDurationMonths: durationMonths,\n      totalWeaves,\n      totalJournalEntries,\n      recentWeaves,\n      recentEntries,\n      detectedThemes,\n      thisMonthWeaves,\n      daysSinceLastWeave,\n      lastEntryDate,\n    };\n  } catch (error) {\n    console.error('[JournalContextEngine] Error getting friend context:', error);\n    return null;\n  }\n}\n\n/**\n * Surface memories worth revisiting (anniversaries, patterns, milestones).\n */\nexport async function getMemories(limit: number = 3): Promise<Memory[]> {\n  const memories: Memory[] = [];\n\n  // Check for anniversaries (entries from ~1 year ago)\n  const anniversaryMemories = await getAnniversaryMemories();\n  memories.push(...anniversaryMemories);\n\n  // Check for first entries with friends\n  const firstEntryMemories = await getFirstEntryMemories();\n  memories.push(...firstEntryMemories);\n\n  // Check for pattern-based memories\n  const patternMemories = await getPatternMemories();\n  memories.push(...patternMemories);\n\n  // Sort by priority and take top N\n  return memories\n    .sort((a, b) => b.priority - a.priority)\n    .slice(0, limit);\n}\n\n/**\n * Get complete friendship arc (timeline of entries and milestones).\n */\nexport async function getFriendshipArc(friendId: string): Promise<FriendshipArc | null> {\n  try {\n    const friend = await database.get<FriendModel>('friends').find(friendId);\n    if (!friend) return null;\n\n    // Get all journal entries mentioning this friend via join table\n    const links = await database\n      .get<JournalEntryFriend>('journal_entry_friends')\n      .query(Q.where('friend_id', friendId))\n      .fetch();\n\n    const entryIds = links.map(l => l.journalEntryId);\n\n    // Fetch the actual entries\n    const friendEntries = await database\n      .get<JournalEntry>('journal_entries')\n      .query(\n        Q.where('id', Q.oneOf(entryIds)),\n        Q.sortBy('entry_date', Q.desc)\n      )\n      .fetch();\n\n    // Get weekly reflections that mention this friend\n    const reflections = await getReflectionsMentioningFriend(friendId);\n\n    // Build timeline\n    const timeline: FriendshipArcEntry[] = [];\n\n    for (const entry of friendEntries) {\n      timeline.push({\n        id: entry.id,\n        date: new Date(entry.entryDate),\n        type: 'journal',\n        title: entry.title || 'Journal Entry',\n        preview: (entry.content || '').slice(0, 100),\n      });\n    }\n\n    for (const reflection of reflections) {\n      timeline.push({\n        id: reflection.id,\n        date: new Date(reflection.weekStartDate),\n        type: 'reflection',\n        title: 'Weekly Reflection',\n        preview: (reflection.gratitudeText || '').slice(0, 100),\n        weaveCount: reflection.totalWeaves,\n      });\n    }\n\n    // Sort timeline by date descending\n    timeline.sort((a, b) => b.date.getTime() - a.date.getTime());\n\n    // Calculate totals\n    const totalWeaves = await getTotalWeavesForFriend(friendId);\n    const totalEntries = friendEntries.length;\n\n    // Detect common themes from all entries\n    const allText = friendEntries.map(e => e.content || '').join(' ');\n    const commonThemes = detectThemes(allText);\n\n    // Get common activities from weaves\n    const commonActivities = await getCommonActivitiesForFriend(friendId);\n\n    // Friendship duration\n    const friendCreatedAt = friend.createdAt || new Date();\n    const durationMs = Date.now() - friendCreatedAt.getTime();\n    const durationMonths = Math.floor(durationMs / (30 * 24 * 60 * 60 * 1000));\n\n    // First and most recent entry dates\n    const firstEntryDate = timeline.length > 0\n      ? timeline[timeline.length - 1].date\n      : null;\n    const mostRecentEntryDate = timeline.length > 0\n      ? timeline[0].date\n      : null;\n\n    return {\n      friend,\n      friendshipDuration: formatDuration(durationMonths),\n      totalWeaves,\n      totalEntries,\n      commonThemes,\n      commonActivities,\n      timeline,\n      firstEntryDate,\n      mostRecentEntryDate,\n    };\n  } catch (error) {\n    console.error('[JournalContextEngine] Error getting friendship arc:', error);\n    return null;\n  }\n}\n\n/**\n * Get friends sorted by journal engagement (entries + weaves).\n */\nexport async function getFriendsForBrowsing(): Promise<{\n  friend: FriendModel;\n  entryCount: number;\n  lastEntryDate: Date | null;\n  recentActivityIndicator: 'high' | 'medium' | 'low';\n}[]> {\n  const friends = await database\n    .get<FriendModel>('friends')\n    .query(Q.where('is_dormant', false))\n    .fetch();\n\n  const results = await Promise.all(\n    friends.map(async (friend) => {\n      const entryCount = await getTotalEntriesForFriend(friend.id);\n      const recentEntries = await getRecentEntriesForFriend(friend.id, 1);\n      const lastEntryDate = recentEntries.length > 0 ? recentEntries[0].date : null;\n\n      // Calculate activity indicator based on entry count\n      let recentActivityIndicator: 'high' | 'medium' | 'low';\n      if (entryCount >= 5) {\n        recentActivityIndicator = 'high';\n      } else if (entryCount >= 2) {\n        recentActivityIndicator = 'medium';\n      } else {\n        recentActivityIndicator = 'low';\n      }\n\n      return {\n        friend,\n        entryCount,\n        lastEntryDate,\n        recentActivityIndicator,\n      };\n    })\n  );\n\n  // Sort by entry count descending, then by last entry date\n  return results\n    .filter(r => r.entryCount > 0)  // Only show friends with entries\n    .sort((a, b) => {\n      if (b.entryCount !== a.entryCount) {\n        return b.entryCount - a.entryCount;\n      }\n      if (a.lastEntryDate && b.lastEntryDate) {\n        return b.lastEntryDate.getTime() - a.lastEntryDate.getTime();\n      }\n      return 0;\n    });\n}\n\n/**\n * Search journal entries with filters.\n */\nexport async function searchEntries(\n  query: string,\n  filters: JournalBrowseFilters = {}\n): Promise<(JournalEntry | WeeklyReflection)[]> {\n  const results: (JournalEntry | WeeklyReflection)[] = [];\n  const normalizedQuery = query.toLowerCase().trim();\n\n  // Search journal entries\n  let journalQuery = database\n    .get<JournalEntry>('journal_entries')\n    .query(Q.sortBy('entry_date', Q.desc));\n\n  // Apply date filters if provided\n  const conditions: any[] = [];\n\n  if (filters.dateFrom) {\n    conditions.push(Q.where('entry_date', Q.gte(filters.dateFrom.getTime())));\n  }\n\n  if (filters.dateTo) {\n    conditions.push(Q.where('entry_date', Q.lte(filters.dateTo.getTime())));\n  }\n\n  // Friend filter\n  if (filters.friendId) {\n    const links = await database\n      .get<JournalEntryFriend>('journal_entry_friends')\n      .query(Q.where('friend_id', filters.friendId))\n      .fetch();\n    const entryIds = links.map(l => l.journalEntryId);\n    conditions.push(Q.where('id', Q.oneOf(entryIds)));\n  }\n\n  // Add sort by date desc\n  conditions.push(Q.sortBy('entry_date', Q.desc));\n\n  journalQuery = database.get<JournalEntry>('journal_entries').query(...conditions);\n\n  const journalEntries = await journalQuery.fetch();\n\n  // Filter by text search\n  for (const entry of journalEntries) {\n    // Text search\n    if (normalizedQuery) {\n      const content = (entry.content || '').toLowerCase();\n      const title = (entry.title || '').toLowerCase();\n      if (!content.includes(normalizedQuery) && !title.includes(normalizedQuery)) {\n        continue;\n      }\n    }\n    results.push(entry);\n  }\n\n  // Also search weekly reflections if type allows\n  if (filters.type === 'all' || filters.type === 'reflection') {\n    const reflections = await database\n      .get<WeeklyReflection>('weekly_reflections')\n      .query(Q.sortBy('week_start_date', Q.desc))\n      .fetch();\n\n    for (const reflection of reflections) {\n      if (normalizedQuery) {\n        const text = (reflection.gratitudeText || '').toLowerCase();\n        if (!text.includes(normalizedQuery)) {\n          continue;\n        }\n      }\n\n      results.push(reflection);\n    }\n  }\n\n  // Sort combined results by date\n  return results.sort((a, b) => {\n    const dateA = 'entryDate' in a ? a.entryDate : a.weekStartDate;\n    const dateB = 'entryDate' in b ? b.entryDate : b.weekStartDate;\n    return dateB - dateA;\n  });\n}\n\n// ============================================================================\n// HELPER FUNCTIONS - DATA FETCHING\n// ============================================================================\n\nasync function getTotalWeavesForFriend(friendId: string): Promise<number> {\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  if (links.length === 0) return 0;\n\n  const interactionIds = links.map(l => l.interactionId);\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  return interactions.length;\n}\n\nasync function getTotalEntriesForFriend(friendId: string): Promise<number> {\n  return await database\n    .get<JournalEntryFriend>('journal_entry_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetchCount();\n}\n\nasync function getRecentWeavesForFriend(\n  friendId: string,\n  limit: number\n): Promise<RecentWeaveItem[]> {\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  if (links.length === 0) return [];\n\n  const interactionIds = links.map(l => l.interactionId);\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed'),\n      Q.sortBy('interaction_date', Q.desc),\n      Q.take(limit)\n    )\n    .fetch();\n\n  return interactions.map(i => ({\n    id: i.id,\n    date: new Date(i.interactionDate),\n    category: i.interactionCategory || 'Connection',\n    activity: i.activity || i.interactionCategory || 'Connection',\n    notes: i.note || null,\n    vibe: i.vibe || 'Neutral',\n    duration: i.duration || 'Short',\n  }));\n}\n\nasync function getRecentEntriesForFriend(\n  friendId: string,\n  limit: number\n): Promise<RecentEntryItem[]> {\n  const links = await database\n    .get<JournalEntryFriend>('journal_entry_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  const entryIds = links.map(l => l.journalEntryId);\n\n  const friendEntries = await database\n    .get<JournalEntry>('journal_entries')\n    .query(\n      Q.where('id', Q.oneOf(entryIds)),\n      Q.sortBy('entry_date', Q.desc),\n      Q.take(limit)\n    )\n    .fetch();\n\n  return friendEntries.map(e => ({\n    id: e.id,\n    date: new Date(e.entryDate),\n    title: e.title || 'Journal Entry',\n    preview: (e.content || '').slice(0, 100),\n    type: 'journal' as const,\n  }));\n}\n\nasync function getThisMonthWeavesForFriend(friendId: string): Promise<number> {\n  const now = new Date();\n  const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);\n\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  if (links.length === 0) return 0;\n\n  const interactionIds = links.map(l => l.interactionId);\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed'),\n      Q.where('interaction_date', Q.gte(monthStart.getTime()))\n    )\n    .fetch();\n\n  return interactions.length;\n}\n\nasync function getLastWeaveDateForFriend(friendId: string): Promise<Date | null> {\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  if (links.length === 0) return null;\n\n  const interactionIds = links.map(l => l.interactionId);\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed'),\n      Q.sortBy('interaction_date', Q.desc),\n      Q.take(1)\n    )\n    .fetch();\n\n  return interactions[0] ? new Date(interactions[0].interactionDate) : null;\n}\n\nasync function getDetectedThemesForFriend(friendId: string): Promise<string[]> {\n  const links = await database\n    .get<JournalEntryFriend>('journal_entry_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  const entryIds = links.map(l => l.journalEntryId);\n\n  const friendEntries = await database\n    .get<JournalEntry>('journal_entries')\n    .query(Q.where('id', Q.oneOf(entryIds)))\n    .fetch();\n\n  const allText = friendEntries.map(e => e.content || '').join(' ');\n  return detectThemes(allText);\n}\n\nasync function getReflectionsMentioningFriend(friendId: string): Promise<WeeklyReflection[]> {\n  // Note: This assumes weekly reflections might mention friends in gratitude text\n  // You may need to adjust based on your actual data model\n  const reflections = await database\n    .get<WeeklyReflection>('weekly_reflections')\n    .query(Q.sortBy('week_start_date', Q.desc))\n    .fetch();\n\n  // For now, return reflections where the friend was likely involved\n  // This could be enhanced with proper friend linking in reflections\n  return reflections.slice(0, 10);  // Simplified for now\n}\n\nasync function getCommonActivitiesForFriend(friendId: string): Promise<string[]> {\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  if (links.length === 0) return [];\n\n  const interactionIds = links.map(l => l.interactionId);\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  // Count activities\n  const activityCounts = new Map<string, number>();\n  for (const interaction of interactions) {\n    const activity = interaction.activity || interaction.interactionCategory || 'Connection';\n    activityCounts.set(activity, (activityCounts.get(activity) || 0) + 1);\n  }\n\n  // Sort by count and take top 3\n  return Array.from(activityCounts.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([activity]) => activity);\n}\n\n// ============================================================================\n// HELPER FUNCTIONS - MEMORIES\n// ============================================================================\n\nexport async function getAnniversaryMemories(): Promise<Memory[]> {\n  const memories: Memory[] = [];\n  const now = new Date();\n\n  // Look for entries from ~1 year ago (widened window)\n  const oneYearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());\n  const startRange = new Date(oneYearAgo);\n  startRange.setDate(startRange.getDate() - 7);\n  const endRange = new Date(oneYearAgo);\n  endRange.setDate(endRange.getDate() + 7);\n\n  // 1. Journal Entries\n  const entries = await database\n    .get<JournalEntry>('journal_entries')\n    .query(\n      Q.where('entry_date', Q.between(startRange.getTime(), endRange.getTime()))\n    )\n    .fetch();\n\n  for (const entry of entries) {\n    let friendName: string | undefined;\n    let friendId: string | undefined;\n\n    try {\n      const links = await database\n        .get<JournalEntryFriend>('journal_entry_friends')\n        .query(Q.where('journal_entry_id', entry.id))\n        .fetch();\n\n      if (links.length > 0) {\n        const friend = await links[0].friend.fetch();\n        if (friend) {\n          friendName = friend.name;\n          friendId = friend.id;\n        }\n      }\n    } catch (e) {\n      console.warn('Error fetching friends for anniversary memory', e);\n    }\n\n    const priority = friendName ? 20 : 10;\n    const contentLength = entry.content?.length || 0;\n    const bonus = contentLength > 100 ? 5 : 0;\n\n    memories.push({\n      id: `anniversary-${entry.id}`,\n      type: 'anniversary',\n      title: friendName ? `Remembering ${friendName}` : 'One Year Ago',\n      description: friendName\n        ? `You wrote about your time with ${friendName} on this day last year`\n        : 'You wrote a journal entry on this day last year.',\n      relatedEntryId: entry.id,\n      relatedFriendId: friendId,\n      relatedFriendName: friendName,\n      actionLabel: 'Read Entry',\n      priority: priority + bonus,\n    });\n  }\n\n  // 2. Weekly Reflections\n  const reflections = await database\n    .get<WeeklyReflection>('weekly_reflections')\n    .query(\n      Q.where('week_start_date', Q.between(startRange.getTime(), endRange.getTime()))\n    )\n    .fetch();\n\n  for (const reflection of reflections) {\n    memories.push({\n      id: `reflection-anniversary-${reflection.id}`,\n      type: 'throwback',\n      title: 'One Year Ago Today',\n      description: 'You completed a weekly reflection one year ago.',\n      relatedEntryId: reflection.id,\n      actionLabel: 'Read Reflection',\n      priority: 15, // Higher than generic entry, lower than friend entry\n    });\n  }\n\n  return memories;\n}\n\nasync function getFirstEntryMemories(): Promise<Memory[]> {\n  const memories: Memory[] = [];\n\n  // Find friends we've never journaled about but have significant weave history with\n  const friends = await database\n    .get<FriendModel>('friends')\n    .query(Q.where('is_dormant', false))\n    .fetch();\n\n  for (const friend of friends) {\n    const entryCount = await getTotalEntriesForFriend(friend.id);\n    if (entryCount > 0) continue;  // Already has entries\n\n    const weaveCount = await getTotalWeavesForFriend(friend.id);\n    if (weaveCount < 5) continue;  // Not enough history yet\n\n    memories.push({\n      id: `first_entry_${friend.id}`,\n      type: 'first_entry',\n      title: `Start ${friend.name}'s story`,\n      description: `You've connected ${weaveCount} times but never written about this friendship`,\n      relatedFriendId: friend.id,\n      relatedFriendName: friend.name,\n      actionLabel: 'Write first entry',\n      priority: 60,\n    });\n  }\n\n  return memories.slice(0, 2);  // Max 2 first-entry suggestions\n}\n\nasync function getPatternMemories(): Promise<Memory[]> {\n  const memories: Memory[] = [];\n\n  // Look for themes that appear multiple times\n  const entries = await database\n    .get<JournalEntry>('journal_entries')\n    .query(Q.sortBy('entry_date', Q.desc), Q.take(50))\n    .fetch();\n\n  const themeFrequency = new Map<string, { count: number; lastEntry: JournalEntry }>();\n\n  for (const entry of entries) {\n    const text = entry.content || '';\n    const themes = detectThemes(text);\n\n    for (const theme of themes) {\n      const existing = themeFrequency.get(theme);\n      if (existing) {\n        existing.count++;\n      } else {\n        themeFrequency.set(theme, { count: 1, lastEntry: entry });\n      }\n    }\n  }\n\n  // Find recurring themes (3+ mentions)\n  for (const [theme, data] of themeFrequency) {\n    if (data.count >= 3) {\n      memories.push({\n        id: `pattern_${theme}`,\n        type: 'pattern',\n        title: `Recurring theme: ${theme}`,\n        description: `You've written about \"${theme}\" in ${data.count} entries`,\n        relatedEntryId: data.lastEntry.id,\n        actionLabel: 'Explore theme',\n        priority: 50 + data.count,\n      });\n    }\n  }\n\n  return memories.slice(0, 2);  // Max 2 pattern memories\n}\n\n// ============================================================================\n// HELPER FUNCTIONS - UTILITIES\n// ============================================================================\n\nfunction formatDuration(months: number): string {\n  if (months < 1) return 'Just started';\n  if (months < 12) return `${months} month${months !== 1 ? 's' : ''}`;\n\n  const years = Math.floor(months / 12);\n  const remainingMonths = months % 12;\n\n  if (remainingMonths === 0) {\n    return `${years} year${years !== 1 ? 's' : ''}`;\n  }\n\n  return `${years} year${years !== 1 ? 's' : ''}, ${remainingMonths} month${remainingMonths !== 1 ? 's' : ''}`;\n}\n\nfunction detectThemes(text: string): string[] {\n  if (!text || text.length < 10) return [];\n\n  const normalizedText = text.toLowerCase();\n  const detectedThemes: string[] = [];\n\n  for (const [theme, keywords] of Object.entries(THEME_KEYWORDS)) {\n    for (const keyword of keywords) {\n      if (normalizedText.includes(keyword)) {\n        detectedThemes.push(theme);\n        break;  // Only add each theme once\n      }\n    }\n  }\n\n  return detectedThemes;\n}\n\n// ============================================================================\n// EXPORTS FOR LLM HANDOFF\n// ============================================================================\n\n/**\n * Future: These interfaces are designed for easy LLM integration.\n * Replace rule-based implementations with API calls when ready.\n */\nexport interface JournalContextEngineConfig {\n  useLLM: boolean;\n  llmEndpoint?: string;\n  llmApiKey?: string;\n}\n\nexport const DEFAULT_CONFIG: JournalContextEngineConfig = {\n  useLLM: false,\n};\n\nexport async function getMemoryForNotification(\n  entryId: string,\n  entryType: 'journal' | 'reflection'\n): Promise<{\n  memory: Memory;\n  entry: JournalEntry | WeeklyReflection;\n  friendName?: string;\n  friendId?: string;\n} | null> {\n  try {\n    if (entryType === 'journal') {\n      const entry = await database.get<JournalEntry>('journal_entries').find(entryId);\n      // Get friends\n      let friendName: string | undefined;\n      let friendId: string | undefined;\n      const links = await database\n        .get<JournalEntryFriend>('journal_entry_friends')\n        .query(Q.where('journal_entry_id', entry.id))\n        .fetch();\n\n      if (links.length > 0) {\n        const friend = await links[0].friend.fetch();\n        friendName = friend?.name;\n        friendId = friend?.id;\n      }\n\n      const memory: Memory = {\n        id: `notif-${entry.id}`,\n        type: 'anniversary',\n        title: friendName ? `Remembering ${friendName}` : 'One Year Ago',\n        description: 'From your journal',\n        relatedEntryId: entry.id,\n        relatedFriendName: friendName,\n        relatedFriendId: friendId,\n        actionLabel: 'Read Entry',\n        priority: 10\n      };\n\n      return { memory, entry, friendName, friendId };\n\n    } else {\n      const reflection = await database.get<WeeklyReflection>('weekly_reflections').find(entryId);\n      const memory: Memory = {\n        id: `notif-${reflection.id}`,\n        type: 'throwback',\n        title: 'Weekly Reflection',\n        description: 'From one year ago',\n        relatedEntryId: reflection.id,\n        actionLabel: 'Read Reflection',\n        priority: 10\n      };\n      return { memory, entry: reflection, friendName: undefined }; // Reflections don't strictly have one friend\n    }\n  } catch (error) {\n    console.error('Error fetching memory for notification:', error);\n    return null;\n  }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/journal/services/journal-prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/hooks/useNotificationPermissions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AppStateStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Notifications' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { useState, useEffect, useCallback } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { checkNotificationPermissions, requestNotificationPermissions, openSystemSettings } from '../services/permission.service';\nimport { notificationStore } from '../services/notification-store';\n\nexport function useNotificationPermissions() {\n    const [hasPermission, setHasPermission] = useState<boolean>(false);\n    const [hasRequested, setHasRequested] = useState<boolean>(false);\n    const [isLoading, setIsLoading] = useState<boolean>(true);\n\n    const check = useCallback(async () => {\n        setIsLoading(true);\n        const granted = await checkNotificationPermissions();\n        const requested = await notificationStore.getPermissionRequested();\n\n        setHasPermission(granted);\n        setHasRequested(requested);\n        setIsLoading(false);\n    }, []);\n\n    const request = useCallback(async () => {\n        setIsLoading(true);\n        const granted = await requestNotificationPermissions();\n        setHasPermission(granted);\n        setHasRequested(true);\n        setIsLoading(false);\n        return granted;\n    }, []);\n\n    // Check on mount and app resume\n    useEffect(() => {\n        check();\n\n        const subscription = AppState.addEventListener('change', (nextAppState) => {\n            if (nextAppState === 'active') {\n                check();\n            }\n        });\n\n        return () => {\n            subscription.remove();\n        };\n    }, [check]);\n\n    return {\n        hasPermission,\n        hasRequested,\n        isLoading,\n        requestPermission: request,\n        openSettings: openSystemSettings,\n        checkPermission: check,\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/battery-checkin.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NotificationChannel' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":29},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":107,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":107,"endColumn":59}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Battery Check-in Channel\n * Handles scheduling and managing of social battery notifications\n */\n\nimport * as Notifications from 'expo-notifications';\nimport { database } from '@/db';\nimport UserProfile from '@/db/models/UserProfile';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from '../notification-analytics';\nimport { shouldSendSocialBatteryNotification } from '../notification-grace-periods';\nimport { NotificationChannel } from '@/modules/notifications';\n\nconst ID_PREFIX = 'daily-battery-checkin';\n\nexport const BatteryCheckinChannel = {\n    schedule: async (time: string = '20:00', startDate?: Date): Promise<void> => {\n        try {\n            // Cancel existing to ensure clean slate\n            await BatteryCheckinChannel.cancel(ID_PREFIX);\n\n            const gracePeriod = await shouldSendSocialBatteryNotification();\n            if (!gracePeriod.shouldSend) {\n                Logger.info('[BatteryCheckin] Skipping grace period:', gracePeriod.reason);\n                return;\n            }\n\n            const [hourStr, minuteStr] = time.split(':');\n            const hour = parseInt(hourStr, 10);\n            const minute = parseInt(minuteStr, 10);\n\n            if (isNaN(hour) || isNaN(minute)) {\n                Logger.error('[BatteryCheckin] Invalid time format:', undefined, time);\n                return;\n            }\n\n            // Safety Net: Schedule 14 days\n            const BATCH_DAYS = 14;\n            const start = startDate || new Date();\n\n            for (let i = 0; i < BATCH_DAYS; i++) {\n                const target = new Date();\n                target.setDate(target.getDate() + i);\n                target.setHours(hour, minute, 0, 0);\n\n                // Skip past\n                if (target <= new Date()) continue;\n\n                // Skip before start date\n                if (startDate && target < startDate) continue;\n\n                const id = `${ID_PREFIX}-${target.toDateString()}`;\n\n                await Notifications.scheduleNotificationAsync({\n                    identifier: id,\n                    content: {\n                        title: \"How's your energy today? 🌙\",\n                        body: \"Take 10 seconds to check in with your social battery.\",\n                        data: { type: 'battery-checkin' },\n                    },\n                    trigger: target as any,\n                });\n\n                await notificationAnalytics.trackScheduled('battery-checkin', id, {\n                    targetDate: target.toISOString(),\n                    batchSize: BATCH_DAYS\n                });\n            }\n\n            Logger.info(`[BatteryCheckin] Scheduled batch starting ${start.toDateString()}`);\n        } catch (error) {\n            Logger.error('[BatteryCheckin] Error scheduling:', error);\n        }\n    },\n\n    cancel: async (idPrefix: string = ID_PREFIX): Promise<void> => {\n        // Cancel the main recurring ID just in case\n        await Notifications.cancelScheduledNotificationAsync(ID_PREFIX);\n\n        // Cancel all batch items\n        const scheduled = await Notifications.getAllScheduledNotificationsAsync();\n        for (const n of scheduled) {\n            if (n.identifier.startsWith(idPrefix)) {\n                await Notifications.cancelScheduledNotificationAsync(n.identifier);\n            }\n        }\n        await notificationAnalytics.trackCancelled('battery-checkin', 'user_disabled_or_reset');\n    },\n\n    handleTap: (data: any, router: any) => {\n        // Navigate to dashboard then open sheet\n        if (router.canGoBack()) router.dismissAll();\n        router.replace('/dashboard');\n\n        // We need a way to open the sheet. \n        // Ideally this shouldn't depend on UIStore directly here but for now we keep it consistent.\n        // In a pure refactor we might emit an event or use a different mechanism, \n        // but the requirement is \"Don't break functionality\", so we will import store in response handler \n        // or pass a callback.\n        // The response handler will likely import the store as before.\n        // For this 'Channel' interface, handleTap might just return where to go?\n        // Let's stick to the interface: handleTap(data, router)\n        // But notice the original code used `useUIStore.getState().openSocialBatterySheet()`.\n        // We will leave the side-effects (opening sheet) to the caller (ResponseHandler)\n        // OR we import store here. Importing store is easiest for now.\n        const { useUIStore } = require('@/stores/uiStore');\n        setTimeout(() => {\n            useUIStore.getState().openSocialBatterySheet();\n            notificationAnalytics.trackActionCompleted('battery-checkin', 'open_sheet');\n        }, 500);\n    },\n\n    // Specific methods for this channel\n\n    /**\n     * Reschedule starting tomorrow (skip today)\n     */\n    rescheduleForTomorrow: async (time: string = '20:00'): Promise<void> => {\n        const tomorrow = new Date();\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        tomorrow.setHours(0, 0, 0, 0);\n\n        // Cancel just today's instance?\n        // Or cancel all and restart from tomorrow? Restarting is safer.\n        const todayStr = new Date().toDateString();\n        await Notifications.cancelScheduledNotificationAsync(`${ID_PREFIX}-${todayStr}`);\n\n        await BatteryCheckinChannel.schedule(time, tomorrow);\n    },\n\n    /**\n     * Check if batch needs extending (when app opens)\n     */\n    checkAndExtendBatch: async (): Promise<void> => {\n        // Check pending notifications\n        const scheduled = await Notifications.getAllScheduledNotificationsAsync();\n        const batteryNotifs = scheduled.filter(n => n.identifier.startsWith(ID_PREFIX));\n\n        // If fewer than 2 days remaining, extend\n        if (batteryNotifs.length < 2) {\n            Logger.info('[BatteryCheckin] Batch running low, extending...');\n            const profiles = await database.get<UserProfile>('user_profile').query().fetch();\n            const profile = profiles[0];\n            if (profile?.batteryCheckinEnabled) {\n                // Find the last scheduled date to start after? \n                // Or just call schedule() which handles overlaps by logic (but we need to be careful not to double up)\n                // Our schedule() logic overwrites because of `cancelExisting`. \n                // Actually `schedule` calls `cancel` first. So calling `schedule` refreshes the whole batch. Correct.\n                const time = profile.batteryCheckinTime || '20:00';\n                await BatteryCheckinChannel.schedule(time);\n            }\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/deepening-nudge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/evening-digest.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'notificationStore' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":27},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":163,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":163,"endColumn":59},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":164,"column":27,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":164,"endColumn":50}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as Notifications from 'expo-notifications';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from '../notification-analytics';\nimport { NotificationChannel } from '@/modules/notifications';\nimport { FocusGenerator, FocusData } from '@/modules/intelligence';\nimport { notificationStore } from '../notification-store';\nimport { differenceInDays } from 'date-fns';\n\nexport interface DigestItem {\n    type: 'plan' | 'confirmation' | 'suggestion' | 'birthday' | 'anniversary' | 'life_event' | 'memory';\n    priority: number;\n    title: string;\n    subtitle?: string;\n    friendId?: string;\n    friendName?: string;\n    interactionId?: string;\n    data?: Record<string, any>;\n}\n\nexport interface DigestContent {\n    items: DigestItem[];\n    notificationTitle: string;\n    notificationBody: string;\n    shouldSend: boolean;\n}\n\nconst ID_PREFIX = 'evening-digest';\n\nexport const EveningDigestChannel: NotificationChannel & {\n    generateContent: () => Promise<DigestContent>,\n    cancel: () => Promise<void>\n} = {\n    schedule: async (time: string = '19:00'): Promise<void> => {\n        try {\n            await EveningDigestChannel.cancel();\n\n            // Parse time\n            const [hourStr, minuteStr] = time.split(':');\n            const hour = parseInt(hourStr, 10);\n            const minute = parseInt(minuteStr, 10);\n\n            if (isNaN(hour) || isNaN(minute)) {\n                Logger.error('[EveningDigest] Invalid time:', time);\n                return;\n            }\n\n            // Standard daily schedule\n            // We schedule a \"check\" notification that will trigger standard \"Evening Check-in\" \n            // OR we must accept that content is static \"Check your evening digest\" \n            // UNLESS we use background fetch to update the notification body daily.\n            // For Weave's current architecture (local, no background fetch guaranteed), \n            // we will use a GENERIC message that encourages opening.\n            // \"Your evening check-in is ready. Tap to view today's summary.\"\n            // AND we generate the *actual* content (DigestContent) only when the user TAPS (in handleTap).\n\n            // Wait, the Requirement said: \"Notification Copy Generation: { title: \"Sarah's birthday tomorrow\", body: \"Tap to see details\" }\"\n            // To do this dynamically without server/background fetch is hard on Expo/iOS.\n            // HOWEVER, we CAN schedule specific notifications if we know the events ahead of time (like birthdays).\n            // But plans change.\n            // Compromise: We schedule a recurring notification with a generic message,\n            // OR the user accepts that it might be slightly stale if we schedule it 24h ahead?\n            // Actually, we can \"reschedule after each digest fires\" (from requirements).\n            // This suggests validation happens when the app is OPEN.\n            // If the app is NOT opened, the recurring notification fires with generic or last-known content.\n\n            // For V1 of Digest, let's stick to a reliable recurring notification with a static, inviting message.\n            // \"Your evening brief is ready 🌙\"\n            // \"Take a moment to review today's connections and plans.\"\n\n            await Notifications.scheduleNotificationAsync({\n                identifier: ID_PREFIX,\n                content: {\n                    title: \"Your evening brief 🌙\",\n                    body: \"Take a moment to review today's connections and plans.\",\n                    data: { type: 'evening-digest' },\n                    sound: true,\n                },\n                trigger: {\n                    hour,\n                    minute,\n                    repeats: true,\n                } as any,\n            });\n\n            await notificationAnalytics.trackScheduled('evening-digest', ID_PREFIX, { time });\n            Logger.info(`[EveningDigest] Scheduled for ${time}`);\n\n        } catch (error) {\n            Logger.error('[EveningDigest] Error scheduling:', error);\n        }\n    },\n\n    cancel: async (): Promise<void> => {\n        await Notifications.cancelScheduledNotificationAsync(ID_PREFIX);\n    },\n\n    generateContent: async (): Promise<DigestContent> => {\n        const focusData: FocusData = await FocusGenerator.generateFocusData();\n        const items: DigestItem[] = [];\n\n        // 1. Pending Confirmations / Today's Plans (Priority 100/70)\n        // FocusGenerator.getImportantPlans includes both.\n        // We separate them by date if needed, or Treat 'pending' as high priority.\n        focusData.pendingConfirmations.forEach(p => {\n            const isToday = differenceInDays(new Date(p.interactionDate), new Date()) === 0;\n            items.push({\n                type: isToday ? 'plan' : 'confirmation',\n                priority: isToday ? 100 : 70, // Today's plans strictly higher\n                title: p.title || 'Untitled Plan',\n                subtitle: isToday ? `Today` : `Pending from ${new Date(p.interactionDate).toLocaleDateString()}`,\n                interactionId: p.id,\n                data: { status: p.status }\n            });\n        });\n\n        // 2. Upcoming (Priority 90/30)\n        focusData.upcomingDates.forEach(d => {\n            const priority = d.daysUntil <= 1 ? 90 : (d.importance === 'critical' ? 80 : 30);\n            items.push({\n                type: d.type,\n                priority,\n                title: d.type === 'birthday' ? `${d.friend.name}'s Birthday` : (d.title || d.type),\n                subtitle: d.daysUntil === 0 ? 'Today' : (d.daysUntil === 1 ? 'Tomorrow' : `In ${d.daysUntil} days`),\n                friendId: d.friend.id,\n                friendName: d.friend.name,\n            });\n        });\n\n        // 3. Suggestions (Priority 50/40)\n        focusData.suggestions.forEach(s => {\n            items.push({\n                type: 'suggestion',\n                priority: s.urgency === 'critical' ? 60 : (s.urgency === 'high' ? 50 : 40),\n                title: s.title,\n                subtitle: s.subtitle,\n                friendId: s.friendId,\n                data: { suggestionId: s.id }\n            });\n        });\n\n        // Sort items by priority desc\n        items.sort((a, b) => b.priority - a.priority);\n\n        // Determine if meaningful\n        // \"Nothing meaningful\" criteria: No plans, no birthdays <3 days, no crit events, no high urgency suggestions.\n        // Simplified: If items length > 0, it's meaningful (since we filter upstream partially).\n        // But let's check priorities.\n        const highValueItems = items.filter(i => i.priority >= 40);\n        const shouldSend = highValueItems.length > 0;\n\n        return {\n            items,\n            notificationTitle: \"Your evening brief 🌙\", // Dynamic copy not used for static schedule\n            notificationBody: \"Tap to view summary\",\n            shouldSend\n        };\n    },\n\n    handleTap: async (data: any, router: any) => {\n        // We need to OPEN the digest sheet.\n        // We'll use UIStore to toggle visibility and pass data.\n        // Lazy load store\n        const { useUIStore } = require('@/stores/uiStore');\n        const { Alert } = require('react-native');\n\n        // Check time restriction (7 PM - 9 PM) unless it's a test\n        const now = new Date();\n        const currentHour = now.getHours();\n        const isEvening = currentHour >= 19 && currentHour < 21; // 7 PM to 8:59 PM\n        const isTest = data?.isTest === true;\n\n        if (!isEvening && !isTest) {\n            Logger.info('[EveningDigest] Tap ignored outside 7-9 PM window');\n            // Optional: Show an alert explaining why it didn't open?\n            // \"The evening digest is only available between 7 PM and 9 PM.\"\n            // User requirement: \"I only want the evening digest to appear in the evening - 7-9pm\"\n            // It's better to give feedback than do nothing if they tap the notification.\n            Alert.alert(\n                'Evening Digest',\n                'The evening digest is only available between 7:00 PM and 9:00 PM.'\n            );\n            return;\n        }\n\n        // Generate FRESH content on tap to ensure it's up to date\n        // (e.g. if user completed a plan since notification fired)\n        try {\n            const content = await EveningDigestChannel.generateContent();\n\n            // Verify if still meaningful? \n            // Even if empty, if user TAPPED, we should show the sheet (maybe empty state).\n\n            if (router.canGoBack()) router.dismissAll();\n            // Navigate to home first or stay current?\n            // DigestSheet is likely global or on Home.\n            // If global modal, we can just open it.\n\n            useUIStore.getState().openDigestSheet(content.items);\n            notificationAnalytics.trackActionCompleted('evening-digest', 'open_sheet');\n\n        } catch (error) {\n            Logger.error('[EveningDigest] Error generating content on tap:', error);\n            router.replace('/dashboard');\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/event-reminder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/event-suggestion.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MAX_ID_LENGTH' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":20,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Event Suggestion Channel\n * Suggestions to log calendar events that were scanned\n */\n\nimport * as Notifications from 'expo-notifications';\nimport { Platform } from 'react-native';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from '../notification-analytics';\nimport { shouldSendAmbientLoggingNotification } from '../notification-grace-periods';\nimport { NotificationChannel } from '@/modules/notifications';\nimport { ScannedEvent } from '@/modules/interactions';\nimport { format } from 'date-fns';\n\nexport async function scheduleEventSuggestionNotification(event: ScannedEvent) {\n    return EventSuggestionChannel.scheduleEvent(event);\n}\n\nconst MAX_ID_LENGTH = 64; // Expo imposes limits on ID length on Android sometimes, but usually string is fine.\nconst ID_PREFIX = 'event-suggestion-';\n\n// Emoji helper\nfunction getEventEmoji(eventType: string): string {\n    const emojiMap: Record<string, string> = {\n        birthday: '🎂',\n        anniversary: '💝',\n        holiday: '🎉',\n        meal: '🍽️',\n        social: '🎊',\n        activity: '🎯',\n        celebration: '🎉',\n        meeting: '👥',\n        call: '📞',\n        default: '📅',\n    };\n    return emojiMap[eventType] || emojiMap.default;\n}\n\nexport const EventSuggestionChannel: NotificationChannel & {\n    scheduleEvent: (event: ScannedEvent) => Promise<string | null>\n} = {\n    // Generic schedule not used here, typically called with specific event\n    schedule: async () => { },\n\n    scheduleEvent: async (event: ScannedEvent): Promise<string | null> => {\n        try {\n            const grace = await shouldSendAmbientLoggingNotification();\n            if (!grace.shouldSend) {\n                Logger.info('[EventSuggestion] Grace period blocking:', grace.reason);\n                return null;\n            }\n\n            const { status } = await Notifications.getPermissionsAsync();\n            if (status !== 'granted') return null;\n\n            const friendNames = event.matchedFriends.map(m => m.friend.name).join(', ');\n            const dateStr = format(event.startDate, 'EEEE, MMM d');\n            const emoji = getEventEmoji(event.eventType);\n\n            const title = `${emoji} Did you weave?`;\n            const body = `You had \"${event.title}\" with ${friendNames} on ${dateStr}. Tap to log it.`;\n\n            const id = `${ID_PREFIX}${event.id}`;\n\n            await Notifications.scheduleNotificationAsync({\n                identifier: id,\n                content: {\n                    title,\n                    body,\n                    data: {\n                        type: 'event-suggestion',\n                        eventId: event.id,\n                        friendIds: event.matchedFriends.map(m => m.friend.id),\n                        eventTitle: event.title,\n                        eventDate: event.startDate.toISOString(),\n                        suggestedCategory: event.suggestedCategory,\n                        location: event.location,\n                        notes: event.notes,\n                    },\n                    sound: true,\n                    priority: Notifications.AndroidNotificationPriority.DEFAULT,\n                    ...(Platform.OS === 'android' ? { channelId: 'event-suggestions' } : {}),\n                },\n                // Schedule for 10 seconds later? Legacy code did this.\n                trigger: {\n                    seconds: 10,\n                    repeats: false,\n                } as any,\n            });\n\n            await notificationAnalytics.trackScheduled('event-suggestion', id, {\n                eventId: event.id,\n                eventType: event.eventType\n            });\n\n            Logger.info(`[EventSuggestion] Scheduled for ${event.title}`);\n            return id;\n\n        } catch (error) {\n            Logger.error('[EventSuggestion] Error scheduling:', error);\n            return null;\n        }\n    },\n\n    cancel: async (id: string): Promise<void> => {\n        await Notifications.cancelScheduledNotificationAsync(id);\n    },\n\n    handleTap: (data, router) => {\n        if (data?.type !== 'event-suggestion') return;\n\n        const {\n            friendIds,\n            // eventDate,\n            // eventTitle,\n            // suggestedCategory,\n            // location,\n            // notes,\n        } = data;\n\n        // WeaveLogger currently mainly supports friendId param.\n        // For now, we route there with the first friend to prevent the dead-end.\n        // TODO: Update WeaveLogger to accept date/category/notes via params\n\n        const params: any = {};\n        if (Array.isArray(friendIds) && friendIds.length > 0) {\n            params.friendId = friendIds[0];\n        } else if (typeof friendIds === 'string') {\n            params.friendId = friendIds;\n        }\n\n        router.push({\n            pathname: '/weave-logger',\n            params\n        });\n\n        notificationAnalytics.trackActionCompleted('event-suggestion', 'open_form');\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/memory-nudge.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":98,"column":36,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":98,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Memory Nudge Channel\n * Handles anniversary reflections\n */\n\nimport * as Notifications from 'expo-notifications';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from '../notification-analytics';\nimport { NotificationChannel } from '@/modules/notifications';\nimport { getAnniversaryMemories, getMemoryForNotification } from '@/modules/journal';\nimport { database } from '@/db';\nimport UserProfile from '@/db/models/UserProfile';\nimport { shouldSendNotification } from '../season-notifications.service';\n\nconst ID_PREFIX = 'memory-nudge-';\n\nexport const MemoryNudgeChannel: NotificationChannel = {\n    schedule: async (): Promise<void> => {\n        try {\n            // Get memories for roughly \"today\" (logic inside handles window)\n            const memories = await getAnniversaryMemories();\n\n            // Check season suppression\n            const profiles = await database.get<UserProfile>('user_profile').query().fetch();\n            const currentSeason = profiles[0]?.currentSocialSeason;\n\n            if (!shouldSendNotification(currentSeason, 'memory-nudge')) {\n                Logger.info('[MemoryNudge] Suppressed due to social season');\n                // Even if suppressed, ensure we don't have lingering old ones\n                await MemoryNudgeChannel.cancel(ID_PREFIX);\n                return;\n            }\n\n            // Clear old\n            await MemoryNudgeChannel.cancel(ID_PREFIX);\n\n            if (memories.length === 0) return;\n\n            // Sort by priority and take the top one\n            const bestMemory = memories.sort((a: any, b: any) => b.priority - a.priority)[0];\n\n            if (!bestMemory) return;\n\n            const id = `${ID_PREFIX}${bestMemory.relatedEntryId}`;\n\n            // Schedule for 9:00 AM tomorrow if it's late, or maybe just schedule for a reasonable time?\n            // \"Nudges\" should be gentle. Let's schedule for 9 AM tomorrow to ensure it's seen fresh.\n            // Or if debugging, maybe sooner. Let's stick to the standard \"morning update\".\n            // Schedule for 9:00 AM tomorrow if it's late, or maybe just schedule for a reasonable time?\n            // \"Nudges\" should be gentle. Let's schedule for 9 AM tomorrow to ensure it's seen fresh.\n            // Or if debugging, maybe sooner. Let's stick to the standard \"morning update\".\n            const tomorrow = new Date();\n            tomorrow.setDate(tomorrow.getDate() + 1);\n            tomorrow.setHours(9, 0, 0, 0);\n\n            const trigger = tomorrow.getTime();\n\n            await Notifications.scheduleNotificationAsync({\n                identifier: id,\n                content: {\n                    title: bestMemory.title,\n                    body: bestMemory.description,\n                    data: {\n                        type: 'memory-nudge',\n                        entryId: bestMemory.relatedEntryId,\n                        entryType: bestMemory.type === 'first_entry' ? 'first_entry' :\n                            (bestMemory.id.includes('reflection') ? 'reflection' : 'journal')\n                    },\n                },\n                trigger: trigger as any,\n            });\n\n            await notificationAnalytics.trackScheduled('memory-nudge', id, {\n                entryId: bestMemory.relatedEntryId,\n                type: bestMemory.type\n            });\n\n        } catch (error) {\n            Logger.error('[MemoryNudge] Error:', error);\n        }\n    },\n\n    cancel: async (matchPrefix: string = ID_PREFIX): Promise<void> => {\n        const all = await Notifications.getAllScheduledNotificationsAsync();\n        for (const n of all) {\n            if (n.identifier.startsWith(matchPrefix)) {\n                await Notifications.cancelScheduledNotificationAsync(n.identifier);\n            }\n        }\n    },\n\n    handleTap: async (data: any, router: any) => {\n        try {\n            const { entryId, entryType } = data;\n\n            // Lazy load store to avoid potential cycles if imported at top level\n            const { useUIStore } = require('@/stores/uiStore');\n\n            if (entryType === 'reflection' || entryType === 'journal') {\n                const memoryData = await getMemoryForNotification(entryId, entryType);\n                if (memoryData) {\n                    useUIStore.getState().openMemoryMoment(memoryData);\n                    return;\n                }\n            }\n\n            // Fallback if data fetch fails or unknown type\n            router.replace('/dashboard');\n        } catch (error) {\n            Logger.error('[MemoryNudge] Error handling tap:', error);\n            router.replace('/dashboard');\n        }\n    }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/smart-suggestions.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'scheduledIds' is never reassigned. Use 'const' instead.","line":206,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":206,"endColumn":25,"fix":{"range":[8699,8782],"text":"const scheduledIds = (scheduledStats?.date === today) ? [...scheduledStats.ids] : [];"}},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used. Allowed unused args must match /^_/u.","line":248,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":248,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"\n/**\n * Smart Suggestions Channel\n * Handles AI-driven friend outreach suggestions\n * Integrates: Social Battery, Suggestion Engine, Portfolio Insights, Time-of-Day\n */\n\nimport * as Notifications from 'expo-notifications';\nimport { database } from '@/db';\nimport Friend from '@/db/models/Friend';\nimport Interaction from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport UserProfile from '@/db/models/UserProfile';\nimport { Q } from '@nozbe/watermelondb';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from '../notification-analytics';\nimport { notificationStore } from '../notification-store';\nimport { NotificationChannel, NotificationPreferences } from '@/modules/notifications';\nimport { generateSuggestion } from '@/modules/interactions';\nimport { calculateCurrentScore } from '@/modules/intelligence';\nimport { HydratedFriend } from '@/types/hydrated';\nimport { Suggestion } from '@/shared/types/common';\nimport { applySeasonLimit, shouldSendNotification } from '../season-notifications.service';\n\nconst ID_PREFIX = 'smart-suggestion';\nconst MIN_HOURS_BETWEEN_NOTIFICATIONS = 2;\n\n// Helper to check quiet hours\nfunction isQuietHours(prefs: NotificationPreferences): boolean {\n    const now = new Date();\n    const currentHour = now.getHours();\n    if (prefs.quietHoursStart > prefs.quietHoursEnd) {\n        return currentHour >= prefs.quietHoursStart || currentHour < prefs.quietHoursEnd;\n    }\n    return currentHour >= prefs.quietHoursStart && currentHour < prefs.quietHoursEnd;\n}\n\n// Helper to determine if we should respect battery\nfunction shouldRespectBattery(\n    batteryLevel: number | null,\n    urgency: Suggestion['urgency'],\n    prefs: NotificationPreferences\n): boolean {\n    if (urgency === 'critical') return true;\n    if (!prefs.respectBattery) return true;\n    if (batteryLevel === null) return urgency === 'high';\n    if (batteryLevel < 30) return urgency === 'high';\n    if (batteryLevel < 50) return urgency === 'high' || urgency === 'medium';\n    return true;\n}\n\n// Helper to calculate spreads\nfunction calculateSpreadDelays(count: number, prefs: NotificationPreferences): number[] {\n    const now = new Date();\n    const currentHour = now.getHours();\n    const currentMinute = now.getMinutes();\n\n    const timeSlots: number[] = [];\n\n    // Morning (9-11)\n    if (currentHour < 9) timeSlots.push(9 - currentHour);\n    // Midday (12-2)\n    if (currentHour < 12) {\n        const hours = 12 - currentHour;\n        if (hours >= MIN_HOURS_BETWEEN_NOTIFICATIONS) timeSlots.push(hours);\n    }\n    // Afternoon (3-5)\n    if (currentHour < 15) {\n        const hours = 15 - currentHour;\n        if (hours >= MIN_HOURS_BETWEEN_NOTIFICATIONS) timeSlots.push(hours);\n    }\n    // Evening (6-8)\n    if (currentHour < 18 && prefs.quietHoursStart > 18) {\n        const hours = 18 - currentHour;\n        if (hours >= MIN_HOURS_BETWEEN_NOTIFICATIONS) timeSlots.push(hours);\n    }\n\n    // Fallback: spread across remaining time\n    if (timeSlots.length === 0) {\n        const hoursUntilQuiet = prefs.quietHoursStart - currentHour;\n        if (hoursUntilQuiet > MIN_HOURS_BETWEEN_NOTIFICATIONS) {\n            for (let i = 1; i <= count && i * MIN_HOURS_BETWEEN_NOTIFICATIONS < hoursUntilQuiet; i++) {\n                timeSlots.push(i * MIN_HOURS_BETWEEN_NOTIFICATIONS);\n            }\n        }\n    }\n\n    // Convert to minutes with noise\n    return timeSlots.slice(0, count).map(hours => {\n        const base = hours * 60 - currentMinute;\n        const noise = Math.floor(Math.random() * 30) - 15;\n        return Math.max(MIN_HOURS_BETWEEN_NOTIFICATIONS * 60 + 1, base + noise); // Ensure at least min gap\n    });\n}\n\nexport const SmartSuggestionsChannel: NotificationChannel & {\n    evaluateAndSchedule: () => Promise<void>\n} = {\n    schedule: async (): Promise<void> => {\n        // This method might be used for manual single scheduling, \n        // but the main logic is in evaluateAndSchedule.\n        await SmartSuggestionsChannel.evaluateAndSchedule();\n    },\n\n    evaluateAndSchedule: async (): Promise<void> => {\n        Logger.info('[SmartSuggestions] Evaluating...');\n\n        // 1. Cooldown check\n        const lastTime = await notificationStore.getLastSmartNotificationTime();\n        if (lastTime) {\n            const hoursSince = (Date.now() - lastTime) / (1000 * 60 * 60);\n            if (hoursSince < MIN_HOURS_BETWEEN_NOTIFICATIONS) {\n                Logger.debug('[SmartSuggestions] Cooldown active, skipping');\n                return;\n            }\n        }\n\n        // 2. Preferences & Limits\n        const prefs = await notificationStore.getPreferences();\n        if (isQuietHours(prefs)) {\n            Logger.debug('[SmartSuggestions] Quiet hours, skipping');\n            return;\n        }\n\n        const todayStats = await notificationStore.getSmartNotificationCount();\n        const today = new Date().toDateString();\n        let todayCount = (todayStats?.date === today) ? todayStats.count : 0;\n\n        const limits = { light: 1, moderate: 2, proactive: 4 };\n        const maxAllowed = limits[prefs.frequency];\n\n        // Check scheduled for today\n        const scheduledStats = await notificationStore.getScheduledSmartNotifications();\n        const alreadyScheduledCount = (scheduledStats?.date === today) ? scheduledStats.ids.length : 0;\n\n        // 3. Battery Check & Season Limits\n        const profiles = await database.get<UserProfile>('user_profile').query().fetch();\n        const profile = profiles[0];\n        const batteryLevel = profile?.socialBatteryCurrent ?? null;\n        const currentSeason = profile?.currentSocialSeason;\n\n        // Apply season limits\n        const seasonAdjustedLimit = applySeasonLimit(maxAllowed, currentSeason);\n        const remainingSlots = seasonAdjustedLimit - alreadyScheduledCount;\n\n        if (remainingSlots <= 0) return;\n\n        // 4. Generate Suggestions\n        const suggestions: Suggestion[] = [];\n        const friends = await database.get<Friend>('friends').query().fetch();\n\n        for (const friend of friends) {\n            // Junction check\n            const interactionFriends = await database.get<InteractionFriend>('interaction_friends').query(Q.where('friend_id', friend.id)).fetch();\n            const iIds = interactionFriends.map(ifriend => ifriend.interactionId);\n\n            let lastInteractionDate;\n            let interactionCount = 0;\n            let recentInteractions: Interaction[] = [];\n\n            if (iIds.length > 0) {\n                const ints = await database.get<Interaction>('interactions').query(Q.where('id', Q.oneOf(iIds)), Q.where('status', 'completed')).fetch();\n                const sorted = ints.filter(i => i.interactionDate).sort((a, b) => b.interactionDate.getTime() - a.interactionDate.getTime());\n                lastInteractionDate = sorted[0]?.interactionDate;\n                interactionCount = sorted.length;\n                recentInteractions = sorted.slice(0, 5);\n            }\n\n            // Dedupe: 24h\n            if (lastInteractionDate && (Date.now() - lastInteractionDate.getTime()) < 24 * 60 * 60 * 1000) {\n                continue;\n            }\n\n            const currentScore = calculateCurrentScore(friend);\n            // Momentum logic\n            const lastUpdated = friend.momentumLastUpdated || friend.createdAt || new Date();\n            const daysSince = (Date.now() - lastUpdated.getTime()) / 86400000;\n            const momentumScore = Math.max(0, friend.momentumScore - daysSince);\n\n            const suggestion = await generateSuggestion({\n                friend: friend as unknown as HydratedFriend,\n                currentScore,\n                lastInteractionDate: lastInteractionDate ?? null,\n                interactionCount,\n                momentumScore,\n                recentInteractions\n            });\n\n            if (suggestion) suggestions.push(suggestion);\n        }\n\n        // 5. Select & Schedule\n        const urgencyOrder: Record<string, number> = { critical: 0, high: 1, medium: 2, low: 3 };\n        const sorted = suggestions.sort((a, b) => urgencyOrder[a.urgency || 'medium'] - urgencyOrder[b.urgency || 'medium']);\n\n        // Filter by battery AND season\n        const eligible = sorted.filter(s => {\n            const batteryOk = shouldRespectBattery(batteryLevel, s.urgency, prefs);\n            const seasonOk = shouldSendNotification(currentSeason, 'friend-suggestion', s.category as any, s.urgency); // Type assertion for safety\n            return batteryOk && seasonOk;\n        });\n\n        const toSchedule = eligible.slice(0, remainingSlots);\n        const delays = calculateSpreadDelays(toSchedule.length, prefs);\n\n        let scheduledIds = (scheduledStats?.date === today) ? [...scheduledStats.ids] : [];\n\n        for (let i = 0; i < toSchedule.length; i++) {\n            const s = toSchedule[i];\n            const delay = delays[i] || (i + 1) * 60; // fallback 1 hour spacing\n\n            const id = `${ID_PREFIX}-${s.id}`;\n            const trigger = new Date(Date.now() + delay * 60000);\n\n            await Notifications.scheduleNotificationAsync({\n                identifier: id,\n                content: {\n                    title: s.title,\n                    body: s.subtitle,\n                    data: {\n                        type: 'friend-suggestion',\n                        friendId: s.friendId,\n                        suggestionId: s.id\n                    }\n                },\n                // Expo types for trigger are strict/complex, casting to any for Date object\n                trigger: trigger as any\n            });\n\n            await notificationAnalytics.trackScheduled('friend-suggestion', id, {\n                friendId: s.friendId,\n                score: s.score,\n                delayMinutes: delay\n            });\n\n            scheduledIds.push(id);\n            todayCount++;\n        }\n\n        // Update store\n        await notificationStore.setScheduledSmartNotifications(today, scheduledIds);\n        await notificationStore.setSmartNotificationCount(today, todayCount);\n        await notificationStore.setLastSmartNotificationTime(Date.now());\n\n        Logger.info(`[SmartSuggestions] Scheduled ${toSchedule.length} notifications.`);\n    },\n\n    cancel: async (id: string = ID_PREFIX): Promise<void> => {\n        // Cancel all starting with prefix is safer\n        const all = await Notifications.getAllScheduledNotificationsAsync();\n        for (const n of all) {\n            if (n.identifier.startsWith(ID_PREFIX)) {\n                await Notifications.cancelScheduledNotificationAsync(n.identifier);\n            }\n        }\n    },\n\n    handleTap: (data, router) => {\n        if (data.friendId) {\n            router.push(`/friend-profile?friendId=${data.friendId}`);\n            notificationAnalytics.trackActionCompleted('friend-suggestion', 'view_profile');\n        } else {\n            router.replace('/dashboard');\n        }\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/channels/weekly-reflection.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":62,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":62,"endColumn":59}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Weekly Reflection Channel\n * Handles scheduling of Sunday weekly reflection notifications\n */\n\nimport * as Notifications from 'expo-notifications';\nimport { database } from '@/db';\nimport UserProfile from '@/db/models/UserProfile';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from '../notification-analytics';\nimport { shouldSendWeeklyReflectionNotification } from '../notification-grace-periods';\nimport { NotificationChannel } from '@/modules/notifications';\n\nconst ID = 'weekly-reflection';\n\nexport const WeeklyReflectionChannel: NotificationChannel = {\n    schedule: async (): Promise<void> => {\n        try {\n            await Notifications.cancelScheduledNotificationAsync(ID);\n\n            const grace = await shouldSendWeeklyReflectionNotification();\n            if (!grace.shouldSend) return;\n\n            const profiles = await database.get<UserProfile>('user_profile').query().fetch();\n            const profile = profiles[0];\n            const reflectionDayIndex = profile?.reflectionDay ?? 0; // 0 = Sunday\n            const expoWeekday = reflectionDayIndex + 1; // 1 = Sunday\n\n            await Notifications.scheduleNotificationAsync({\n                identifier: ID,\n                content: {\n                    title: \"Time to reflect on your weave 🕸️\",\n                    body: \"How did your friendships feel this week?\",\n                    data: { type: 'weekly-reflection' },\n                },\n                trigger: {\n                    weekday: expoWeekday,\n                    hour: 19,\n                    minute: 0,\n                    repeats: true,\n                } as any,\n            });\n\n            await notificationAnalytics.trackScheduled('weekly-reflection', ID, {\n                dayOfWeek: expoWeekday\n            });\n        } catch (error) {\n            Logger.error('[WeeklyReflection] Error scheduling:', error);\n        }\n    },\n\n    cancel: async (id: string = ID): Promise<void> => {\n        await Notifications.cancelScheduledNotificationAsync(id);\n    },\n\n    handleTap: (data, router) => {\n        if (router.canGoBack()) router.dismissAll();\n        router.replace('/dashboard');\n\n        // Open modal via store\n        const { useUIStore } = require('@/stores/uiStore');\n        setTimeout(() => {\n            useUIStore.getState().openWeeklyReflection();\n            notificationAnalytics.trackActionCompleted('weekly-reflection', 'open_modal');\n        }, 500);\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/notification-analytics.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":192,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":192,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":204,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":204,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { trackEvent } from '@/shared/services/analytics.service';\nimport Logger from '@/shared/utils/Logger';\n\n// Feature flag - set to true to enable analytics\nconst ANALYTICS_ENABLED = true;\n\n// Storage keys\nconst NOTIFICATION_CORRELATION_KEY = '@weave:notification_correlation';\n\n// Types of notifications we track\nexport type NotificationType =\n    | 'battery-checkin'\n    | 'weekly-reflection'\n    | 'event-reminder'\n    | 'deepening-nudge'\n    | 'friend-suggestion'\n    | 'memory-nudge'\n    | 'event-suggestion'\n    | 'life-event'\n    | 'portfolio-insight'\n    | 'evening-digest';\n\nexport interface NotificationEventProperties {\n    type: NotificationType;\n    notificationId: string;\n    [key: string]: any;\n}\n\ninterface CorrelationData {\n    scheduledAt: number;\n    type: NotificationType;\n}\n\nclass NotificationAnalyticsService {\n    /**\n     * Track when a notification is scheduled\n     */\n    async trackScheduled(\n        type: NotificationType,\n        notificationId: string,\n        properties: Record<string, any> = {}\n    ): Promise<void> {\n        if (!ANALYTICS_ENABLED) return;\n\n        try {\n            // 1. Track the event\n            trackEvent('notification_scheduled', {\n                type,\n                notificationId,\n                ...properties,\n            });\n\n            // 2. Store correlation data\n            await this.storeCorrelationData(notificationId, type);\n        } catch (error) {\n            // Fail silently to not impact app performance\n            Logger.warn('[NotificationAnalytics] Error tracking scheduled:', error);\n        }\n    }\n\n    /**\n     * Track when a notification is tapped\n     */\n    async trackTapped(\n        type: NotificationType,\n        notificationId: string,\n        properties: Record<string, any> = {}\n    ): Promise<void> {\n        if (!ANALYTICS_ENABLED) return;\n\n        try {\n            // 1. Get correlation data to calculate time-to-tap\n            const correlation = await this.getCorrelationData(notificationId);\n            let secondsSinceScheduled: number | undefined;\n\n            if (correlation) {\n                const now = Date.now();\n                secondsSinceScheduled = Math.floor((now - correlation.scheduledAt) / 1000);\n            }\n\n            // 2. Track the event\n            trackEvent('notification_tapped', {\n                type,\n                notificationId,\n                secondsSinceScheduled,\n                ...properties,\n            });\n\n            // 3. Cleanup is handled periodically, not here, so we can track subsequent actions\n        } catch (error) {\n            Logger.warn('[NotificationAnalytics] Error tracking tapped:', error);\n        }\n    }\n\n    /**\n     * Track when a notification action is completed (conversion)\n     */\n    trackActionCompleted(\n        type: NotificationType,\n        action: string,\n        notificationId?: string,\n        properties: Record<string, any> = {}\n    ): void {\n        if (!ANALYTICS_ENABLED) return;\n\n        trackEvent('notification_action_completed', {\n            type,\n            notificationId,\n            action,\n            ...properties,\n        });\n    }\n\n    /**\n     * Track when a notification is cancelled\n     */\n    trackCancelled(\n        type: NotificationType,\n        reason: string,\n        properties: Record<string, any> = {}\n    ): void {\n        if (!ANALYTICS_ENABLED) return;\n\n        trackEvent('notification_cancelled', {\n            type,\n            reason,\n            ...properties,\n        });\n    }\n\n    /**\n     * Track permission request flows\n     */\n    trackPermissionRequested(source: string): void {\n        if (!ANALYTICS_ENABLED) return;\n\n        trackEvent('notification_permission_requested', {\n            source,\n        });\n    }\n\n    /**\n     * Track permission result\n     */\n    trackPermissionResult(granted: boolean, canAskAgain: boolean): void {\n        if (!ANALYTICS_ENABLED) return;\n\n        trackEvent('notification_permission_result', {\n            granted,\n            canAskAgain,\n        });\n    }\n\n    /**\n     * Track when user explicitly dismisses/skips permission\n     */\n    trackPermissionSkipped(source: string): void {\n        if (!ANALYTICS_ENABLED) return;\n\n        trackEvent('notification_permission_skipped', {\n            source,\n        });\n    }\n\n    // ==============================================================================\n    // Correlation Helper Methods (Private)\n    // ==============================================================================\n\n    private async storeCorrelationData(notificationId: string, type: NotificationType): Promise<void> {\n        try {\n            const stored = await AsyncStorage.getItem(NOTIFICATION_CORRELATION_KEY);\n            const data: Record<string, CorrelationData> = stored ? JSON.parse(stored) : {};\n\n            // Add new entry\n            data[notificationId] = {\n                scheduledAt: Date.now(),\n                type,\n            };\n\n            // Cleanup old entries (older than 7 days)\n            const now = Date.now();\n            const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;\n\n            Object.keys(data).forEach(key => {\n                if (now - data[key].scheduledAt > sevenDaysMs) {\n                    delete data[key];\n                }\n            });\n\n            await AsyncStorage.setItem(NOTIFICATION_CORRELATION_KEY, JSON.stringify(data));\n        } catch (error) {\n            // Ignore storage errors\n        }\n    }\n\n    private async getCorrelationData(notificationId: string): Promise<CorrelationData | null> {\n        try {\n            const stored = await AsyncStorage.getItem(NOTIFICATION_CORRELATION_KEY);\n            if (!stored) return null;\n\n            const data: Record<string, CorrelationData> = JSON.parse(stored);\n            return data[notificationId] || null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * Track when a notification is shown in foreground\n     */\n    trackForegroundShown(type: NotificationType): void {\n        if (!ANALYTICS_ENABLED) return;\n        trackEvent('notification_foreground_shown', { type });\n    }\n}\n\nexport const notificationAnalytics = new NotificationAnalyticsService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/notification-grace-periods.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/notification-orchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Platform' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventSuggestionChannel' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DeepeningNudgeChannel' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventReminderChannel' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Notification Orchestrator\n * Central coordinator for the notification system\n */\n\nimport * as Notifications from 'expo-notifications';\nimport { Platform } from 'react-native';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationStore } from './notification-store';\nimport { notificationAnalytics } from './notification-analytics';\nimport { checkNotificationPermissions, requestNotificationPermissions } from './permission.service';\n\n// Channels\nimport { BatteryCheckinChannel } from './channels/battery-checkin';\nimport { WeeklyReflectionChannel } from './channels/weekly-reflection';\nimport { MemoryNudgeChannel } from './channels/memory-nudge';\nimport { SmartSuggestionsChannel } from './channels/smart-suggestions';\nimport { EventSuggestionChannel } from './channels/event-suggestion';\nimport { DeepeningNudgeChannel } from './channels/deepening-nudge';\nimport { EventReminderChannel } from './channels/event-reminder';\nimport { NotificationType } from '../types';\n\nclass NotificationOrchestratorService {\n    private isInitialized = false;\n    private lastCheckTime: number = 0;\n\n    async init(): Promise<void> {\n        if (this.isInitialized) return;\n\n        try {\n            // 1. Configure handler for foreground notifications\n            Notifications.setNotificationHandler({\n                handleNotification: async (notification) => {\n                    // Track foreground presentation\n                    const type = notification.request.content.data?.type as NotificationType;\n                    if (type) {\n                        notificationAnalytics.trackForegroundShown(type);\n                    }\n\n                    return {\n                        shouldShowAlert: type !== 'weekly-reflection', // Don't show banner if app is open (we show modal instead)\n                        shouldPlaySound: true,\n                        shouldSetBadge: false,\n                    };\n                },\n            });\n\n            // 2. Check if we have permissions to proceed with setup\n            const hasPermission = await checkNotificationPermissions();\n            if (hasPermission) {\n                // 3. Run startup checks\n                await this.runStartupChecks();\n            }\n\n            this.isInitialized = true;\n            Logger.info('[NotificationOrchestrator] Initialized');\n        } catch (error) {\n            Logger.error('[NotificationOrchestrator] Init failed:', error);\n        }\n    }\n\n    /**\n     * Run checks that should happen on app launch or significant foregrounding\n     */\n    async runStartupChecks(): Promise<void> {\n        Logger.info('[NotificationOrchestrator] Running startup/maintenance checks');\n        this.lastCheckTime = Date.now();\n\n        try {\n            // Check if battery batch needs extending\n            // This checks if we're running low on scheduled notifications and adds more if needed\n            await BatteryCheckinChannel.checkAndExtendBatch();\n\n            // Refresh memory nudges (they change daily)\n            // This ensures if we open the app on a new day, we schedule the new nudge\n            await MemoryNudgeChannel.schedule();\n\n            // Ensure weekly reflection is scheduled (idempotent)\n            await WeeklyReflectionChannel.schedule();\n\n        } catch (error) {\n            Logger.error('[NotificationOrchestrator] Error during startup checks:', error);\n        }\n    }\n\n    /**\n     * Request permissions and setup if granted\n     */\n    async requestPermissions(): Promise<boolean> {\n        const granted = await requestNotificationPermissions();\n        if (granted) {\n            await this.runStartupChecks();\n        }\n        return granted;\n    }\n\n    /**\n     * Cancel ALL notifications across all channels\n     */\n    async cancelAll(): Promise<void> {\n        await Notifications.cancelAllScheduledNotificationsAsync();\n        await notificationStore.clearAll();\n        Logger.info('[NotificationOrchestrator] All notifications cancelled');\n    }\n\n    /**\n     * Get all scheduled notifications with typed data\n     */\n    async getAllScheduled() {\n        return await Notifications.getAllScheduledNotificationsAsync();\n    }\n\n    /**\n     * Evaluate and schedule smart notifications (called on foreground)\n     */\n    async evaluateSmartNotifications(): Promise<void> {\n        await SmartSuggestionsChannel.evaluateAndSchedule();\n    }\n\n    /**\n     * Handle app returning to foreground\n     * Checks if maintenance is needed based on time elapsed\n     */\n    async onAppForeground(): Promise<void> {\n        Logger.info('[NotificationOrchestrator] App foregrounded');\n\n        // Always evaluate smart notifications as they are context-dependent (time, location, etc)\n        await this.evaluateSmartNotifications();\n\n        // Throttle heavy maintenance checks\n        // If it's been more than an hour, or if the day has changed (logic simplified to time interval for now)\n        const now = Date.now();\n        const ONE_HOUR = 60 * 60 * 1000;\n\n        // Check if day changed\n        const lastCheckDate = new Date(this.lastCheckTime);\n        const currentDate = new Date(now);\n        const isDifferentDay = lastCheckDate.getDate() !== currentDate.getDate() ||\n            lastCheckDate.getMonth() !== currentDate.getMonth();\n\n        if (isDifferentDay || (now - this.lastCheckTime > ONE_HOUR)) {\n            Logger.info('[NotificationOrchestrator] Running maintenance checks due to time elapsed/day change');\n            await this.runStartupChecks();\n        }\n    }\n}\n\nexport const NotificationOrchestrator = new NotificationOrchestratorService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/notification-response-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/notification-store.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":70,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":85,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":85,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":100,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":127,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":138,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":149,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":149,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":162,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":162,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Notification Store\n * Centralized AsyncStorage management for the notification system\n */\n\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport Logger from '@/shared/utils/Logger';\nimport { NotificationPreferences } from '../types';\n\n// Storage Keys\nconst KEYS = {\n    // Grace Period / Init\n    NOTIFICATIONS_INITIALIZED: '@weave:notifications_initialized',\n\n    // Weekly Reflection\n    LAST_REFLECTION_DATE: '@weave:last_reflection_date',\n\n    // Deepening Nudges\n    DEEPENING_NUDGES: '@weave:deepening_nudges',\n\n    // Memory Nudges\n    LAST_MEMORY_CHECK: '@weave:last_memory_check',\n\n    // Smart Notifications\n    LAST_SMART_NOTIFICATION: '@weave:last_smart_notification',\n    SMART_NOTIFICATION_COUNT: '@weave:smart_notification_count',\n    SCHEDULED_SMART_NOTIFICATIONS: '@weave:scheduled_smart_notifications',\n    NOTIFICATION_PREFERENCES: '@weave:notification_preferences',\n\n    // Permissions\n    PERMISSION_REQUESTED: '@weave:notification_permission_requested',\n\n    // Analytics\n    CORRELATION: '@weave:notification_correlation',\n} as const;\n\n// Default Preferences\nconst DEFAULT_PREFERENCES: NotificationPreferences = {\n    frequency: 'moderate',\n    quietHoursStart: 22, // 10 PM\n    quietHoursEnd: 8, // 8 AM\n    respectBattery: true,\n    digestEnabled: true,\n    digestTime: '19:00',\n};\n\nclass NotificationStoreService {\n    /**\n     * Initialize or reset state\n     */\n    async clearAll(): Promise<void> {\n        try {\n            const keys = Object.values(KEYS);\n            await AsyncStorage.multiRemove(keys);\n            Logger.info('[NotificationStore] All notification state cleared');\n        } catch (error) {\n            Logger.error('[NotificationStore] Error clearing state:', error);\n        }\n    }\n\n    // ==============================================================================\n    // Initialization\n    // ==============================================================================\n\n    async getInitializationDate(): Promise<Date | null> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.NOTIFICATIONS_INITIALIZED);\n            return val ? new Date(parseInt(val, 10)) : null;\n        } catch (e) { return null; }\n    }\n\n    async markAsInitialized(): Promise<void> {\n        await AsyncStorage.setItem(KEYS.NOTIFICATIONS_INITIALIZED, Date.now().toString());\n    }\n\n    // ==============================================================================\n    // Weekly Reflection\n    // ==============================================================================\n\n    async getLastReflectionDate(): Promise<Date | null> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.LAST_REFLECTION_DATE);\n            return val ? new Date(val) : null;\n        } catch (e) { return null; }\n    }\n\n    async setLastReflectionDate(date: Date): Promise<void> {\n        await AsyncStorage.setItem(KEYS.LAST_REFLECTION_DATE, date.toISOString());\n    }\n\n    // ==============================================================================\n    // Deepening Nudges\n    // ==============================================================================\n\n    async getDeepeningNudges(): Promise<any[]> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.DEEPENING_NUDGES);\n            return val ? JSON.parse(val) : [];\n        } catch (e) { return []; }\n    }\n\n    async setDeepeningNudges(nudges: any[]): Promise<void> {\n        await AsyncStorage.setItem(KEYS.DEEPENING_NUDGES, JSON.stringify(nudges));\n    }\n\n    // ==============================================================================\n    // Memory Nudges\n    // ==============================================================================\n\n    async getLastMemoryCheckDate(): Promise<string | null> {\n        return await AsyncStorage.getItem(KEYS.LAST_MEMORY_CHECK);\n    }\n\n    async setLastMemoryCheckDate(dateStr: string): Promise<void> {\n        await AsyncStorage.setItem(KEYS.LAST_MEMORY_CHECK, dateStr);\n    }\n\n    // ==============================================================================\n    // Smart Notifications\n    // ==============================================================================\n\n    async getLastSmartNotificationTime(): Promise<number | null> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.LAST_SMART_NOTIFICATION);\n            return val ? parseInt(val, 10) : null;\n        } catch (e) { return null; }\n    }\n\n    async setLastSmartNotificationTime(timestamp: number): Promise<void> {\n        await AsyncStorage.setItem(KEYS.LAST_SMART_NOTIFICATION, timestamp.toString());\n    }\n\n    async getSmartNotificationCount(): Promise<{ date: string; count: number } | null> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.SMART_NOTIFICATION_COUNT);\n            return val ? JSON.parse(val) : null;\n        } catch (e) { return null; }\n    }\n\n    async setSmartNotificationCount(date: string, count: number): Promise<void> {\n        await AsyncStorage.setItem(KEYS.SMART_NOTIFICATION_COUNT, JSON.stringify({ date, count }));\n    }\n\n    async getScheduledSmartNotifications(): Promise<{ date: string; ids: string[] } | null> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.SCHEDULED_SMART_NOTIFICATIONS);\n            return val ? JSON.parse(val) : null;\n        } catch (e) { return null; }\n    }\n\n    async setScheduledSmartNotifications(date: string, ids: string[]): Promise<void> {\n        await AsyncStorage.setItem(KEYS.SCHEDULED_SMART_NOTIFICATIONS, JSON.stringify({ date, ids }));\n    }\n\n    async getPreferences(): Promise<NotificationPreferences> {\n        try {\n            const val = await AsyncStorage.getItem(KEYS.NOTIFICATION_PREFERENCES);\n            if (val) {\n                return { ...DEFAULT_PREFERENCES, ...JSON.parse(val) };\n            }\n        } catch (e) { /* ignore */ }\n        return DEFAULT_PREFERENCES;\n    }\n\n    async setPreferences(prefs: Partial<NotificationPreferences>): Promise<void> {\n        try {\n            const current = await this.getPreferences();\n            const updated = { ...current, ...prefs };\n            await AsyncStorage.setItem(KEYS.NOTIFICATION_PREFERENCES, JSON.stringify(updated));\n        } catch (e) { Logger.error('[NotificationStore] Error saving prefs', e); }\n    }\n\n    // ==============================================================================\n    // Permissions\n    // ==============================================================================\n\n    async getPermissionRequested(): Promise<boolean> {\n        const val = await AsyncStorage.getItem(KEYS.PERMISSION_REQUESTED);\n        return val === 'true';\n    }\n\n    async setPermissionRequested(requested: boolean): Promise<void> {\n        await AsyncStorage.setItem(KEYS.PERMISSION_REQUESTED, requested ? 'true' : 'false');\n    }\n}\n\nexport const notificationStore = new NotificationStoreService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/permission.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":129,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport * as Notifications from 'expo-notifications';\nimport { Platform, Linking } from 'react-native';\nimport Logger from '@/shared/utils/Logger';\nimport { notificationAnalytics } from './notification-analytics';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst PERMISSION_REQUESTED_KEY = '@weave:notification_permission_requested';\n\nexport interface NotificationPermissionStatus {\n    status: Notifications.PermissionStatus;\n    canAskAgain: boolean;\n    granted: boolean;\n}\n\nclass NotificationPermissionService {\n    /**\n     * Get current permission status without requesting\n     */\n    async getStatus(): Promise<NotificationPermissionStatus> {\n        try {\n            const settings = await Notifications.getPermissionsAsync();\n            return {\n                status: settings.status,\n                canAskAgain: settings.canAskAgain,\n                granted: settings.granted,\n            };\n        } catch (error) {\n            Logger.error('[Permissions] Error getting status:', error);\n            return {\n                status: Notifications.PermissionStatus.UNDETERMINED,\n                canAskAgain: true,\n                granted: false,\n            };\n        }\n    }\n\n    /**\n     * Request notification permissions\n     * Handles platform specific logic (like Android channels)\n     */\n    async requestPermissions(): Promise<boolean> {\n        try {\n            Logger.info('[Permissions] Requesting notification permissions...');\n            notificationAnalytics.trackPermissionRequested('permission_service');\n\n            const { status: existingStatus } = await Notifications.getPermissionsAsync();\n            let finalStatus = existingStatus;\n\n            // Only request if not already granted\n            if (existingStatus !== Notifications.PermissionStatus.GRANTED) {\n                const { status } = await Notifications.requestPermissionsAsync({\n                    ios: {\n                        allowAlert: true,\n                        allowBadge: true,\n                        allowSound: true,\n                    },\n                });\n                finalStatus = status;\n            }\n\n            // Mark as requested\n            await AsyncStorage.setItem(PERMISSION_REQUESTED_KEY, 'true');\n\n            if (finalStatus !== Notifications.PermissionStatus.GRANTED) {\n                Logger.info('[Permissions] Permission denied or not granted');\n                notificationAnalytics.trackPermissionResult(false, existingStatus !== 'granted'); // Simplified logic\n                return false;\n            }\n\n            // Android Channel Setup (Safe to run on iOS as it's a no-op or handled by check)\n            if (Platform.OS === 'android') {\n                await this.setupAndroidChannels();\n            }\n\n            Logger.info('[Permissions] Permission granted');\n            notificationAnalytics.trackPermissionResult(true, true);\n            return true;\n        } catch (error) {\n            Logger.error('[Permissions] Error requesting permissions:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Setup Android Notification Channels\n     */\n    private async setupAndroidChannels() {\n        try {\n            // General Channel\n            await Notifications.setNotificationChannelAsync('default', {\n                name: 'General',\n                importance: Notifications.AndroidImportance.DEFAULT,\n                vibrationPattern: [0, 250, 250, 250],\n                lightColor: '#6366F1',\n            });\n\n            // Event Suggestions\n            await Notifications.setNotificationChannelAsync('event-suggestions', {\n                name: 'Event Suggestions',\n                description: 'Suggestions to log calendar events as weaves',\n                importance: Notifications.AndroidImportance.DEFAULT,\n                vibrationPattern: [0, 250, 250, 250],\n                lightColor: '#8B7FD6',\n            });\n\n            // Reflections\n            await Notifications.setNotificationChannelAsync('reflections', {\n                name: 'Reflections',\n                description: 'Weekly reflections and deepening nudges',\n                importance: Notifications.AndroidImportance.HIGH,\n                vibrationPattern: [0, 250, 250, 250],\n                lightColor: '#F472B6',\n            });\n\n            Logger.info('[Permissions] Android channels configured');\n        } catch (error) {\n            Logger.error('[Permissions] Error setting up Android channels:', error);\n        }\n    }\n\n    /**\n     * Check if we have already asked for permissions\n     */\n    async hasAskedBefore(): Promise<boolean> {\n        try {\n            const result = await AsyncStorage.getItem(PERMISSION_REQUESTED_KEY);\n            return result === 'true';\n        } catch (error) {\n            return false;\n        }\n    }\n}\n\nexport const permissionService = new NotificationPermissionService();\n\n// Standalone Helper Exports\nexport const checkNotificationPermissions = async (): Promise<boolean> => {\n    const status = await permissionService.getStatus();\n    return status.granted;\n};\n\nexport const requestNotificationPermissions = async (): Promise<boolean> => {\n    return await permissionService.requestPermissions();\n};\n\nexport const openSystemSettings = async (): Promise<void> => {\n    await Linking.openSettings();\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/services/season-notifications.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/notifications/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/adaptive-chips.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/archetype-actions.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/chip-usage.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/contextual-prompts.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomContactedIndex' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":41,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Contextual Gratitude Prompts\n * Generates personalized prompts based on user's weekly activity\n */\n\nimport { WeeklySummary } from './weekly-stats.service';\n\nexport interface ContextualPrompt {\n  prompt: string;\n  context: string; // Short description of why this prompt was chosen\n}\n\n/**\n * Generate contextual gratitude prompts based on weekly summary\n */\nexport function generateContextualPrompts(summary: WeeklySummary): ContextualPrompt[] {\n  const prompts: ContextualPrompt[] = [];\n\n  // Prompts for active weeks (5+ weaves)\n  if (summary.totalWeaves >= 5) {\n    prompts.push({\n      prompt: `You logged ${summary.totalWeaves} weaves this week. Which connection brought you the most joy?`,\n      context: 'Active week reflection',\n    });\n\n    if (summary.friendsContacted >= 3) {\n      prompts.push({\n        prompt: `You connected with ${summary.friendsContacted} different friends. What pattern do you notice in your best moments with them?`,\n        context: 'Multiple connections',\n      });\n    }\n\n    if (summary.topActivityCount >= 3) {\n      prompts.push({\n        prompt: `${summary.topActivity} was your go-to this week (${summary.topActivityCount}×). What does that tell you about how you like to connect?`,\n        context: 'Activity pattern',\n      });\n    }\n\n    // If they have a specific friend they contacted multiple times\n    const randomContactedIndex = Math.floor(Math.random() * Math.min(summary.friendsContacted, 3));\n    prompts.push({\n      prompt: `What made your time connecting this week feel meaningful?`,\n      context: 'General reflection',\n    });\n  }\n\n  // Prompts for moderate weeks (1-4 weaves)\n  else if (summary.totalWeaves > 0 && summary.totalWeaves < 5) {\n    prompts.push({\n      prompt: `Even small connections matter. What stood out about the time you made for relationships this week?`,\n      context: 'Gentle week',\n    });\n\n    prompts.push({\n      prompt: `Quality over quantity. What made your ${summary.totalWeaves === 1 ? 'connection' : 'connections'} this week special?`,\n      context: 'Intentional connection',\n    });\n  }\n\n  // Prompts for quiet weeks (0 weaves)\n  else {\n    prompts.push({\n      prompt: `This was a quiet week. What would help you feel more connected in the week ahead?`,\n      context: 'Restful week',\n    });\n\n    prompts.push({\n      prompt: `Sometimes we need time for ourselves. What relationships are you grateful for, even when you haven't connected recently?`,\n      context: 'Appreciation',\n    });\n\n    if (summary.missedFriends.length > 0) {\n      const randomMissed = summary.missedFriends[Math.floor(Math.random() * summary.missedFriends.length)];\n      prompts.push({\n        prompt: `${randomMissed.friend.name} came to mind this week. What do you appreciate most about your friendship with them?`,\n        context: 'Missed connection',\n      });\n    }\n  }\n\n  // Prompts for when there are missed friends (regardless of activity level)\n  if (summary.missedFriends.length > 0 && summary.totalWeaves > 0) {\n    const randomMissed = summary.missedFriends[Math.floor(Math.random() * Math.min(summary.missedFriends.length, 2))];\n    prompts.push({\n      prompt: `You haven't connected with ${randomMissed.friend.name} recently. What memory with them makes you smile?`,\n      context: 'Drifting friend',\n    });\n\n    if (summary.missedFriends.length >= 3) {\n      prompts.push({\n        prompt: `A few close friends need attention. What's one small step you could take to reach out this week?`,\n        context: 'Multiple missed',\n      });\n    }\n  }\n\n  // Growth/momentum prompts\n  if (summary.totalWeaves >= 10) {\n    prompts.push({\n      prompt: `You're building incredible momentum. How does it feel to prioritize your relationships this way?`,\n      context: 'Strong momentum',\n    });\n  }\n\n  // Balance prompts\n  if (summary.friendsContacted >= 5 && summary.missedFriends.length === 0) {\n    prompts.push({\n      prompt: `Your important relationships are thriving. What practices or habits are helping you stay connected?`,\n      context: 'Balanced weave',\n    });\n  }\n\n  // Variety prompts\n  if (summary.topActivityCount > 0 && summary.totalWeaves > summary.topActivityCount + 2) {\n    prompts.push({\n      prompt: `You mixed it up this week with different ways of connecting. Which style felt most natural?`,\n      context: 'Variety',\n    });\n  }\n\n  // Always include a few universal fallbacks\n  prompts.push({\n    prompt: `What unexpected moment of connection surprised you this week?`,\n    context: 'Universal',\n  });\n\n  prompts.push({\n    prompt: `When you think about your friendships, what fills your heart with gratitude?`,\n    context: 'Universal',\n  });\n\n  prompts.push({\n    prompt: `If you could send a thank-you message to one friend right now, who would it be and why?`,\n    context: 'Universal',\n  });\n\n  return prompts;\n}\n\n/**\n * Select the best prompt from generated options\n * Prioritizes context-specific over universal\n */\nexport function selectBestPrompt(prompts: ContextualPrompt[]): ContextualPrompt {\n  // Filter out universal prompts first\n  const specificPrompts = prompts.filter(p => p.context !== 'Universal');\n\n  // If we have specific prompts, randomly pick one\n  if (specificPrompts.length > 0) {\n    return specificPrompts[Math.floor(Math.random() * specificPrompts.length)];\n  }\n\n  // Otherwise use a universal prompt\n  const universalPrompts = prompts.filter(p => p.context === 'Universal');\n  return universalPrompts[Math.floor(Math.random() * universalPrompts.length)];\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/custom-chip.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/keyword-dictionary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/narrative-generator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/oracle/context-builder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/oracle/oracle-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/oracle/types.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":4,"endColumn":35,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[103,187],"text":"type SuggestionContext = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[103,187],"text":"type SuggestionContext = unknown"},"desc":"Replace empty interface with `unknown`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/prompt-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'input' is defined but never used. Allowed unused args must match /^_/u.","line":223,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'input' is defined but never used. Allowed unused args must match /^_/u.","line":237,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":237,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reflection Prompt Engine\n * \n * Generates contextual prompts for weekly reflections based on week's data.\n * Designed for future LLM handoff — rule-based for now, but interface supports\n * swapping in AI-generated prompts later.\n */\n\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport PortfolioSnapshot from '@/db/models/PortfolioSnapshot';\nimport { STORY_CHIPS, StoryChip } from './story-chips.service';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ReflectionPrompt {\n  id: string;\n  question: string;\n  context: string;  // Internal reasoning (for debugging / future LLM handoff)\n  promptType: 'highlight' | 'gratitude' | 'intention' | 'reconnect' | 'quiet' | 'celebration' | 'gentle';\n  suggestedChipIds?: string[];  // Max 2, contextually relevant\n  mentionedFriendId?: string;\n  mentionedFriendName?: string;\n}\n\nexport interface PromptEngineInput {\n  totalWeaves: number;\n  friendsContacted: number;\n  topFriend?: { id: string; name: string; weaveCount: number };\n  reconnectedFriend?: { id: string; name: string; daysSinceLastContact: number };\n  topActivity?: string;\n  topActivityCount?: number;\n  isQuietWeek: boolean;  // < 2 weaves\n  previousWeekWeaves?: number;\n  weekStreak: number;\n  averageWeeklyWeaves?: number;\n}\n\nexport interface InsightLine {\n  text: string;\n  tone: 'celebration' | 'neutral' | 'gentle';\n}\n\nexport interface DetectedChip {\n  chipId: string;\n  chip: StoryChip;\n  confidence: number;  // 0-1, how confident we are this matches\n}\n\n// ============================================================================\n// PROMPT TEMPLATES\n// ============================================================================\n\ninterface PromptTemplate {\n  id: string;\n  type: ReflectionPrompt['promptType'];\n  condition: (input: PromptEngineInput) => boolean;\n  priority: number;  // Higher = checked first\n  generate: (input: PromptEngineInput) => Omit<ReflectionPrompt, 'id'>;\n}\n\nconst PROMPT_TEMPLATES: PromptTemplate[] = [\n  // High engagement with specific friend\n  {\n    id: 'top_friend_highlight',\n    type: 'highlight',\n    priority: 100,\n    condition: (input) => !!input.topFriend && input.topFriend.weaveCount >= 3,\n    generate: (input) => ({\n      question: `You connected with ${input.topFriend!.name} ${input.topFriend!.weaveCount} times this week. What made those moments stand out?`,\n      context: `Top friend ${input.topFriend!.name} had ${input.topFriend!.weaveCount} weaves — unusually high frequency suggests meaningful connection`,\n      promptType: 'highlight',\n      suggestedChipIds: ['feeling_connected', 'moment_lost-track-time'],\n      mentionedFriendId: input.topFriend!.id,\n      mentionedFriendName: input.topFriend!.name,\n    }),\n  },\n\n  // Reconnected with someone after a gap\n  {\n    id: 'reconnection',\n    type: 'reconnect',\n    priority: 95,\n    condition: (input) => !!input.reconnectedFriend && input.reconnectedFriend.daysSinceLastContact >= 14,\n    generate: (input) => ({\n      question: `You reached out to ${input.reconnectedFriend!.name} after ${input.reconnectedFriend!.daysSinceLastContact} days. How did it feel to reconnect?`,\n      context: `Reconnection after ${input.reconnectedFriend!.daysSinceLastContact} days — worth reflecting on`,\n      promptType: 'reconnect',\n      suggestedChipIds: ['dynamic_picked-up', 'feeling_closer'],\n      mentionedFriendId: input.reconnectedFriend!.id,\n      mentionedFriendName: input.reconnectedFriend!.name,\n    }),\n  },\n\n  // Big increase from last week\n  {\n    id: 'momentum_surge',\n    type: 'celebration',\n    priority: 90,\n    condition: (input) => {\n      if (!input.previousWeekWeaves) return false;\n      return input.totalWeaves >= input.previousWeekWeaves * 1.5 && input.totalWeaves >= 5;\n    },\n    generate: (input) => ({\n      question: `A fuller week than usual — ${input.totalWeaves} connections. Which one surprised you?`,\n      context: `50%+ increase from last week (${input.previousWeekWeaves} → ${input.totalWeaves})`,\n      promptType: 'celebration',\n      suggestedChipIds: ['surprise_deeper-than-expected', 'feeling_energized'],\n    }),\n  },\n\n  // Above average week\n  {\n    id: 'above_average',\n    type: 'celebration',\n    priority: 85,\n    condition: (input) => {\n      if (!input.averageWeeklyWeaves) return false;\n      return input.totalWeaves > input.averageWeeklyWeaves * 1.2 && input.totalWeaves >= 5;\n    },\n    generate: (input) => ({\n      question: `You showed up for ${input.friendsContacted} friends this week. Who left you feeling most energised?`,\n      context: `Above average week (${input.totalWeaves} vs avg ${input.averageWeeklyWeaves?.toFixed(1)})`,\n      promptType: 'gratitude',\n      suggestedChipIds: ['feeling_energized', 'feeling_grateful'],\n    }),\n  },\n\n  // Good variety of friends\n  {\n    id: 'friend_variety',\n    type: 'gratitude',\n    priority: 80,\n    condition: (input) => input.friendsContacted >= 5,\n    generate: (input) => ({\n      question: `You connected with ${input.friendsContacted} different friends. Who are you most grateful for this week?`,\n      context: `High friend diversity (${input.friendsContacted} unique friends)`,\n      promptType: 'gratitude',\n      suggestedChipIds: ['feeling_grateful', 'feeling_connected'],\n    }),\n  },\n\n  // Consistent activity with top friend\n  {\n    id: 'top_friend_regular',\n    type: 'highlight',\n    priority: 75,\n    condition: (input) => !!input.topFriend && input.topFriend.weaveCount === 2,\n    generate: (input) => ({\n      question: `You and ${input.topFriend!.name} connected twice this week. What do you value most about that friendship?`,\n      context: `Regular contact with ${input.topFriend!.name} (2 weaves)`,\n      promptType: 'highlight',\n      suggestedChipIds: ['feeling_comfortable', 'dynamic_flowed-naturally'],\n      mentionedFriendId: input.topFriend!.id,\n      mentionedFriendName: input.topFriend!.name,\n    }),\n  },\n\n  // Had a specific top activity\n  {\n    id: 'top_activity',\n    type: 'gratitude',\n    priority: 70,\n    condition: (input) => !!input.topActivity && (input.topActivityCount ?? 0) >= 2,\n    generate: (input) => ({\n      question: `${input.topActivity} ${input.topActivityCount}× this week. What made those moments special?`,\n      context: `Repeated activity pattern: ${input.topActivity} (${input.topActivityCount}×)`,\n      promptType: 'gratitude',\n      suggestedChipIds: ['feeling_nourished', 'moment_laughed'],\n    }),\n  },\n\n  // Moderate week\n  {\n    id: 'moderate_week',\n    type: 'gratitude',\n    priority: 60,\n    condition: (input) => input.totalWeaves >= 3 && input.totalWeaves <= 6,\n    generate: (input) => ({\n      question: `What's one moment of connection from this week you want to hold onto?`,\n      context: `Moderate activity week (${input.totalWeaves} weaves)`,\n      promptType: 'gratitude',\n      suggestedChipIds: ['feeling_connected', 'moment_they-got-me'],\n    }),\n  },\n\n  // Had some activity (1-2 weaves)\n  {\n    id: 'light_week',\n    type: 'gratitude',\n    priority: 50,\n    condition: (input) => input.totalWeaves >= 1 && input.totalWeaves <= 2,\n    generate: (input) => ({\n      question: `Even a small moment matters. What are you grateful for from this week?`,\n      context: `Light activity week (${input.totalWeaves} weave${input.totalWeaves > 1 ? 's' : ''})`,\n      promptType: 'gratitude',\n      suggestedChipIds: ['feeling_grateful', 'feeling_comfortable'],\n    }),\n  },\n\n  // Quiet week but had streak\n  {\n    id: 'quiet_with_streak',\n    type: 'gentle',\n    priority: 45,\n    condition: (input) => input.isQuietWeek && input.weekStreak > 0,\n    generate: (input) => ({\n      question: `A quieter week. Is there one small moment you're grateful for?`,\n      context: `Quiet week but maintaining streak (${input.weekStreak} weeks)`,\n      promptType: 'quiet',\n      suggestedChipIds: ['feeling_grateful'],\n    }),\n  },\n\n  // Quiet week, no streak\n  {\n    id: 'quiet_fresh_start',\n    type: 'intention',\n    priority: 40,\n    condition: (input) => input.isQuietWeek && input.weekStreak === 0,\n    generate: (input) => ({\n      question: `Who's been on your mind lately?`,\n      context: `Quiet week, no active streak — intention-focused prompt`,\n      promptType: 'intention',\n      suggestedChipIds: [],\n    }),\n  },\n\n  // Default fallback\n  {\n    id: 'default',\n    type: 'gratitude',\n    priority: 0,\n    condition: () => true,\n    generate: (input) => ({\n      question: `What's one moment of connection you want to remember from this week?`,\n      context: `Default prompt — no specific patterns detected`,\n      promptType: 'gratitude',\n      suggestedChipIds: ['feeling_connected', 'feeling_grateful'],\n    }),\n  },\n];\n\n// ============================================================================\n// INSIGHT LINE TEMPLATES\n// ============================================================================\n\ninterface InsightTemplate {\n  condition: (input: PromptEngineInput) => boolean;\n  priority: number;\n  generate: (input: PromptEngineInput) => InsightLine;\n}\n\nconst INSIGHT_TEMPLATES: InsightTemplate[] = [\n  // Strong streak\n  {\n    priority: 100,\n    condition: (input) => input.weekStreak >= 4,\n    generate: (input) => ({\n      text: `${input.weekStreak} weeks of showing up. That's a practice.`,\n      tone: 'celebration',\n    }),\n  },\n\n  // Most active week (vs average)\n  {\n    priority: 95,\n    condition: (input) => {\n      if (!input.averageWeeklyWeaves) return false;\n      return input.totalWeaves > input.averageWeeklyWeaves * 1.3;\n    },\n    generate: () => ({\n      text: `Your most active week in a while — nice rhythm.`,\n      tone: 'celebration',\n    }),\n  },\n\n  // Big increase from last week\n  {\n    priority: 90,\n    condition: (input) => {\n      if (!input.previousWeekWeaves || input.previousWeekWeaves === 0) return false;\n      return input.totalWeaves >= input.previousWeekWeaves * 1.5;\n    },\n    generate: (input) => ({\n      text: `Up from ${input.previousWeekWeaves} last week. Building momentum.`,\n      tone: 'celebration',\n    }),\n  },\n\n  // Consistent with last week\n  {\n    priority: 80,\n    condition: (input) => {\n      if (!input.previousWeekWeaves) return false;\n      const diff = Math.abs(input.totalWeaves - input.previousWeekWeaves);\n      return diff <= 1 && input.totalWeaves >= 3;\n    },\n    generate: () => ({\n      text: `Consistent with last week. Steady rhythm.`,\n      tone: 'neutral',\n    }),\n  },\n\n  // Good friend variety\n  {\n    priority: 75,\n    condition: (input) => input.friendsContacted >= 5,\n    generate: (input) => ({\n      text: `${input.friendsContacted} friends this week. Your network is alive.`,\n      tone: 'celebration',\n    }),\n  },\n\n  // Drop from last week (but still active)\n  {\n    priority: 70,\n    condition: (input) => {\n      if (!input.previousWeekWeaves || input.previousWeekWeaves < 3) return false;\n      return input.totalWeaves < input.previousWeekWeaves * 0.6 && input.totalWeaves >= 2;\n    },\n    generate: () => ({\n      text: `A slower week — that's okay.`,\n      tone: 'gentle',\n    }),\n  },\n\n  // Standard summary\n  {\n    priority: 50,\n    condition: (input) => input.totalWeaves >= 1,\n    generate: (input) => ({\n      text: `${input.totalWeaves} weave${input.totalWeaves !== 1 ? 's' : ''} across ${input.friendsContacted} friend${input.friendsContacted !== 1 ? 's' : ''}.`,\n      tone: 'neutral',\n    }),\n  },\n\n  // Quiet week\n  {\n    priority: 10,\n    condition: (input) => input.isQuietWeek,\n    generate: () => ({\n      text: `A quiet week. Rest is part of the rhythm.`,\n      tone: 'gentle',\n    }),\n  },\n\n  // Fallback\n  {\n    priority: 0,\n    condition: () => true,\n    generate: () => ({\n      text: `Every connection matters.`,\n      tone: 'neutral',\n    }),\n  },\n];\n\n// ============================================================================\n// KEYWORD DETECTION\n// ============================================================================\n\n/**\n * Maps keywords/phrases to chip IDs\n * Focused on feeling and moment chips for weekly reflection context\n */\nconst KEYWORD_TO_CHIPS: Record<string, string[]> = {\n  // Positive feelings\n  'grateful': ['feeling_grateful'],\n  'thankful': ['feeling_grateful'],\n  'appreciate': ['feeling_grateful'],\n  'happy': ['feeling_joyful'],\n  'joy': ['feeling_joyful'],\n  'joyful': ['feeling_joyful'],\n  'connected': ['feeling_connected'],\n  'close': ['feeling_connected', 'feeling_closer'],\n  'understood': ['feeling_understood'],\n  'seen': ['feeling_understood'],\n  'heard': ['feeling_understood'],\n  'comfortable': ['feeling_comfortable'],\n  'easy': ['feeling_comfortable'],\n  'natural': ['feeling_comfortable', 'dynamic_flowed-naturally'],\n  'energised': ['feeling_energized'],\n  'energized': ['feeling_energized'],\n  'inspired': ['feeling_inspired'],\n  'motivated': ['feeling_inspired'],\n  'nourished': ['feeling_nourished'],\n  'warm': ['feeling_nourished'],\n\n  // Mixed/complex feelings\n  'bittersweet': ['feeling_bittersweet'],\n  'exhausted': ['feeling_exhausted-good'],\n  'drained': ['feeling_exhausted-good'],\n  'awkward': ['feeling_awkward-worth-it'],\n\n  // Moments\n  'laughed': ['moment_laughed'],\n  'laugh': ['moment_laughed'],\n  'funny': ['moment_laughed'],\n  'hilarious': ['moment_laughed'],\n  'silence': ['moment_silence'],\n  'quiet': ['moment_silence'],\n  'breakthrough': ['moment_breakthrough'],\n  'realisation': ['moment_breakthrough'],\n  'realization': ['moment_breakthrough'],\n  'aha': ['moment_breakthrough'],\n  'lost track': ['moment_lost-track-time'],\n  'hours flew': ['moment_lost-track-time'],\n  'got me': ['moment_they-got-me'],\n  'understands me': ['moment_they-got-me'],\n  'shared something': ['moment_shared-something', 'moment_they-shared'],\n  'opened up': ['moment_shared-something', 'dynamic_i-opened-up'],\n  'vulnerable': ['moment_they-shared'],\n  'disagreement': ['moment_disagreement'],\n  'argument': ['moment_disagreement'],\n  'worked through': ['moment_worked-through'],\n  'resolved': ['moment_worked-through'],\n  'inside joke': ['moment_inside-joke'],\n  'stayed up': ['moment_stayed-up-late'],\n  'late night': ['moment_stayed-up-late'],\n\n  // Activities (for context)\n  'deep': ['activity_deep-conversation', 'surprise_deeper-than-expected'],\n  'talk': ['activity_deep-conversation', 'activity_caught-up'],\n  'conversation': ['activity_deep-conversation'],\n  'walk': ['activity_went-for'],\n  'coffee': ['activity_shared-meal'],\n  'dinner': ['activity_shared-meal'],\n  'meal': ['activity_shared-meal'],\n  'celebrated': ['activity_celebrated'],\n  'party': ['activity_event'],\n\n  // Surprises\n  'learned': ['surprise_learned-new'],\n  'discovered': ['surprise_learned-new'],\n  'different side': ['surprise_different-side'],\n  'perspective': ['surprise_perspective-shift'],\n  'changed my mind': ['surprise_perspective-shift'],\n  'unexpected': ['surprise_unexpected-topic'],\n  'surprised': ['surprise_more-fun'],\n  'remembered': ['surprise_they-remembered'],\n};\n\n// ============================================================================\n// CORE FUNCTIONS\n// ============================================================================\n\n/**\n * Generate a contextual reflection prompt based on the week's data\n */\nexport function generateReflectionPrompt(input: PromptEngineInput): ReflectionPrompt {\n  // Sort templates by priority (highest first)\n  const sortedTemplates = [...PROMPT_TEMPLATES].sort((a, b) => b.priority - a.priority);\n\n  // Find first matching template\n  for (const template of sortedTemplates) {\n    if (template.condition(input)) {\n      const generated = template.generate(input);\n      return {\n        id: template.id,\n        ...generated,\n      };\n    }\n  }\n\n  // Should never reach here due to default template, but just in case\n  return {\n    id: 'fallback',\n    question: `What's one moment of connection you want to remember?`,\n    context: 'Fallback prompt',\n    promptType: 'gratitude',\n  };\n}\n\n/**\n * Generate a one-line insight based on the week's data\n */\nexport function generateInsightLine(input: PromptEngineInput): InsightLine {\n  const sortedTemplates = [...INSIGHT_TEMPLATES].sort((a, b) => b.priority - a.priority);\n\n  for (const template of sortedTemplates) {\n    if (template.condition(input)) {\n      return template.generate(input);\n    }\n  }\n\n  return {\n    text: 'Every connection matters.',\n    tone: 'neutral',\n  };\n}\n\n/**\n * Detect relevant story chips from user's reflection text\n * Returns max 2 chips, sorted by confidence\n */\nexport function detectChipsFromText(text: string): DetectedChip[] {\n  if (!text || text.trim().length < 5) return [];\n\n  const normalizedText = text.toLowerCase();\n  const detectedChipIds = new Map<string, number>(); // chipId -> confidence score\n\n  // Check each keyword\n  for (const [keyword, chipIds] of Object.entries(KEYWORD_TO_CHIPS)) {\n    if (normalizedText.includes(keyword)) {\n      // Longer keywords get higher confidence\n      const keywordConfidence = Math.min(1, 0.5 + (keyword.length / 20));\n\n      chipIds.forEach(chipId => {\n        const existing = detectedChipIds.get(chipId) || 0;\n        detectedChipIds.set(chipId, Math.max(existing, keywordConfidence));\n      });\n    }\n  }\n\n  // Convert to array and sort by confidence\n  const detected: DetectedChip[] = [];\n\n  for (const [chipId, confidence] of detectedChipIds.entries()) {\n    const chip = STORY_CHIPS.find(c => c.id === chipId);\n    if (chip) {\n      // Filter to only feeling and moment chips for weekly reflection\n      if (chip.type === 'feeling' || chip.type === 'moment') {\n        detected.push({ chipId, chip, confidence });\n      }\n    }\n  }\n\n  // Sort by confidence descending, take top 2\n  return detected\n    .sort((a, b) => b.confidence - a.confidence)\n    .slice(0, 2);\n}\n\n/**\n * Get suggested chips based on prompt type (used when user hasn't written anything)\n */\nexport function getDefaultChipsForPromptType(promptType: ReflectionPrompt['promptType']): string[] {\n  const defaults: Record<ReflectionPrompt['promptType'], string[]> = {\n    highlight: ['feeling_connected', 'moment_lost-track-time'],\n    gratitude: ['feeling_grateful', 'feeling_connected'],\n    intention: [],  // No default chips for intention prompts\n    reconnect: ['dynamic_picked-up', 'feeling_closer'],\n    quiet: ['feeling_grateful'],\n    celebration: ['feeling_energized', 'feeling_joyful'],\n    gentle: ['feeling_grateful', 'feeling_comfortable'],\n  };\n\n  return defaults[promptType] || [];\n}\n\n// ============================================================================\n// DATA FETCHING HELPERS\n// ============================================================================\n\n/**\n * Get the most recent portfolio snapshot for comparison data\n */\nexport async function getRecentPortfolioSnapshot(): Promise<PortfolioSnapshot | null> {\n  try {\n    const snapshots = await database\n      .get<PortfolioSnapshot>('portfolio_snapshots')\n      .query(Q.sortBy('snapshot_date', Q.desc), Q.take(1))\n      .fetch();\n\n    return snapshots[0] || null;\n  } catch (error) {\n    console.error('[PromptEngine] Error fetching portfolio snapshot:', error);\n    return null;\n  }\n}\n\n/**\n * Get previous week's weave count from portfolio snapshots\n */\nexport async function getPreviousWeekWeaves(): Promise<number | undefined> {\n  try {\n    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);\n    const twoWeeksAgo = Date.now() - (14 * 24 * 60 * 60 * 1000);\n\n    const snapshots = await database\n      .get<PortfolioSnapshot>('portfolio_snapshots')\n      .query(\n        Q.where('snapshot_date', Q.between(twoWeeksAgo, oneWeekAgo)),\n        Q.sortBy('snapshot_date', Q.desc),\n        Q.take(1)\n      )\n      .fetch();\n\n    if (snapshots[0]) {\n      return snapshots[0].interactionsPerWeek;\n    }\n\n    return undefined;\n  } catch (error) {\n    console.error('[PromptEngine] Error fetching previous week weaves:', error);\n    return undefined;\n  }\n}\n\n/**\n * Get average weekly weaves from recent snapshots\n */\nexport async function getAverageWeeklyWeaves(): Promise<number | undefined> {\n  try {\n    const fourWeeksAgo = Date.now() - (28 * 24 * 60 * 60 * 1000);\n\n    const snapshots = await database\n      .get<PortfolioSnapshot>('portfolio_snapshots')\n      .query(\n        Q.where('snapshot_date', Q.gte(fourWeeksAgo)),\n        Q.sortBy('snapshot_date', Q.desc)\n      )\n      .fetch();\n\n    if (snapshots.length === 0) return undefined;\n\n    const total = snapshots.reduce((sum, s) => sum + s.interactionsPerWeek, 0);\n    return total / snapshots.length;\n  } catch (error) {\n    console.error('[PromptEngine] Error calculating average weaves:', error);\n    return undefined;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/reflection-friends.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/story-chip-aggregator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/story-chips.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/weekly-event-review.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'interactionFriendMap' is never reassigned. Use 'const' instead.","line":85,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":85,"endColumn":29,"fix":{"range":[2813,2871],"text":"const interactionFriendMap = new Map<string, Set<string>>();"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Weekly Event Review System\n *\n * Scans past week's calendar events and presents them during weekly reflection\n * for mindful, batched logging. Integrates with learning system to filter noise.\n */\n\nimport { database } from '@/db';\nimport InteractionModel from '@/db/models/Interaction';\nimport { Q } from '@nozbe/watermelondb';\nimport {\n  scanCalendarEvents,\n  type ScannedEvent,\n  shouldFilterEvent,\n  isAmbiguousEvent,\n  recordFeedback,\n  CalendarService\n} from '@/modules/interactions';\nimport Logger from '@/shared/utils/Logger';\n\nimport InteractionFriend from '@/db/models/InteractionFriend';\n\nexport interface WeeklyEventReview {\n  events: ScannedEvent[];\n  totalScanned: number;\n  filteredCount: number; // Events filtered by learning\n  ambiguousCount: number; // Events needing friend selection\n}\n\n/**\n * Scan past week for unlogged calendar events\n * Called when user opens weekly reflection\n */\nexport async function scanWeekForUnloggedEvents(): Promise<WeeklyEventReview> {\n  try {\n    // Check if calendar integration is enabled\n    const calendarSettings = await CalendarService.getCalendarSettings();\n    if (!calendarSettings.enabled || !calendarSettings.twoWaySync) {\n      Logger.info('[WeeklyReview] Calendar sync disabled');\n      return {\n        events: [],\n        totalScanned: 0,\n        filteredCount: 0,\n        ambiguousCount: 0,\n      };\n    }\n\n    // Calculate date range (past 7 days)\n    const now = new Date();\n    const weekAgo = new Date();\n    weekAgo.setDate(weekAgo.getDate() - 7);\n\n    Logger.info('[WeeklyReview] Scanning events from', weekAgo, 'to', now);\n\n    // Scan calendar\n    const scanResult = await scanCalendarEvents({\n      startDate: weekAgo,\n      endDate: now,\n      includeWeaveEvents: false,\n      minImportance: 'medium',\n    });\n\n    Logger.info(`[WeeklyReview] Found ${scanResult.totalScanned} events, ${scanResult.matchedEvents} with friend matches`);\n\n    // Filter to only events with friend matches\n    const candidateEvents = scanResult.events.filter(e => e.matchedFriends.length > 0);\n\n    // Batch fetch data for \"already logged\" check\n    // ---------------------------------------------------------\n    // 1. Get all completed interactions for the entire scan window (+/- buffer)\n    // We scan from weekAgo to now. Events could be logged +/- 3 hours.\n    const queryStart = weekAgo.getTime() - (3 * 60 * 60 * 1000);\n    const queryEnd = now.getTime() + (3 * 60 * 60 * 1000);\n\n    const existingInteractions = await database\n      .get<InteractionModel>('interactions')\n      .query(\n        Q.where('interaction_date', Q.between(queryStart, queryEnd)),\n        Q.where('status', 'completed')\n      )\n      .fetch();\n\n    // 2. Get all friend links for these interactions\n    const interactionIds = existingInteractions.map(i => i.id);\n    let interactionFriendMap = new Map<string, Set<string>>();\n\n    if (interactionIds.length > 0) {\n      // Fetch in chunks if too many (WatermelonDB/SQLite limit safety)\n      const chunkedIds = [];\n      const CHUNK_SIZE = 500;\n      for (let i = 0; i < interactionIds.length; i += CHUNK_SIZE) {\n        chunkedIds.push(interactionIds.slice(i, i + CHUNK_SIZE));\n      }\n\n      const allLinks = [];\n      for (const chunk of chunkedIds) {\n        const links = await database\n          .get<InteractionFriend>('interaction_friends')\n          .query(Q.where('interaction_id', Q.oneOf(chunk)))\n          .fetch();\n        allLinks.push(...links);\n      }\n\n      // Build map: interactionId -> Set<friendId>\n      for (const link of allLinks) {\n        if (!interactionFriendMap.has(link.interactionId)) {\n          interactionFriendMap.set(link.interactionId, new Set());\n        }\n        interactionFriendMap.get(link.interactionId)?.add(link.friendId);\n      }\n    }\n\n    // Pre-process interactions for faster time-based lookup\n    // Sort by time for binary search or just simple iteration (list is likely small enough)\n    const sortedInteractions = existingInteractions.sort((a, b) => a.interactionDate.getTime() - b.interactionDate.getTime());\n    // ---------------------------------------------------------\n\n    // Check if already logged (IN MEMORY)\n    const unloggedEvents: ScannedEvent[] = [];\n    for (const event of candidateEvents) {\n      const isLogged = isEventAlreadyLoggedInMemory(event, sortedInteractions, interactionFriendMap);\n      if (!isLogged) {\n        unloggedEvents.push(event);\n      }\n    }\n\n    Logger.debug(`[WeeklyReview] ${unloggedEvents.length} unlogged events`);\n\n    // Apply learning filters\n    const filteredEvents: ScannedEvent[] = [];\n    let filteredCount = 0;\n    let ambiguousCount = 0;\n\n    for (const event of unloggedEvents) {\n      // Check learning filters\n      const filterResult = await shouldFilterEvent(event);\n      if (filterResult.shouldFilter) {\n        Logger.debug(`[WeeklyReview] Filtered event \"${event.title}\": ${filterResult.reason}`);\n        filteredCount++;\n        continue;\n      }\n\n      // Check if ambiguous (needs friend selection)\n      if (isAmbiguousEvent(event)) {\n        ambiguousCount++;\n        // Still include it but mark it\n        event.extractedNames = ['(needs selection)']; // Flag for UI\n      }\n\n      filteredEvents.push(event);\n    }\n\n    Logger.info(`[WeeklyReview] Final: ${filteredEvents.length} events, ${filteredCount} filtered, ${ambiguousCount} ambiguous`);\n\n    return {\n      events: filteredEvents,\n      totalScanned: scanResult.totalScanned,\n      filteredCount,\n      ambiguousCount,\n    };\n  } catch (error) {\n    Logger.error('[WeeklyReview] Error scanning week:', error);\n    return {\n      events: [],\n      totalScanned: 0,\n      filteredCount: 0,\n      ambiguousCount: 0,\n    };\n  }\n}\n\n/**\n * Check if a calendar event has already been logged as an interaction (In-Memory Version)\n */\nfunction isEventAlreadyLoggedInMemory(\n  event: ScannedEvent,\n  sortedInteractions: InteractionModel[],\n  interactionFriendMap: Map<string, Set<string>>\n): boolean {\n  try {\n    // Check if any interaction exists for this event's friends around the same time\n    // Look for interactions within +/- 3 hours of event time\n    const eventTime = event.startDate.getTime();\n    const threeHours = 3 * 60 * 60 * 1000;\n    const startWindow = eventTime - threeHours;\n    const endWindow = eventTime + threeHours;\n\n    const eventFriendIds = event.matchedFriends.map(m => m.friend.id);\n    if (eventFriendIds.length === 0) return false;\n\n    // Filter candidate interactions by time window (in memory)\n    // Since list is sorted, we could optimize, but simple filter is fine for <1000 items\n    const candidates = sortedInteractions.filter(i =>\n      i.interactionDate.getTime() >= startWindow && i.interactionDate.getTime() <= endWindow\n    );\n\n    // Check if any candidate interaction involves these friends\n    for (const interaction of candidates) {\n      const interactionFriendIds = interactionFriendMap.get(interaction.id);\n      if (!interactionFriendIds) continue;\n\n      // If any of the event's friends are in this interaction, consider it logged\n      const hasOverlap = eventFriendIds.some(id => interactionFriendIds.has(id));\n      if (hasOverlap) {\n        Logger.debug(`[WeeklyReview] Event \"${event.title}\" already logged as interaction ${interaction.id}`);\n        return true;\n      }\n    }\n\n    return false;\n  } catch (error) {\n    Logger.error('[WeeklyReview] Error checking if event logged:', error);\n    return false; // Err on side of showing suggestion\n  }\n}\n\n/**\n * Batch log multiple calendar events as interactions\n * Called when user selects events in weekly reflection\n */\nexport async function batchLogCalendarEvents(params: {\n  events: ScannedEvent[];\n  emotionalRating?: number; // Overall rating for the week\n  reflectionNotes?: string; // Overall notes\n}): Promise<{\n  success: boolean;\n  loggedCount: number;\n  errors: number;\n  interactionIds: string[];\n}> {\n  const { events, emotionalRating, reflectionNotes } = params;\n  const result = {\n    success: true,\n    loggedCount: 0,\n    errors: 0,\n    interactionIds: [] as string[],\n  };\n\n  try {\n    for (const event of events) {\n      try {\n        await database.write(async () => {\n          // Create interaction\n          const interaction = await database.get<InteractionModel>('interactions').create((record) => {\n            record.interactionDate = event.startDate;\n            record.interactionType = event.suggestedCategory || 'hangout';\n            record.interactionCategory = event.suggestedCategory || 'hangout';\n            record.status = 'completed';\n            record.title = event.title;\n            record.location = event.location;\n            record.mode = 'ambient'; // Special mode for calendar-sourced events\n\n            // Add emotional context if provided\n            if (reflectionNotes) {\n              record.note = reflectionNotes;\n            }\n\n            // Could add vibe based on emotional rating\n            if (emotionalRating) {\n              if (emotionalRating >= 4) record.vibe = 'full-moon';\n              else if (emotionalRating === 3) record.vibe = 'waxing-gibbous';\n              else if (emotionalRating === 2) record.vibe = 'waning-gibbous';\n              else record.vibe = 'new-moon';\n            }\n          });\n\n          // Link friends\n          const interactionFriendsCollection = database.get('interaction_friends');\n          for (const match of event.matchedFriends) {\n            await interactionFriendsCollection.create((record: any) => {\n              record.interaction.set(interaction);\n              record.friend.set(match.friend);\n            });\n          }\n\n          result.interactionIds.push(interaction.id);\n          result.loggedCount++;\n\n          Logger.info(`[WeeklyReview] Logged event \"${event.title}\" as interaction ${interaction.id}`);\n        });\n\n        // Record feedback as accepted\n        await recordFeedback({\n          event,\n          action: 'accepted',\n          emotionalRating,\n          reflectionNotes,\n          resultingInteractionId: result.interactionIds[result.interactionIds.length - 1],\n        });\n\n      } catch (error) {\n        Logger.error(`[WeeklyReview] Error logging event \"${event.title}\":`, error);\n        result.errors++;\n        result.success = false;\n      }\n    }\n\n    Logger.info(`[WeeklyReview] Batch log complete: ${result.loggedCount} logged, ${result.errors} errors`);\n    return result;\n\n  } catch (error) {\n    Logger.error('[WeeklyReview] Error in batch log:', error);\n    return {\n      success: false,\n      loggedCount: 0,\n      errors: events.length,\n      interactionIds: [],\n    };\n  }\n}\n\n/**\n * Dismiss a calendar event (won't show again)\n */\nexport async function dismissCalendarEvent(params: {\n  event: ScannedEvent;\n  reason: 'wrong-friends' | 'not-social' | 'already-logged' | 'not-relevant';\n}): Promise<void> {\n  const { event, reason } = params;\n\n  try {\n    await recordFeedback({\n      event,\n      action: 'dismissed',\n      dismissalReason: reason,\n    });\n\n    Logger.info(`[WeeklyReview] Dismissed event \"${event.title}\" (reason: ${reason})`);\n  } catch (error) {\n    Logger.error('[WeeklyReview] Error dismissing event:', error);\n  }\n}\n\n/**\n * Snooze suggestions for a specific friend or event pattern\n */\nexport async function snoozeFromWeeklyReview(params: {\n  type: 'friend' | 'event-pattern';\n  friendId?: string;\n  eventPattern?: string;\n  days: 7 | 14 | 30;\n}): Promise<void> {\n  const { type, friendId, eventPattern, days } = params;\n\n  try {\n    const until = Date.now() + (days * 24 * 60 * 60 * 1000);\n\n    // Create a dummy event for recording snooze\n    // (We need an event reference for recordFeedback)\n    const snoozeEvent: Partial<ScannedEvent> = {\n      id: `snooze-${type}-${Date.now()}`,\n      title: eventPattern || 'Snoozed',\n      startDate: new Date(),\n      endDate: new Date(),\n      allDay: false,\n      eventType: 'social',\n      importance: 'medium',\n      confidence: 1,\n      matchedFriends: [],\n      extractedNames: [],\n    };\n\n    await recordFeedback({\n      event: snoozeEvent as ScannedEvent,\n      action: 'snoozed',\n      snoozeConfig: {\n        type,\n        friendId,\n        eventPattern,\n        until,\n      },\n    });\n\n    Logger.info(`[WeeklyReview] Snoozed ${type} for ${days} days`);\n  } catch (error) {\n    Logger.error('[WeeklyReview] Error creating snooze:', error);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/weekly-reflection.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/weekly-stats.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/weekly-summary-extended.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLastInteractionDate' is defined but never used. Allowed unused vars must match /^_/u.","line":629,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":629,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Extended Weekly Summary Service\n * \n * Extends the base weekly summary with additional data needed for the prompt engine:\n * - friendActivity: Per-friend weave counts for the week\n * - reconnections: Friends contacted after a significant gap\n * - weekStreak: Consecutive weeks with completed reflections\n * \n * This can either replace your existing calculateWeeklySummary() or be merged into it.\n */\n\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport InteractionModel from '@/db/models/Interaction';\nimport InteractionFriend from '@/db/models/InteractionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport WeeklyReflection from '@/db/models/WeeklyReflection';\nimport { getAverageWeeklyWeaves } from './prompt-engine';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface FriendActivityItem {\n  friendId: string;\n  friendName: string;\n  weaveCount: number;\n  lastInteractionDate: Date;\n}\n\nexport interface ReconnectionItem {\n  friendId: string;\n  friendName: string;\n  daysSince: number;  // Days since previous contact before this week's interaction\n  reconnectionDate: Date;\n}\n\nexport interface ExtendedWeeklySummary {\n  // Existing fields (from your current WeeklySummary)\n  totalWeaves: number;\n  friendsContacted: number;\n  topActivity: string;\n  topActivityCount: number;\n  missedFriends: MissedFriend[];\n  weekStartDate: Date;\n  weekEndDate: Date;\n\n  // New fields for prompt engine\n  friendActivity: FriendActivityItem[];\n  reconnections: ReconnectionItem[];\n  weekStreak: number;\n\n  // Optional existing fields\n  comparison?: {\n    weavesChange: number;\n    friendsChange: number;\n  };\n  patterns?: {\n    mostConsistentFriend?: { name: string; weaveCount: number };\n    risingConnection?: { name: string };\n    needsAttention?: number;\n  };\n  socialHealth?: {\n    score: number;\n  };\n  averageWeeklyWeaves?: number;\n}\n\nimport { MissedFriend } from './weekly-stats.service';\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Get the start and end of the current week (Sunday to Saturday)\n */\nfunction getCurrentWeekBounds(): { weekStart: Date; weekEnd: Date } {\n  const now = new Date();\n  const dayOfWeek = now.getDay(); // 0 = Sunday\n\n  const weekStart = new Date(now);\n  weekStart.setDate(now.getDate() - dayOfWeek);\n  weekStart.setHours(0, 0, 0, 0);\n\n  const weekEnd = new Date(weekStart);\n  weekEnd.setDate(weekStart.getDate() + 6);\n  weekEnd.setHours(23, 59, 59, 999);\n\n  return { weekStart, weekEnd };\n}\n\n/**\n * Calculate friend activity for the week\n * Returns list of friends contacted with weave counts, sorted by count descending\n */\nasync function calculateFriendActivity(\n  weekStart: Date,\n  weekEnd: Date\n): Promise<FriendActivityItem[]> {\n  // Get all completed interactions this week\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('interaction_date', Q.between(weekStart.getTime(), weekEnd.getTime())),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  if (interactions.length === 0) return [];\n\n  // Get all interaction-friend links for these interactions\n  const interactionIds = interactions.map(i => i.id);\n  const interactionFriends = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('interaction_id', Q.oneOf(interactionIds)))\n    .fetch();\n\n  // Build friend ID to interaction mapping\n  const friendInteractions = new Map<string, { count: number; lastDate: Date }>();\n\n  for (const link of interactionFriends) {\n    const interaction = interactions.find(i => i.id === link.interactionId);\n    if (!interaction) continue;\n\n    const existing = friendInteractions.get(link.friendId);\n    const interactionDate = new Date(interaction.interactionDate);\n\n    if (existing) {\n      existing.count++;\n      if (interactionDate > existing.lastDate) {\n        existing.lastDate = interactionDate;\n      }\n    } else {\n      friendInteractions.set(link.friendId, {\n        count: 1,\n        lastDate: interactionDate,\n      });\n    }\n  }\n\n  // Get friend details\n  const friendIds = Array.from(friendInteractions.keys());\n  if (friendIds.length === 0) return [];\n\n  const friends = await database\n    .get<FriendModel>('friends')\n    .query(Q.where('id', Q.oneOf(friendIds)))\n    .fetch();\n\n  // Build result\n  const result: FriendActivityItem[] = [];\n\n  for (const friend of friends) {\n    const data = friendInteractions.get(friend.id);\n    if (data) {\n      result.push({\n        friendId: friend.id,\n        friendName: friend.name,\n        weaveCount: data.count,\n        lastInteractionDate: data.lastDate,\n      });\n    }\n  }\n\n  // Sort by weave count descending\n  return result.sort((a, b) => b.weaveCount - a.weaveCount);\n}\n\n/**\n * Count total unique completed interactions for the week\n */\nasync function countWeeklyInteractions(\n  weekStart: Date,\n  weekEnd: Date\n): Promise<number> {\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('interaction_date', Q.between(weekStart.getTime(), weekEnd.getTime())),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  return interactions.length;\n}\n\n/**\n * Find reconnections - friends contacted this week after a significant gap\n * A \"reconnection\" is defined as contact after 14+ days of no interaction\n */\n/**\n * Find reconnections - friends contacted this week after a significant gap\n * A \"reconnection\" is defined as contact after 14+ days of no interaction\n * Optimized to use batch queries.\n */\nasync function findReconnections(\n  weekStart: Date,\n  weekEnd: Date,\n  minGapDays: number = 14\n): Promise<ReconnectionItem[]> {\n  // Get all completed interactions this week\n  const thisWeekInteractions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('interaction_date', Q.between(weekStart.getTime(), weekEnd.getTime())),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  if (thisWeekInteractions.length === 0) return [];\n\n  // Get friend IDs from this week's interactions\n  const interactionIds = thisWeekInteractions.map(i => i.id);\n  const interactionFriends = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('interaction_id', Q.oneOf(interactionIds)))\n    .fetch();\n\n  const friendIdsThisWeek = new Set<string>();\n  const friendFirstInteraction = new Map<string, Date>();\n\n  for (const link of interactionFriends) {\n    friendIdsThisWeek.add(link.friendId);\n\n    const interaction = thisWeekInteractions.find(i => i.id === link.interactionId);\n    if (interaction) {\n      const date = new Date(interaction.interactionDate);\n      const existing = friendFirstInteraction.get(link.friendId);\n      if (!existing || date < existing) {\n        friendFirstInteraction.set(link.friendId, date);\n      }\n    }\n  }\n\n  if (friendIdsThisWeek.size === 0) return [];\n\n  // Batch fetch previous interactions for all relevant friends\n  // -------------------------------------------------------------\n  const friendIdsArray = Array.from(friendIdsThisWeek);\n  const beforeWeekStart = weekStart.getTime() - 1;\n\n  // 1. Get ALL previous interaction links for these friends\n  // This might be large, but usually manageable per user. \n  // If extremely large, would need chunking or raw SQL.\n  const allHistoryLinks = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', Q.oneOf(friendIdsArray)))\n    .fetch();\n\n  if (allHistoryLinks.length === 0) return [];\n\n  const allHistoryInteractionIds = allHistoryLinks.map(l => l.interactionId);\n\n  // 2. Fetch the interactions themselves (filtered by date < weekStart)\n  const historyInteractions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(allHistoryInteractionIds)),\n      Q.where('interaction_date', Q.lt(beforeWeekStart)),\n      Q.where('status', 'completed'),\n      Q.sortBy('interaction_date', Q.desc)\n      // We can't use take(1) per friend here easily with standard queries, \n      // so we fetch history and filter in memory.\n    )\n    .fetch();\n\n  // Map interactionId -> Interaction\n  const historyMap = new Map<string, InteractionModel>();\n  historyInteractions.forEach(i => historyMap.set(i.id, i));\n\n  // Find last interaction for each friend\n  const reconnections: ReconnectionItem[] = [];\n\n  for (const friendId of friendIdsThisWeek) {\n    // Get links for this friend\n    const friendLinks = allHistoryLinks.filter(l => l.friendId === friendId);\n\n    // Find most recent interaction from history\n    let lastInteractionDate: Date | null = null;\n\n    for (const link of friendLinks) {\n      const interaction = historyMap.get(link.interactionId);\n      if (interaction) {\n        const date = new Date(interaction.interactionDate);\n        if (!lastInteractionDate || date > lastInteractionDate) {\n          lastInteractionDate = date;\n        }\n      }\n    }\n\n    if (!lastInteractionDate) {\n      // First time contact (not reconnection)\n      continue;\n    }\n\n    const thisWeekFirstDate = friendFirstInteraction.get(friendId);\n    if (!thisWeekFirstDate) continue;\n\n    const daysSince = Math.floor(\n      (thisWeekFirstDate.getTime() - lastInteractionDate.getTime()) / (1000 * 60 * 60 * 24)\n    );\n\n    if (daysSince >= minGapDays) {\n      // Get friend name (fetch from DB or if we have a cache)\n      // We can optimize by fetching these friends in batch too if strictly needed,\n      // but fetching ~3-5 reconnection friends individually is acceptable cost \n      // compared to the previous loop. Let's strict optimize though.\n      const friend = await database.get<FriendModel>('friends').find(friendId);\n\n      reconnections.push({\n        friendId,\n        friendName: friend.name,\n        daysSince,\n        reconnectionDate: thisWeekFirstDate,\n      });\n    }\n  }\n\n  // Sort by gap length descending (longest reconnection first)\n  return reconnections.sort((a, b) => b.daysSince - a.daysSince);\n}\n\n/**\n * Calculate week streak - consecutive weeks with completed reflections\n */\nasync function calculateWeekStreak(): Promise<number> {\n  // Get all weekly reflections, sorted by date descending\n  const reflections = await database\n    .get<WeeklyReflection>('weekly_reflections')\n    .query(Q.sortBy('week_end_date', Q.desc))\n    .fetch();\n\n  if (reflections.length === 0) return 0;\n\n  const now = Date.now();\n  const oneWeekMs = 7 * 24 * 60 * 60 * 1000;\n  let streak = 0;\n\n  // Check if most recent reflection is from this week or last week\n  // (Allow current week to not have a reflection yet)\n  const mostRecent = reflections[0];\n  const weeksSinceMostRecent = Math.floor((now - mostRecent.weekEndDate) / oneWeekMs);\n\n  // If more than 1 week since last reflection, streak is broken\n  if (weeksSinceMostRecent > 1) {\n    return 0;\n  }\n\n  // Count consecutive weeks\n  for (let i = 0; i < reflections.length; i++) {\n    const reflection = reflections[i];\n    const expectedWeekEnd = now - (i * oneWeekMs);\n    const difference = Math.abs(reflection.weekEndDate - expectedWeekEnd);\n\n    // Allow 3 days of flexibility for week alignment\n    if (difference < 3 * 24 * 60 * 60 * 1000) {\n      streak++;\n    } else {\n      break;\n    }\n  }\n\n  return streak;\n}\n\n/**\n * Get previous week's stats for comparison\n */\nasync function getPreviousWeekStats(): Promise<{ weaves: number; friends: number } | null> {\n  const now = new Date();\n  const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n  const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);\n\n  // Get last week's bounds\n  const lastWeekEnd = new Date(oneWeekAgo);\n  lastWeekEnd.setHours(23, 59, 59, 999);\n\n  const lastWeekStart = new Date(twoWeeksAgo);\n  const dayOfWeek = lastWeekStart.getDay();\n  lastWeekStart.setDate(lastWeekStart.getDate() - dayOfWeek + 7); // Start of last week\n  lastWeekStart.setHours(0, 0, 0, 0);\n\n  // Get interactions from last week\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('interaction_date', Q.between(lastWeekStart.getTime(), lastWeekEnd.getTime())),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  if (interactions.length === 0) return null;\n\n  // Get unique friends\n  const interactionIds = interactions.map(i => i.id);\n  const interactionFriends = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('interaction_id', Q.oneOf(interactionIds)))\n    .fetch();\n\n  const uniqueFriends = new Set(interactionFriends.map(link => link.friendId));\n\n  return {\n    weaves: interactions.length,\n    friends: uniqueFriends.size,\n  };\n}\n\n// ============================================================================\n// MAIN FUNCTION\n// ============================================================================\n\n/**\n * Calculate extended weekly summary with all fields needed for the prompt engine.\n * \n * This is designed to either:\n * 1. Replace your existing calculateWeeklySummary() entirely\n * 2. Be called alongside it and merged\n * \n * If you want option 2, you can call this and spread the results into your existing summary.\n */\nexport async function calculateExtendedWeeklySummary(): Promise<ExtendedWeeklySummary> {\n  const { weekStart, weekEnd } = getCurrentWeekBounds();\n\n  // Run calculations in parallel where possible\n  const [\n    friendActivity,\n    reconnections,\n    weekStreak,\n    previousWeekStats,\n    averageWeeklyWeaves,\n    totalWeaves,\n  ] = await Promise.all([\n    calculateFriendActivity(weekStart, weekEnd),\n    findReconnections(weekStart, weekEnd),\n    calculateWeekStreak(),\n    getPreviousWeekStats(),\n    getAverageWeeklyWeaves(),\n    countWeeklyInteractions(weekStart, weekEnd),\n  ]);\n\n  // Calculate basic stats from friendActivity\n  // const totalWeaves = friendActivity.reduce((sum, f) => sum + f.weaveCount, 0); // OLD: Counted person-interactions\n  const friendsContacted = friendActivity.length;\n\n  // Get top activity (would need interaction data - simplified here)\n  // In your real implementation, you'd calculate this from interactions\n  const topActivity = await getTopActivity(weekStart, weekEnd);\n\n  // Get missed friends (friends needing attention)\n  const missedFriends = await getMissedFriends();\n\n  // Build comparison if we have previous week data\n  const comparison = previousWeekStats ? {\n    weavesChange: totalWeaves - previousWeekStats.weaves,\n    friendsChange: friendsContacted - previousWeekStats.friends,\n  } : undefined;\n\n  // Build patterns\n  const patterns = buildPatterns(friendActivity, missedFriends);\n\n  // Calculate social health score\n  const socialHealth = await calculateSocialHealth();\n\n  return {\n    totalWeaves,\n    friendsContacted,\n    topActivity: topActivity.activity,\n    topActivityCount: topActivity.count,\n    missedFriends,\n    weekStartDate: weekStart,\n    weekEndDate: weekEnd,\n    friendActivity,\n    reconnections,\n    weekStreak,\n    comparison,\n    patterns,\n    socialHealth,\n    averageWeeklyWeaves,\n  };\n}\n\n/**\n * Get top activity for the week\n */\nasync function getTopActivity(\n  weekStart: Date,\n  weekEnd: Date\n): Promise<{ activity: string; count: number }> {\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('interaction_date', Q.between(weekStart.getTime(), weekEnd.getTime())),\n      Q.where('status', 'completed')\n    )\n    .fetch();\n\n  if (interactions.length === 0) {\n    return { activity: 'None', count: 0 };\n  }\n\n  // Count activities\n  const activityCounts = new Map<string, number>();\n\n  for (const interaction of interactions) {\n    const activity = interaction.activity || interaction.interactionCategory || 'Connection';\n    activityCounts.set(activity, (activityCounts.get(activity) || 0) + 1);\n  }\n\n  // Find top activity\n  let topActivity = 'Connection';\n  let topCount = 0;\n\n  for (const [activity, count] of activityCounts) {\n    if (count > topCount) {\n      topActivity = activity;\n      topCount = count;\n    }\n  }\n\n  return { activity: topActivity, count: topCount };\n}\n\n/**\n * Get friends who need attention (low weave scores in important tiers)\n */\n/**\n * Get friends who need attention (low weave scores in important tiers)\n * Optimized to batch fetch last interaction dates.\n */\nasync function getMissedFriends(): Promise<MissedFriend[]> {\n  // Get non-dormant friends with low scores\n  const friends = await database\n    .get<FriendModel>('friends')\n    .query(\n      Q.where('is_dormant', false),\n      Q.where('weave_score', Q.lt(50)), // Below 50 needs attention\n      Q.sortBy('weave_score', Q.asc)\n    )\n    .fetch();\n\n  if (friends.length === 0) return [];\n\n  // Batch fetch last interactions for these friends\n  // -------------------------------------------------------------\n  const friendIds = friends.map(f => f.id);\n\n  // 1. Get all interaction links for these friends\n  const allLinks = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', Q.oneOf(friendIds)))\n    .fetch();\n\n  const interactionIds = allLinks.map(l => l.interactionId);\n\n  // 2. Fetch the actual interactions\n  // NOTE: If user has minimal history, this is small. \n  // If user has huge history, filtering by date DESC and limit might be better in SQL,\n  // but WatermelonDB support for complex joins is limited.\n  // We'll fetch 'completed' interactions for these IDs.\n  // To optimize, we probably only care about RECENT interactions (e.g. last 30 days) to confirm 'missed' state? \n  // No, we need the *absolute last*. \n  // Let's fetch them sorted by date desc.\n\n  let interactions: InteractionModel[] = [];\n  if (interactionIds.length > 0) {\n    interactions = await database\n      .get<InteractionModel>('interactions')\n      .query(\n        Q.where('id', Q.oneOf(interactionIds)),\n        Q.where('status', 'completed')\n      )\n      .fetch();\n  }\n\n  // Map interactionId -> Interaction\n  const interactionMap = new Map<string, InteractionModel>();\n  interactions.forEach(i => interactionMap.set(i.id, i));\n\n  // Determine last interaction date per friend\n  const lastInteractionMap = new Map<string, Date>();\n\n  for (const friendId of friendIds) {\n    const friendLinks = allLinks.filter(l => l.friendId === friendId);\n    let maxDate: Date | null = null;\n\n    for (const link of friendLinks) {\n      const interaction = interactionMap.get(link.interactionId);\n      if (interaction) {\n        const date = new Date(interaction.interactionDate);\n        if (!maxDate || date > maxDate) {\n          maxDate = date;\n        }\n      }\n    }\n\n    if (maxDate) {\n      lastInteractionMap.set(friendId, maxDate);\n    }\n  }\n  // -------------------------------------------------------------\n\n  const missedFriends: MissedFriend[] = [];\n\n  for (const friend of friends) {\n    // Calculate days since last contact\n    const lastInteraction = lastInteractionMap.get(friend.id);\n    const daysSince = lastInteraction\n      ? Math.floor((Date.now() - lastInteraction.getTime()) / (1000 * 60 * 60 * 24))\n      : 999;\n\n    missedFriends.push({\n      friend,\n      weaveScore: friend.weaveScore,\n      daysSinceLastContact: daysSince,\n      archetypeValue: getArchetypeValue(friend.archetype),\n      suggestedAction: getSuggestedAction(friend.archetype, friend.dunbarTier),\n    });\n  }\n\n  return missedFriends;\n}\n\n/**\n * Get the date of the last interaction with a friend\n * (Deprecated helper - kept for compatibility if needed elsewhere, but logic inlined above)\n */\nasync function getLastInteractionDate(friendId: string): Promise<Date | null> {\n  const links = await database\n    .get<InteractionFriend>('interaction_friends')\n    .query(Q.where('friend_id', friendId))\n    .fetch();\n\n  if (links.length === 0) return null;\n\n  const interactionIds = links.map(l => l.interactionId);\n  const interactions = await database\n    .get<InteractionModel>('interactions')\n    .query(\n      Q.where('id', Q.oneOf(interactionIds)),\n      Q.where('status', 'completed'),\n      Q.sortBy('interaction_date', Q.desc),\n      Q.take(1)\n    )\n    .fetch();\n\n  return interactions[0] ? new Date(interactions[0].interactionDate) : null;\n}\n\n/**\n * Get what this archetype values in friendships\n */\nfunction getArchetypeValue(archetype: string): string {\n  const values: Record<string, string> = {\n    'Emperor': 'structure and reliability',\n    'Empress': 'nurturing and care',\n    'HighPriestess': 'depth and intuition',\n    'Fool': 'spontaneity and adventure',\n    'Sun': 'joy and celebration',\n    'Hermit': 'quality one-on-one time',\n    'Magician': 'creativity and ideas',\n    'Lovers': 'emotional connection',\n  };\n  return values[archetype] || 'meaningful connection';\n}\n\n/**\n * Get a suggested action based on archetype and tier\n */\nfunction getSuggestedAction(archetype: string, tier: string): string {\n  const actions: Record<string, string> = {\n    'Emperor': 'Schedule a catch-up call',\n    'Empress': 'Send a caring message',\n    'HighPriestess': 'Share something meaningful',\n    'Fool': 'Suggest a spontaneous hangout',\n    'Sun': 'Celebrate something together',\n    'Hermit': 'Invite them for quiet time',\n    'Magician': 'Bounce an idea off them',\n    'Lovers': 'Express appreciation',\n  };\n\n  const action = actions[archetype] || 'Reach out with a hello';\n\n  // Adjust for tier\n  if (tier === 'InnerCircle') {\n    return action.replace('message', 'call').replace('Suggest', 'Plan');\n  }\n\n  return action;\n}\n\n/**\n * Build patterns from week data\n */\nfunction buildPatterns(\n  friendActivity: FriendActivityItem[],\n  missedFriends: MissedFriend[]\n): ExtendedWeeklySummary['patterns'] {\n  const patterns: ExtendedWeeklySummary['patterns'] = {};\n\n  // Most consistent friend (most weaves this week)\n  if (friendActivity.length > 0 && friendActivity[0].weaveCount > 1) {\n    patterns.mostConsistentFriend = {\n      name: friendActivity[0].friendName,\n      weaveCount: friendActivity[0].weaveCount,\n    };\n  }\n\n  // Rising connection (second most contacted, if they have 2+ weaves)\n  if (friendActivity.length > 1 && friendActivity[1].weaveCount >= 2) {\n    patterns.risingConnection = {\n      name: friendActivity[1].friendName,\n    };\n  }\n\n  // Friends needing attention\n  patterns.needsAttention = missedFriends.length;\n\n  return patterns;\n}\n\n/**\n * Calculate overall social health score\n */\nasync function calculateSocialHealth(): Promise<{ score: number } | undefined> {\n  const friends = await database\n    .get<FriendModel>('friends')\n    .query(Q.where('is_dormant', false))\n    .fetch();\n\n  if (friends.length === 0) return undefined;\n\n  const totalScore = friends.reduce((sum, f) => sum + f.weaveScore, 0);\n  const averageScore = Math.round(totalScore / friends.length);\n\n  return { score: averageScore };\n}\n\n// ============================================================================\n// INTEGRATION HELPER\n// ============================================================================\n\n/**\n * Helper to extend an existing WeeklySummary with the new fields.\n * Use this if you want to keep your existing calculateWeeklySummary() \n * and just add the new fields.\n * \n * Usage:\n * const baseSummary = await calculateWeeklySummary(); // Your existing function\n * const extendedSummary = await extendWeeklySummary(baseSummary);\n */\nexport async function extendWeeklySummary(\n  baseSummary: Omit<ExtendedWeeklySummary, 'friendActivity' | 'reconnections' | 'weekStreak'>\n): Promise<ExtendedWeeklySummary> {\n  const [friendActivity, reconnections, weekStreak] = await Promise.all([\n    calculateFriendActivity(baseSummary.weekStartDate, baseSummary.weekEndDate),\n    findReconnections(baseSummary.weekStartDate, baseSummary.weekEndDate),\n    calculateWeekStreak(),\n  ]);\n\n  return {\n    ...baseSummary,\n    friendActivity,\n    reconnections,\n    weekStreak,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/services/year-in-moons-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/reflection/utils/text-analysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/FriendDetailSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/FriendForm.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { useDebounceCallback } from '@/shared/hooks/useDebounceCallback';\nimport { View, Text, TouchableOpacity, TextInput, ScrollView, Image, StyleSheet, Modal, Alert, ActivityIndicator } from 'react-native';\nimport { ArrowLeft, Camera, X, Users, AlertCircle } from 'lucide-react-native';\nimport * as ImagePicker from 'expo-image-picker';\nimport * as Contacts from 'expo-contacts';\nimport { useRouter } from 'expo-router';\nimport { SafeAreaView } from 'react-native-safe-area-context';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport FriendModel from '@/db/models/Friend';\nimport { type Archetype, type FriendFormData, type Tier, type RelationshipType } from '@/components/types';\nimport { ArchetypeCard } from '@/components/ArchetypeCard';\nimport { ArchetypeDetailModal } from '@/components/ArchetypeDetailModal';\nimport { ContactPickerGrid } from '@/components/onboarding/ContactPickerGrid';\nimport { MonthDayPicker } from '@/components/MonthDayPicker';\nimport { getTierCapacity, getTierDisplayName, isTierAtCapacity } from '@/shared/constants/constants';\nimport { normalizeContactImageUri } from '../utils/image.utils';\nimport { SimpleTutorialTooltip } from '@/components/SimpleTutorialTooltip';\nimport { useTutorialStore } from '@/stores/tutorialStore';\nimport { validateMMDDFormat } from '@/shared/utils/validation-helpers';\nimport { processAndStoreImage, getRelativePath, resolveImageUri } from '../services/image.service';\n\ninterface FriendFormProps {\n  onSave: (friendData: FriendFormData) => void;\n  friend?: FriendModel;\n  initialTier?: 'inner' | 'close' | 'community';\n  fromOnboarding?: boolean;\n  onSkip?: () => void;\n}\n\n\nexport function FriendForm({ onSave, friend, initialTier, fromOnboarding, onSkip }: FriendFormProps) {\n  const router = useRouter();\n  const { colors } = useTheme(); // Use the hook\n\n  // Tutorial state - simple approach\n  const hasAddedFirstFriend = useTutorialStore((state) => state.hasAddedFirstFriend);\n  const markFirstFriendAdded = useTutorialStore((state) => state.markFirstFriendAdded);\n  const [currentTutorialStep, setCurrentTutorialStep] = useState(0);\n\n  // Tutorial handlers\n  const showTutorial = fromOnboarding && !hasAddedFirstFriend && !friend;\n\n  const handleTutorialNext = useCallback(() => {\n    if (currentTutorialStep < 1) {\n      setCurrentTutorialStep(prev => prev + 1);\n    } else {\n      // Tutorial complete\n      setCurrentTutorialStep(-1);\n    }\n  }, [currentTutorialStep]);\n\n  const handleTutorialSkip = useCallback(async () => {\n    await markFirstFriendAdded();\n    setCurrentTutorialStep(-1);\n  }, [markFirstFriendAdded]);\n\n  // Helper function to map DB tier to form tier\n  const getFormTier = (dbTier?: Tier | string) => {\n    if (dbTier === 'InnerCircle') return 'inner';\n    if (dbTier === 'CloseFriends') return 'close';\n    if (dbTier === 'Community') return 'community';\n    return 'close'; // Default\n  };\n\n  const [formData, setFormData] = useState<FriendFormData>({\n    name: friend?.name || \"\",\n    tier: friend ? getFormTier(friend.dunbarTier) : initialTier || 'inner',\n    archetype: (friend?.archetype as Archetype) || \"Emperor\",\n    notes: friend?.notes || \"\",\n    photoUrl: friend?.photoUrl || \"\",\n    birthday: friend?.birthday,\n    anniversary: friend?.anniversary,\n    relationshipType: friend?.relationshipType as RelationshipType | undefined,\n  });\n\n  // Resolve initial photo URL if it's a relative path\n  useEffect(() => {\n    if (friend?.photoUrl) {\n      resolveImageUri(friend.photoUrl).then(resolvedUri => {\n        if (resolvedUri !== friend.photoUrl) {\n          setFormData(prev => ({ ...prev, photoUrl: resolvedUri }));\n        }\n      });\n    }\n  }, [friend?.photoUrl]);\n\n  const [imageError, setImageError] = useState(false);\n  const [imageProcessing, setImageProcessing] = useState(false);\n  const [showContactPicker, setShowContactPicker] = useState(false);\n  const [showCapacityWarning, setShowCapacityWarning] = useState(false);\n\n  // State for tier counts\n  const [tierCounts, setTierCounts] = useState({ inner: 0, close: 0, community: 0 });\n  const [allFriendNames, setAllFriendNames] = useState<string[]>([]);\n\n  // Fetch friend data for validation/capacity\n  useEffect(() => {\n    const fetchFriendData = async () => {\n      try {\n        const friends = await database.get<FriendModel>('friends').query().fetch();\n\n        const counts = { inner: 0, close: 0, community: 0 };\n        const names: string[] = [];\n\n        friends.forEach(f => {\n          if (f.isDormant) return;\n\n          // Add to names list for duplicate check (excluding current friend)\n          if (!friend || f.id !== friend.id) {\n            names.push(f.name);\n          }\n\n          // Skip counting the current friend for capacity if we are editing them\n          // But we DO want to know the *other* friends in the tier to see if there's room\n          if (friend && f.id === friend.id) return;\n\n          const tier = getFormTier(f.dunbarTier);\n          counts[tier as keyof typeof counts]++;\n        });\n\n        setTierCounts(counts);\n        setAllFriendNames(names);\n      } catch (e) {\n        console.error(\"Error fetching friend data for form:\", e);\n      }\n    };\n\n    fetchFriendData();\n  }, [friend]);\n\n  // Reset image error when friend changes or photoUrl updates\n  useEffect(() => {\n    setImageError(false);\n  }, [friend?.id, formData.photoUrl]);\n\n  // Validation helper functions\n  const validateBirthdayFormat = (birthday?: string): boolean => {\n    if (!birthday) return true; // Birthday is optional\n    return validateMMDDFormat(birthday);\n  };\n\n  const validateAnniversaryFormat = (anniversary?: string): boolean => {\n    if (!anniversary) return true; // Anniversary is optional\n    return validateMMDDFormat(anniversary);\n  };\n\n  const checkDuplicateName = (name: string): boolean => {\n    if (!name.trim()) return false;\n    // Check if name already exists (case-insensitive) using the fetched names list\n    const isDuplicate = allFriendNames.some(existingName =>\n      existingName.toLowerCase() === name.trim().toLowerCase()\n    );\n    return isDuplicate;\n  };\n\n  const proceedWithSave = async () => {\n    setShowCapacityWarning(false);\n\n    // Convert absolute path to relative path before saving\n    const dataToSave = {\n      ...formData,\n      photoUrl: getRelativePath(formData.photoUrl)\n    };\n\n    onSave(dataToSave);\n\n    // Mark first friend added if this is from onboarding\n    if (showTutorial && !friend) {\n      await markFirstFriendAdded();\n    }\n\n    // Navigation is now handled by the parent component via onSave\n    // if (router.canGoBack()) {\n    //   router.back();\n    // } else {\n    //   router.replace('/(tabs)');\n    // }\n  };\n\n  const handleSave = useDebounceCallback(() => {\n    // 1. Validate name\n    if (!formData.name.trim()) {\n      Alert.alert('Name Required', 'Please enter a name for your friend.');\n      return;\n    }\n\n    // 2. Check for duplicate names\n    if (checkDuplicateName(formData.name)) {\n      Alert.alert(\n        'Duplicate Name',\n        `You already have a friend named \"${formData.name}\". Please use a different name or nickname.`,\n        [{ text: 'OK' }]\n      );\n      return;\n    }\n\n    // 3. Validate birthday format (should always be valid from MonthDayPicker)\n    if (formData.birthday && !validateBirthdayFormat(formData.birthday)) {\n      Alert.alert(\n        'Invalid Birthday',\n        'Please select a valid birthday using the date picker.',\n        [{ text: 'OK' }]\n      );\n      return;\n    }\n\n    // 4. Validate anniversary format (should always be valid from MonthDayPicker)\n    if (formData.anniversary && !validateAnniversaryFormat(formData.anniversary)) {\n      Alert.alert(\n        'Invalid Anniversary',\n        'Please select a valid anniversary using the date picker.',\n        [{ text: 'OK' }]\n      );\n      return;\n    }\n\n    // Check if tier is at capacity (only for new friends or tier changes)\n    const selectedTier = formData.tier as 'inner' | 'close' | 'community';\n    const isChangingTier = friend && getFormTier(friend.dunbarTier) !== selectedTier;\n    const isNewFriend = !friend;\n\n    if ((isNewFriend || isChangingTier) && isTierAtCapacity(tierCounts[selectedTier], selectedTier)) {\n      // Show capacity warning modal\n      setShowCapacityWarning(true);\n      return;\n    }\n\n    // Proceed with save\n    proceedWithSave();\n  });\n\n  const pickImage = async () => {\n    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n    if (status !== 'granted') {\n      alert('Sorry, we need camera roll permissions to make this work!');\n      return;\n    }\n\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.Images,\n      allowsEditing: true,\n      aspect: [1, 1],\n      quality: 0.8, // Reduced from 1 for better performance\n    });\n\n    if (!result.canceled) {\n      setImageProcessing(true);\n\n      try {\n        // Generate a temporary ID for new friends, or use existing friend ID\n        const imageId = friend?.id || `temp_${Date.now()}`;\n\n        // Process and store the image using ImageService\n        const imageResult = await processAndStoreImage({\n          uri: result.assets[0].uri,\n          type: 'profilePicture',\n          imageId,\n          // userId will be populated when accounts are enabled\n          // For now it's undefined and only local storage is used\n        });\n\n        if (imageResult.success) {\n          // Store the persistent local URI (not the temporary picker URI)\n          setFormData({ ...formData, photoUrl: imageResult.localUri });\n          setImageError(false);\n\n        } else {\n          console.error('[FriendForm] Image processing failed:', imageResult.error);\n          Alert.alert(\n            'Image Processing Failed',\n            'Could not save the image. Please try again.',\n            [{ text: 'OK' }]\n          );\n        }\n      } catch (error) {\n        console.error('[FriendForm] Error processing image:', error);\n        Alert.alert(\n          'Image Processing Failed',\n          'Could not save the image. Please try again.',\n          [{ text: 'OK' }]\n        );\n      } finally {\n        setImageProcessing(false);\n      }\n    }\n  };\n\n  const removePhoto = () => {\n    setFormData({ ...formData, photoUrl: \"\" });\n  };\n\n  const handleContactSelection = useCallback(async (selectedContacts: Contacts.Contact[]) => {\n    if (selectedContacts.length > 0) {\n      // 1. Close modal immediately to prevent stuck state\n      setShowContactPicker(false);\n\n      const contact = selectedContacts[0];\n      const contactName = contact.name || '';\n      let contactPhotoUrl = '';\n\n      // Process contact photo if available\n      if (contact.imageAvailable && contact.image) {\n        setImageProcessing(true);\n\n        try {\n          const normalizedUri = normalizeContactImageUri(contact.image.uri || '');\n          const imageId = friend?.id || `temp_${Date.now()}`;\n\n          if (normalizedUri) {\n            const imageResult = await processAndStoreImage({\n              uri: normalizedUri,\n              type: 'profilePicture',\n              imageId,\n            });\n\n            if (imageResult.success) {\n              contactPhotoUrl = imageResult.localUri;\n\n            }\n          }\n        } catch (error) {\n          console.error('[FriendForm] Error processing contact photo:', error);\n        } finally {\n          setImageProcessing(false);\n        }\n      }\n\n      setFormData(prev => ({\n        ...prev,\n        name: contactName,\n        photoUrl: contactPhotoUrl\n      }));\n      // setShowContactPicker(false); // Moved to top\n    }\n  }, [friend?.id]);\n\n  return (\n    <SafeAreaView style={[styles.safeArea, { backgroundColor: colors.background }]}>\n      <View style={[styles.header, { borderColor: colors.border }]}>\n        {fromOnboarding ? (\n          <TouchableOpacity onPress={onSkip} style={styles.backButton}>\n            <Text style={[styles.backButtonText, { color: colors['muted-foreground'] }]}>Skip</Text>\n          </TouchableOpacity>\n        ) : (\n          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>\n            <ArrowLeft size={20} color={colors['muted-foreground']} />\n            <Text style={[styles.backButtonText, { color: colors['muted-foreground'] }]}>Back</Text>\n          </TouchableOpacity>\n        )}\n        <Text style={[styles.headerTitle, { color: colors.foreground }]}>\n          {friend ? \"Edit Friend\" : \"Add Friend\"}\n        </Text>\n        <View style={{ width: 40 }} />\n      </View>\n\n      <ScrollView contentContainerStyle={styles.scrollViewContent}>\n        <View style={{ gap: 24 }}>\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Portrait</Text>\n            <View style={styles.imagePickerContainer}>\n              <TouchableOpacity onPress={pickImage} disabled={imageProcessing}>\n                <View style={[styles.avatarContainer, { backgroundColor: colors.muted, borderColor: colors.border }]}>\n                  {imageProcessing ? (\n                    <ActivityIndicator size=\"large\" color={colors.primary} />\n                  ) : formData.photoUrl && !imageError ? (\n                    <Image\n                      source={{ uri: normalizeContactImageUri(formData.photoUrl) }}\n                      style={styles.avatarImage}\n                      resizeMode=\"cover\"\n                      onError={() => setImageError(true)}\n                    />\n                  ) : (\n                    <Camera size={24} color={colors['muted-foreground']} />\n                  )}\n                </View>\n              </TouchableOpacity>\n              {formData.photoUrl && (\n                <TouchableOpacity onPress={removePhoto} style={styles.removeImageButton}>\n                  <X size={12} color=\"white\" />\n                </TouchableOpacity>\n              )}\n              <View style={{ flex: 1, gap: 8 }}>\n                <TouchableOpacity\n                  onPress={pickImage}\n                  disabled={imageProcessing}\n                  style={[styles.addPhotoButton, { borderColor: colors.border, opacity: imageProcessing ? 0.5 : 1 }]}\n                >\n                  <Text style={{ color: colors.foreground }}>\n                    {imageProcessing ? \"Processing...\" : formData.photoUrl ? \"Change Photo\" : \"Add Photo\"}\n                  </Text>\n                </TouchableOpacity>\n                <TouchableOpacity\n                  onPress={() => setShowContactPicker(true)}\n                  style={[styles.importContactsButton, { borderColor: colors.border, backgroundColor: colors.muted }]}\n                >\n                  <Users size={16} color={colors.foreground} />\n                  <Text style={{ color: colors.foreground, fontSize: 14 }}>Import from Contacts</Text>\n                </TouchableOpacity>\n              </View>\n            </View>\n          </View>\n\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Name</Text>\n            <TextInput\n              value={formData.name}\n              onChangeText={(name) => setFormData({ ...formData, name })}\n              style={[styles.input, { backgroundColor: colors.card, borderColor: colors.border, color: colors.foreground }]}\n              placeholder=\"Enter friend's name\"\n              placeholderTextColor={colors['muted-foreground']}\n            />\n          </View>\n\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Connection Tier</Text>\n            <View style={styles.tierSelectorContainer}>\n              {[\n                { id: \"inner\", label: \"Inner\" },\n                { id: \"close\", label: \"Close\" },\n                { id: \"community\", label: \"Community\" }\n              ].map((tier) => (\n                <TouchableOpacity\n                  key={tier.id}\n                  onPress={() => setFormData({ ...formData, tier: tier.id })}\n                  style={[\n                    styles.tierButton,\n                    { backgroundColor: colors.card, borderColor: colors.border },\n                    formData.tier === tier.id && [styles.tierButtonSelected, { borderColor: colors.primary, backgroundColor: colors.primary + '20' }]\n                  ]}\n                >\n                  <Text style={[\n                    styles.tierButtonText,\n                    { color: colors.foreground },\n                    formData.tier === tier.id && [styles.tierButtonTextSelected, { color: colors.primary }]\n                  ]}>{tier.label}</Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </View>\n\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Archetype</Text>\n            <Text style={[styles.helperText, { color: colors['muted-foreground'] }]}>\n              Tap to select • Long-press to learn more\n            </Text>\n            <View style={styles.archetypeGrid}>\n              {(['Emperor', 'Empress', 'HighPriestess', 'Fool', 'Sun', 'Hermit', 'Magician', 'Lovers'] as Archetype[]).map((archetype) => (\n                <View key={archetype} style={styles.archetypeCardWrapper}>\n                  <ArchetypeCard\n                    archetype={archetype}\n                    isSelected={formData.archetype === archetype}\n                    onSelect={(arch) => setFormData({ ...formData, archetype: arch })}\n                  />\n                </View>\n              ))}\n            </View>\n          </View>\n\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Relationship Type (Optional)</Text>\n            <View style={styles.relationshipTypeContainer}>\n              {[\n                { id: \"friend\", label: \"Friend\", icon: \"🤝\" },\n                { id: \"family\", label: \"Family\", icon: \"👨‍👩‍👧‍👦\" },\n                { id: \"partner\", label: \"Partner\", icon: \"❤️\" },\n                { id: \"colleague\", label: \"Colleague\", icon: \"💼\" },\n                { id: \"neighbor\", label: \"Neighbor\", icon: \"🏘️\" },\n                { id: \"mentor\", label: \"Mentor\", icon: \"🎓\" },\n                { id: \"creative\", label: \"Creative\", icon: \"🎨\" }\n              ].map((type) => (\n                <TouchableOpacity\n                  key={type.id}\n                  onPress={() => setFormData({ ...formData, relationshipType: type.id as RelationshipType })}\n                  style={[\n                    styles.relationshipTypeButton,\n                    { backgroundColor: colors.card, borderColor: colors.border },\n                    formData.relationshipType === type.id && [styles.relationshipTypeButtonSelected, { borderColor: colors.primary, backgroundColor: colors.primary + '20' }]\n                  ]}\n                >\n                  <Text style={[\n                    styles.relationshipTypeButtonText,\n                    { color: colors.foreground },\n                    formData.relationshipType === type.id && { color: colors.primary }\n                  ]}>{type.icon} {type.label}</Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </View>\n\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Birthday (Optional)</Text>\n            <MonthDayPicker\n              value={formData.birthday}\n              onChange={(birthday) => setFormData({ ...formData, birthday })}\n              label=\"Set birthday\"\n            />\n          </View>\n\n          {/* Only show anniversary field for partners */}\n          {formData.relationshipType === 'partner' && (\n            <View>\n              <Text style={[styles.label, { color: colors.foreground }]}>Anniversary (Optional)</Text>\n              <Text style={[styles.helperText, { color: colors['muted-foreground'] }]}>Romantic relationship anniversary</Text>\n              <MonthDayPicker\n                value={formData.anniversary}\n                onChange={(anniversary) => setFormData({ ...formData, anniversary })}\n                label=\"Set anniversary\"\n              />\n            </View>\n          )}\n\n          <View>\n            <Text style={[styles.label, { color: colors.foreground }]}>Notes (Optional)</Text>\n            <TextInput\n              value={formData.notes}\n              onChangeText={(notes) => setFormData({ ...formData, notes })}\n              style={[styles.input, { height: 96, paddingTop: 16, backgroundColor: colors.card, borderColor: colors.border, color: colors.foreground }]}\n              placeholder=\"Any special notes about this person...\"\n              placeholderTextColor={colors['muted-foreground']}\n              multiline\n            />\n          </View>\n\n          <TouchableOpacity\n            onPress={handleSave}\n            disabled={!formData.name.trim()}\n            style={[styles.saveButton, { backgroundColor: colors.primary }, !formData.name.trim() && { opacity: 0.5 }]}\n          >\n            <Text style={[styles.saveButtonText, { color: colors['primary-foreground'] }]}>\n              {friend ? \"Save Changes\" : \"Add Friend\"}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </ScrollView>\n\n      {/* Archetype Detail Modal */}\n      <ArchetypeDetailModal />\n\n      {/* Contact Picker Modal */}\n      <Modal\n        visible={showContactPicker}\n        animationType=\"slide\"\n        presentationStyle=\"pageSheet\"\n        onRequestClose={() => setShowContactPicker(false)}\n      >\n        <SafeAreaView style={{ flex: 1, backgroundColor: colors.background }}>\n          <View style={[styles.modalHeader, { borderBottomColor: colors.border }]}>\n            <Text style={[styles.modalTitle, { color: colors.foreground }]}>Import from Contacts</Text>\n            <TouchableOpacity onPress={() => setShowContactPicker(false)}>\n              <Text style={{ color: colors.primary, fontSize: 16, fontWeight: '600' }}>Done</Text>\n            </TouchableOpacity>\n          </View>\n          <ContactPickerGrid\n            maxSelection={1}\n            onSelectionChange={handleContactSelection}\n            title=\"Select a Contact\"\n            subtitle=\"Choose a friend to import their details.\"\n          />\n        </SafeAreaView>\n      </Modal>\n\n      {/* Capacity Warning Modal */}\n      <Modal\n        visible={showCapacityWarning}\n        animationType=\"fade\"\n        transparent={true}\n        onRequestClose={() => setShowCapacityWarning(false)}\n      >\n        <View style={styles.modalOverlay}>\n          <View style={[styles.capacityWarningContainer, { backgroundColor: colors.card, borderColor: colors.border }]}>\n            {/* Warning Icon */}\n            <View style={[styles.warningIconContainer, { backgroundColor: '#F59E0B20' }]}>\n              <AlertCircle size={32} color=\"#F59E0B\" />\n            </View>\n\n            {/* Title */}\n            <Text style={[styles.warningTitle, { color: colors.foreground }]}>\n              {getTierDisplayName(formData.tier)} is at Capacity\n            </Text>\n\n            {/* Description */}\n            <Text style={[styles.warningDescription, { color: colors['muted-foreground'] }]}>\n              Your {getTierDisplayName(formData.tier)} is designed for about {getTierCapacity(formData.tier)} {formData.tier === 'inner' ? 'closest' : formData.tier === 'close' ? 'important' : ''} relationships.\n              You currently have {tierCounts[formData.tier as 'inner' | 'close' | 'community']}/{getTierCapacity(formData.tier)}.\n            </Text>\n\n            <Text style={[styles.warningDescription, { color: colors['muted-foreground'] }]}>\n              {formData.tier === 'inner'\n                ? 'Adding more than 5 friends to your Inner Circle may make it harder to maintain these closest bonds. Consider if this friend might fit better in Close Friends, or if another friend should be moved.'\n                : formData.tier === 'close'\n                  ? 'Close Friends is for your most important ongoing relationships. Consider whether some existing friends might fit better in Community, or if this new friend should start there.'\n                  : 'Community is for meaningful acquaintances and broader connections. You can add more friends here, but remember that quality matters more than quantity.'}\n            </Text>\n\n            {/* Action Buttons */}\n            <View style={styles.warningButtonContainer}>\n              <TouchableOpacity\n                onPress={() => setShowCapacityWarning(false)}\n                style={[styles.warningButtonSecondary, { borderColor: colors.border, backgroundColor: colors.muted }]}\n              >\n                <Text style={[styles.warningButtonSecondaryText, { color: colors.foreground }]}>\n                  Let me reconsider\n                </Text>\n              </TouchableOpacity>\n\n              <TouchableOpacity\n                onPress={proceedWithSave}\n                style={[styles.warningButtonPrimary, { backgroundColor: colors.primary }]}\n              >\n                <Text style={[styles.warningButtonPrimaryText, { color: colors['primary-foreground'] }]}>\n                  Proceed anyway\n                </Text>\n              </TouchableOpacity>\n            </View>\n          </View>\n        </View>\n      </Modal>\n\n      {/* Tutorial Tooltip */}\n      {showTutorial && currentTutorialStep === 0 && (\n        <SimpleTutorialTooltip\n          visible={true}\n          title=\"Choose their circle\"\n          description=\"Inner circles are your closest bonds (up to 5). Close friends are important relationships (up to 15). Community holds enriching connections (up to 50).\"\n          onNext={handleTutorialNext}\n          onSkip={handleTutorialSkip}\n          currentStep={0}\n          totalSteps={2}\n        />\n      )}\n\n      {showTutorial && currentTutorialStep === 1 && (\n        <SimpleTutorialTooltip\n          visible={true}\n          title=\"Discover their archetype\"\n          description=\"Each friend has a unique way of connecting. Tap to choose, or press and hold any archetype to learn more about their patterns.\"\n          onNext={handleTutorialNext}\n          onSkip={handleTutorialSkip}\n          currentStep={1}\n          totalSteps={2}\n        />\n      )}\n    </SafeAreaView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  safeArea: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    padding: 20,\n    borderBottomWidth: 1,\n  },\n  backButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 8,\n  },\n  backButtonText: {},\n  headerTitle: {\n    fontSize: 20,\n    fontWeight: '600',\n    fontFamily: 'Lora_700Bold',\n  },\n  scrollViewContent: {\n    padding: 20,\n  },\n  label: {\n    fontSize: 16,\n    marginBottom: 12,\n    fontFamily: 'Lora_400Regular',\n  },\n  imagePickerContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 16,\n  },\n  avatarContainer: {\n    width: 80,\n    height: 80,\n    borderRadius: 40,\n    borderWidth: 2,\n    borderStyle: 'dashed',\n    alignItems: 'center',\n    justifyContent: 'center',\n    overflow: 'hidden',\n  },\n  avatarImage: {\n    width: '100%',\n    height: '100%',\n  },\n  removeImageButton: {\n    position: 'absolute',\n    top: -8,\n    left: 68, // Position at top-right corner of 80px avatar (80 - 12)\n    width: 24,\n    height: 24,\n    backgroundColor: '#ef4444',\n    borderRadius: 12,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  addPhotoButton: {\n    width: '100%',\n    height: 48,\n    borderRadius: 12,\n    borderWidth: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  input: {\n    borderWidth: 1,\n    borderRadius: 12,\n    height: 56,\n    fontSize: 18,\n    paddingHorizontal: 16,\n  },\n  tierSelectorContainer: {\n    flexDirection: 'row',\n    gap: 8,\n  },\n  tierButton: {\n    flex: 1,\n    padding: 16,\n    borderRadius: 12,\n    borderWidth: 1,\n    alignItems: 'center',\n  },\n  tierButtonSelected: {},\n  tierButtonText: {\n    fontWeight: '500',\n  },\n  tierButtonTextSelected: {},\n  archetypeGrid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: 12,\n    marginTop: 8,\n  },\n  archetypeCardWrapper: {\n    width: '48%',\n  },\n  helperText: {\n    fontSize: 13,\n    lineHeight: 18,\n    marginTop: 4,\n    marginBottom: 8,\n  },\n  relationshipTypeContainer: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: 10,\n    rowGap: 10,\n  },\n  relationshipTypeButton: {\n    paddingVertical: 12,\n    paddingHorizontal: 18,\n    borderRadius: 24,\n    borderWidth: 1.5,\n    minWidth: 100,\n    alignItems: 'center',\n  },\n  relationshipTypeButtonSelected: {},\n  relationshipTypeButtonText: {\n    fontSize: 14,\n    fontWeight: '600',\n    textAlign: 'center',\n  },\n  dateButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 12,\n    borderWidth: 1,\n    borderRadius: 12,\n    padding: 16,\n  },\n  dateButtonText: {\n    flex: 1,\n    fontSize: 16,\n  },\n  saveButton: {\n    width: '100%',\n    paddingVertical: 16,\n    borderRadius: 16,\n    alignItems: 'center',\n  },\n  saveButtonText: {\n    fontSize: 18,\n    fontWeight: '500',\n  },\n  importContactsButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: 8,\n    height: 40,\n    borderRadius: 12,\n    borderWidth: 1,\n  },\n  modalHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: 20,\n    paddingVertical: 16,\n    borderBottomWidth: 1,\n  },\n  modalTitle: {\n    fontSize: 18,\n    fontWeight: '600',\n    fontFamily: 'Lora_700Bold',\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 24,\n  },\n  capacityWarningContainer: {\n    width: '100%',\n    maxWidth: 400,\n    borderRadius: 20,\n    padding: 24,\n    borderWidth: 1,\n    gap: 16,\n  },\n  warningIconContainer: {\n    width: 64,\n    height: 64,\n    borderRadius: 32,\n    alignItems: 'center',\n    justifyContent: 'center',\n    alignSelf: 'center',\n  },\n  warningTitle: {\n    fontSize: 22,\n    fontWeight: '600',\n    fontFamily: 'Lora_700Bold',\n    textAlign: 'center',\n  },\n  warningDescription: {\n    fontSize: 15,\n    lineHeight: 22,\n    textAlign: 'center',\n  },\n  warningButtonContainer: {\n    flexDirection: 'row',\n    gap: 12,\n    marginTop: 8,\n  },\n  warningButtonSecondary: {\n    flex: 1,\n    paddingVertical: 14,\n    borderRadius: 12,\n    alignItems: 'center',\n    borderWidth: 1,\n  },\n  warningButtonSecondaryText: {\n    fontSize: 15,\n    fontWeight: '500',\n  },\n  warningButtonPrimary: {\n    flex: 1,\n    paddingVertical: 14,\n    borderRadius: 12,\n    alignItems: 'center',\n  },\n  warningButtonPrimaryText: {\n    fontSize: 15,\n    fontWeight: '600',\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/FriendListRow.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withSpring' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Friend' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setArchetypeModal' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":63,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pressScale' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":91,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pressOpacity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":92,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useMemo, useState } from 'react';\nimport { View, Text, Image, Pressable } from 'react-native';\nimport * as Haptics from 'expo-haptics';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSequence,\n  withTiming,\n  withSpring,\n  Easing,\n  interpolate,\n} from 'react-native-reanimated';\n\nimport { useUIStore } from '@/stores/uiStore';\nimport { type Archetype, type RelationshipType, type Friend } from '@/components/types';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { ArchetypeIcon } from '@/components/ArchetypeIcon';\nimport { archetypeData } from '@/shared/constants/constants';\nimport FriendModel from '@/db/models/Friend';\nimport { useCardGesture } from '@/context/CardGestureContext';\nimport { calculateCurrentScore } from '@/modules/intelligence';\nimport { generateIntelligentStatusLine } from '@/modules/intelligence';\nimport { normalizeContactImageUri } from '../utils/image.utils';\nimport { resolveImageUri } from '../services/image.service';\nimport { statusLineCache } from '@/modules/intelligence';\nimport { FriendDetailSheet } from './FriendDetailSheet';\nimport { HydratedFriend } from '@/types/hydrated';\n\nconst ATTENTION_THRESHOLD = 35;\nconst STABLE_THRESHOLD = 65;\n\n// Relationship type icon mapping\nconst RELATIONSHIP_ICONS: Record<RelationshipType, string> = {\n  friend: '🤝',\n  family: '👨‍👩‍👧‍👦',\n  partner: '❤️',\n  colleague: '💼',\n  neighbor: '🏘️',\n  mentor: '🎓',\n  creative: '🎨',\n};\n\ninterface FriendListRowProps {\n  friend: FriendModel;\n  animatedRef?: React.RefObject<Animated.View>;\n  variant?: 'default' | 'full';\n}\n\nimport withObservables from '@nozbe/with-observables';\n\nexport const FriendListRowContent = ({ friend, animatedRef, variant = 'default' }: FriendListRowProps) => {\n  if (!friend) return null;\n\n  const { id, name, archetype, isDormant = false, photoUrl, relationshipType } = friend;\n  const [statusLine, setStatusLine] = useState<{ text: string; icon?: string; variant?: 'default' | 'accent' | 'warning' | 'success' }>({\n    text: archetypeData[archetype as Archetype]?.essence || '',\n    variant: 'default'\n  });\n  const [imageError, setImageError] = useState(false);\n  const [showDetailSheet, setShowDetailSheet] = useState(false);\n  const { colors, isDarkMode } = useTheme();\n  const { setArchetypeModal, justNurturedFriendId, setJustNurturedFriendId } = useUIStore();\n  const { activeCardId, pendingCardId } = useCardGesture();\n\n  // Calculate current score with decay - memoized by ID to avoid recalculation\n  const weaveScore = useMemo(\n    () => calculateCurrentScore(friend),\n    [friend.id, friend.weaveScore, friend.lastUpdated]\n  );\n\n  // Determine gradient colors based on score\n  const gradientColors = useMemo(() => {\n    if (weaveScore > STABLE_THRESHOLD) {\n      return colors.living.healthy;\n    } else if (weaveScore > ATTENTION_THRESHOLD) {\n      return colors.living.stable;\n    } else {\n      return colors.living.attention;\n    }\n  }, [weaveScore, colors]);\n\n  // Determine gradient opacity based on score (attention gets more visible)\n  const gradientOpacity = useMemo(() => {\n    if (weaveScore > STABLE_THRESHOLD) return 0.22;\n    if (weaveScore > ATTENTION_THRESHOLD) return 0.25;\n    return 0.30; // Attention state more visible\n  }, [weaveScore]);\n\n  const glowProgress = useSharedValue(0);\n  const pressScale = useSharedValue(1);\n  const pressOpacity = useSharedValue(gradientOpacity);\n\n  // Reset image error state when photoUrl changes\n  useEffect(() => {\n    setImageError(false);\n  }, [photoUrl]);\n\n  // Resolve photo URL\n  const [resolvedPhotoUrl, setResolvedPhotoUrl] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (photoUrl) {\n      resolveImageUri(photoUrl).then(uri => {\n        if (uri) setResolvedPhotoUrl(uri);\n      });\n    } else {\n      setResolvedPhotoUrl(null);\n    }\n  }, [photoUrl]);\n\n  // Update intelligent status line with caching for performance\n  useEffect(() => {\n    // Special handling for Unknown archetype\n    if (archetype === 'Unknown') {\n      setStatusLine({ text: 'Tap to assign an archetype', icon: '✨', variant: 'accent' });\n      return;\n    }\n\n    // Try cache first\n    const cacheKey = {\n      friendId: friend.id,\n      lastUpdated: friend.lastUpdated.getTime(),\n      weaveScore: friend.weaveScore,\n      archetype: friend.archetype,\n    };\n\n    const cached = statusLineCache.get(cacheKey);\n    if (cached) {\n      setStatusLine(cached);\n      return;\n    }\n\n    // Generate and cache if not found\n    const timeoutId = setTimeout(() => {\n      generateIntelligentStatusLine(friend as unknown as HydratedFriend)\n        .then(status => {\n          statusLineCache.set(cacheKey, status);\n          setStatusLine(status);\n        })\n        .catch(error => {\n          console.error('Error generating status line:', error);\n          const fallback = { text: archetypeData[archetype as Archetype]?.essence || '', variant: 'default' as const };\n          setStatusLine(fallback);\n        });\n    }, 300);\n\n    return () => clearTimeout(timeoutId);\n  }, [friend.id, friend.lastUpdated.getTime(), friend.weaveScore, archetype]);\n\n  // \"Just Nurtured\" glow effect\n  useEffect(() => {\n    if (justNurturedFriendId === id) {\n      glowProgress.value = withSequence(\n        withTiming(1, { duration: 400, easing: Easing.out(Easing.quad) }),\n        withTiming(0, { duration: 1000, easing: Easing.in(Easing.quad) })\n      );\n      setJustNurturedFriendId(null);\n    }\n  }, [justNurturedFriendId, id]);\n\n  const handleCardLongPress = () => {\n    // Only allow long press on friend profile page (variant='full'), not on dashboard\n    if (variant !== 'full') return;\n\n    setShowDetailSheet(true);\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n  };\n\n  // Animated styles for gesture feedback\n  const rowStyle = useAnimatedStyle(() => {\n    const isGestureActive = activeCardId.value === id;\n    const isPending = pendingCardId.value === id;\n\n    // During pending: smooth continuous growth, during active: slightly larger\n    let targetScale = 1;\n    if (isGestureActive) {\n      targetScale = 1.03;\n    } else if (isPending) {\n      targetScale = 1.03; // Grows to same as active for seamless transition\n    }\n\n    // Use timing with easeOut for smooth continuous growth (no \"tick tick\")\n    return {\n      transform: [{\n        scale: withTiming(targetScale, {\n          duration: isPending ? 260 : 150, // Match long-press duration for pending, quick return otherwise\n          easing: Easing.out(Easing.quad)\n        })\n      }],\n      opacity: isDormant ? 0.6 : 1,\n    };\n  });\n\n  const gradientStyle = useAnimatedStyle(() => {\n    const isGestureActive = activeCardId.value === id;\n    const isPending = pendingCardId.value === id;\n\n    // Gradient grows smoothly more visible during pending/active states\n    let targetOpacity = gradientOpacity;\n    if (isGestureActive || isPending) {\n      targetOpacity = gradientOpacity + 0.12; // Same target for seamless transition\n    }\n\n    return {\n      opacity: withTiming(targetOpacity, {\n        duration: (isGestureActive || isPending) ? 260 : 150,\n        easing: Easing.out(Easing.quad)\n      }),\n    };\n  });\n\n  const glowStyle = useAnimatedStyle(() => {\n    const opacity = interpolate(glowProgress.value, [0, 0.5, 1], [0, 0.6, 0]);\n    const scaleVal = interpolate(glowProgress.value, [0, 1], [1, 1.5]);\n    return {\n      opacity,\n      transform: [{ scale: scaleVal }]\n    };\n  });\n\n  // Border color based on theme\n  const borderColor = isDarkMode ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.06)';\n\n  // Determine status text color based on variant\n  const getStatusColor = () => {\n    switch (statusLine.variant) {\n      case 'accent':\n        return isDarkMode ? '#A78BFA' : '#7C3AED'; // Violet/Purple\n      case 'warning':\n        return isDarkMode ? '#F87171' : '#DC2626'; // Red\n      case 'success':\n        return isDarkMode ? '#34D399' : '#059669'; // Emerald/Green\n      default:\n        return colors.foreground;\n    }\n  };\n\n  const statusColor = getStatusColor();\n\n  return (\n    <Animated.View ref={animatedRef} style={rowStyle}>\n      <View\n        className={`mb-3 rounded-2xl overflow-hidden ${variant === 'full' ? '' : 'mx-4'}`}\n        style={{\n          borderWidth: 0.5,\n          borderColor,\n          backgroundColor: colors.background,\n          shadowColor: '#000',\n          shadowOffset: { width: 0, height: 2 },\n          shadowOpacity: isDarkMode ? 0.15 : 0.08,\n          shadowRadius: 6,\n          elevation: 2,\n        }}\n      >\n        {/* Single gradient background - health indicator */}\n        <Animated.View style={[{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }, gradientStyle]}>\n          <LinearGradient\n            colors={[`${gradientColors[0]}`, `${gradientColors[1]}`]}\n            start={{ x: 0, y: 0 }}\n            end={{ x: 1, y: 1 }}\n            style={{ flex: 1 }}\n          />\n        </Animated.View>\n\n        {/* \"Just Nurtured\" glow overlay */}\n        <Animated.View\n          style={[\n            { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'white', zIndex: 10 },\n            glowStyle\n          ]}\n          pointerEvents=\"none\"\n        />\n\n        {/* Subtle top highlight for depth */}\n        <View\n          className=\"absolute top-0 left-0 right-0 h-[1px]\"\n          style={{ backgroundColor: 'rgba(255, 255, 255, 0.3)' }}\n        />\n\n        {/* Content */}\n        <Pressable\n          onLongPress={handleCardLongPress}\n          delayLongPress={500}\n          className=\"flex-row items-center p-3 gap-3\"\n        >\n          {/* Avatar */}\n          <View\n            className=\"w-12 h-12 rounded-full overflow-hidden items-center justify-center\"\n            style={{\n              backgroundColor: isDarkMode ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.08)',\n              borderWidth: 0.5,\n              borderColor: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)',\n            }}\n          >\n            {resolvedPhotoUrl && !imageError ? (\n              <Image\n                source={{ uri: normalizeContactImageUri(resolvedPhotoUrl) }}\n                className=\"w-full h-full\"\n                resizeMode=\"cover\"\n                onError={() => setImageError(true)}\n                fadeDuration={0}\n              />\n            ) : (\n              <Text\n                className=\"text-lg font-semibold\"\n                style={{ color: colors.foreground }}\n              >\n                {name.charAt(0).toUpperCase()}\n              </Text>\n            )}\n          </View>\n\n          {/* Text Content */}\n          <View className=\"flex-1\">\n            <View className=\"flex-row items-center gap-1.5\">\n              <Text\n                className=\"font-semibold\"\n                style={{\n                  fontSize: 17,\n                  lineHeight: 20,\n                  color: colors.foreground,\n                  fontFamily: 'Lora_700Bold',\n                }}\n                numberOfLines={1}\n              >\n                {name}\n              </Text>\n              {variant === 'full' && relationshipType && (\n                <Text style={{ fontSize: 14 }}>\n                  {RELATIONSHIP_ICONS[relationshipType as RelationshipType]}\n                </Text>\n              )}\n            </View>\n\n            <View className=\"flex-row items-center gap-1.5 mt-0.5\">\n              {statusLine.icon && (\n                <Text style={{ fontSize: 12 }}>{statusLine.icon}</Text>\n              )}\n              <Text\n                className=\"text-status\"\n                style={{\n                  color: statusColor,\n                  opacity: statusLine.variant === 'default' ? 0.7 : 0.9,\n                  fontWeight: statusLine.variant !== 'default' ? '500' : '400'\n                }}\n                numberOfLines={1}\n                ellipsizeMode=\"tail\"\n              >\n                {statusLine.text}\n              </Text>\n            </View>\n          </View>\n\n          {/* Archetype Icon */}\n          <View className=\"relative\">\n            <View\n              className=\"w-10 h-10 rounded-[10px] items-center justify-center\"\n              style={{\n                backgroundColor: isDarkMode ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.04)',\n                borderWidth: 0.5,\n                borderColor: isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)',\n              }}\n            >\n              <ArchetypeIcon\n                archetype={archetype as Archetype}\n                size={18}\n                color={isDarkMode ? '#FFFFFF' : colors['muted-foreground']}\n              />\n            </View>\n            {/* Unknown Archetype Indicator */}\n            {archetype === 'Unknown' && (\n              <View\n                className=\"absolute -top-1 -right-1 w-4 h-4 rounded-full items-center justify-center\"\n                style={{\n                  backgroundColor: '#f59e0b',\n                  borderWidth: 1.5,\n                  borderColor: colors.card,\n                }}\n              >\n                <Text style={{ fontSize: 8, color: 'white', fontWeight: 'bold' }}>!</Text>\n              </View>\n            )}\n          </View>\n        </Pressable>\n      </View>\n\n      {/* Friend Detail Sheet */}\n      <FriendDetailSheet\n        isVisible={showDetailSheet}\n        onClose={() => setShowDetailSheet(false)}\n        friendId={friend.id}\n      />\n    </Animated.View>\n  );\n};\n\nexport const FriendListRow = withObservables(['friend'], ({ friend }: { friend: FriendModel }) => ({\n  friend: friend.observe(),\n}))(FriendListRowContent);\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/FriendSearchBar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isActive' is defined but never used. Allowed unused args must match /^_/u.","line":74,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useEffect } from 'react';\nimport { View, TextInput, TouchableOpacity, ScrollView, Text } from 'react-native';\nimport Animated, { FadeIn, FadeOut } from 'react-native-reanimated';\nimport { Search, X, ChevronDown, ChevronUp, ArrowUpDown } from 'lucide-react-native';\nimport * as Haptics from 'expo-haptics';\n\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { ArchetypeIcon } from '@/components/ArchetypeIcon';\nimport { Archetype } from '../types';\n\n// Health status based on weave score thresholds\nexport type HealthStatus = 'thriving' | 'stable' | 'attention' | 'drifting';\n\n// Sort options for friend list\nexport type SortOption =\n  | 'default'           // Tier view (no sorting applied)\n  | 'needs-attention'   // Weave score ascending (lowest first)\n  | 'thriving-first'    // Weave score descending (highest first)\n  | 'recently-connected' // Last updated descending (most recent first)\n  | 'longest-since'     // Last updated ascending (oldest first)\n  | 'alphabetical';     // A-Z by name\n\nexport interface SearchFilters {\n  healthStatus: HealthStatus[];\n  archetypes: Archetype[];\n}\n\ninterface FriendSearchBarProps {\n  searchQuery: string;\n  onSearchChange: (query: string) => void;\n  filters: SearchFilters;\n  onFiltersChange: (filters: SearchFilters) => void;\n  sortOption: SortOption;\n  onSortChange: (sort: SortOption) => void;\n  isActive: boolean;\n  onFocus?: () => void;\n  onClear?: () => void;\n}\n\nconst HEALTH_STATUSES: { key: HealthStatus; label: string; color: string }[] = [\n  { key: 'thriving', label: 'Thriving', color: '#10B981' },\n  { key: 'stable', label: 'Stable', color: '#F59E0B' },\n  { key: 'attention', label: 'Needs Care', color: '#F97316' },\n  { key: 'drifting', label: 'Drifting', color: '#EF4444' },\n];\n\nconst ARCHETYPES: { key: Archetype; label: string }[] = [\n  { key: 'Emperor', label: 'Emperor' },\n  { key: 'Empress', label: 'Empress' },\n  { key: 'HighPriestess', label: 'High Priestess' },\n  { key: 'Fool', label: 'Fool' },\n  { key: 'Sun', label: 'Sun' },\n  { key: 'Hermit', label: 'Hermit' },\n  { key: 'Magician', label: 'Magician' },\n  { key: 'Lovers', label: 'Lovers' },\n];\n\nconst SORT_OPTIONS: { key: SortOption; label: string; shortLabel: string }[] = [\n  { key: 'default', label: 'Default (Tier View)', shortLabel: 'Default' },\n  { key: 'needs-attention', label: 'Needs Attention First', shortLabel: 'Needs Attention' },\n  { key: 'thriving-first', label: 'Thriving First', shortLabel: 'Thriving' },\n  { key: 'recently-connected', label: 'Recently Connected', shortLabel: 'Recent' },\n  { key: 'longest-since', label: 'Longest Since Contact', shortLabel: 'Longest Since' },\n  { key: 'alphabetical', label: 'Alphabetical (A-Z)', shortLabel: 'A-Z' },\n];\n\nexport function FriendSearchBar({\n  searchQuery,\n  onSearchChange,\n  filters,\n  onFiltersChange,\n  sortOption,\n  onSortChange,\n  isActive,\n  onFocus,\n  onClear,\n}: FriendSearchBarProps) {\n  const { colors, isDarkMode } = useTheme();\n  const [showFilters, setShowFilters] = useState(false);\n  const [showSortOptions, setShowSortOptions] = useState(false);\n  const [localQuery, setLocalQuery] = useState(searchQuery);\n\n  // Debounce search query\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      onSearchChange(localQuery);\n    }, 300);\n    return () => clearTimeout(timer);\n  }, [localQuery, onSearchChange]);\n\n  // Sync external changes\n  useEffect(() => {\n    setLocalQuery(searchQuery);\n  }, [searchQuery]);\n\n  const hasActiveFilters = filters.healthStatus.length > 0 || filters.archetypes.length > 0;\n  const activeFilterCount = filters.healthStatus.length + filters.archetypes.length;\n  const hasNonDefaultSort = sortOption !== 'default';\n\n  const toggleHealthStatus = useCallback((status: HealthStatus) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    const newStatuses = filters.healthStatus.includes(status)\n      ? filters.healthStatus.filter(s => s !== status)\n      : [...filters.healthStatus, status];\n    onFiltersChange({ ...filters, healthStatus: newStatuses });\n  }, [filters, onFiltersChange]);\n\n  const toggleArchetype = useCallback((archetype: Archetype) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    const newArchetypes = filters.archetypes.includes(archetype)\n      ? filters.archetypes.filter(a => a !== archetype)\n      : [...filters.archetypes, archetype];\n    onFiltersChange({ ...filters, archetypes: newArchetypes });\n  }, [filters, onFiltersChange]);\n\n  const handleSortChange = useCallback((sort: SortOption) => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    onSortChange(sort);\n    setShowSortOptions(false);\n  }, [onSortChange]);\n\n  const clearAll = useCallback(() => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    setLocalQuery('');\n    onSearchChange('');\n    onFiltersChange({ healthStatus: [], archetypes: [] });\n    onSortChange('default');\n    setShowFilters(false);\n    setShowSortOptions(false);\n    onClear?.();\n  }, [onSearchChange, onFiltersChange, onSortChange, onClear]);\n\n  const toggleFilters = useCallback(() => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setShowFilters(!showFilters);\n    if (!showFilters) setShowSortOptions(false);\n  }, [showFilters]);\n\n  const toggleSortOptions = useCallback(() => {\n    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    setShowSortOptions(!showSortOptions);\n    if (!showSortOptions) setShowFilters(false);\n  }, [showSortOptions]);\n\n  const currentSortLabel = SORT_OPTIONS.find(s => s.key === sortOption)?.shortLabel || 'Default';\n\n  const hasAnyActive = localQuery.length > 0 || hasActiveFilters || hasNonDefaultSort;\n\n  return (\n    <View className=\"px-5 pt-3 pb-2\">\n      {/* Search Input Row */}\n      <View\n        className=\"flex-row items-center px-4 py-3 rounded-xl\"\n        style={{ backgroundColor: colors.muted }}\n      >\n        <Search size={18} color={colors['muted-foreground']} />\n        <TextInput\n          className=\"flex-1 ml-3 font-inter-regular text-base\"\n          style={{ color: colors.foreground }}\n          placeholder=\"Search friends...\"\n          placeholderTextColor={colors['muted-foreground']}\n          value={localQuery}\n          onChangeText={setLocalQuery}\n          onFocus={onFocus}\n          returnKeyType=\"search\"\n          autoCorrect={false}\n          autoCapitalize=\"none\"\n        />\n\n        {/* Sort Toggle Button */}\n        <TouchableOpacity\n          onPress={toggleSortOptions}\n          className=\"flex-row items-center ml-2 px-2 py-1 rounded-lg\"\n          style={{\n            backgroundColor: hasNonDefaultSort ? colors.primary + '20' : 'transparent',\n          }}\n        >\n          <ArrowUpDown size={14} color={hasNonDefaultSort ? colors.primary : colors['muted-foreground']} />\n          {hasNonDefaultSort && (\n            <Text\n              className=\"font-inter-medium text-xs ml-1\"\n              style={{ color: colors.primary }}\n              numberOfLines={1}\n            >\n              {currentSortLabel}\n            </Text>\n          )}\n        </TouchableOpacity>\n\n        {/* Filter Toggle Button */}\n        <TouchableOpacity\n          onPress={toggleFilters}\n          className=\"flex-row items-center ml-2 px-2 py-1 rounded-lg\"\n          style={{\n            backgroundColor: hasActiveFilters ? colors.primary + '20' : 'transparent',\n          }}\n        >\n          <Text\n            className=\"font-inter-medium text-sm mr-1\"\n            style={{\n              color: hasActiveFilters ? colors.primary : colors['muted-foreground']\n            }}\n          >\n            Filters{activeFilterCount > 0 ? ` (${activeFilterCount})` : ''}\n          </Text>\n          {showFilters ? (\n            <ChevronUp size={14} color={hasActiveFilters ? colors.primary : colors['muted-foreground']} />\n          ) : (\n            <ChevronDown size={14} color={hasActiveFilters ? colors.primary : colors['muted-foreground']} />\n          )}\n        </TouchableOpacity>\n\n        {/* Clear Button */}\n        {hasAnyActive && (\n          <TouchableOpacity onPress={clearAll} className=\"ml-2 p-1\">\n            <X size={18} color={colors['muted-foreground']} />\n          </TouchableOpacity>\n        )}\n      </View>\n\n      {/* Sort Options Panel */}\n      {showSortOptions && (\n        <Animated.View\n          entering={FadeIn.duration(200)}\n          exiting={FadeOut.duration(150)}\n          className=\"mt-3\"\n        >\n          <Text\n            className=\"font-inter-medium text-xs mb-2 ml-1\"\n            style={{ color: colors['muted-foreground'] }}\n          >\n            Sort By\n          </Text>\n          <ScrollView\n            horizontal\n            showsHorizontalScrollIndicator={false}\n          >\n            <View className=\"flex-row gap-2\">\n              {SORT_OPTIONS.map((option) => {\n                const isSelected = sortOption === option.key;\n                return (\n                  <TouchableOpacity\n                    key={option.key}\n                    onPress={() => handleSortChange(option.key)}\n                    className=\"px-3 py-2 rounded-full\"\n                    style={{\n                      backgroundColor: isSelected\n                        ? colors.primary + '20'\n                        : isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)',\n                      borderWidth: isSelected ? 1 : 0,\n                      borderColor: colors.primary,\n                    }}\n                  >\n                    <Text\n                      className=\"font-inter-medium text-sm\"\n                      style={{\n                        color: isSelected ? colors.primary : colors.foreground\n                      }}\n                    >\n                      {option.label}\n                    </Text>\n                  </TouchableOpacity>\n                );\n              })}\n            </View>\n          </ScrollView>\n        </Animated.View>\n      )}\n\n      {/* Filter Panels */}\n      {showFilters && (\n        <Animated.View\n          entering={FadeIn.duration(200)}\n          exiting={FadeOut.duration(150)}\n          className=\"mt-3\"\n        >\n          {/* Health Status Filters */}\n          <Text\n            className=\"font-inter-medium text-xs mb-2 ml-1\"\n            style={{ color: colors['muted-foreground'] }}\n          >\n            Connection Health\n          </Text>\n          <ScrollView\n            horizontal\n            showsHorizontalScrollIndicator={false}\n            className=\"mb-3\"\n          >\n            <View className=\"flex-row gap-2\">\n              {HEALTH_STATUSES.map((status) => {\n                const isSelected = filters.healthStatus.includes(status.key);\n                return (\n                  <TouchableOpacity\n                    key={status.key}\n                    onPress={() => toggleHealthStatus(status.key)}\n                    className=\"px-3 py-2 rounded-full flex-row items-center\"\n                    style={{\n                      backgroundColor: isSelected\n                        ? status.color + '20'\n                        : isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)',\n                      borderWidth: isSelected ? 1 : 0,\n                      borderColor: status.color,\n                    }}\n                  >\n                    <View\n                      className=\"w-2 h-2 rounded-full mr-2\"\n                      style={{ backgroundColor: status.color }}\n                    />\n                    <Text\n                      className=\"font-inter-medium text-sm\"\n                      style={{\n                        color: isSelected ? status.color : colors.foreground\n                      }}\n                    >\n                      {status.label}\n                    </Text>\n                  </TouchableOpacity>\n                );\n              })}\n            </View>\n          </ScrollView>\n\n          {/* Archetype Filters */}\n          <Text\n            className=\"font-inter-medium text-xs mb-2 ml-1\"\n            style={{ color: colors['muted-foreground'] }}\n          >\n            Archetype\n          </Text>\n          <ScrollView\n            horizontal\n            showsHorizontalScrollIndicator={false}\n          >\n            <View className=\"flex-row gap-2\">\n              {ARCHETYPES.map((arch) => {\n                const isSelected = filters.archetypes.includes(arch.key);\n                return (\n                  <TouchableOpacity\n                    key={arch.key}\n                    onPress={() => toggleArchetype(arch.key)}\n                    className=\"px-3 py-2 rounded-full flex-row items-center\"\n                    style={{\n                      backgroundColor: isSelected\n                        ? colors.primary + '20'\n                        : isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)',\n                      borderWidth: isSelected ? 1 : 0,\n                      borderColor: colors.primary,\n                    }}\n                  >\n                    <ArchetypeIcon\n                      archetype={arch.key}\n                      size={14}\n                      color={isSelected ? colors.primary : colors['muted-foreground']}\n                    />\n                    <Text\n                      className=\"font-inter-medium text-sm ml-1.5\"\n                      style={{\n                        color: isSelected ? colors.primary : colors.foreground\n                      }}\n                    >\n                      {arch.label}\n                    </Text>\n                  </TouchableOpacity>\n                );\n              })}\n            </View>\n          </ScrollView>\n        </Animated.View>\n      )}\n    </View>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/FriendSearchResults.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":47,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useEffect } from 'react';\nimport { View, Text, Dimensions, StyleSheet } from 'react-native';\nimport Animated, { useAnimatedRef, runOnUI } from 'react-native-reanimated';\nimport { FlashList } from '@shopify/flash-list';\nimport withObservables from '@nozbe/with-observables';\nimport { Q } from '@nozbe/watermelondb';\n\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport { FriendListRow } from '@/modules/relationships';\nimport { useCardGesture } from '@/context/CardGestureContext';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { WeaveIcon } from '@/components/WeaveIcon';\nimport { calculateCurrentScore } from '@/modules/intelligence';\nimport { SearchFilters, HealthStatus, SortOption } from './FriendSearchBar';\nimport { Archetype } from '../types';\n\nconst { width: screenWidth } = Dimensions.get('window');\nconst AnimatedFlashList = Animated.createAnimatedComponent(FlashList);\n\n// Health thresholds for search filters\nconst THRIVING_THRESHOLD = 70;\nconst ATTENTION_THRESHOLD = 35;\nconst DRIFTING_THRESHOLD = 20;\n\n// Helper to determine health status from score\nconst getHealthStatus = (score: number): HealthStatus => {\n  if (score >= THRIVING_THRESHOLD) return 'thriving';\n  if (score >= ATTENTION_THRESHOLD) return 'stable';\n  if (score >= DRIFTING_THRESHOLD) return 'attention';\n  return 'drifting';\n};\n\n// Sort label mapping for display\nconst SORT_LABELS: Record<SortOption, string> = {\n  'default': 'Default',\n  'needs-attention': 'Needs attention first',\n  'thriving-first': 'Thriving first',\n  'recently-connected': 'Recently connected',\n  'longest-since': 'Longest since contact',\n  'alphabetical': 'A-Z',\n};\n\n// Animated item wrapper with gesture registration\nconst AnimatedSearchResultItem = React.memo(({\n  item,\n  index,\n}: {\n  item: FriendModel;\n  index: number;\n}) => {\n  const { registerRef, unregisterRef } = useCardGesture();\n  const animatedRef = useAnimatedRef<Animated.View>();\n\n  useEffect(() => {\n    runOnUI(registerRef)(item.id, animatedRef);\n    return () => {\n      runOnUI(unregisterRef)(item.id);\n    };\n  }, [item.id, animatedRef, registerRef, unregisterRef]);\n\n  return (\n    <Animated.View style={{ marginBottom: 12 }}>\n      <FriendListRow friend={item} animatedRef={animatedRef} />\n    </Animated.View>\n  );\n}, (prevProps, nextProps) => {\n  return prevProps.item.id === nextProps.item.id;\n});\n\ninterface FriendSearchResultsProps {\n  friends: FriendModel[];\n  searchQuery: string;\n  filters: SearchFilters;\n  sortOption: SortOption;\n  scrollHandler?: any;\n  isQuickWeaveOpen?: boolean;\n}\n\nconst FriendSearchResultsContent = ({\n  friends,\n  searchQuery,\n  filters,\n  sortOption,\n  scrollHandler,\n  isQuickWeaveOpen,\n}: FriendSearchResultsProps) => {\n  const { colors } = useTheme();\n\n  // Filter and sort friends based on search query, filters, and sort option\n  const filteredFriends = useMemo(() => {\n    let results = [...friends];\n\n    // Text search filter\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase().trim();\n      results = results.filter(friend =>\n        friend.name.toLowerCase().includes(query)\n      );\n    }\n\n    // Health status filter\n    if (filters.healthStatus.length > 0) {\n      results = results.filter(friend => {\n        const currentScore = calculateCurrentScore(friend);\n        const status = getHealthStatus(currentScore);\n        return filters.healthStatus.includes(status);\n      });\n    }\n\n    // Archetype filter\n    if (filters.archetypes.length > 0) {\n      results = results.filter(friend =>\n        filters.archetypes.includes(friend.archetype as Archetype)\n      );\n    }\n\n    // Apply sorting\n    switch (sortOption) {\n      case 'needs-attention':\n        // Weave score ascending (lowest/needs attention first)\n        return results.sort((a, b) => {\n          const scoreA = calculateCurrentScore(a);\n          const scoreB = calculateCurrentScore(b);\n          return scoreA - scoreB;\n        });\n\n      case 'thriving-first':\n        // Weave score descending (highest/thriving first)\n        return results.sort((a, b) => {\n          const scoreA = calculateCurrentScore(a);\n          const scoreB = calculateCurrentScore(b);\n          return scoreB - scoreA;\n        });\n\n      case 'recently-connected':\n        // Last updated descending (most recent first)\n        return results.sort((a, b) => {\n          const dateA = a.lastUpdated?.getTime() || 0;\n          const dateB = b.lastUpdated?.getTime() || 0;\n          return dateB - dateA;\n        });\n\n      case 'longest-since':\n        // Last updated ascending (oldest first)\n        return results.sort((a, b) => {\n          const dateA = a.lastUpdated?.getTime() || 0;\n          const dateB = b.lastUpdated?.getTime() || 0;\n          return dateA - dateB;\n        });\n\n      case 'alphabetical':\n        // Alphabetical A-Z\n        return results.sort((a, b) =>\n          a.name.localeCompare(b.name)\n        );\n\n      case 'default':\n      default:\n        // Default: needs attention first (same as needs-attention)\n        return results.sort((a, b) => {\n          const scoreA = calculateCurrentScore(a);\n          const scoreB = calculateCurrentScore(b);\n          return scoreA - scoreB;\n        });\n    }\n  }, [friends, searchQuery, filters, sortOption]);\n\n  const hasActiveSearch = searchQuery.trim().length > 0 ||\n    filters.healthStatus.length > 0 ||\n    filters.archetypes.length > 0;\n\n  // Empty state\n  if (filteredFriends.length === 0) {\n    return (\n      <View style={[styles.emptyContainer, { width: screenWidth }]}>\n        <WeaveIcon size={80} color={colors['muted-foreground']} />\n        <Text style={[styles.emptyTitle, { color: colors.foreground }]}>\n          {hasActiveSearch ? 'No friends match this search' : 'No friends yet'}\n        </Text>\n        {hasActiveSearch && (\n          <Text style={[styles.emptySubtitle, { color: colors['muted-foreground'] }]}>\n            Try adjusting your search or filters\n          </Text>\n        )}\n      </View>\n    );\n  }\n\n  const renderSearchResultItem = ({ item, index }: { item: FriendModel; index: number }) => (\n    <AnimatedSearchResultItem item={item} index={index} />\n  );\n\n  // Build results header text\n  const sortLabel = SORT_LABELS[sortOption] || '';\n  const countText = `${filteredFriends.length} friend${filteredFriends.length !== 1 ? 's' : ''}`;\n  const headerText = sortOption !== 'default' && !hasActiveSearch\n    ? `${countText} · ${sortLabel}`\n    : countText;\n\n  return (\n    <View style={{ flex: 1, width: screenWidth }}>\n      {/* Results count header */}\n      <View className=\"px-5 py-2\">\n        <Text\n          className=\"font-inter-medium text-sm\"\n          style={{ color: colors['muted-foreground'] }}\n        >\n          {headerText}\n        </Text>\n      </View>\n\n      <AnimatedFlashList\n        contentContainerStyle={styles.listContent}\n        data={filteredFriends}\n        estimatedItemSize={72}\n        keyExtractor={(item: any) => item.id}\n        scrollEnabled={!isQuickWeaveOpen}\n        onScroll={scrollHandler}\n        scrollEventThrottle={8}\n        renderItem={renderSearchResultItem as any}\n        disableIntervalMomentum={true}\n      />\n    </View>\n  );\n};\n\n// Observable wrapper to fetch all friends\nconst enhance = withObservables([], () => ({\n  friends: database.get<FriendModel>('friends').query(\n    Q.sortBy('weave_score', Q.asc)\n  ).observe(),\n}));\n\nexport const FriendSearchResults = enhance(FriendSearchResultsContent);\n\nconst styles = StyleSheet.create({\n  emptyContainer: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingHorizontal: 32,\n    paddingTop: 60,\n  },\n  emptyTitle: {\n    fontSize: 18,\n    fontWeight: '600',\n    marginTop: 20,\n    marginBottom: 8,\n    textAlign: 'center',\n  },\n  emptySubtitle: {\n    fontSize: 14,\n    textAlign: 'center',\n  },\n  listContent: {\n    paddingHorizontal: 20,\n    paddingVertical: 8,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/FriendTierList.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef } from 'react';\nimport { View, Text, Dimensions, StyleSheet } from 'react-native';\nimport Animated, { useSharedValue, useAnimatedStyle, withDelay, withTiming, useAnimatedRef, runOnUI } from 'react-native-reanimated';\nimport { FlashList } from '@shopify/flash-list';\nimport withObservables from '@nozbe/with-observables';\nimport { Q } from '@nozbe/watermelondb';\n\n// import { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\nimport { friendRepository } from '../repositories/friend.repository';\nimport { FriendListRow } from '@/modules/relationships';\nimport { useCardGesture } from '@/context/CardGestureContext';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport { WeaveIcon } from '@/components/WeaveIcon';\nimport { tierColors } from '@/shared/constants/constants';\nimport { type Tier } from '../types';\n\nconst { width: screenWidth } = Dimensions.get('window');\nconst AnimatedFlashList = Animated.createAnimatedComponent(FlashList);\n\n// Keep this consistent with _friends.tsx for now\nconst getTierBackground = (tier: Tier, isDarkMode: boolean) => {\n    const tierColorMap: Record<string, string> = {\n        InnerCircle: tierColors.InnerCircle,\n        CloseFriends: tierColors.CloseFriends,\n        Community: tierColors.Community,\n    };\n    const color = tierColorMap[tier] || tierColors.Community;\n    // Very subtle tinting - 3% opacity for light mode, 5% for dark mode\n    const opacity = isDarkMode ? '0D' : '08'; // Hex opacity values\n    return `${color}${opacity}`;\n};\n\nconst AnimatedFriendCardItem = React.memo(({\n    item,\n    index,\n}: {\n    item: FriendModel;\n    index: number;\n}) => {\n    const { registerRef, unregisterRef } = useCardGesture();\n    const animatedRef = useAnimatedRef<Animated.View>();\n    const hasAnimated = useRef(false);\n\n    const opacity = useSharedValue(hasAnimated.current ? 1 : 0);\n    const translateY = useSharedValue(hasAnimated.current ? 0 : 25);\n\n    useEffect(() => {\n        runOnUI(registerRef)(item.id, animatedRef);\n        return () => {\n            runOnUI(unregisterRef)(item.id);\n        };\n    }, [item.id, animatedRef, registerRef, unregisterRef]);\n\n    // Only animate on initial mount\n    useEffect(() => {\n        if (!hasAnimated.current) {\n            opacity.value = withDelay(index * 35, withTiming(1, { duration: 250 }));\n            translateY.value = withDelay(index * 35, withTiming(0, { duration: 250 }));\n            hasAnimated.current = true;\n        }\n    }, [index]);\n\n    const animatedStyle = useAnimatedStyle(() => ({\n        opacity: opacity.value,\n        transform: [{ translateY: translateY.value }],\n    }));\n\n    return (\n        <Animated.View\n            style={[animatedStyle, { marginBottom: 12 }]}>\n            <FriendListRow friend={item} animatedRef={animatedRef} />\n        </Animated.View>\n    );\n}, (prevProps, nextProps) => {\n    return prevProps.item.id === nextProps.item.id;\n});\n\ninterface FriendTierListProps {\n    tier: Tier;\n    friends: FriendModel[];\n    scrollHandler?: any;\n    isQuickWeaveOpen?: boolean;\n}\n\nconst FriendTierListContent = ({ tier, friends, scrollHandler, isQuickWeaveOpen }: FriendTierListProps) => {\n    const { colors, isDarkMode } = useTheme();\n    const tierBgColor = getTierBackground(tier, isDarkMode);\n\n    if (friends.length === 0) {\n        return (\n            <View style={[styles.emptyTierContainer, { width: screenWidth, backgroundColor: tierBgColor }]}>\n                <View style={styles.emptyTierEmoji}>\n                    <WeaveIcon size={120} color={colors['muted-foreground']} />\n                </View>\n                <Text style={[styles.emptyTierTitle, { color: colors.foreground }]}>Your weave is empty</Text>\n            </View>\n        );\n    }\n\n    const renderFriendItem = ({ item, index }: { item: FriendModel; index: number }) => (\n        <AnimatedFriendCardItem\n            item={item}\n            index={index}\n        />\n    );\n\n    return (\n        <View style={{ width: screenWidth, height: '100%', backgroundColor: tierBgColor }}>\n            <AnimatedFlashList\n                contentContainerStyle={styles.tierScrollView}\n                data={friends}\n                estimatedItemSize={72}\n                keyExtractor={(item: any) => item.id}\n                scrollEnabled={!isQuickWeaveOpen}\n                onScroll={scrollHandler}\n                scrollEventThrottle={8}\n                renderItem={renderFriendItem as any}\n                disableIntervalMomentum={true}\n            />\n        </View>\n    );\n};\n\nconst enhance = withObservables(['tier'], ({ tier }: { tier: Tier }) => ({\n    friends: friendRepository.getFriendsByTierQuery(tier),\n}));\n\nexport const FriendTierList = enhance(FriendTierListContent);\n\nconst styles = StyleSheet.create({\n    emptyTierContainer: { flex: 1, alignItems: 'center', justifyContent: 'center', paddingHorizontal: 16 },\n    emptyTierEmoji: { fontSize: 50, marginBottom: 24, opacity: 0.6 },\n    emptyTierTitle: { fontSize: 18, marginBottom: 12 },\n    tierScrollView: { paddingHorizontal: 20, paddingVertical: 16 },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/components/ReactiveFriendProfile.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityIndicator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { ReactNode } from 'react';\nimport { View, Text, ActivityIndicator, StyleSheet } from 'react-native';\nimport withObservables from '@nozbe/with-observables';\nimport { database } from '@/db';\nimport FriendModel from '@/db/models/Friend';\n\ninterface ReactiveFriendProfileProps {\n    friend: FriendModel;\n    children: (friend: FriendModel) => ReactNode;\n}\n\nconst ReactiveFriendProfileContent = ({ friend, children }: ReactiveFriendProfileProps) => {\n    if (!friend) {\n        return (\n            <View style={styles.center}>\n                <Text style={styles.errorText}>Friend not found</Text>\n            </View>\n        );\n    }\n\n    return <>{children(friend)}</>;\n};\n\nconst enhance = withObservables(['friendId'], ({ friendId }: { friendId: string }) => ({\n    friend: database.get<FriendModel>('friends').findAndObserve(friendId),\n}));\n\nexport const ReactiveFriendProfile = enhance(ReactiveFriendProfileContent);\n\nconst styles = StyleSheet.create({\n    center: {\n        flex: 1,\n        justifyContent: 'center',\n        alignItems: 'center',\n    },\n    errorText: {\n        fontSize: 16,\n        color: '#EF4444', // Red-500\n    },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/hooks/useFriendActions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Tier' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/relationships/hooks/useFriendActions.ts\nimport {\n  createFriend,\n  updateFriend,\n  deleteFriend,\n  batchAddFriends,\n} from '../services/friend.service';\nimport { Tier } from '../types';\n\nexport const useFriendActions = () => {\n  const batchDeleteFriends = async (ids: string[]) => {\n    for (const id of ids) {\n      await deleteFriend(id);\n    }\n  };\n\n  return {\n    addFriend: createFriend,\n    updateFriend,\n    deleteFriend,\n    batchAddFriends,\n    batchDeleteFriends,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/hooks/useFriendProfileData.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useRef' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LifeEventModel' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'router' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useInteractions, usePlans } from '@/modules/interactions';\nimport { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport IntentionModel from '@/db/models/Intention';\nimport { LifeEventRepository } from '@/repositories/LifeEventRepository';\nimport LifeEventModel from '@/db/models/LifeEvent';\nimport { Friend, Interaction, LifeEvent, Intention } from '@/components/types';\nimport { switchMap } from 'rxjs/operators';\nimport { of, combineLatest } from 'rxjs';\nimport IntentionFriend from '@/db/models/IntentionFriend';\nimport FriendModel from '@/db/models/Friend';\nimport InteractionModel from '@/db/models/Interaction';\nimport { useRouter } from 'expo-router';\n\nexport function useFriendProfileData(friendId: string | undefined) {\n    const router = useRouter();\n    const { deleteWeave, updateReflection, updateInteraction } = useInteractions();\n    const { createIntention, dismissIntention } = usePlans();\n\n    const [isDataLoaded, setIsDataLoaded] = useState(false);\n    const [activeLifeEvents, setActiveLifeEvents] = useState<LifeEvent[]>([]);\n    const [isLoadingMore, setIsLoadingMore] = useState(false);\n    const [interactionsLimit, setInteractionsLimit] = useState(20);\n\n    const [friendModel, setFriendModel] = useState<FriendModel | null>(null);\n    const [interactionsModels, setInteractionsModels] = useState<InteractionModel[]>([]);\n    const [friendIntentionsModels, setFriendIntentionsModels] = useState<IntentionModel[]>([]);\n    const [hasMoreInteractions, setHasMoreInteractions] = useState(false);\n\n    // Observe Friend\n    useEffect(() => {\n        if (!friendId || typeof friendId !== 'string') {\n            setFriendModel(null);\n            return;\n        }\n\n        const subscription = database.get<FriendModel>('friends')\n            .findAndObserve(friendId)\n            .subscribe({\n                next: (friend) => {\n                    setFriendModel(friend);\n                    setIsDataLoaded(true);\n                },\n                error: (error) => {\n                    // If friend is deleted or not found\n                    console.log('Error observing friend or friend deleted:', error);\n                    setFriendModel(null);\n                }\n            });\n\n        return () => subscription.unsubscribe();\n    }, [friendId]);\n\n    // Observe Interactions\n    useEffect(() => {\n        if (!friendId || typeof friendId !== 'string') return;\n\n        // Create the query\n        const query = database.get<InteractionModel>('interactions')\n            .query(\n                Q.on('interaction_friends', 'friend_id', friendId),\n                Q.sortBy('interaction_date', Q.desc),\n                Q.take(interactionsLimit)\n            );\n\n        const subscription = query.observe()\n            .pipe(\n                switchMap(interactions => {\n                    if (interactions.length === 0) {\n                        return of([]);\n                    }\n                    // Observe each interaction model for changes individually\n                    // This ensures that if a property of an interaction changes (like activity type), we get an update\n                    return combineLatest(interactions.map(i => i.observe()));\n                })\n            )\n            .subscribe(interactions => {\n                setInteractionsModels(interactions);\n                // Simple check for \"has more\": if we got as many as the limit, assume there might be more.\n                // A perfect check would require a count query, but this is a reasonable heuristic for now.\n                setHasMoreInteractions(interactions.length >= interactionsLimit);\n            });\n\n        return () => subscription.unsubscribe();\n    }, [friendId, interactionsLimit]);\n\n    // Observe Intentions\n    useEffect(() => {\n        if (!friendId || typeof friendId !== 'string') {\n            setFriendIntentionsModels([]);\n            return;\n        }\n\n        // Manual many-to-many query to ensure reactivity\n        const subscription = database.get<IntentionFriend>('intention_friends')\n            .query(Q.where('friend_id', friendId))\n            .observe()\n            .pipe(\n                switchMap(intentionFriends => {\n                    const intentionIds = intentionFriends.map(ifriend => ifriend.intentionId);\n\n                    if (intentionIds.length === 0) {\n                        return of([]);\n                    }\n\n                    return database.get<IntentionModel>('intentions')\n                        .query(\n                            Q.where('id', Q.oneOf(intentionIds)),\n                            Q.where('status', 'active')\n                        )\n                        .observe();\n                })\n            )\n            .subscribe(intentions => {\n                setFriendIntentionsModels(intentions);\n            });\n\n        return () => subscription.unsubscribe();\n    }, [friendId]);\n\n    // Map Intention Models to DTOs\n    const friendIntentions: Intention[] = useMemo(() => {\n        return friendIntentionsModels.map(model => ({\n            id: model.id,\n            description: model.description,\n            interactionCategory: model.interactionCategory,\n            status: model.status,\n            createdAt: model.createdAt,\n            updatedAt: model.updatedAt,\n            lastRemindedAt: model.lastRemindedAt,\n            linkedInteractionId: model.linkedInteractionId,\n            fulfilledAt: model.fulfilledAt,\n            daysToFulfillment: model.daysToFulfillment,\n            friendIds: [friendId || ''], // Default to current friend\n        }));\n    }, [friendIntentionsModels, friendId]);\n\n    // Map Friend Model to DTO\n    const friend: Friend | null = useMemo(() => {\n        if (!friendModel) return null;\n        return {\n            id: friendModel.id,\n            name: friendModel.name,\n            createdAt: friendModel.createdAt,\n            dunbarTier: friendModel.dunbarTier as any, // Cast to Tier\n            archetype: friendModel.archetype as any, // Cast to Archetype\n            weaveScore: friendModel.weaveScore,\n            lastUpdated: friendModel.lastUpdated,\n            photoUrl: friendModel.photoUrl,\n            notes: friendModel.notes,\n            isDormant: friendModel.isDormant,\n            birthday: friendModel.birthday,\n            anniversary: friendModel.anniversary,\n            relationshipType: friendModel.relationshipType as any,\n            toleranceWindowDays: friendModel.toleranceWindowDays,\n            resilience: friendModel.resilience,\n            typicalIntervalDays: friendModel.typicalIntervalDays,\n        };\n    }, [friendModel]);\n\n    // Map Interaction Models to DTOs\n    const interactions: Interaction[] = useMemo(() => {\n        return (interactionsModels || []).map(model => ({\n            id: model.id,\n            friendIds: [friendId || ''], // Default to current friend\n            createdAt: model.createdAt,\n            interactionDate: model.interactionDate,\n            category: model.interactionCategory as any,\n            interactionType: model.interactionType as any,\n            duration: model.duration as any,\n            vibe: model.vibe as any,\n            note: model.note || null,\n            source: undefined, // Not on model\n            photos: undefined, // Not on model\n            reflection: model.reflection,\n            activity: model.activity,\n            status: model.status,\n            mode: model.mode,\n            title: model.title,\n            location: model.location,\n            eventImportance: model.eventImportance,\n            initiator: model.initiator,\n            updatedAt: model.updatedAt,\n            interactionCategory: model.interactionCategory as any,\n        }));\n    }, [interactionsModels, friendId]);\n\n    const loadLifeEvents = useCallback(async (id: string) => {\n        try {\n            const events = await LifeEventRepository.getActiveEventsForFriend(id);\n            // Map LifeEvent Models to DTOs\n            const eventDTOs: LifeEvent[] = events.map(event => ({\n                id: event.id,\n                friendId: event.friendId,\n                title: event.title,\n                date: event.eventDate,\n                eventType: event.eventType,\n                description: event.notes, // Map notes to description\n                importance: event.importance,\n                isRecurring: event.isRecurring,\n                source: event.source,\n                createdAt: event.createdAt,\n                updatedAt: event.updatedAt,\n            }));\n            setActiveLifeEvents(eventDTOs);\n        } catch (error) {\n            console.error('Error loading life events:', error);\n        }\n    }, []);\n\n    useEffect(() => {\n        if (friendId && typeof friendId === 'string') {\n            loadLifeEvents(friendId);\n        }\n    }, [friendId, loadLifeEvents]);\n\n\n    const handleLoadMore = useCallback(async () => {\n        if (isLoadingMore || !hasMoreInteractions) return;\n        setIsLoadingMore(true);\n        // Just increase the limit to fetch more\n        setInteractionsLimit(prev => prev + 20);\n        setIsLoadingMore(false);\n    }, [isLoadingMore, hasMoreInteractions]);\n\n    const deleteFriend = useCallback(async (id: string) => {\n        try {\n            if (friendModel && friendModel.id === id) {\n                await database.write(async () => {\n                    await friendModel.destroyPermanently();\n                });\n                // Navigation back is handled by the caller or simple reactivity will show \"Friend deleted\"\n            }\n        } catch (e) {\n            console.error(\"Error deleting friend\", e);\n            throw e;\n        }\n    }, [friendModel]);\n\n\n    return {\n        friend,\n        friendModel, // Expose the raw model for reactive components\n        interactions,\n        friendIntentions,\n        activeLifeEvents,\n        isDataLoaded,\n        hasMoreInteractions,\n        isLoadingMore,\n        handleLoadMore,\n        deleteFriend,\n        deleteWeave,\n        updateReflection,\n        updateInteraction,\n        createIntention,\n        dismissIntention,\n        refreshLifeEvents: async () => {\n            if (friendId && typeof friendId === 'string') {\n                await loadLifeEvents(friendId);\n            }\n        }\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/hooks/useFriendProfileModals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/hooks/useFriendTimeline.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/repositories/__tests__/friend.repository.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/repositories/friend.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":15,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport Friend from '@/db/models/Friend';\nimport { Q, Query } from '@nozbe/watermelondb';\n\nexport class FriendRepository {\n    private collection = database.get<Friend>('friends');\n\n    async getAllFriends(): Promise<Friend[]> {\n        return this.collection.query().fetch();\n    }\n\n    async getFriendById(id: string): Promise<Friend | undefined> {\n        try {\n            return await this.collection.find(id);\n        } catch (error) {\n            return undefined;\n        }\n    }\n\n    async getAllFriendsWithLastInteraction(): Promise<Friend[]> {\n        // This is a placeholder for the optimized query. \n        // In a real implementation, we might use unsafeSql or a raw query \n        // to join with interactions and get the latest one to avoid N+1.\n        // For now, we'll return all friends and let the caller handle it, \n        // or we can implement the optimization here later.\n        return this.collection.query().fetch();\n    }\n\n    async createFriend(data: Partial<Friend>): Promise<Friend> {\n        return await database.write(async () => {\n            return await this.collection.create(friend => {\n                Object.assign(friend, data);\n            });\n        });\n    }\n\n    async updateFriend(id: string, data: Partial<Friend>): Promise<Friend> {\n        const friend = await this.getFriendById(id);\n        if (!friend) throw new Error('Friend not found');\n\n        return await database.write(async () => {\n            return await friend.update(f => {\n                Object.assign(f, data);\n            });\n        });\n    }\n\n    // Add more specialized queries here as needed\n    async getFriendsByTier(tier: string): Promise<Friend[]> {\n        return this.collection.query(Q.where('dunbar_tier', tier)).fetch();\n    }\n\n    getFriendsByTierQuery(tier: string): Query<Friend> {\n        return this.collection.query(\n            Q.where('dunbar_tier', tier),\n            Q.sortBy('weave_score', Q.asc)\n        );\n    }\n}\n\nexport const friendRepository = new FriendRepository();\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/__tests__/friend.service.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":116,"column":30,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":116,"endColumn":76,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":148,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":148,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/__tests__/image.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/__tests__/lifecycle.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/friend.logic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/friend.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/modules/relationships/services/friend.service.ts\nimport { database } from '@/db';\nimport Friend from '@/db/models/Friend';\nimport UserProgress from '@/db/models/UserProgress';\nimport { Q } from '@nozbe/watermelondb';\nimport { type FriendFormData } from '../types';\nimport { tierMap } from '@/shared/constants/constants';\nimport { trackEvent, AnalyticsEvents } from '@/shared/services/analytics.service';\nimport { deleteImage, getRelativePath } from './image.service';\n\nexport async function createFriend(data: FriendFormData, source: 'manual' | 'onboarding' | 'import' = 'manual'): Promise<Friend> {\n  let newFriend: Friend | undefined;\n  try {\n    await database.write(async () => {\n      const batchOps: any[] = [];\n\n      newFriend = database.get<Friend>('friends').prepareCreate(friend => {\n        friend.name = data.name;\n        friend.dunbarTier = tierMap[data.tier] || 'Community';\n        friend.archetype = data.archetype;\n        friend.photoUrl = getRelativePath(data.photoUrl || '');\n        friend.notes = data.notes;\n        friend.weaveScore = 50; // Start with a neutral score (Green)\n        friend.lastUpdated = new Date();\n        friend.birthday = data.birthday || undefined;\n        friend.anniversary = data.anniversary || undefined;\n        friend.relationshipType = data.relationshipType || undefined;\n        friend.resilience = 1.0;\n        friend.ratedWeavesCount = 0;\n        friend.momentumScore = 0;\n        friend.momentumLastUpdated = new Date();\n        friend.isDormant = false;\n        friend.dormantSince = undefined;\n      });\n      batchOps.push(newFriend);\n\n      const allFriends = await database.get<Friend>('friends').query().fetch();\n      // Note: allFriends won't include the newFriend yet since it's not committed.\n      // We need to account for that manually or accept it updates on next sync/action.\n      // Since we are just counting archetypes, we can check the new friend's archetype.\n      const archetypes = new Set(allFriends.map(f => f.archetype));\n      archetypes.add(data.archetype);\n\n      const userProgress = await database.get<UserProgress>('user_progress').query().fetch();\n      if (userProgress.length > 0) {\n        const progress = userProgress[0];\n        batchOps.push(progress.prepareUpdate(p => {\n          p.curatorProgress = archetypes.size;\n        }));\n      }\n\n      await database.batch(batchOps);\n    });\n\n    trackEvent(AnalyticsEvents.FRIEND_ADDED, {\n      archetype: data.archetype,\n      tier: data.tier,\n      source: source,\n      has_photo: !!data.photoUrl,\n      has_notes: !!data.notes,\n    });\n  } catch (error) {\n    console.error('[createFriend] ERROR: Failed to create friend.', error);\n    throw error;\n  }\n  return newFriend!;\n}\n\nexport async function updateFriend(id: string, data: FriendFormData): Promise<Friend> {\n  let updatedFriend: Friend | undefined;\n  const friend = await database.get<Friend>('friends').find(id);\n  await database.write(async () => {\n    updatedFriend = await friend.update(record => {\n      record.name = data.name;\n      record.dunbarTier = tierMap[data.tier] || 'Community';\n      record.archetype = data.archetype;\n      record.photoUrl = getRelativePath(data.photoUrl || '');\n      record.notes = data.notes;\n      record.birthday = data.birthday || undefined;\n      record.anniversary = data.anniversary || undefined;\n      record.relationshipType = data.relationshipType || undefined;\n      record.lastUpdated = new Date();\n    });\n  });\n\n  trackEvent(AnalyticsEvents.FRIEND_UPDATED, {\n    archetype: data.archetype,\n    tier: data.tier,\n  });\n  return updatedFriend!;\n}\n\nexport async function deleteFriend(id: string): Promise<void> {\n  const friend = await database.get<Friend>('friends').find(id);\n  const photoUrl = friend.photoUrl;\n\n  await database.write(async () => {\n    await friend.destroyPermanently();\n  });\n\n  if (photoUrl) {\n    try {\n      await deleteImage({\n        imageId: id,\n        type: 'profilePicture',\n      });\n    } catch (error) {\n      console.error('[deleteFriend] Error deleting profile picture:', error);\n    }\n  }\n\n  trackEvent(AnalyticsEvents.FRIEND_DELETED);\n}\n\nexport async function batchAddFriends(contacts: Array<{ name: string; photoUrl?: string }>, tier: any): Promise<Friend[]> {\n  const newFriends: Friend[] = [];\n  const BATCH_SIZE = 500;\n\n  try {\n    for (let i = 0; i < contacts.length; i += BATCH_SIZE) {\n      const chunk = contacts.slice(i, i + BATCH_SIZE);\n\n      await database.write(async () => {\n        const batchOps: any[] = [];\n\n        for (const contact of chunk) {\n          const newFriend = database.get<Friend>('friends').prepareCreate(friend => {\n            friend.name = contact.name;\n            friend.dunbarTier = tier;\n            friend.archetype = 'Unknown';\n            friend.photoUrl = getRelativePath(contact.photoUrl || '');\n            friend.notes = '';\n            friend.weaveScore = 50;\n            friend.lastUpdated = new Date();\n\n            friend.birthday = undefined;\n            friend.anniversary = undefined;\n            friend.relationshipType = undefined;\n            friend.resilience = 1.0;\n            friend.ratedWeavesCount = 0;\n            friend.momentumScore = 0;\n            friend.momentumLastUpdated = new Date();\n            friend.isDormant = false;\n            friend.dormantSince = undefined;\n          });\n          newFriends.push(newFriend);\n          batchOps.push(newFriend);\n        }\n\n        const allFriends = await database.get<Friend>('friends').query().fetch();\n        const archetypes = new Set(allFriends.filter(f => f.archetype !== 'Unknown').map(f => f.archetype));\n\n        const userProgress = await database.get<UserProgress>('user_progress').query().fetch();\n        if (userProgress.length > 0) {\n          const progress = userProgress[0];\n          batchOps.push(progress.prepareUpdate(p => {\n            p.curatorProgress = archetypes.size;\n          }));\n        }\n\n        await database.batch(batchOps);\n      });\n    }\n\n    trackEvent(AnalyticsEvents.FRIEND_BATCH_ADDED, {\n      count: contacts.length,\n      tier: tier,\n      source: 'batch_import',\n    });\n  } catch (error) {\n    console.error('[batchAddFriends] ERROR: Failed to create friends.', error);\n    throw error;\n  }\n  return newFriends;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/image.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":271,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":271,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cleanDocDir' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":470,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":470,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cleanPath' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":471,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":471,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ImageService - Unified image management for Weave\n *\n * Handles:\n * - Image compression and resizing\n * - Local storage (active now)\n * - Cloud storage with Supabase (ready to enable)\n * - Cleanup on deletion\n *\n * Architecture:\n * 1. Local-first: Images stored in FileSystem.documentDirectory\n * 2. Cloud-ready: Upload to Supabase Storage when ENABLE_CLOUD_STORAGE = true\n * 3. Graceful fallback: Works offline, syncs when online\n */\n\nimport * as FileSystem from 'expo-file-system';\nimport * as ImageManipulator from 'expo-image-manipulator';\nimport { Image } from 'react-native';\nimport Logger from '@/shared/utils/Logger';\n\n// Lazy-load supabase only when cloud storage is enabled\nlet supabase: any = null;\nconst getSupabase = async () => {\n  if (!supabase) {\n    const { supabase: supabaseClient } = await import('@/modules/auth');\n    supabase = supabaseClient;\n  }\n  return supabase;\n};\n\n// =====================================================\n// CONFIGURATION\n// =====================================================\n\n/**\n * Set to true when you're ready to enable cloud storage\n *\n * Prerequisites:\n * 1. Run supabase/schema.sql to create storage buckets\n * 2. Create buckets in Supabase Dashboard > Storage\n * 3. Ensure user is authenticated\n */\nconst ENABLE_CLOUD_STORAGE = false;\n\n/**\n * Image quality and size settings\n */\nconst IMAGE_SETTINGS = {\n  profilePicture: {\n    width: 400,\n    height: 400,\n    quality: 0.7, // 0-1, balances quality vs file size\n    format: ImageManipulator.SaveFormat.JPEG,\n  },\n  journalPhoto: {\n    width: 1200,\n    height: undefined, // Maintain aspect ratio\n    quality: 0.8, // Higher quality for journal photos\n    format: ImageManipulator.SaveFormat.JPEG,\n  },\n} as const;\n\n/**\n * Storage paths\n */\nconst LOCAL_STORAGE_DIR = `${FileSystem.documentDirectory}weave_images/`;\nconst SUPABASE_BUCKETS = {\n  profilePictures: 'profile-pictures',\n  journalPhotos: 'journal-photos',\n} as const;\n\n// =====================================================\n// TYPES\n// =====================================================\n\nexport type ImageType = 'profilePicture' | 'journalPhoto';\n\nexport interface ProcessImageOptions {\n  uri: string;\n  type: ImageType;\n  userId?: string; // Required when ENABLE_CLOUD_STORAGE = true\n  imageId: string; // Unique ID (friend_id for profile, interaction_id for journal)\n}\n\nexport interface ImageResult {\n  localUri: string;\n  cloudUrl?: string;\n  success: boolean;\n  error?: string;\n}\n\n// =====================================================\n// INITIALIZATION\n// =====================================================\n\n/**\n * Ensure local storage directory exists\n */\nasync function ensureDirectoryExists(): Promise<void> {\n  const dirInfo = await FileSystem.getInfoAsync(LOCAL_STORAGE_DIR);\n  if (!dirInfo.exists) {\n    await FileSystem.makeDirectoryAsync(LOCAL_STORAGE_DIR, { intermediates: true });\n    Logger.info('[ImageService] Created local storage directory:', LOCAL_STORAGE_DIR);\n  }\n}\n\n// =====================================================\n// CORE FUNCTIONS\n// =====================================================\n\n/**\n * Process and store an image\n *\n * Steps:\n * 1. Compress and resize image\n * 2. Save to local storage (persistent across rebuilds)\n * 3. Upload to cloud storage (if enabled and user authenticated)\n * 4. Return both local URI and cloud URL\n *\n * @param options - Image processing options\n * @returns ImageResult with local URI and optional cloud URL\n */\nexport async function processAndStoreImage(\n  options: ProcessImageOptions\n): Promise<ImageResult> {\n  try {\n    const { uri, type, userId, imageId } = options;\n\n    // Ensure local directory exists\n    await ensureDirectoryExists();\n\n    // Get image settings based on type\n    const settings = IMAGE_SETTINGS[type];\n\n    Logger.debug(`[ImageService] Processing ${type}:`, imageId);\n\n    // Step 1: Get original dimensions to determine if cropping is needed\n    const getImageSize = (uri: string): Promise<{ width: number; height: number }> => {\n      return new Promise((resolve, reject) => {\n        Image.getSize(\n          uri,\n          (width, height) => resolve({ width, height }),\n          (error) => reject(error)\n        );\n      });\n    };\n\n    const { width, height } = await getImageSize(uri);\n    const actions: ImageManipulator.Action[] = [];\n\n    // Step 2: Smart Center Crop (if needed)\n    // Only apply for profile pictures or if we want square images\n    if (type === 'profilePicture' && Math.abs(width - height) > 5) {\n      const size = Math.min(width, height);\n      const originX = (width - size) / 2;\n      const originY = (height - size) / 2;\n\n      Logger.debug(`[ImageService] Cropping to square: ${size}x${size} at (${originX}, ${originY})`);\n\n      actions.push({\n        crop: {\n          originX,\n          originY,\n          width: size,\n          height: size,\n        },\n      });\n    }\n\n    // Step 3: Resize\n    actions.push({\n      resize: {\n        width: settings.width,\n        height: settings.height,\n      },\n    });\n\n    // Execute manipulation\n    const manipulatedImage = await ImageManipulator.manipulateAsync(\n      uri,\n      actions,\n      {\n        compress: settings.quality,\n        format: settings.format,\n      }\n    );\n\n    Logger.debug('[ImageService] Processed:', {\n      originalSize: `${width}x${height}`,\n      processedUri: manipulatedImage.uri,\n    });\n\n    // Step 4: Save to local storage (persistent)\n    const fileName = `${type}_${imageId}.jpg`;\n    const localUri = `${LOCAL_STORAGE_DIR}${fileName}`;\n\n    await FileSystem.copyAsync({\n      from: manipulatedImage.uri,\n      to: localUri\n    });\n\n    Logger.info('[ImageService] Saved locally:', localUri);\n\n    // Step 5: Upload to cloud storage (if enabled)\n    let cloudUrl: string | undefined;\n\n    if (ENABLE_CLOUD_STORAGE && userId) {\n      try {\n        cloudUrl = await uploadToSupabase({\n          localUri,\n          userId,\n          imageId,\n          type,\n        });\n        Logger.info('[ImageService] Uploaded to cloud:', cloudUrl);\n      } catch (cloudError) {\n        Logger.warn('[ImageService] Cloud upload failed (continuing with local):', cloudError);\n        // Don't fail the whole operation - image is still saved locally\n      }\n    }\n\n    return {\n      localUri,\n      cloudUrl,\n      success: true,\n    };\n  } catch (error) {\n    Logger.error('[ImageService] Error processing image:', error);\n    return {\n      localUri: '',\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Upload image to Supabase Storage\n *\n * File structure:\n * - profile-pictures/{userId}/{imageId}.jpg\n * - journal-photos/{userId}/{imageId}.jpg\n */\nasync function uploadToSupabase(params: {\n  localUri: string;\n  userId: string;\n  imageId: string;\n  type: ImageType;\n}): Promise<string> {\n  const { localUri, userId, imageId, type } = params;\n\n  const bucket =\n    type === 'profilePicture'\n      ? SUPABASE_BUCKETS.profilePictures\n      : SUPABASE_BUCKETS.journalPhotos;\n\n  const filePath = `${userId}/${imageId}.jpg`;\n\n  // Read file as base64\n  const base64 = await FileSystem.readAsStringAsync(localUri, {\n    encoding: FileSystem.EncodingType.Base64,\n  });\n\n  // Convert to blob\n  const blob = base64ToBlob(base64, 'image/jpeg');\n\n  // Get Supabase client\n  const supabaseClient = await getSupabase();\n\n  // Upload to Supabase Storage\n  const { data, error } = await supabaseClient.storage\n    .from(bucket)\n    .upload(filePath, blob, {\n      contentType: 'image/jpeg',\n      upsert: true, // Replace if exists\n    });\n\n  if (error) {\n    throw new Error(`Supabase upload failed: ${error.message}`);\n  }\n\n  // Get public URL (even though bucket is private, this is the reference URL)\n  const { data: urlData } = supabaseClient.storage.from(bucket).getPublicUrl(filePath);\n\n  return urlData.publicUrl;\n}\n\n/**\n * Delete an image (both local and cloud)\n */\nexport async function deleteImage(params: {\n  imageId: string;\n  type: ImageType;\n  userId?: string;\n}): Promise<void> {\n  const { imageId, type, userId } = params;\n\n  try {\n    // Delete local file\n    const fileName = `${type}_${imageId}.jpg`;\n    const localUri = `${LOCAL_STORAGE_DIR}${fileName}`;\n    const fileInfo = await FileSystem.getInfoAsync(localUri);\n\n    if (fileInfo.exists) {\n      await FileSystem.deleteAsync(localUri, { idempotent: true });\n      Logger.info('[ImageService] Deleted local file:', localUri);\n    }\n\n    // Delete from cloud (if enabled)\n    if (ENABLE_CLOUD_STORAGE && userId) {\n      try {\n        await deleteFromSupabase({ userId, imageId, type });\n        Logger.info('[ImageService] Deleted from cloud');\n      } catch (cloudError) {\n        Logger.warn('[ImageService] Cloud deletion failed:', cloudError);\n      }\n    }\n  } catch (error) {\n    Logger.error('[ImageService] Error deleting image:', error);\n  }\n}\n\n/**\n * Delete image from Supabase Storage\n */\nasync function deleteFromSupabase(params: {\n  userId: string;\n  imageId: string;\n  type: ImageType;\n}): Promise<void> {\n  const { userId, imageId, type } = params;\n\n  const bucket =\n    type === 'profilePicture'\n      ? SUPABASE_BUCKETS.profilePictures\n      : SUPABASE_BUCKETS.journalPhotos;\n\n  const filePath = `${userId}/${imageId}.jpg`;\n\n  // Get Supabase client\n  const supabaseClient = await getSupabase();\n\n  const { error } = await supabaseClient.storage.from(bucket).remove([filePath]);\n\n  if (error) {\n    throw new Error(`Supabase deletion failed: ${error.message}`);\n  }\n}\n\n/**\n * Get image URI - checks local first, falls back to cloud\n *\n * Useful for displaying images:\n * - Try local cache first (fast)\n * - If not found and cloud URL exists, download and cache\n */\nexport async function getImageUri(params: {\n  imageId: string;\n  type: ImageType;\n  cloudUrl?: string;\n}): Promise<string | null> {\n  const { imageId, type, cloudUrl } = params;\n\n  // Check local storage first\n  const fileName = `${type}_${imageId}.jpg`;\n  const localUri = `${LOCAL_STORAGE_DIR}${fileName}`;\n  const fileInfo = await FileSystem.getInfoAsync(localUri);\n\n  if (fileInfo.exists) {\n    return localUri;\n  }\n\n  // If cloud URL exists, download and cache\n  if (cloudUrl && ENABLE_CLOUD_STORAGE) {\n    try {\n      await ensureDirectoryExists();\n      await FileSystem.downloadAsync(cloudUrl, localUri);\n      Logger.info('[ImageService] Downloaded from cloud to cache:', localUri);\n      return localUri;\n    } catch (error) {\n      Logger.warn('[ImageService] Failed to download from cloud:', error);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Cleanup orphaned images\n *\n * Call this periodically to remove images that no longer have\n * corresponding database records (e.g., deleted friends/interactions)\n */\nexport async function cleanupOrphanedImages(\n  activeImageIds: string[],\n  type: ImageType\n): Promise<void> {\n  try {\n    const dirInfo = await FileSystem.getInfoAsync(LOCAL_STORAGE_DIR);\n    if (!dirInfo.exists) return;\n\n    const contents = await FileSystem.readDirectoryAsync(LOCAL_STORAGE_DIR);\n    const prefix = `${type}_`;\n\n    for (const item of contents) {\n      if (item.startsWith(prefix)) {\n        // Extract imageId from filename (e.g., \"profilePicture_123.jpg\" -> \"123\")\n        const imageId = item.replace(prefix, '').replace('.jpg', '');\n\n        if (!activeImageIds.includes(imageId)) {\n          await FileSystem.deleteAsync(`${LOCAL_STORAGE_DIR}${item}`, { idempotent: true });\n          Logger.info('[ImageService] Cleaned up orphaned image:', item);\n        }\n      }\n    }\n  } catch (error) {\n    Logger.error('[ImageService] Error cleaning up orphaned images:', error);\n  }\n}\n\n/**\n * Get relative path from absolute URI\n * Use this before saving to database\n */\nexport function getRelativePath(uri: string): string {\n  if (!uri) return '';\n  if (uri.startsWith(FileSystem.documentDirectory as string)) {\n    return uri.replace(FileSystem.documentDirectory as string, '');\n  }\n  return uri;\n}\n\n/**\n * Resolve absolute URI from potential relative path\n * Handles:\n * 1. Already absolute paths (checks existence, attempts recovery if broken)\n * 2. Relative paths (prepends documentDirectory)\n * 3. Empty paths (returns default/empty)\n */\nexport async function resolveImageUri(path: string): Promise<string> {\n  if (!path) return '';\n\n  // Case 1: Already absolute path (Legacy support)\n  if (path.startsWith('file://') || path.startsWith('/')) {\n    const fileInfo = await FileSystem.getInfoAsync(path);\n\n    if (fileInfo.exists) {\n      return path;\n    }\n\n    // Recovery attempt for iOS Container migration\n    // If we have a full path like /.../CoreSimulator/.../weave_images/profile.jpg\n    // extract just the filename and try to find it in current documents dir\n    const filename = path.split('/').pop();\n    if (filename) {\n      const recoveryPath = `${LOCAL_STORAGE_DIR}${filename}`;\n      const recoveryInfo = await FileSystem.getInfoAsync(recoveryPath);\n      if (recoveryInfo.exists) {\n        Logger.info('[ImageService] Recovered broken path:', { old: path, new: recoveryPath });\n        return recoveryPath; // Return the working local URI\n      }\n    }\n\n    Logger.warn('[ImageService] Image file missing:', path);\n    return path; // Return original as fail-safe (or could return empty)\n  }\n\n  // Case 2: Relative path (New way)\n  // Ensure we don't double-slash\n  const cleanDocDir = (FileSystem.documentDirectory as string).replace(/\\/$/, '');\n  const cleanPath = path.replace(/^\\//, '');\n\n  // If path implies weave_images, just join\n  // But wait, LOCAL_STORAGE_DIR includes weave_images/\n  // If we saved relative from docDir, it might include weave_images/\n\n  // Strategy: Just blindly prepend docDir\n  return (FileSystem.documentDirectory as string) + path;\n}\n\n// =====================================================\n// UTILITIES\n// =====================================================\n\n/**\n * Convert base64 string to Blob (for Supabase upload)\n */\nfunction base64ToBlob(base64: string, mimeType: string): Blob {\n  // Polyfill for atob/Blob if needed in environment\n  const byteCharacters = atob(base64);\n  const byteArrays = [];\n\n  for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n    const slice = byteCharacters.slice(offset, offset + 512);\n    const byteNumbers = new Array(slice.length);\n\n    for (let i = 0; i < slice.length; i++) {\n      byteNumbers[i] = slice.charCodeAt(i);\n    }\n\n    const byteArray = new Uint8Array(byteNumbers);\n    byteArrays.push(byteArray);\n  }\n\n  return new Blob(byteArrays, { type: mimeType });\n}\n\n/**\n * Get storage statistics\n */\nexport async function getStorageStats(): Promise<{\n  totalImages: number;\n  profilePictures: number;\n  journalPhotos: number;\n  estimatedSizeMB: number;\n}> {\n  try {\n    const dirInfo = await FileSystem.getInfoAsync(LOCAL_STORAGE_DIR);\n    if (!dirInfo.exists) {\n      return {\n        totalImages: 0,\n        profilePictures: 0,\n        journalPhotos: 0,\n        estimatedSizeMB: 0,\n      };\n    }\n\n    const contents = await FileSystem.readDirectoryAsync(LOCAL_STORAGE_DIR);\n    let totalSize = 0;\n    let profileCount = 0;\n    let journalCount = 0;\n    let fileCount = 0;\n\n    for (const item of contents) {\n      fileCount++;\n      const fileInfo = await FileSystem.getInfoAsync(`${LOCAL_STORAGE_DIR}${item}`);\n      if (fileInfo.exists) {\n        totalSize += fileInfo.size;\n      }\n\n      if (item.startsWith('profilePicture_')) {\n        profileCount++;\n      } else if (item.startsWith('journalPhoto_')) {\n        journalCount++;\n      }\n    }\n\n    return {\n      totalImages: fileCount,\n      profilePictures: profileCount,\n      journalPhotos: journalCount,\n      estimatedSizeMB: totalSize / (1024 * 1024),\n    };\n  } catch (error) {\n    Logger.error('[ImageService] Error getting storage stats:', error);\n    return {\n      totalImages: 0,\n      profilePictures: 0,\n      journalPhotos: 0,\n      estimatedSizeMB: 0,\n    };\n  }\n}\n\n// =====================================================\n// EXPORT CONFIGURATION\n// =====================================================\n\nexport const ImageServiceConfig = {\n  isCloudStorageEnabled: ENABLE_CLOUD_STORAGE,\n  localStorageDir: LOCAL_STORAGE_DIR,\n  imageSettings: IMAGE_SETTINGS,\n};\n\n/**\n * Convenience wrappers for existing consumers\n */\nexport async function uploadFriendPhoto(uri: string, friendId: string): Promise<ImageResult> {\n  return processAndStoreImage({\n    uri,\n    type: 'profilePicture',\n    imageId: friendId,\n  });\n}\n\nexport async function deleteFriendPhoto(friendId: string): Promise<void> {\n  return deleteImage({\n    imageId: friendId,\n    type: 'profilePicture',\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/life-event-detection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/life-event.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/services/lifecycle.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/modules/relationships/utils/image.utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/repositories/LifeEventRepository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/services/diagnostic.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Q' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { database } from '@/db';\nimport { Q } from '@nozbe/watermelondb';\nimport Friend from '@/db/models/Friend';\nimport InteractionFriend from '@/db/models/InteractionFriend';\n\nexport interface DiagnosticIssue {\n    type: 'orphan_interaction' | 'orphan_badge' | 'orphan_life_event' | 'invalid_date' | 'invalid_tier' | 'invalid_archetype' | 'duplicate_singleton';\n    table: string;\n    id: string;\n    description: string;\n    severity: 'low' | 'medium' | 'high';\n    payload?: any;\n}\n\nexport interface DiagnosticReport {\n    timestamp: number;\n    issues: DiagnosticIssue[];\n    totalIssues: number;\n    scanDurationMs: number;\n}\n\nconst VALID_TIERS = ['InnerCircle', 'CloseFriends', 'Community', 'Acquaintance'];\nconst VALID_ARCHETYPES = ['Sun', 'Hermit', 'Emperor', 'Fool', 'Empress', 'Magician', 'HighPriestess', 'Unknown', 'Lovers'];\n\nexport const DiagnosticService = {\n    /**\n     * Run a full health scan of the database\n     */\n    async runScan(): Promise<DiagnosticReport> {\n        const startTime = Date.now();\n        const issues: DiagnosticIssue[] = [];\n\n        try {\n            // 1. Check for Orphaned Interaction Links\n            // An InteractionFriend record where the friend_id or interaction_id doesn't exist\n            const interactionFriends = await database.get<InteractionFriend>('interaction_friends').query().fetch();\n            const allFriendIds = new Set((await database.get<Friend>('friends').query().fetch()).map(f => f.id));\n            const allInteractionIds = new Set((await database.get('interactions').query().fetch()).map(i => i.id));\n\n            for (const link of interactionFriends) {\n                if (!allFriendIds.has(link.friendId)) {\n                    issues.push({\n                        type: 'orphan_interaction',\n                        table: 'interaction_friends',\n                        id: link.id,\n                        description: `Link to non-existent friend ID: ${link.friendId}`,\n                        severity: 'high',\n                    });\n                }\n                if (!allInteractionIds.has(link.interactionId)) {\n                    issues.push({\n                        type: 'orphan_interaction',\n                        table: 'interaction_friends',\n                        id: link.id,\n                        description: `Link to non-existent interaction ID: ${link.interactionId}`,\n                        severity: 'medium',\n                    });\n                }\n            }\n\n            // 2. Check Friend Data Integrity\n            const friends = await database.get<Friend>('friends').query().fetch();\n            for (const friend of friends) {\n                // defined manually to avoid circular dependency or import issues if constants aren't perfect\n                if (!VALID_TIERS.includes(friend.dunbarTier)) {\n                    // Some migrating data might use legacy names, check if critical\n                    issues.push({\n                        type: 'invalid_tier',\n                        table: 'friends',\n                        id: friend.id,\n                        description: `Invalid Dunbar Tier: ${friend.dunbarTier}`,\n                        severity: 'low',\n                    });\n                }\n\n                if (!VALID_ARCHETYPES.includes(friend.archetype)) {\n                    issues.push({\n                        type: 'invalid_archetype',\n                        table: 'friends',\n                        id: friend.id,\n                        description: `Invalid Archetype: ${friend.archetype}`,\n                        severity: 'low',\n                    });\n                }\n\n                // Check dates - allow MM-DD (standard) or YYYY-MM-DD (legacy/ISO)\n                const validDateRegex = /^(\\d{4}-)?\\d{2}-\\d{2}(T.*)?$/;\n\n                if (friend.birthday && !validDateRegex.test(friend.birthday)) {\n                    issues.push({\n                        type: 'invalid_date',\n                        table: 'friends',\n                        id: friend.id,\n                        description: `Invalid Birthday Format: ${friend.birthday} (Expected MM-DD or ISO)`,\n                        severity: 'low',\n                    });\n                }\n\n                if (friend.anniversary && !validDateRegex.test(friend.anniversary)) {\n                    issues.push({\n                        type: 'invalid_date',\n                        table: 'friends',\n                        id: friend.id,\n                        description: `Invalid Anniversary Format: ${friend.anniversary} (Expected MM-DD or ISO)`,\n                        severity: 'low',\n                    });\n                }\n            }\n\n            // 3. Check for singleton duplication\n            const currentProgressCount = await database.get('user_progress').query().fetchCount();\n            if (currentProgressCount > 1) {\n                issues.push({\n                    type: 'duplicate_singleton',\n                    table: 'user_progress',\n                    id: 'GLOBAL',\n                    description: `Found ${currentProgressCount} user_progress records. Should be exactly 1.`,\n                    severity: 'high',\n                });\n            }\n\n            const currentProfileCount = await database.get('user_profile').query().fetchCount();\n            if (currentProfileCount > 1) {\n                issues.push({\n                    type: 'duplicate_singleton',\n                    table: 'user_profile',\n                    id: 'GLOBAL',\n                    description: `Found ${currentProfileCount} user_profile records. Should be exactly 1.`,\n                    severity: 'high',\n                });\n            }\n\n\n        } catch (error) {\n            console.error('Diagnostic scan failed:', error);\n            // We might want to add a special issue type for \"scan_failed\"\n        }\n\n        return {\n            timestamp: Date.now(),\n            issues,\n            totalIssues: issues.length,\n            scanDurationMs: Date.now() - startTime,\n        };\n    },\n\n    /**\n     * DANGER: Fix specific issues.\n     * Currently only supports deleting invalid interaction links.\n     */\n    async fixOrphans(issues: DiagnosticIssue[]): Promise<number> {\n        let fixedCount = 0;\n\n        await database.write(async () => {\n            for (const issue of issues) {\n                if (issue.type === 'orphan_interaction' && issue.table === 'interaction_friends') {\n                    try {\n                        const record = await database.get('interaction_friends').find(issue.id);\n                        await record.destroyPermanently();\n                        fixedCount++;\n                    } catch (e) {\n                        console.warn(`Could not delete orphan ${issue.id}`, e);\n                    }\n                }\n            }\n        });\n\n        return fixedCount;\n    }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/components/LoadingScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'View' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LoadingScreen Component\n * Animated loading screen with draw/trace animation of the Weave icon\n * Shows while initial data is loading\n */\n\nimport React, { useEffect, useState } from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport Svg, { Path } from 'react-native-svg';\nimport Animated, {\n  useSharedValue,\n  useAnimatedProps,\n  useAnimatedStyle,\n  withTiming,\n  withDelay,\n  withSequence,\n  runOnJS,\n  Easing,\n} from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\nconst { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');\n\nconst AnimatedPath = Animated.createAnimatedComponent(Path);\n\ninterface LoadingScreenProps {\n  visible: boolean;\n}\n\n// SVG path from Weave_icon.svg\nconst WEAVE_PATH = \"M973.57,442.07c14.65,5.27,82.38,10.98,88.01-5.32,10.32-29.87-30.82-116.41-55.2-137.29-45.85-39.28-149.19-44.55-197.44-7.41-109.42,84.23-76.57,256.02-81.96,376.11,5.11,37.96,72.04,11.53,96.9,12.8,3.23-88.91-18.34-185.83,13.14-271.53,11.42-31.1,26.65-55.15,63.34-56.01,58.44-1.37,58.86,46.65,73.2,88.64ZM1174.36,669.21c28.77,5.6,58.94,7.04,87.04-2.84-.14-16.68,4.9-33.98,5.47-50.34,2.39-67.97-14.86-183.89,49.24-229.85,23.8-17.07,31.73-18.72,56.74-2.95,28.41,17.91,34.42,45.15,49.97,72.47,25.72,1.29,51.82,4.68,76.74-5.16,10.22-51.53-13.42-95.59-46.89-132.24-38.17-41.8-120.36-45.07-171.01-26.13-116.89,43.73-121.67,257.59-111.67,360.94.54,5.54,1.55,11.24,4.38,16.09ZM539.25,424.24c21.82,3.86,53.25-2.83,76.28,0-.39-39.23,8.31-77.54-7.95-114.84-21.52,5.39-62.28-13-79.69-10.2-22.37,3.6-9.78,67.07-9.08,82.24.75,16.45-12.22,37.03,20.45,42.8ZM689.96,545.17v-66.98c0-1.03-3.81-8.68-6.28-9.43-103.55-3.33-240.17-25.12-328.3,43.24-39.38,30.54-58.78,119.36-43.05,165.2,20.79,60.58,99.84,128.09,167.3,115.32,24.94-4.72,16.24-48.51,10.66-66.28-9.89-31.48-32.99-15.09-45.79-20.94-10.39-4.75-29.33-29.67-34.3-40.37-13.29-28.64-17-53.11,4.39-78.83,55.95-67.28,186.47-26.23,262.54-35.15,5.42-.64,9.57-.46,12.83-5.77ZM862,561.04c3.37,3.36,11,4.08,15.81,4.6,64.98,7.03,149.21,2.94,216.03,3.55,18.09.16,28.86,11.48,37.92-13.86,7.67-21.45,1.98-39.99.46-61.71l-2.93-4.51-265.79-4.82c-6.12,2.02-10.02,34-10.12,42.27s3.59,29.46,8.62,34.48ZM1650.01,487.5l-336.25,7.95c-13.04,4.42-17.08,74.33,3.93,80.63,12.51,3.75,46.59.46,62.5.75,70.56,1.29,144.6,1.44,215.83-3.79,16.22-1.19,41.34-2.47,54-9.26v-76.28ZM611.34,592.15l-81.63-2.56-2.96,4.48,3.18,306.49,85.85,2.06,2.95-4.46c-2.32-28.41,3.43-57.71,4.39-84.91,1.02-28.51,2.93-211.52-11.79-221.1ZM974.91,607.01c-5.94,1.42-8.75,36.63-9.56,46.12-4.9,57.69-9.55,124.42-11.35,182.14-.99,31.75-9.39,69.49,31.8,72.91,9.59.79,53.79-5.08,62.53-8.35,4.55-1.7,6.17-3.64,6.32-8.56l10.61-271.15c-1.25-4.92-4.53-5.29-8.81-6.08-26.27-4.8-55.47-.98-81.55-7.04ZM1489.97,919.12l18.02-280.01c-14.33-39.04-61.03-10.55-92.43-17.67l-11.15,293.97,85.56,3.71ZM660.19,725.65v65.12c0,.83-2.76,2.02-2.86,3.75l2.67,3.7c13.34,8.62,75.78,6.04,95.24,5.73,44.77-.72,114.66,1.2,156.32-3.69,5.42-.64,9.57-.46,12.83-5.77v-74.42c-5.99-9.2-14.57-1.88-24.02-1.68-31.15.68-232.53-4.76-240.18,7.26ZM1370.92,718.21h-262.34c-14.45,2.68-16.68,40.1-17.02,53.86-.5,20.04-.58,29.43,20.68,31.72,22.62,2.44,61.23-2.12,85.61-3.76,57.62-3.87,115.21-16.65,173.07-7.41v-74.42ZM1659.87,992.27c87.89-87.89,39.11-245.24-83.3-269.47-52.22-10.34-41.04,3.55-45.93,41.62-1.34,10.42-8.07,16.17-5.72,28.31,4.94,25.45,27.62,14.07,44.61,22.68,45.72,23.19,53.97,111.76,2.39,131.71-15.35,5.94-58.22,11.05-76.38,12.92-57.69,5.94-116.26,4.39-174.08.94-14.5,1.11-14.37,22.75-14.09,34.5.24,9.88,6.06,50.78,13.78,53.42,104.7.71,257.15,24.91,338.71-56.64ZM1269.94,1138.17l-3.96-287.11c-5.47-18.57-65.46-7.27-82.46-9.53l-6.13,8.76c-8.92,95.09-8.4,190.47-6.9,286.03l8.78,6.11c30.75-1.8,61.05,6.98,90.66-4.25ZM742.6,848.98l-7.48,283.63c3.41,10.19,55.74,10.88,67.45,8.92,8.62-1.45,24.03-6.28,25.08-15.85l-7.97-271.13c-4.06-12.3-64.1-8.75-77.08-5.57ZM708.56,1027.06v-53.96c0-8.09-11.05-34.62-24-31.81-104.39,6.47-219.87-20.72-313.48,36.68-48.42,29.69-76.78,126.85-63.49,180.27,15.73,63.23,103.66,116.41,167.88,102.73,15.78-5.18-.7-66.98-3.04-81.51-27.24-4.12-49.8-10.53-64.01-36.46-17.92-32.7-10.05-58.6,17.65-80.27,72.72-56.9,197.1-19.21,282.49-35.67ZM1135.94,1033.98c8.57-5.41-1.6-73.14-13.09-77l-234.03-11.95c-36,4.89-24.49,60.84-20.07,85.56l267.19,3.39ZM603.85,1365.17l19.13-265.47c-2.62-28.45-91.52-31.39-96.75-3.79l-9.54,270.01c5.4,7.76,73.54,3.11,87.17-.75ZM959.74,1365.69h78.14l12.57-272.83c-5.4-16.76-73.17-9.09-89.09-8.35l-2.97,4.48c-1.99,22.11.71,44.51-.37,66.61-2.83,58.21-10.74,140.39-4.06,197.26.64,5.42.46,9.57,5.77,12.83ZM1477.95,1372.22c10.21-11.81,4.17-228.31,8.34-261.43-2.94-24.84-82.03-8.54-85.11.48l-4.22,265.6c18.56-.59,67.74,10.69,81-4.65ZM916.94,1261.49v-80c-16.47-13.35-42.73-2.24-61.25-1.71-35.98,1.04-72.5-3.49-107.91,3.72-15.54,5.19-93.7-10.74-98.75,2.57-2.03,18.51-11.95,75.58,7.42,84.74,38.69,2.35,78.14-1.62,117.4-2.05,35.4-.39,71.56,3.3,107.67.11,11.9-1.05,23.71-5.33,35.41-7.38ZM1080.67,1265.21c70.01,1.39,140.36-1.8,210.4-.15,38.27.9,73.39,20.9,72.72-38.92-.12-10.9-2.59-40.8-13.33-42.8-23.53-4.37-66.52,1.01-93.19.16-50.62-1.63-101.41-6.16-152.47-.21-11.19,1.3-24.13,8.21-24.13,20.52v61.4ZM1488.14,1428.94c-52.77,5.35-113.74-3.97-167.45,0-16.17,25.43-6.86,57.36-1.5,85.21,40.03,4.68,80.32,4.9,120.73,4.26,59.45-.94,127.3-3.4,180.03-35.81,51.14-31.44,89.83-129.18,68.1-186.58-9.06-23.92-47.44-68.75-68.12-84.44-19.91-15.11-94.77-51.3-103.07-14.41-1.17,5.21-5.03,62.43-3.99,65.55,3.61,10.92,38.9,14.33,50.47,20.34,27.15,14.12,36.27,63.82,30.09,91.14-6.51,28.78-79.05,52.08-105.27,54.74ZM1270.43,1306.18l-85.97-1.59c-17.39,96.1,20.05,206.92-28.72,298.02-13.97,26.09-30.53,47.22-64.1,36.78-40.49-12.59-42.73-101.73-55.57-108.15-29.58-4.51-60.32-2.26-88.84,6.13-2.37,51.79,16.2,115.26,55.26,150.24,69.67,62.39,176.8,49.96,234.4-22.46,42.57-53.52,38.2-125.4,45.06-189.71l-11.51-169.26ZM591.35,1536.86h-81.87l-5.58,5.58v59.54c0,3.93,22.59,48.26,26.79,55.08,49.47,80.31,118.34,93.89,202.76,55.39,38.35-17.5,51.67-34.45,68.79-72.62,44.49-99.2,30.02-220.77,17.65-325.91-15.68-3.25-83.23-9.7-88.51,5.73-5.27,89.18,21.16,175.61-8.96,262.68-2.1,6.06-15.75,36.35-18.55,39.13-4.03,3.99-43.82,22.19-49.9,22.37s-24.24-9.71-29.17-13.88c-28.61-24.18-9.94-67.69-33.44-93.08ZM373.66,1417.78v80c0,.9-4.32,2.84-2.13,5.6l7.74,3.94c22.31-2.19,48.5-7.01,70.51-7.83,36.83-1.37,227.62,10.9,242.3.43,16.73-11.94.09-74.43-4.42-93.53l-178.34.07-135.67,11.32ZM1132.78,1507.11l2.1-78.41c-3.44-4.76-101.15-17.09-115.64-18.32-19.11-1.61-44.01-3.34-63.04-3.94-20.68-.65-88.11-6.82-94.53,17.77,6.53,16.92-3.77,72.87,13.1,78.55l258.02,4.35ZM1470.86,1556.01c-3.59-5.9-75.27-6.93-79.63-.7-6.12,24.49-16.46,119.68,4.17,133.82,8.73,5.98,68.75,6.69,74.17.33,12.54-14.71,3.74-109.81,1.29-133.45Z\";\n\n// Approximate path length for strokeDasharray\nconst PATH_LENGTH = 14500;\n\nexport const LoadingScreen: React.FC<LoadingScreenProps> = ({ visible }) => {\n  const { colors } = useTheme();\n  const strokeDashoffset = useSharedValue(PATH_LENGTH);\n  const opacity = useSharedValue(1);\n  const [shouldRender, setShouldRender] = useState(true);\n\n  // Manage rendering state\n  useEffect(() => {\n    if (visible) {\n      setShouldRender(true);\n      // Reset values\n      strokeDashoffset.value = PATH_LENGTH;\n      opacity.value = 1;\n\n      // Start animation\n      strokeDashoffset.value = withSequence(\n        withTiming(0, { duration: 1500, easing: Easing.inOut(Easing.ease) }),\n        withDelay(300, withTiming(0, { duration: 0 }))\n      );\n    } else {\n      // Fade out then unmount\n      opacity.value = withTiming(0, { duration: 800, easing: Easing.out(Easing.ease) }, (finished) => {\n        if (finished) {\n          runOnJS(setShouldRender)(false);\n        }\n      });\n    }\n  }, [visible]);\n\n  const animatedPathProps = useAnimatedProps(() => ({\n    strokeDashoffset: strokeDashoffset.value,\n  }));\n\n  const animatedContainerStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n  }));\n\n  if (!shouldRender) return null;\n\n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        { backgroundColor: colors.background },\n        animatedContainerStyle\n      ]}\n      pointerEvents={visible ? 'auto' : 'none'}\n    >\n      <Svg width={200} height={200} viewBox=\"0 0 2000 2000\">\n        <AnimatedPath\n          d={WEAVE_PATH}\n          fill=\"none\"\n          stroke={colors.primary}\n          strokeWidth={40}\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          strokeDasharray={PATH_LENGTH}\n          animatedProps={animatedPathProps}\n        />\n      </Svg>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: SCREEN_WIDTH,\n    height: SCREEN_HEIGHT,\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 9999,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/components/WeaveLoading.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StyleSheet' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport Svg, { Path } from 'react-native-svg';\nimport Animated, {\n    useSharedValue,\n    useAnimatedProps,\n    withRepeat,\n    withTiming,\n    Easing,\n    cancelAnimation,\n} from 'react-native-reanimated';\nimport { useTheme } from '@/shared/hooks/useTheme';\n\nconst AnimatedPath = Animated.createAnimatedComponent(Path);\n\n// SVG path from Weave_icon.svg\nconst WEAVE_PATH = \"M973.57,442.07c14.65,5.27,82.38,10.98,88.01-5.32,10.32-29.87-30.82-116.41-55.2-137.29-45.85-39.28-149.19-44.55-197.44-7.41-109.42,84.23-76.57,256.02-81.96,376.11,5.11,37.96,72.04,11.53,96.9,12.8,3.23-88.91-18.34-185.83,13.14-271.53,11.42-31.1,26.65-55.15,63.34-56.01,58.44-1.37,58.86,46.65,73.2,88.64ZM1174.36,669.21c28.77,5.6,58.94,7.04,87.04-2.84-.14-16.68,4.9-33.98,5.47-50.34,2.39-67.97-14.86-183.89,49.24-229.85,23.8-17.07,31.73-18.72,56.74-2.95,28.41,17.91,34.42,45.15,49.97,72.47,25.72,1.29,51.82,4.68,76.74-5.16,10.22-51.53-13.42-95.59-46.89-132.24-38.17-41.8-120.36-45.07-171.01-26.13-116.89,43.73-121.67,257.59-111.67,360.94.54,5.54,1.55,11.24,4.38,16.09ZM539.25,424.24c21.82,3.86,53.25-2.83,76.28,0-.39-39.23,8.31-77.54-7.95-114.84-21.52,5.39-62.28-13-79.69-10.2-22.37,3.6-9.78,67.07-9.08,82.24.75,16.45-12.22,37.03,20.45,42.8ZM689.96,545.17v-66.98c0-1.03-3.81-8.68-6.28-9.43-103.55-3.33-240.17-25.12-328.3,43.24-39.38,30.54-58.78,119.36-43.05,165.2,20.79,60.58,99.84,128.09,167.3,115.32,24.94-4.72,16.24-48.51,10.66-66.28-9.89-31.48-32.99-15.09-45.79-20.94-10.39-4.75-29.33-29.67-34.3-40.37-13.29-28.64-17-53.11,4.39-78.83,55.95-67.28,186.47-26.23,262.54-35.15,5.42-.64,9.57-.46,12.83-5.77ZM862,561.04c3.37,3.36,11,4.08,15.81,4.6,64.98,7.03,149.21,2.94,216.03,3.55,18.09.16,28.86,11.48,37.92-13.86,7.67-21.45,1.98-39.99.46-61.71l-2.93-4.51-265.79-4.82c-6.12,2.02-10.02,34-10.12,42.27s3.59,29.46,8.62,34.48ZM1650.01,487.5l-336.25,7.95c-13.04,4.42-17.08,74.33,3.93,80.63,12.51,3.75,46.59.46,62.5.75,70.56,1.29,144.6,1.44,215.83-3.79,16.22-1.19,41.34-2.47,54-9.26v-76.28ZM611.34,592.15l-81.63-2.56-2.96,4.48,3.18,306.49,85.85,2.06,2.95-4.46c-2.32-28.41,3.43-57.71,4.39-84.91,1.02-28.51,2.93-211.52-11.79-221.1ZM974.91,607.01c-5.94,1.42-8.75,36.63-9.56,46.12-4.9,57.69-9.55,124.42-11.35,182.14-.99,31.75-9.39,69.49,31.8,72.91,9.59.79,53.79-5.08,62.53-8.35,4.55-1.7,6.17-3.64,6.32-8.56l10.61-271.15c-1.25-4.92-4.53-5.29-8.81-6.08-26.27-4.8-55.47-.98-81.55-7.04ZM1489.97,919.12l18.02-280.01c-14.33-39.04-61.03-10.55-92.43-17.67l-11.15,293.97,85.56,3.71ZM660.19,725.65v65.12c0,.83-2.76,2.02-2.86,3.75l2.67,3.7c13.34,8.62,75.78,6.04,95.24,5.73,44.77-.72,114.66,1.2,156.32-3.69,5.42-.64,9.57-.46,12.83-5.77v-74.42c-5.99-9.2-14.57-1.88-24.02-1.68-31.15.68-232.53-4.76-240.18,7.26ZM1370.92,718.21h-262.34c-14.45,2.68-16.68,40.1-17.02,53.86-.5,20.04-.58,29.43,20.68,31.72,22.62,2.44,61.23-2.12,85.61-3.76,57.62-3.87,115.21-16.65,173.07-7.41v-74.42ZM1659.87,992.27c87.89-87.89,39.11-245.24-83.3-269.47-52.22-10.34-41.04,3.55-45.93,41.62-1.34,10.42-8.07,16.17-5.72,28.31,4.94,25.45,27.62,14.07,44.61,22.68,45.72,23.19,53.97,111.76,2.39,131.71-15.35,5.94-58.22,11.05-76.38,12.92-57.69,5.94-116.26,4.39-174.08.94-14.5,1.11-14.37,22.75-14.09,34.5.24,9.88,6.06,50.78,13.78,53.42,104.7.71,257.15,24.91,338.71-56.64ZM1269.94,1138.17l-3.96-287.11c-5.47-18.57-65.46-7.27-82.46-9.53l-6.13,8.76c-8.92,95.09-8.4,190.47-6.9,286.03l8.78,6.11c30.75-1.8,61.05,6.98,90.66-4.25ZM742.6,848.98l-7.48,283.63c3.41,10.19,55.74,10.88,67.45,8.92,8.62-1.45,24.03-6.28,25.08-15.85l-7.97-271.13c-4.06-12.3-64.1-8.75-77.08-5.57ZM708.56,1027.06v-53.96c0-8.09-11.05-34.62-24-31.81-104.39,6.47-219.87-20.72-313.48,36.68-48.42,29.69-76.78,126.85-63.49,180.27,15.73,63.23,103.66,116.41,167.88,102.73,15.78-5.18-.7-66.98-3.04-81.51-27.24-4.12-49.8-10.53-64.01-36.46-17.92-32.7-10.05-58.6,17.65-80.27,72.72-56.9,197.1-19.21,282.49-35.67ZM1135.94,1033.98c8.57-5.41-1.6-73.14-13.09-77l-234.03-11.95c-36,4.89-24.49,60.84-20.07,85.56l267.19,3.39ZM603.85,1365.17l19.13-265.47c-2.62-28.45-91.52-31.39-96.75-3.79l-9.54,270.01c5.4,7.76,73.54,3.11,87.17-.75ZM959.74,1365.69h78.14l12.57-272.83c-5.4-16.76-73.17-9.09-89.09-8.35l-2.97,4.48c-1.99,22.11.71,44.51-.37,66.61-2.83,58.21-10.74,140.39-4.06,197.26.64,5.42.46,9.57,5.77,12.83ZM1477.95,1372.22c10.21-11.81,4.17-228.31,8.34-261.43-2.94-24.84-82.03-8.54-85.11.48l-4.22,265.6c18.56-.59,67.74,10.69,81-4.65ZM916.94,1261.49v-80c-16.47-13.35-42.73-2.24-61.25-1.71-35.98,1.04-72.5-3.49-107.91,3.72-15.54,5.19-93.7-10.74-98.75,2.57-2.03,18.51-11.95,75.58,7.42,84.74,38.69,2.35,78.14-1.62,117.4-2.05,35.4-.39,71.56,3.3,107.67.11,11.9-1.05,23.71-5.33,35.41-7.38ZM1080.67,1265.21c70.01,1.39,140.36-1.8,210.4-.15,38.27.9,73.39,20.9,72.72-38.92-.12-10.9-2.59-40.8-13.33-42.8-23.53-4.37-66.52,1.01-93.19.16-50.62-1.63-101.41-6.16-152.47-.21-11.19,1.3-24.13,8.21-24.13,20.52v61.4ZM1488.14,1428.94c-52.77,5.35-113.74-3.97-167.45,0-16.17,25.43-6.86,57.36-1.5,85.21,40.03,4.68,80.32,4.9,120.73,4.26,59.45-.94,127.3-3.4,180.03-35.81,51.14-31.44,89.83-129.18,68.1-186.58-9.06-23.92-47.44-68.75-68.12-84.44-19.91-15.11-94.77-51.3-103.07-14.41-1.17,5.21-5.03,62.43-3.99,65.55,3.61,10.92,38.9,14.33,50.47,20.34,27.15,14.12,36.27,63.82,30.09,91.14-6.51,28.78-79.05,52.08-105.27,54.74ZM1270.43,1306.18l-85.97-1.59c-17.39,96.1,20.05,206.92-28.72,298.02-13.97,26.09-30.53,47.22-64.1,36.78-40.49-12.59-42.73-101.73-55.57-108.15-29.58-4.51-60.32-2.26-88.84,6.13-2.37,51.79,16.2,115.26,55.26,150.24,69.67,62.39,176.8,49.96,234.4-22.46,42.57-53.52,38.2-125.4,45.06-189.71l-11.51-169.26ZM591.35,1536.86h-81.87l-5.58,5.58v59.54c0,3.93,22.59,48.26,26.79,55.08,49.47,80.31,118.34,93.89,202.76,55.39,38.35-17.5,51.67-34.45,68.79-72.62,44.49-99.2,30.02-220.77,17.65-325.91-15.68-3.25-83.23-9.7-88.51,5.73-5.27,89.18,21.16,175.61-8.96,262.68-2.1,6.06-15.75,36.35-18.55,39.13-4.03,3.99-43.82,22.19-49.9,22.37s-24.24-9.71-29.17-13.88c-28.61-24.18-9.94-67.69-33.44-93.08ZM373.66,1417.78v80c0,.9-4.32,2.84-2.13,5.6l7.74,3.94c22.31-2.19,48.5-7.01,70.51-7.83,36.83-1.37,227.62,10.9,242.3.43,16.73-11.94.09-74.43-4.42-93.53l-178.34.07-135.67,11.32ZM1132.78,1507.11l2.1-78.41c-3.44-4.76-101.15-17.09-115.64-18.32-19.11-1.61-44.01-3.34-63.04-3.94-20.68-.65-88.11-6.82-94.53,17.77,6.53,16.92-3.77,72.87,13.1,78.55l258.02,4.35ZM1470.86,1556.01c-3.59-5.9-75.27-6.93-79.63-.7-6.12,24.49-16.46,119.68,4.17,133.82,8.73,5.98,68.75,6.69,74.17.33,12.54-14.71,3.74-109.81,1.29-133.45Z\";\n\nconst PATH_LENGTH = 14500;\n\ninterface WeaveLoadingProps {\n    size?: number;\n    color?: string;\n}\n\nexport const WeaveLoading: React.FC<WeaveLoadingProps> = ({\n    size = 40,\n    color\n}) => {\n    const { colors } = useTheme();\n    const strokeColor = color || colors.primary;\n\n    const strokeDashoffset = useSharedValue(PATH_LENGTH);\n\n    useEffect(() => {\n        // Continuous drawing animation\n        strokeDashoffset.value = withRepeat(\n            withTiming(0, {\n                duration: 3000,\n                easing: Easing.inOut(Easing.ease)\n            }),\n            -1, // Infinite repeat\n            true // Reverse direction\n        );\n\n        return () => {\n            cancelAnimation(strokeDashoffset);\n        };\n    }, []);\n\n    const animatedPathProps = useAnimatedProps(() => ({\n        strokeDashoffset: strokeDashoffset.value,\n    }));\n\n    return (\n        <View style={{ width: size, height: size }}>\n            <Svg width={size} height={size} viewBox=\"0 0 2000 2000\">\n                <AnimatedPath\n                    d={WEAVE_PATH}\n                    fill=\"none\"\n                    stroke={strokeColor}\n                    strokeWidth={80} // Thicker stroke for smaller sizes\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeDasharray={PATH_LENGTH}\n                    animatedProps={animatedPathProps}\n                />\n            </Svg>\n        </View>\n    );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/constants/archetype-content.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/constants/constants.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActivityType' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":60}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":118,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":118,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":120,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":120,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":122,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":122,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":124,"column":9,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":124,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":126,"column":8,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":126,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":128,"column":11,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":128,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":130,"column":13,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":130,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":132,"column":11,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":132,"endColumn":39,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":134,"column":12,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":134,"endColumn":40,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Tier, Archetype, InteractionCategory, ActivityType } from '../types/common';\n\nexport const TIER_CONFIG = {\n  InnerCircle: {\n    displayName: 'Inner Circle',\n    maxCount: 5,\n    decayRate: 0.05, // 5% per week\n    idealFrequency: 7, // Days\n  },\n  CloseFriends: {\n    displayName: 'Close Friends',\n    maxCount: 15,\n    decayRate: 0.10, // 10% per week\n    idealFrequency: 14, // Days\n  },\n  Community: {\n    displayName: 'Community',\n    maxCount: 50, // Soft limit, Dunbar says 150 total relationships\n    decayRate: 0.15, // 15% per week\n    idealFrequency: 30, // Days\n  },\n} as const;\n\nexport const getTierDisplayName = (tier?: string) => {\n  if (tier === 'InnerCircle' || tier === 'inner') return 'Inner Circle';\n  if (tier === 'CloseFriends' || tier === 'close') return 'Close Friends';\n  return 'Community';\n};\n\nexport const getTierCapacity = (tier?: string) => {\n  if (tier === 'InnerCircle' || tier === 'inner') return 5;\n  if (tier === 'CloseFriends' || tier === 'close') return 15;\n  return 50;\n};\n\nexport const isTierAtCapacity = (currentCount: number, tier: string) => {\n  const capacity = getTierCapacity(tier);\n  return currentCount >= capacity;\n};\n\nexport const archetypeData: Record<Archetype, { name: string; essence: string; description: string; traits: string[]; icon: string; careStyle: string }> = {\n  Emperor: {\n    name: 'The Emperor',\n    essence: 'Protector & Builder',\n    description: 'Provides stability, structure, and practical support. They are reliable foundations in your life.',\n    traits: ['Reliable', 'Protective', 'Structured', 'Practical'],\n    icon: '🏰',\n    careStyle: 'Acts of Service'\n  },\n  Empress: {\n    name: 'The Empress',\n    essence: 'Nurturer & Creator',\n    description: 'Brings warmth, abundance, and emotional nourishment. They help you grow and feel cared for.',\n    traits: ['Nurturing', 'Creative', 'Warm', 'Abundant'],\n    icon: '🌱',\n    careStyle: 'Gifts & Nurturing'\n  },\n  HighPriestess: {\n    name: 'The High Priestess',\n    essence: 'Intuitive & Confidant',\n    description: 'Understands the unspoken. A safe harbor for secrets, deep feelings, and spiritual connection.',\n    traits: ['Intuitive', 'Deep', 'Mysterious', 'Understanding'],\n    icon: '🌙',\n    careStyle: 'Deep Listening'\n  },\n  Fool: {\n    name: 'The Fool',\n    essence: 'Adventurer & Joy-Bringer',\n    description: 'Brings spontaneity, fun, and new experiences. They remind you not to take life too seriously.',\n    traits: ['Spontaneous', 'Playful', 'Optimistic', 'Free-spirited'],\n    icon: '🎒',\n    careStyle: 'Play & Adventure'\n  },\n  Sun: {\n    name: 'The Sun',\n    essence: 'Optimist & Energizer',\n    description: 'Radiates positivity and vitality. Being around them recharges your batteries and lifts your spirits.',\n    traits: ['Radiant', 'Optimistic', 'Energetic', 'Joyful'],\n    icon: '☀️',\n    careStyle: 'Celebration & Energy'\n  },\n  Hermit: {\n    name: 'The Hermit',\n    essence: 'Guide & Truth-Seeker',\n    description: 'Values deep, one-on-one connection and wisdom. They help you find clarity and inner truth.',\n    traits: ['Wise', 'Introspective', 'Authentic', 'Patient'],\n    icon: '🏮',\n    careStyle: 'Presence & Wisdom'\n  },\n  Magician: {\n    name: 'The Magician',\n    essence: 'Catalyst & Inspirer',\n    description: 'Makes things happen. They inspire you to take action, transform, and realize your potential.',\n    traits: ['Transformative', 'Inspiring', 'Resourceful', 'Active'],\n    icon: '✨',\n    careStyle: 'Shared Projects'\n  },\n  Lovers: {\n    name: 'The Lovers',\n    essence: 'Mirror & Harmonizer',\n    description: 'Reflects your values and seeks harmony. A connection based on mutual choice and deep alignment.',\n    traits: ['Harmonious', 'Aligned', 'Reflective', 'Connected'],\n    icon: '❤️',\n    careStyle: 'Quality Time'\n  },\n  Unknown: {\n    name: 'Unknown',\n    essence: 'Unassigned Archetype',\n    description: 'This friend has not been assigned an archetype yet.',\n    traits: [],\n    icon: '❓',\n    careStyle: 'Unknown'\n  }\n};\n\nexport const archetypeIcons: Record<Archetype, any> = {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Emperor: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Empress: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  HighPriestess: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Fool: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Sun: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Hermit: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Magician: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Lovers: require('@/assets/icon.png'),\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  Unknown: require('@/assets/icon.png'),\n};\n\nexport const tierColors = {\n  InnerCircle: '#10B981',\n  CloseFriends: '#3B82F6',\n  Community: '#8B5CF6',\n};\n\nexport const tierMap: Record<string, Tier> = {\n  inner: 'InnerCircle',\n  close: 'CloseFriends',\n  community: 'Community',\n  InnerCircle: 'InnerCircle',\n  CloseFriends: 'CloseFriends',\n  Community: 'Community',\n};\n\nexport const moonPhasesData = {\n  NewMoon: { icon: '🌑', label: 'New Moon' },\n  WaxingCrescent: { icon: '🌒', label: 'Waxing Crescent' },\n  FirstQuarter: { icon: '🌓', label: 'First Quarter' },\n  WaxingGibbous: { icon: '🌔', label: 'Waxing Gibbous' },\n  FullMoon: { icon: '🌕', label: 'Full Moon' },\n};\n\nexport const modeIcons = {\n  light: '☀️',\n  dark: '🌙',\n  system: '⚙️',\n};\n\n// V2 Matrix: Maps Archetype -> Interaction Category -> Multiplier (0.5 to 2.0)\n// This replaces the old Activity-based matrix\nexport const CategoryArchetypeMatrix: Record<Archetype, Record<InteractionCategory, number>> = {\n  Emperor: {\n    'favor-support': 2.0,    // Loves being useful\n    'meal-drink': 1.5,       // Traditional bonding\n    'text-call': 1.2,        // Keeping in touch\n    'activity-hobby': 1.0,\n    'event-party': 0.8,      // Can be overwhelming\n    'hangout': 1.2,\n    'deep-talk': 1.0,\n    'celebration': 1.0,\n    'voice-note': 0.8\n  },\n  Empress: {\n    'meal-drink': 1.8,       // Nurturing through food\n    'hangout': 1.8,          // Cozy time\n    'celebration': 1.5,      // Loves gathering\n    'text-call': 1.2,\n    'voice-note': 1.2,\n    'favor-support': 1.5,    // Emotional support\n    'deep-talk': 1.2,\n    'event-party': 1.2,\n    'activity-hobby': 1.0\n  },\n  HighPriestess: {\n    'deep-talk': 2.0,        // The core need\n    'voice-note': 1.5,       // Personal, asynchronous depth\n    'hangout': 1.5,          // Quiet time\n    'text-call': 1.0,\n    'meal-drink': 1.0,\n    'activity-hobby': 0.8,\n    'favor-support': 1.2,\n    'celebration': 0.8,      // Prefers intimacy\n    'event-party': 0.6       // Dislikes crowds\n  },\n  Fool: {\n    'activity-hobby': 1.8,   // Adventure!\n    'event-party': 1.8,      // Fun!\n    'hangout': 1.5,          // Spontaneous\n    'celebration': 1.5,\n    'meal-drink': 1.2,\n    'text-call': 1.0,\n    'voice-note': 1.0,\n    'favor-support': 0.8,    // Can be heavy\n    'deep-talk': 0.8\n  },\n  Sun: {\n    'event-party': 2.0,      // Shines in groups\n    'celebration': 2.0,      // Loves joy\n    'activity-hobby': 1.5,   // Active\n    'meal-drink': 1.2,\n    'hangout': 1.2,\n    'text-call': 1.2,\n    'voice-note': 1.2,\n    'favor-support': 1.0,\n    'deep-talk': 1.0\n  },\n  Hermit: {\n    'deep-talk': 1.8,        // Wisdom sharing\n    'hangout': 1.5,          // Quiet parallel play\n    'text-call': 1.2,        // One-on-one\n    'meal-drink': 1.2,\n    'activity-hobby': 1.0,\n    'voice-note': 1.0,\n    'favor-support': 1.0,\n    'celebration': 0.8,\n    'event-party': 0.5       // Drains battery\n  },\n  Magician: {\n    'activity-hobby': 1.8,   // Creating together\n    'deep-talk': 1.5,        // Brainstorming\n    'celebration': 1.5,      // Milestones\n    'event-party': 1.2,\n    'favor-support': 1.2,    // Solving problems\n    'text-call': 1.2,\n    'voice-note': 1.2,\n    'meal-drink': 1.0,\n    'hangout': 1.0\n  },\n  Lovers: {\n    'meal-drink': 1.8,       // Intimate dates\n    'deep-talk': 1.8,        // Connection\n    'hangout': 1.5,          // Quality time\n    'text-call': 1.5,        // Constant contact\n    'voice-note': 1.5,\n    'celebration': 1.5,\n    'favor-support': 1.5,\n    'activity-hobby': 1.2,\n    'event-party': 1.0\n  },\n  Unknown: {\n    'text-call': 1.0,\n    'voice-note': 1.0,\n    'meal-drink': 1.0,\n    'hangout': 1.0,\n    'deep-talk': 1.0,\n    'event-party': 1.0,\n    'activity-hobby': 1.0,\n    'favor-support': 1.0,\n    'celebration': 1.0\n  }\n};\n\nexport const ARCHETYPE_GRADIENTS: Record<Archetype, string[]> = {\n  Emperor: ['#ef4444', '#dc2626'],\n  Empress: ['#10b981', '#059669'],\n  HighPriestess: ['#8b5cf6', '#7c3aed'],\n  Fool: ['#f59e0b', '#d97706'],\n  Sun: ['#eab308', '#ca8a04'],\n  Hermit: ['#6366f1', '#4f46e5'],\n  Magician: ['#ec4899', '#db2777'],\n  Lovers: ['#fb7185', '#f43f5e'],\n  Unknown: ['#9ca3af', '#6b7280'],\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/constants/interaction-categories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/events/event-bus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/hooks/useAppState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/hooks/useDatabaseReady.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/hooks/useDebounceCallback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/hooks/usePausableAnimation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/hooks/useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/services/analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Constants' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getOrCreateUserId' is defined but never used. Allowed unused vars must match /^_/u.","line":103,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":103,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport Constants from 'expo-constants';\nimport { Platform } from 'react-native';\n\n// PostHog instance - will be set from the provider\nlet posthogInstance: any = null;\n\n// Helper to set the PostHog instance from the provider\nexport function setPostHogInstance(instance: any) {\n  posthogInstance = instance;\n\n}\n\n// Analytics events\nexport const AnalyticsEvents = {\n  // App Lifecycle\n  APP_OPENED: 'app_opened',\n  APP_BACKGROUNDED: 'app_backgrounded',\n\n  // Onboarding\n  ONBOARDING_STARTED: 'onboarding_started',\n  ONBOARDING_COMPLETED: 'onboarding_completed',\n  ONBOARDING_SKIPPED: 'onboarding_skipped',\n\n  // Friends\n  FRIEND_ADDED: 'friend_added',\n  FRIEND_UPDATED: 'friend_updated',\n  FRIEND_DELETED: 'friend_deleted',\n  FRIEND_BATCH_ADDED: 'friend_batch_added',\n  FRIEND_PROFILE_VIEWED: 'friend_profile_viewed',\n\n  // Interactions\n  INTERACTION_LOGGED: 'interaction_logged',\n  INTERACTION_PLANNED: 'interaction_planned',\n  INTERACTION_UPDATED: 'interaction_updated',\n  INTERACTION_DELETED: 'interaction_deleted',\n  INTERACTION_COMPLETED: 'interaction_completed',\n\n  // Quick Weave\n  QUICK_WEAVE_OPENED: 'quick_weave_opened',\n  QUICK_WEAVE_SUBMITTED: 'quick_weave_submitted',\n  QUICK_WEAVE_CANCELLED: 'quick_weave_cancelled',\n\n  // Retention & Churn\n  DAILY_ACTIVE_USER: 'daily_active_user',\n  WEEKLY_ACTIVE_USER: 'weekly_active_user',\n  USER_RETURNED: 'user_returned',\n  USER_AT_RISK: 'user_at_risk', // 3+ days no interaction\n  USER_CHURNED: 'user_churned', // 5+ days no app open\n\n  // Features\n  CALENDAR_INTEGRATION_ENABLED: 'calendar_integration_enabled',\n  NOTIFICATION_ENABLED: 'notification_enabled',\n  BATTERY_CHECKIN_COMPLETED: 'battery_checkin_completed',\n  WEEKLY_REFLECTION_COMPLETED: 'weekly_reflection_completed',\n\n  // Insights & Analytics\n  INSIGHTS_VIEWED: 'insights_viewed',\n  YEAR_IN_MOONS_VIEWED: 'year_in_moons_viewed',\n  TROPHY_CABINET_VIEWED: 'trophy_cabinet_viewed',\n  ACHIEVEMENT_UNLOCKED: 'achievement_unlocked',\n\n  // Tier Intelligence\n  TIER_SUGGESTION_SHOWN: 'tier_suggestion_shown',\n  TIER_SUGGESTION_ACCEPTED: 'tier_suggestion_accepted',\n  TIER_SUGGESTION_DISMISSED: 'tier_suggestion_dismissed',\n  TIER_CHANGED_MANUALLY: 'tier_changed_manually',\n  TIER_BATCH_CHANGED: 'tier_batch_changed',\n  NETWORK_BALANCE_VIEWED: 'network_balance_viewed',\n  TIER_FIT_ANALYZED: 'tier_fit_analyzed',\n\n  // Settings\n  SETTINGS_OPENED: 'settings_opened',\n  THEME_CHANGED: 'theme_changed',\n\n  // Feedback\n  FEEDBACK_SUBMITTED: 'feedback_submitted',\n\n  // Errors\n  ERROR_OCCURRED: 'error_occurred',\n} as const;\n\nexport type AnalyticsEvent = typeof AnalyticsEvents[keyof typeof AnalyticsEvents];\n\n/**\n * Initialize PostHog analytics\n * Note: PostHog is primarily initialized via PostHogProvider in app/_layout.tsx\n * This function is kept for backwards compatibility and additional setup\n */\nexport async function initializeAnalytics(): Promise<void> {\n  try {\n    // PostHog is initialized via PostHogProvider in app/_layout.tsx\n    // This function just logs that analytics are ready\n\n  } catch (error) {\n    console.error('[Analytics] Failed to initialize analytics:', error);\n  }\n}\n\n/**\n * Get or create a unique user ID\n */\nasync function getOrCreateUserId(): Promise<string> {\n  try {\n    let userId = await AsyncStorage.getItem('@weave:user_id');\n    if (!userId) {\n      // Generate a unique ID\n      userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      await AsyncStorage.setItem('@weave:user_id', userId);\n    }\n    return userId;\n  } catch (error) {\n    console.error('[Analytics] Failed to get/create user ID:', error);\n    return 'unknown';\n  }\n}\n\n/**\n * Track an analytics event\n */\nexport function trackEvent(\n  event: AnalyticsEvent | string,\n  properties?: Record<string, any>\n): void {\n  try {\n    if (!posthogInstance) {\n      console.warn('[Analytics] PostHog not initialized, skipping event:', event);\n      return;\n    }\n\n    const enrichedProperties = {\n      ...properties,\n      timestamp: new Date().toISOString(),\n      platform: Platform.OS,\n    };\n\n    posthogInstance.capture(event, enrichedProperties);\n\n    if (__DEV__) {\n\n    }\n  } catch (error) {\n    console.error('[Analytics] Failed to track event:', error);\n  }\n}\n\n/**\n * Track screen view\n */\nexport function trackScreenView(screenName: string, properties?: Record<string, any>): void {\n  trackEvent('screen_viewed', {\n    screen_name: screenName,\n    ...properties,\n  });\n}\n\n/**\n * Set user properties\n */\nexport function setUserProperties(properties: Record<string, any>): void {\n  try {\n    if (!posthogInstance) {\n      console.warn('[Analytics] PostHog not initialized, skipping user properties');\n      return;\n    }\n\n    // Use identify to set person properties. \n    // If we don't pass a distinctId (first arg), it might reset it or throw.\n    // Safe bet for existing anonymous users is to capture an $identify event or use the capture('$set') pattern if we don't want to manage IDs manually.\n    // However, the best practice is often: posthog.identify(posthog.getDistinctId(), properties)\n\n    // Check if we can get the distinct ID\n    const distinctId = posthogInstance.getDistinctId();\n    if (distinctId) {\n      posthogInstance.identify(distinctId, properties);\n    } else {\n      // Fallback if no ID is available (unlikely if authorized)\n      posthogInstance.capture('$set', { $set: properties });\n    }\n  } catch (error) {\n    console.error('[Analytics] Failed to set user properties:', error);\n  }\n}\n\n/**\n * Track retention metrics\n */\nexport async function trackRetentionMetrics(): Promise<void> {\n  try {\n    const now = Date.now();\n\n    // Get last app open timestamp\n    const lastAppOpenStr = await AsyncStorage.getItem('@weave:last_app_open');\n    const lastAppOpen = lastAppOpenStr ? parseInt(lastAppOpenStr, 10) : now;\n\n    // Get last interaction timestamp\n    const lastInteractionStr = await AsyncStorage.getItem('@weave:last_interaction');\n    const lastInteraction = lastInteractionStr ? parseInt(lastInteractionStr, 10) : now;\n\n    const daysSinceLastOpen = (now - lastAppOpen) / (1000 * 60 * 60 * 24);\n    const daysSinceLastInteraction = (now - lastInteraction) / (1000 * 60 * 60 * 24);\n\n    // Track daily active user\n    trackEvent(AnalyticsEvents.DAILY_ACTIVE_USER, {\n      days_since_last_open: daysSinceLastOpen,\n      days_since_last_interaction: daysSinceLastInteraction,\n    });\n\n    // Track user returned (if more than 1 day since last open)\n    if (daysSinceLastOpen >= 1 && daysSinceLastOpen < 5) {\n      trackEvent(AnalyticsEvents.USER_RETURNED, {\n        days_away: daysSinceLastOpen,\n      });\n    }\n\n    // Track at-risk user (3+ days since last interaction)\n    if (daysSinceLastInteraction >= 3 && daysSinceLastInteraction < 5) {\n      trackEvent(AnalyticsEvents.USER_AT_RISK, {\n        days_since_interaction: daysSinceLastInteraction,\n      });\n    }\n\n    // Track churned user (5+ days since app open)\n    if (daysSinceLastOpen >= 5) {\n      trackEvent(AnalyticsEvents.USER_CHURNED, {\n        days_away: daysSinceLastOpen,\n      });\n    }\n\n    // Update last app open timestamp\n    await AsyncStorage.setItem('@weave:last_app_open', now.toString());\n\n    // Track weekly active user\n    const lastWeeklyTrackStr = await AsyncStorage.getItem('@weave:last_weekly_track');\n    const lastWeeklyTrack = lastWeeklyTrackStr ? parseInt(lastWeeklyTrackStr, 10) : 0;\n    const daysSinceWeeklyTrack = (now - lastWeeklyTrack) / (1000 * 60 * 60 * 24);\n\n    if (daysSinceWeeklyTrack >= 7) {\n      trackEvent(AnalyticsEvents.WEEKLY_ACTIVE_USER);\n      await AsyncStorage.setItem('@weave:last_weekly_track', now.toString());\n    }\n  } catch (error) {\n    console.error('[Analytics] Failed to track retention metrics:', error);\n  }\n}\n\n/**\n * Update last interaction timestamp (called when user logs an interaction)\n */\nexport async function updateLastInteractionTimestamp(): Promise<void> {\n  try {\n    await AsyncStorage.setItem('@weave:last_interaction', Date.now().toString());\n  } catch (error) {\n    console.error('[Analytics] Failed to update last interaction timestamp:', error);\n  }\n}\n\n/**\n * Reset analytics (for testing or user opt-out)\n */\nexport async function resetAnalytics(): Promise<void> {\n  try {\n    if (posthogInstance) {\n      posthogInstance.reset();\n    }\n    await AsyncStorage.removeItem('@weave:user_id');\n    await AsyncStorage.removeItem('@weave:last_app_open');\n    await AsyncStorage.removeItem('@weave:last_interaction');\n    await AsyncStorage.removeItem('@weave:last_weekly_track');\n\n  } catch (error) {\n    console.error('[Analytics] Failed to reset analytics:', error);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/services/app-state-manager.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/services/posthog.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Constants' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PostHogProvider, usePostHog, PostHog, PostHogOptions } from 'posthog-react-native';\nimport * as FileSystem from 'expo-file-system';\nimport Constants from 'expo-constants';\n\n// Beta API Key and Host\nexport const POSTHOG_API_KEY = 'phc_7zVVcjN8nMJWbw2XgIANio1B7EqNUn4jxWiZZzGActJ';\nexport const POSTHOG_HOST = 'https://eu.i.posthog.com';\n\nexport const posthogOptions: PostHogOptions | any = {\n    host: POSTHOG_HOST,\n\n    // Use file system for caching to ensure persistence\n    persistence: 'file',\n    fileSystem: FileSystem,\n    captureScreenViews: false,\n};\n\n// Export the provider for wrapping the app\nexport { PostHogProvider };\n\n// Export the hook for using PostHog in components\nexport { usePostHog };\n\n// Export the type\nexport type { PostHog };\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/theme/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/theme/tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/types/common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/types/core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/types/validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Icon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Sheet/AnimatedBottomSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Sheet/StandardBottomSheet.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'testID' is defined but never used. Allowed unused args must match /^_/u.","line":65,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDarkMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":72,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo, useRef, useEffect } from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet, Alert, TouchableWithoutFeedback } from 'react-native';\nimport BottomSheet, {\n  BottomSheetBackdrop,\n  BottomSheetView,\n  BottomSheetScrollView,\n  BottomSheetBackdropProps,\n  BottomSheetFooter,\n  BottomSheetFooterProps,\n} from '@gorhom/bottom-sheet';\nimport { Portal } from '@gorhom/portal';\nimport { X } from 'lucide-react-native';\nimport { useTheme } from '@/shared/hooks/useTheme';\nimport {\n  SHEET_HEIGHTS,\n  SHEET_SPRING_CONFIG,\n  BACKDROP_OPACITY,\n  SHEET_BORDER_RADIUS,\n} from './constants';\nimport { StandardBottomSheetProps } from './types';\n\n/**\n * StandardBottomSheet - Unified bottom sheet component for consistent modal interactions\n *\n * Uses @gorhom/bottom-sheet for native gesture handling and smooth animations.\n * All sheets in the app should use this component for visual consistency.\n *\n * @example\n * // Simple action sheet\n * <StandardBottomSheet\n *   visible={isOpen}\n *   onClose={() => setIsOpen(false)}\n *   height=\"action\"\n *   title=\"Choose an option\"\n * >\n *   <ActionButtons />\n * </StandardBottomSheet>\n *\n * @example\n * // Form sheet with scrollable content\n * <StandardBottomSheet\n *   visible={isOpen}\n *   onClose={() => setIsOpen(false)}\n *   height=\"full\"\n *   scrollable\n *   title=\"Edit Details\"\n * >\n *   <FormContent />\n * </StandardBottomSheet>\n */\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\nexport function StandardBottomSheet({\n  visible,\n  onClose,\n  height = 'form',\n  snapPoints: customSnapPoints,\n  initialSnapIndex = 0,\n  enableSwipeClose = true,\n  scrollable = false,\n  title,\n  titleComponent,\n  showCloseButton = true,\n  children,\n  testID,\n  scrollRef,\n  footerComponent,\n  disableContentPanning = false,\n  hasUnsavedChanges = false,\n  confirmCloseMessage = 'Discard Changes? You have unsaved changes. Are you sure you want to discard them?',\n}: StandardBottomSheetProps) {\n  const { colors, isDarkMode } = useTheme();\n  const bottomSheetRef = useRef<BottomSheet>(null);\n  const insets = useSafeAreaInsets();\n\n  const isDynamic = height === 'auto';\n\n  // Compute snap points from height variant or custom\n  const snapPoints = useMemo(() => {\n    if (isDynamic) {\n      return [];\n    }\n    if (customSnapPoints) {\n      return customSnapPoints;\n    }\n    return [SHEET_HEIGHTS[height as keyof typeof SHEET_HEIGHTS]];\n  }, [height, customSnapPoints, isDynamic]);\n\n  // Handle sheet state changes\n  const handleSheetChanges = useCallback(\n    (index: number) => {\n      if (index === -1) {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  // Handle attempt to close (checks for unsaved changes)\n  const handleAttemptClose = useCallback(() => {\n    if (hasUnsavedChanges) {\n      Alert.alert(\n        'Discard Changes?',\n        confirmCloseMessage,\n        [\n          {\n            text: 'Cancel',\n            style: 'cancel',\n          },\n          {\n            text: 'Discard',\n            style: 'destructive',\n            onPress: () => onClose(),\n          },\n        ]\n      );\n    } else {\n      onClose();\n    }\n  }, [hasUnsavedChanges, onClose, confirmCloseMessage]);\n\n  // Render backdrop with consistent styling and interception\n  const renderBackdrop = useCallback(\n    (props: BottomSheetBackdropProps) => (\n      <View style={StyleSheet.absoluteFill}>\n        <BottomSheetBackdrop\n          {...props}\n          disappearsOnIndex={-1}\n          appearsOnIndex={0}\n          opacity={BACKDROP_OPACITY.visible}\n          pressBehavior=\"none\"\n        />\n        <TouchableWithoutFeedback onPress={handleAttemptClose}>\n          <View style={StyleSheet.absoluteFill} />\n        </TouchableWithoutFeedback>\n      </View>\n    ),\n    [handleAttemptClose]\n  );\n\n  // Handle manual close with animation\n  const handleClose = useCallback(() => {\n    handleAttemptClose();\n  }, [handleAttemptClose]);\n\n  // Sync visibility with sheet state\n  useEffect(() => {\n    if (visible) {\n      bottomSheetRef.current?.snapToIndex(initialSnapIndex);\n    } else {\n      bottomSheetRef.current?.close();\n    }\n  }, [visible, initialSnapIndex]);\n\n  // Render footer using BottomSheetFooter for robust handling\n  const renderFooter = useCallback(\n    (props: BottomSheetFooterProps) => (\n      <BottomSheetFooter {...props} bottomInset={0}>\n        <View style={[\n          styles.footer,\n          {\n            backgroundColor: colors.card,\n            borderTopColor: colors.border,\n            paddingBottom: Math.max(insets.bottom, 16)\n          }\n        ]}>\n          {footerComponent}\n        </View>\n      </BottomSheetFooter>\n    ),\n    [footerComponent, colors.card, colors.border, insets.bottom]\n  );\n\n  // Don't render anything if not visible\n  if (!visible) return null;\n\n  const ContentWrapper = scrollable ? BottomSheetScrollView : BottomSheetView;\n\n  return (\n    <Portal>\n      <BottomSheet\n        ref={bottomSheetRef}\n        index={initialSnapIndex}\n        snapPoints={snapPoints}\n        enableDynamicSizing={isDynamic}\n        onChange={handleSheetChanges}\n        enablePanDownToClose={enableSwipeClose && !hasUnsavedChanges}\n        enableContentPanningGesture={!scrollable && !disableContentPanning}\n        backdropComponent={renderBackdrop}\n        footerComponent={footerComponent ? renderFooter : undefined}\n        backgroundStyle={[\n          styles.background,\n          { backgroundColor: colors.card },\n        ]}\n        handleIndicatorStyle={[\n          styles.handleIndicator,\n          { backgroundColor: colors.border },\n        ]}\n        animationConfigs={{\n          damping: SHEET_SPRING_CONFIG.damping,\n          stiffness: SHEET_SPRING_CONFIG.stiffness,\n        }}\n        keyboardBehavior=\"interactive\"\n        keyboardBlurBehavior=\"restore\"\n        android_keyboardInputMode=\"adjustResize\"\n        style={styles.sheet}\n      >\n        {/* Header with optional title and close button */}\n        {(title || titleComponent || showCloseButton) && (\n          <View style={styles.header}>\n            {titleComponent ? (\n              <View style={{ flex: 1, marginRight: 16 }}>\n                {titleComponent}\n              </View>\n            ) : title ? (\n              <Text\n                style={[styles.title, { color: colors.foreground }]}\n                numberOfLines={1}\n              >\n                {title}\n              </Text>\n            ) : (\n              <View style={{ flex: 1 }} />\n            )}\n            {showCloseButton && (\n              <TouchableOpacity\n                onPress={handleClose}\n                style={styles.closeButton}\n                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}\n                accessibilityLabel=\"Close\"\n                accessibilityRole=\"button\"\n              >\n                <X size={24} color={colors['muted-foreground']} />\n              </TouchableOpacity>\n            )}\n          </View>\n        )}\n\n        <ContentWrapper\n          style={styles.contentContainer}\n          ref={scrollable ? scrollRef : undefined}\n          contentContainerStyle={[\n            scrollable && {\n              paddingHorizontal: 16,\n              paddingBottom: footerComponent ? 80 : Math.max(insets.bottom, 24), // Extra padding for footer overlap\n              flexGrow: 1\n            }\n          ]}\n          showsVerticalScrollIndicator={false}\n          keyboardShouldPersistTaps=\"handled\"\n          keyboardDismissMode=\"interactive\"\n        >\n          {/* Sheet content */}\n          {scrollable ? (\n            children\n          ) : (\n            <View style={[\n              styles.content,\n              { paddingBottom: footerComponent ? 80 : Math.max(insets.bottom + 20, 24) }\n            ]}>\n              {children}\n            </View>\n          )}\n        </ContentWrapper>\n      </BottomSheet >\n    </Portal >\n  );\n}\n\nconst styles = StyleSheet.create({\n  sheet: {\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: -4 },\n    shadowOpacity: 0.15,\n    shadowRadius: 16,\n    elevation: 16,\n    zIndex: 1000,\n  },\n  background: {\n    borderTopLeftRadius: SHEET_BORDER_RADIUS,\n    borderTopRightRadius: SHEET_BORDER_RADIUS,\n  },\n  handleIndicator: {\n    width: 40,\n    height: 4,\n    borderRadius: 2,\n    marginTop: 8,\n  },\n  contentContainer: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingTop: 12,\n    paddingBottom: 8,\n  },\n  title: {\n    fontSize: 20,\n    fontFamily: 'Lora_700Bold',\n    fontWeight: '700',\n    flex: 1,\n    marginRight: 16,\n  },\n  closeButton: {\n    padding: 4,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: 16,\n    // paddingBottom handled dynamically\n  },\n  footer: {\n    padding: 16,\n    borderTopWidth: 1,\n  },\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Sheet/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Sheet/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Sheet/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/Text.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/utils/Logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/utils/date-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/utils/date-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/utils/time-aware-filter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/utils/timeline-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/shared/utils/validation-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/stores/interactionStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/stores/tutorialStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/stores/uiStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/types/hydrated.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/src/types/suggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/supabase/functions/oracle-journal/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/supabase/functions/oracle-weekly/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/svg.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/tailwind.config.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":21,"column":13,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":21,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { tokens, typography, spacing, radius } from './src/shared/theme/tokens';\nimport { type Config } from 'tailwindcss';\n\n/**\n * Tailwind Configuration\n * Source of Truth: src/shared/theme/tokens.ts\n *\n * This config maps our Design System tokens to Tailwind utility classes.\n * Currently mapping the LIGHT theme as the default root values.\n *\n * TODO: Implement CSS variables or dark mode strategy if dynamic switching\n * without nativewind's specific \"dark\" modifier is needed.\n */\n\n// Helper to flatten nested objects for Tailwind if needed,\n// but Tailwind supports nested colors structure natively.\n\nconst config: Config = {\n  // NOTE: NativeWind v4 usually scans these paths\n  content: [\"./app/**/*.{js,jsx,ts,tsx}\", \"./src/**/*.{js,jsx,ts,tsx}\"],\n  presets: [require(\"nativewind/preset\")],\n  theme: {\n    extend: {\n      colors: {\n        // Semantic Colors (Mapped from Light Theme)\n        background: tokens.light.background,\n        'background-elevated': tokens.light.backgroundElevated,\n        'background-subtle': tokens.light.backgroundSubtle,\n        'background-muted': tokens.light.backgroundMuted,\n\n        foreground: tokens.light.foreground,\n        'foreground-muted': tokens.light.foregroundMuted,\n        'foreground-subtle': tokens.light.foregroundSubtle,\n\n        primary: tokens.light.primary,\n        'primary-hover': tokens.light.primaryHover,\n        'primary-foreground': tokens.light.primaryForeground,\n        'primary-muted': tokens.light.primaryMuted,\n        'primary-subtle': tokens.light.primarySubtle,\n\n        secondary: tokens.light.secondary,\n        'secondary-hover': tokens.light.secondaryHover,\n        'secondary-foreground': tokens.light.secondaryForeground,\n\n        destructive: tokens.light.destructive,\n        'destructive-foreground': tokens.light.destructiveForeground,\n        'destructive-subtle': tokens.light.destructiveSubtle,\n\n        success: tokens.light.success,\n        'success-foreground': tokens.light.successForeground,\n        'success-subtle': tokens.light.successSubtle,\n\n        warning: tokens.light.warning,\n        'warning-foreground': tokens.light.warningForeground,\n        'warning-subtle': tokens.light.warningSubtle,\n\n        info: tokens.light.info,\n        'info-foreground': tokens.light.infoForeground,\n        'info-subtle': tokens.light.infoSubtle,\n\n        border: tokens.light.border,\n        'border-subtle': tokens.light.borderSubtle,\n        'border-focus': tokens.light.borderFocus,\n\n        // Component specific\n        card: tokens.light.card.background,\n        'card-foreground': tokens.light.card.foreground,\n        'card-border': tokens.light.card.border,\n\n        input: tokens.light.input.background,\n        'input-border': tokens.light.input.border,\n        'input-focus': tokens.light.input.borderFocus,\n        'input-placeholder': tokens.light.input.placeholder,\n\n        // Domain specific\n        'tier-inner': tokens.light.tier.inner,\n        'tier-close': tokens.light.tier.close,\n        'tier-community': tokens.light.tier.community,\n\n        'weave-vibrant': tokens.light.weave.vibrant,\n        'weave-stable': tokens.light.weave.stable,\n        'weave-fading': tokens.light.weave.fading,\n      },\n      fontFamily: {\n        serif: ['Lora_400Regular'],\n        'serif-bold': ['Lora_700Bold'],\n        sans: ['Inter_400Regular'],\n        'sans-medium': ['Inter_500Medium'],\n        'sans-semibold': ['Inter_600SemiBold'],\n      },\n      fontSize: {\n        // Display\n        'display-lg': [`${typography.scale.displayLarge.fontSize}px`, { lineHeight: `${typography.scale.displayLarge.lineHeight}px` }],\n\n        // Headings\n        'h1': [`${typography.scale.h1.fontSize}px`, { lineHeight: `${typography.scale.h1.lineHeight}px` }],\n        'h2': [`${typography.scale.h2.fontSize}px`, { lineHeight: `${typography.scale.h2.lineHeight}px` }],\n        'h3': [`${typography.scale.h3.fontSize}px`, { lineHeight: `${typography.scale.h3.lineHeight}px` }],\n\n        // Body\n        'body-lg': [`${typography.scale.bodyLarge.fontSize}px`, { lineHeight: `${typography.scale.bodyLarge.lineHeight}px` }],\n        'body': [`${typography.scale.body.fontSize}px`, { lineHeight: `${typography.scale.body.lineHeight}px` }],\n        'body-sm': [`${typography.scale.bodySmall.fontSize}px`, { lineHeight: `${typography.scale.bodySmall.lineHeight}px` }],\n\n        // UI\n        'label': [`${typography.scale.label.fontSize}px`, { lineHeight: `${typography.scale.label.lineHeight}px` }],\n        'label-sm': [`${typography.scale.labelSmall.fontSize}px`, { lineHeight: `${typography.scale.labelSmall.lineHeight}px`, letterSpacing: `${typography.scale.labelSmall.letterSpacing}px` }],\n        'caption': [`${typography.scale.caption.fontSize}px`, { lineHeight: `${typography.scale.caption.lineHeight}px` }],\n      },\n      borderRadius: {\n        xs: `${radius.xs}px`,\n        sm: `${radius.sm}px`,\n        md: `${radius.md}px`,\n        lg: `${radius.lg}px`,\n        xl: `${radius.xl}px`,\n        full: `${radius.full}px`,\n      },\n      spacing: {\n        // Mapping tokens.ts spacing\n        0.5: `${spacing[0.5]}px`,\n        1: `${spacing[1]}px`,\n        1.5: `${spacing[1.5]}px`,\n        2: `${spacing[2]}px`,\n        2.5: `${spacing[2.5]}px`,\n        3: `${spacing[3]}px`,\n        4: `${spacing[4]}px`,\n        5: `${spacing[5]}px`,\n        6: `${spacing[6]}px`,\n        8: `${spacing[8]}px`,\n        10: `${spacing[10]}px`,\n        12: `${spacing[12]}px`,\n        16: `${spacing[16]}px`,\n      }\n    },\n  },\n  plugins: [],\n};\n\nexport default config;\n","usedDeprecatedRules":[]},{"filePath":"/Users/DITcart/Desktop/Programs/WeaveNative/toast_notification.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'withDelay' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'runOnJS' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nimport Animated, { \n  useSharedValue, \n  useAnimatedStyle, \n  withSpring,\n  withDelay,\n  withTiming,\n  runOnJS,\n} from 'react-native-reanimated';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { theme } from '@/shared/theme/theme';\n\ninterface ToastNotificationProps {\n  message: string;\n  friendName: string;\n  onDismiss: () => void;\n}\n\nexport function ToastNotification({ message, friendName, onDismiss }: ToastNotificationProps) {\n  const insets = useSafeAreaInsets();\n  const translateY = useSharedValue(-100);\n  const opacity = useSharedValue(0);\n\n  useEffect(() => {\n    // Slide in\n    translateY.value = withSpring(0, {\n      damping: 15,\n      stiffness: 150,\n    });\n    opacity.value = withTiming(1, { duration: 200 });\n\n    // Auto dismiss after 2.5 seconds\n    const timer = setTimeout(() => {\n      translateY.value = withTiming(-100, { duration: 250 });\n      opacity.value = withTiming(0, { duration: 250 });\n      setTimeout(onDismiss, 250);\n    }, 2500);\n\n    return () => clearTimeout(timer);\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateY: translateY.value }],\n    opacity: opacity.value,\n  }));\n\n  return (\n    <Animated.View \n      style={[\n        styles.container, \n        { top: insets.top + 12 },\n        animatedStyle\n      ]}\n    >\n      <View style={styles.content}>\n        <Text style={styles.icon}>✓</Text>\n        <View style={styles.textContainer}>\n          <Text style={styles.message}>\n            <Text style={styles.activityText}>{message}</Text>\n            <Text style={styles.withText}> logged with </Text>\n            <Text style={styles.friendNameText}>{friendName}</Text>\n          </Text>\n        </View>\n      </View>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    left: 20,\n    right: 20,\n    zIndex: 9999,\n  },\n  content: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: 'rgba(255, 255, 255, 0.95)',\n    borderRadius: 16,\n    padding: 16,\n    paddingVertical: 14,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.15,\n    shadowRadius: 12,\n    elevation: 8,\n    borderWidth: 1.5,\n    borderColor: 'rgba(181, 138, 108, 0.3)',\n  },\n  icon: {\n    fontSize: 24,\n    marginRight: 12,\n  },\n  textContainer: {\n    flex: 1,\n  },\n  message: {\n    fontSize: 15,\n    lineHeight: 20,\n  },\n  activityText: {\n    fontWeight: '700',\n    color: theme.colors.foreground,\n  },\n  withText: {\n    fontWeight: '400',\n    color: theme.colors['muted-foreground'],\n  },\n  friendNameText: {\n    fontWeight: '700',\n    color: theme.colors.primary,\n    fontFamily: 'Lora_700Bold',\n  },\n});","usedDeprecatedRules":[]}]